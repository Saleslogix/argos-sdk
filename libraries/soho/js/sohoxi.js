/*! 
 *  IDS Enterprise Components - v4.36.2
 *  Date: 2021-01-25T21:45:32.182Z
 *  Revision: 057fc3b6595d40824a84fd7ddeee375c2bbf8180
 *  
 *  
 *  Apache License
 *  Version 2.0, January 2004
 *  http://www.apache.org/licenses/
 *  
 *  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *  
 *  1. Definitions.
 *  
 *  "License" shall mean the terms and conditions for use, reproduction,
 *  and distribution as defined by Sections 1 through 9 of this document.
 *  
 *  "Licensor" shall mean the copyright owner or entity authorized by
 *  the copyright owner that is granting the License.
 *  
 *  "Legal Entity" shall mean the union of the acting entity and all
 *  other entities that control, are controlled by, or are under common
 *  control with that entity. For the purposes of this definition,
 *  "control" means (i) the power, direct or indirect, to cause the
 *  direction or management of such entity, whether by contract or
 *  otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *  outstanding shares, or (iii) beneficial ownership of such entity.
 *  
 *  "You" (or "Your") shall mean an individual or Legal Entity
 *  exercising permissions granted by this License.
 *  
 *  "Source" form shall mean the preferred form for making modifications,
 *  including but not limited to software source code, documentation
 *  source, and configuration files.
 *  
 *  "Object" form shall mean any form resulting from mechanical
 *  transformation or translation of a Source form, including but
 *  not limited to compiled object code, generated documentation,
 *  and conversions to other media types.
 *  
 *  "Work" shall mean the work of authorship, whether in Source or
 *  Object form, made available under the License, as indicated by a
 *  copyright notice that is included in or attached to the work
 *  (an example is provided in the Appendix below).
 *  
 *  "Derivative Works" shall mean any work, whether in Source or Object
 *  form, that is based on (or derived from) the Work and for which the
 *  editorial revisions, annotations, elaborations, or other modifications
 *  represent, as a whole, an original work of authorship. For the purposes
 *  of this License, Derivative Works shall not include works that remain
 *  separable from, or merely link (or bind by name) to the interfaces of,
 *  the Work and Derivative Works thereof.
 *  
 *  "Contribution" shall mean any work of authorship, including
 *  the original version of the Work and any modifications or additions
 *  to that Work or Derivative Works thereof, that is intentionally
 *  submitted to Licensor for inclusion in the Work by the copyright owner
 *  or by an individual or Legal Entity authorized to submit on behalf of
 *  the copyright owner. For the purposes of this definition, "submitted"
 *  means any form of electronic, verbal, or written communication sent
 *  to the Licensor or its representatives, including but not limited to
 *  communication on electronic mailing lists, source code control systems,
 *  and issue tracking systems that are managed by, or on behalf of, the
 *  Licensor for the purpose of discussing and improving the Work, but
 *  excluding communication that is conspicuously marked or otherwise
 *  designated in writing by the copyright owner as "Not a Contribution."
 *  
 *  "Contributor" shall mean Licensor and any individual or Legal Entity
 *  on behalf of whom a Contribution has been received by Licensor and
 *  subsequently incorporated within the Work.
 *  
 *  2. Grant of Copyright License. Subject to the terms and conditions of
 *  this License, each Contributor hereby grants to You a perpetual,
 *  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *  copyright license to reproduce, prepare Derivative Works of,
 *  publicly display, publicly perform, sublicense, and distribute the
 *  Work and such Derivative Works in Source or Object form.
 *  
 *  3. Grant of Patent License. Subject to the terms and conditions of
 *  this License, each Contributor hereby grants to You a perpetual,
 *  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *  (except as stated in this section) patent license to make, have made,
 *  use, offer to sell, sell, import, and otherwise transfer the Work,
 *  where such license applies only to those patent claims licensable
 *  by such Contributor that are necessarily infringed by their
 *  Contribution(s) alone or by combination of their Contribution(s)
 *  with the Work to which such Contribution(s) was submitted. If You
 *  institute patent litigation against any entity (including a
 *  cross-claim or counterclaim in a lawsuit) alleging that the Work
 *  or a Contribution incorporated within the Work constitutes direct
 *  or contributory patent infringement, then any patent licenses
 *  granted to You under this License for that Work shall terminate
 *  as of the date such litigation is filed.
 *  
 *  4. Redistribution. You may reproduce and distribute copies of the
 *  Work or Derivative Works thereof in any medium, with or without
 *  modifications, and in Source or Object form, provided that You
 *  meet the following conditions:
 *  
 *  (a) You must give any other recipients of the Work or
 *  Derivative Works a copy of this License; and
 *  
 *  (b) You must cause any modified files to carry prominent notices
 *  stating that You changed the files; and
 *  
 *  (c) You must retain, in the Source form of any Derivative Works
 *  that You distribute, all copyright, patent, trademark, and
 *  attribution notices from the Source form of the Work,
 *  excluding those notices that do not pertain to any part of
 *  the Derivative Works; and
 *  
 *  (d) If the Work includes a "NOTICE" text file as part of its
 *  distribution, then any Derivative Works that You distribute must
 *  include a readable copy of the attribution notices contained
 *  within such NOTICE file, excluding those notices that do not
 *  pertain to any part of the Derivative Works, in at least one
 *  of the following places: within a NOTICE text file distributed
 *  as part of the Derivative Works; within the Source form or
 *  documentation, if provided along with the Derivative Works; or,
 *  within a display generated by the Derivative Works, if and
 *  wherever such third-party notices normally appear. The contents
 *  of the NOTICE file are for informational purposes only and
 *  do not modify the License. You may add Your own attribution
 *  notices within Derivative Works that You distribute, alongside
 *  or as an addendum to the NOTICE text from the Work, provided
 *  that such additional attribution notices cannot be construed
 *  as modifying the License.
 *  
 *  You may add Your own copyright statement to Your modifications and
 *  may provide additional or different license terms and conditions
 *  for use, reproduction, or distribution of Your modifications, or
 *  for any such Derivative Works as a whole, provided Your use,
 *  reproduction, and distribution of the Work otherwise complies with
 *  the conditions stated in this License.
 *  
 *  5. Submission of Contributions. Unless You explicitly state otherwise,
 *  any Contribution intentionally submitted for inclusion in the Work
 *  by You to the Licensor shall be under the terms and conditions of
 *  this License, without any additional terms or conditions.
 *  Notwithstanding the above, nothing herein shall supersede or modify
 *  the terms of any separate license agreement you may have executed
 *  with Licensor regarding such Contributions.
 *  
 *  6. Trademarks. This License does not grant permission to use the trade
 *  names, trademarks, service marks, or product names of the Licensor,
 *  except as required for reasonable and customary use in describing the
 *  origin of the Work and reproducing the content of the NOTICE file.
 *  
 *  7. Disclaimer of Warranty. Unless required by applicable law or
 *  agreed to in writing, Licensor provides the Work (and each
 *  Contributor provides its Contributions) on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *  implied, including, without limitation, any warranties or conditions
 *  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *  PARTICULAR PURPOSE. You are solely responsible for determining the
 *  appropriateness of using or redistributing the Work and assume any
 *  risks associated with Your exercise of permissions under this License.
 *  
 *  8. Limitation of Liability. In no event and under no legal theory,
 *  whether in tort (including negligence), contract, or otherwise,
 *  unless required by applicable law (such as deliberate and grossly
 *  negligent acts) or agreed to in writing, shall any Contributor be
 *  liable to You for damages, including any direct, indirect, special,
 *  incidental, or consequential damages of any character arising as a
 *  result of this License or out of the use or inability to use the
 *  Work (including but not limited to damages for loss of goodwill,
 *  work stoppage, computer failure or malfunction, or any and all
 *  other commercial damages or losses), even if such Contributor
 *  has been advised of the possibility of such damages.
 *  
 *  9. Accepting Warranty or Additional Liability. While redistributing
 *  the Work or Derivative Works thereof, You may choose to offer,
 *  and charge a fee for, acceptance of support, warranty, indemnity,
 *  or other liability obligations and/or rights consistent with this
 *  License. However, in accepting such obligations, You may act only
 *  on Your own behalf and on Your sole responsibility, not on behalf
 *  of any other Contributor, and only if You agree to indemnify,
 *  defend, and hold each Contributor harmless for any liability
 *  incurred by, or claims asserted against, such Contributor by reason
 *  of your accepting any such warranty or additional liability.
 *  
 *  END OF TERMS AND CONDITIONS
 *  
 *  APPENDIX: How to apply the Apache License to your work.
 *  
 *  To apply the Apache License to your work, attach the following
 *  boilerplate notice, with the fields enclosed by brackets "[]"
 *  replaced with your own identifying information. (Don't include
 *  the brackets!)  The text should be enclosed in the appropriate
 *  comment syntax for the file format. We also recommend that a
 *  file or class name and description of purpose be included on the
 *  same "printed page" as the copyright notice for easier
 *  identification within third-party archives.
 *  
 *  Copyright 2018  Infor, Inc.
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */ 
var Soho = (function (exports) {
  'use strict';

  /* eslint-disable no-console */
  // Easy flag for determining whether or not time will be logged to the console.
  var enableTimeLogging = false;
  /**
   * Start the logging timer
   * @param  {string} label Provide a way to match a timing operation.
   * @returns {void}
   */

  function logTimeStart(label) {
  }
  /**
   * End the logging timer and print the result
   * @param  {string} label End this matching timing operation
   * @returns {void}
   */

  function logTimeEnd(label) {
  } // Easy flag for allowing console debugging

  var enableConsoleLogging = false;
  /**
   * Simple wrapper for `console.[whatever]` to abstract out console access.
   * @param {string} type console display type
   * @param {string} message message type
   * @returns {void}
   */

  function log(type, message) {
    {
      return;
    }
  }
  /**
   * Returns a list of all elements that currently have a $.data() property.
   * @param {jQuery[]|HTMLElement} rootElem the root element to work from.
   * @returns {array} containing all matching elements with a data property attached.
   */

  function getComponents(rootElem) {
    var elem = !rootElem ? $('body') : $(rootElem);
    var allElems = elem.find('*');
    var results = [];
    allElems.each(function (i, thisElem) {
      var data = $(thisElem).data();

      if (data && Object.keys(data).length) {
        results.push({
          data: data,
          element: thisElem
        });
      }
    });
    return results;
  }

  var debug = /*#__PURE__*/Object.freeze({
    __proto__: null,
    enableTimeLogging: enableTimeLogging,
    logTimeStart: logTimeStart,
    logTimeEnd: logTimeEnd,
    enableConsoleLogging: enableConsoleLogging,
    log: log,
    getComponents: getComponents
  });

  // Polyfill for `Element.prototype.matches`
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s);
      var i = matches.length;

      while (--i >= 0 && matches.item(i) !== this) {} // eslint-disable-line


      return i > -1;
    };
  }

  // from:https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/remove()/remove().md

  /* eslint-disable */
  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('remove')) {
        return;
      }

      Object.defineProperty(item, 'remove', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function remove() {
          if (this.parentNode === null) {
            return;
          }

          this.parentNode.removeChild(this);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

  /**
   * Polyfills passive event support in jQuery
   * This eliminates a ton of console warnings when doing scrolling.
   * - https://github.com/jquery/jquery/issues/2871
   * - https://github.com/infor-design/enterprise/issues/414
   */
  var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

  if (!isIE11) {
    jQuery.event.special.touchstart = {
      setup: function setup(_, ns, handle) {
        this.addEventListener('touchstart', handle, {
          passive: true
        });
      }
    };
    jQuery.event.special.touchmove = {
      setup: function setup(_, ns, handle) {
        this.addEventListener('touchmove', handle, {
          passive: true
        });
      }
    };
    jQuery.event.special.mousewheel = {
      setup: function setup(_, ns, handle) {
        this.addEventListener('mousewheel', handle, {
          passive: true
        });
      }
    };
  }

  var version = "4.36.2";

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var xssUtils = {};
  /**
   * Takes a string and removes all html tags
   * @param {string} str The string to parse
   * @returns {string} The string minus html tags.
   */

  xssUtils.stripHTML = function stripHTML(str) {
    var newStr = str;

    if (!newStr) {
      return '';
    }

    newStr = newStr.replace(/<\/?[^>]+(>|$)/g, '');
    return newStr;
  };
  /**
   * Remove all html tags except for the ones specified. I.E. White list to a specific set of accepted tags.
   * @private
   * @param {string} html HTML in string form
   * @param {string} allowed Comma seperated string of allowed tags e.g. '<b><i><p>''
   * @returns {string} the modified value
   */


  xssUtils.stripTags = function (html, allowed) {
    if (!html) {
      return '';
    }

    if (typeof html === 'number') {
      return html;
    }

    var whitelist = ("".concat(allowed || '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)

    var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
    var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
    var returnHTML = '';
    returnHTML = html.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line

    returnHTML = returnHTML.replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line

    returnHTML = returnHTML.replace(tags, function ($0, $1) {
      return whitelist.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    }); //eslint-disable-line

    return returnHTML;
  };
  /**
   * Remove console methods
   * @private
   * @param {string} html HTML in string form
   * @returns {string} the modified value
   */


  xssUtils.sanitizeConsoleMethods = function (html) {
    var methods = ['assert', 'clear', 'count', 'debug', 'dirxml', 'dir', 'error', 'exception', 'groupCollapsed', 'groupEnd', 'group', 'info', 'log', 'markTimeline', 'profileEnd', 'profile', 'table', 'timeEnd', 'timeStamp', 'time', 'trace', 'warn'];
    var expr = new RegExp("console\\.(".concat(methods.join('|'), ")((\\s+)?\\(([^)]+)\\);?)?"), 'igm');
    return typeof html !== 'string' ? html : html.replace(expr, '');
  };
  /**
   * Remove Script tags and all onXXX functions
   * @private
   * @param {string} html HTML in string form
   * @returns {string} the modified value
   */


  xssUtils.sanitizeHTML = function (html) {
    var santizedHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/g, '');
    santizedHtml = santizedHtml.replace(/<[^>]+/g, function (match) {
      return match.replace(/(\/|\s)on\w+=(\'|")?[^"]*(\'|")?/g, '');
    }); // eslint-disable-line
    // Remove console methods

    santizedHtml = this.sanitizeConsoleMethods(santizedHtml); // Remove nested script tags

    santizedHtml = santizedHtml.replace(/<\/script>/g, '');
    return santizedHtml;
  };
  /**
   * Make sure a string is only alphanumeric (with dashes allowed.)
   * @private
   * @param {string} string HTML in string form
   * @returns {string} the modified value
   */


  xssUtils.ensureAlphaNumeric = function (string) {
    if (typeof string === 'number') {
      return string;
    }

    return this.stripTags(string).replace(/[^a-z0-9-]/gi, '', '');
  };
  /**
   * Make sure a string is only alphanumeric with spaces.
   * @private
   * @param {string} string HTML in string form
   * @returns {string} the modified value
   */


  xssUtils.ensureAlphaNumericWithSpaces = function (string) {
    if (typeof string === 'number') {
      return string;
    }

    return this.stripTags(string).replace(/[^a-z0-9 ]/gi, '', '');
  };
  /**
   * Converting given string into camel case.
   * @private
   * @param {string} string To be convert into camel case
   * @returns {string} the modified value
   */


  xssUtils.toCamelCase = function (string) {
    if (typeof string !== 'string') {
      return string;
    }

    string = this.stripTags(string).replace(/[^a-z0-9 ]/gi, '', '');
    return string.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, function (m, chr) {
      return chr.toUpperCase();
    });
  };
  /**
   * Escapes HTML, replacing special characters with encoded symbols.
   * Symbols taken from https://bit.ly/1iVkGlc
   * @private
   * @param {string} value HTML in string form
   * @returns {string} the modified value
   */


  xssUtils.escapeHTML = function (value) {
    var newValue = value;

    if (typeof newValue === 'string') {
      var map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&apos;'
      };
      var reg = /[&<>"']/ig;
      return newValue.replace(reg, function (match) {
        return map[match];
      });
    }

    return newValue;
  };
  /**
   * Un-escapes HTML, replacing encoded symbols with special characters.
   * Symbols taken from https://bit.ly/1iVkGlc
   * @private
   * @param {string} value HTML in string form
   * @returns {string} the modified value
   */


  xssUtils.unescapeHTML = function (value) {
    if (value === '') {
      return '';
    }

    if (typeof value === 'string') {
      var match = function match(regx) {
        return (value.match(regx) || [''])[0];
      };

      var doc = new DOMParser().parseFromString(value, 'text/html'); // Keep leading/trailing spaces

      return "".concat(match(/^\s*/)).concat(doc.documentElement.textContent.trim()).concat(match(/\s*$/));
    }

    return value;
  };
  /**
   * htmlentities() is a PHP function which converts special characters (like <)
   * into their escaped/encoded values (like &lt;). This is a JS verson of it.
   * This allows you to show to display the string without the browser reading it as HTML.
   * This is useful for encoding hrefs.
   * @private
   * @param {string} string string to process
   * @returns {string} the processed value
   */


  xssUtils.htmlEntities = function (string) {
    return String(string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };
  /**
   * Ensure that a link is a local link (relative to the current page)
   * @private
   * @param {string} url string to process
   * @returns {boolean} If it is local or not
   */


  xssUtils.isUrlLocal = function (url) {
    var isEmpty = url === '';
    return !isEmpty && (url[0] === '/' && (url.length === 1 || url[1] !== '/' && url[1] !== '\\') || // "/" or "/foo" but not "//" or "/\"
    url.length > 1 && url[0] === '~' && url[1] === '/') || // "~/" or "~/foo"
    url.length >= 1 && url[0] === '#'; // "#" or "#foo"
  };

  var DOM = {};
  /**
   * DOM operations are only allowed on elements that are based on HTML or SVG. This method
   * determines whether or not the element is valid for performing a DOM operation.
   * @param {HTMLElement|SVGElement} el the element being examined
   * @returns {boolean} true if the element is valid
   */

  DOM.isValidElement = function isValidElement(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
  };
  /**
   * Returns an array containing an element's attributes.
   * @param {HTMLElement|SVGElement} element the element whose attributes are being accessed
   * @returns {object} list of attributes in name/value pairs.
   */


  DOM.getAttributes = function getAttributes(element) {
    if (!element || !(element instanceof HTMLElement) && !(element instanceof SVGElement)) {
      return {};
    }

    return element.attributes;
  };
  /**
   * Adding, removing, and testing for classes
   * @param {HTMLElement} element the element to test
   * @returns {boolean} whether or not a className exists
   */


  DOM.hasAnyClass = function hasAnyClass(element) {
    var cn = element.className;
    return cn && cn.length > 0;
  };
  /**
   * Checks the element for the existence of a particular class.
   * @param {HTMLElement|SVGElement} elem a element being checked.
   * @param {string} className a string representing a class name to check for.
   * @returns {boolean} whether or not the element's class attribute contains the string.
   */


  DOM.hasClass = function hasClass(elem, className) {
    var r = false;

    if (!(elem !== null && elem !== void 0 && (elem == null ? void 0 : elem.getAttribute))) {
      return r;
    }

    if ('classList' in elem) {
      r = elem.classList.contains(className);
    } else {
      var classAttr = elem.getAttribute('class');
      r = classAttr ? classAttr.split(/\s+/).indexOf(className) !== -1 : false;
    }

    return r;
  };
  /**
   * Add a class to any element and handle multiple classes.
   * Handles DOM and SVG elements down to IE11
   * @param {HTMLElement} el a element being checked.
   * @param {...string} className a string representing a class name.
   */


  DOM.addClass = function addClass(el) {
    if (!el) {
      return;
    }

    var classStr = '';

    for (var _len = arguments.length, className = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      className[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < className.length; i++) {
      if (el.classList) {
        el.classList.add(className[i]);
      } else if (!DOM.hasClass(el, [i])) {
        if (classStr.length) {
          classStr += ' ';
        }

        classStr += className[i];
      }
    }

    if (classStr.length) {
      $(el).addClass(classStr);
    }
  };
  /**
   * Remove a class from any element and handle multiple classes.
   * Handles DOM and SVG elements down to IE11
   * @param {HTMLElement} el a element being checked.
   * @param {...string} className a string representing a class name.
   */


  DOM.removeClass = function removeClass(el) {
    if (!el) {
      return;
    }

    var classStr = '';

    for (var _len2 = arguments.length, className = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      className[_key2 - 1] = arguments[_key2];
    }

    for (var i = 0; i < className.length; i++) {
      if (el.classList) {
        el.classList.remove(className[i]);
      } else if (!DOM.hasClass(el, [i])) {
        if (classStr.length) {
          classStr += ' ';
        }

        classStr += className[i];
      }
    }

    if (classStr.length) {
      $(el).removeClass(classStr);
    }
  };
  /**
   * Checks if an element is valid
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being checked
   * @returns {boolean} represents all values normally contained by a DOMRect or ClientRect
   */


  DOM.isElement = function isElement(el) {
    if (el instanceof HTMLElement || el instanceof SVGElement || el instanceof $ && el.length) {
      return true;
    }

    return false;
  };
  /**
   * Runs the generic _getBoundingClientRect()_ method on an element, but returns its results
   * as a plain object instead of a ClientRect
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated
   * @returns {object} represents all values normally contained by a DOMRect or ClientRect
   */


  DOM.getDimensions = function getDimensions(el) {
    if (!DOM.isElement(el)) {
      return {};
    }

    if (el instanceof $) {
      if (!el.length) {
        return {};
      }

      el = el[0];
    }

    var rect = el.getBoundingClientRect();
    var rectObj = {};

    for (var prop in rect) {
      // eslint-disable-line
      if (!isNaN(rect[prop])) {
        rectObj[prop] = rect[prop];
      }
    }

    return rectObj;
  };
  /**
   * Append content to a DOM element (like jQuery.append)
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to append to
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   */


  DOM.append = function append(el, contents, stripTags) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.insertAdjacentHTML('beforeend', this.xssClean(contents, stripTags));
    }
  };
  /**
   * Remove a DOM Element
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to remove.
   */


  DOM.remove = function append(el) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if ((domEl instanceof HTMLElement || domEl instanceof SVGElement) && el.parentNode) {
      el.parentNode.removeChild(el);
    }
  };
  /**
   * Set an attribute with an extra check that the object exists.
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to set the attribute on
   * @param {string} attribute The attribute name.
   * @param {string} value The attribute value.
   */


  DOM.setAttribute = function append(el, attribute, value) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.setAttribute('attribute', value);
    }
  };
  /**
   * Clean the markup before insertion.
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   * @returns {string} the cleaned up markup
   */


  DOM.xssClean = function xssClean(contents, stripTags) {
    var markup = contents;

    if (stripTags && stripTags !== '*') {
      markup = xssUtils.stripTags(contents, stripTags);
    }

    if (stripTags === '*') {
      markup = xssUtils.sanitizeHTML(contents);
    }

    return markup;
  };
  /**
   * Append content to a DOM element (like jQuery.append)
   * @param {HTMLElement|SVGElement|jQuery[]} el The element to append to
   * @param {string|jQuery} contents The html string or jQuery object.
   * @param {string} stripTags A list of tags to strip to prevent xss, or * for sanitizing and allowing all tags.
   */


  DOM.html = function html(el, contents, stripTags) {
    var domEl = el;

    if (el instanceof $ && el.length) {
      domEl = domEl[0];
    }

    if (domEl instanceof HTMLElement || domEl instanceof SVGElement) {
      domEl.innerHTML = this.xssClean(contents, stripTags);
    }
  };
  /**
   * Recursively checks parent nodes for a matching CSS selector
   * @param {HTMLElement/SVGElement} el the lower-level element being checked
   * @param {string} selector a valid CSS selector
   * @param {boolean} closest if true, returns the first match found, or undefined if no matches are found.
   * @returns {Array|HTMLElement|SVGElement|undefined} containing references to parent elements that match the selector
   */


  DOM.parents = function parents(el, selector, closest) {
    var parentEls = [];

    if (!DOM.isValidElement(el)) {
      return parentEls;
    } // Pushes to the element array.


    function checkEl(thisEl) {
      if (thisEl !== document && thisEl.matches(selector)) {
        parentEls.push(thisEl);
      }
    } // Loop until we hit the <html> tag.
    // If we're only looking for the closest element, break out once we find it.


    while (el.parentNode) {
      if (closest && parentEls.length) {
        break;
      }

      el = el.parentNode;
      checkEl(el);
    } // Return the first one, or the entire array.


    if (closest) {
      return parentEls[0]; // can be `undefined`
    }

    return parentEls;
  };
  /**
   * Get the next sibling with an optional css selector.
   * @param {HTMLElement/SVGElement} el The element being checked
   * @param {string} selector a valid CSS selector
   * @returns {HTMLElement} The next sibling
   */


  DOM.getNextSibling = function getNextSibling(el, selector) {
    if (el instanceof $ && el.length) {
      el = el[0];
    } // Get the next sibling element


    var sibling = el.nextElementSibling; // If there's no selector, return the first sibling

    if (!selector) return sibling; // If the sibling matches our selector, use it
    // If not, jump to the next sibling and continue the loop

    while (sibling) {
      if (sibling.matches(selector)) return sibling;
      sibling = sibling.nextElementSibling;
    }

    return undefined;
  };
  /**
   * Get the next previous with an optional css selector.
   * @param {HTMLElement/SVGElement} el The element being checked
   * @param {string} selector a valid CSS selector
   * @returns {HTMLElement} The previous sibling
   */


  DOM.getPreviousSibling = function getPreviousSibling(el, selector) {
    if (el instanceof $ && el.length) {
      el = el[0];
    } // Get the previous sibling element


    var sibling = el.previousElementSibling; // If there's no selector, return the first sibling

    if (!selector) return sibling; // If the sibling matches our selector, use it
    // If not, jump to the previous sibling and continue the loop

    while (sibling) {
      if (sibling.matches(selector)) return sibling;
      sibling = sibling.previousElementSibling;
    }

    return undefined;
  };
  /**
   * Get the sibling elements.
   * @param {HTMLElement/SVGElement} el The element to get siblings
   * @returns {array} Array of sibling elements
   */


  DOM.getSiblings = function getSiblings(el) {
    if (el instanceof $ && el.length) {
      el = el[0];
    }

    return [].slice.call(el.parentNode.children).filter(function (child) {
      return child !== el;
    });
  };
  /**
   * Returns a simple CSS selector string that represents an existing page element.
   * Generally used in reporting (error/console messages).
   * @param {HTMLElement|SVGElement} el the element to report on
   * @returns {string} containing a simple CSS selector that represents the element
   */


  DOM.getSimpleSelector = function getSimpleSelector(el) {
    var tagName = el.tagName.toLowerCase();
    var id = el.id ? "#".concat(el.id) : '';
    var className = el.className ? ".".concat(el.className.split(' ').join('.')) : '';
    return "".concat(tagName).concat(id).concat(className);
  };

  // Soho JS-level Breakpoint Access
  // NOTE: these should match whatever the breakpoints are in "/sass/_config.scss"
  // =================================================================

  var breakpoints = {
    phone: 320,
    slim: 400,
    phablet: 610,
    'phone-to-tablet': 767,
    'wide-tablet': 968,
    'tablet-to-desktop': 1280,
    desktop: 1024,
    'desktop-to-extralarge': 1600
  };
  /**
   * @returns {array} a list of available breakpoint names
   */

  var availableBreakpoints = Object.keys(breakpoints);
  breakpoints.available = availableBreakpoints;
  /**
   * Get the name of the current CSS breakpoint by checking the popuplated 'content' value of the
   * <body> tag's `::after` pseudo-element.  These names should be reflected in the breakpoints object
   * above.
   * @returns {string} name of the current breakpoint
   */

  breakpoints.current = function () {
    var afterElement = window.getComputedStyle ? window.getComputedStyle(document.body, ':after') : false;

    if (!afterElement) {
      return '';
    }

    return (afterElement.getPropertyValue('content') || '').replace(/"/g, '');
  };
  /**
   * @param {string} breakpoint matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean} whether or not the window is currently wider than the breakpoint provided.
   */


  breakpoints.isAbove = function isAbove(breakpoint) {
    var bp = breakpoints[breakpoint];

    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth > bp - 1;
  };
  /**
   * @param {string} breakpoint matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean} whether or not the window is currently more narrow
   *  than the breakpoint provided.
   */


  breakpoints.isBelow = function isBelow(breakpoint) {
    var bp = breakpoints[breakpoint];

    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth < bp;
  };
  /**
   * Compares the last-stored breakpoint with a check on the "current" breakpoint to see if the
   * breakpoint has changed.
   * @returns {void}
   */


  breakpoints.compare = function compare() {
    if (!this.last) {
      this.last = '';
    }

    var cur = this.current();

    if (this.last !== cur) {
      $('body').triggerHandler('breakpoint-change', [{
        previous: this.last,
        current: cur
      }]);
      this.last = cur;
    }
  };
  /**
   * Checks an element for Soho visibility classes and determines whether or not
   * should be hidden based on those values at the current breakpoint.
   * NOTE: this method does NOT determine if the element is ACTUALLY hidden with a
   * `display: none;` or `visibility: hidden;` rule.  It determines whether or not a CSS
   * visibility rule alone would hide the element.
   * @param {HTMLElement} element the element being checked.
   * @returns {boolean} whether or not the element is hidden at this breakpoint.
   */


  breakpoints.isHidden = function (element) {
    if (!element || !DOM.isElement(element)) {
      return false;
    } // If there are no CSS classes on the element, return false.


    var cl = element.classList;

    if (!cl.length) {
      return false;
    } // If it's always hidden, always return true.


    if (cl.contains('hidden')) {
      return true;
    }

    var bp = this.current();
    var map = {
      phonedown: 'xs',
      phone: 'sm',
      tablet: 'md',
      desktop: 'lg',
      extralarge: 'xl'
    };
    var size = map[bp];
    var hiddenClassName = "hidden-".concat(size);
    var visibleClassName = "visible-".concat(size, "-"); // Should be hidden on this breakpoint

    if (cl.contains(hiddenClassName)) {
      return true;
    } // If explicitly visible, return


    if (cl.toString().indexOf(visibleClassName) > -1) {
      return false;
    } // Simply return false if none of these thing are found


    return false;
  };
  /**
   * jQuery wrapper for `Soho.breakpoints.isHidden()`
   * NOTE: if a jQuery selector with multiple elements is passed to this function,
   * it will only operate on the first one.
   * This method is NOT chainable.
   * @returns {boolean} whether or not the element is hidden at this breakpoint.
   */


  $.fn.isHiddenAtBreakpoint = function () {
    if (!this.length) {
      return false;
    }

    return breakpoints.isHidden($(this).first()[0]);
  };

  /**
   * Debounce method
   * @param {function} func the callback function to be run on a stagger.
   * @param {number} [threshold] the amount of time in CPU ticks to delay.
   * @param {boolean} [execAsap] if true, executes the callback immediately
   *  instead of waiting for the threshold to complete.
   * @returns {void}
   */
  function debounce(func, threshold, execAsap) {
    var timeout;
    return function debounced() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var obj = this;

      function delayed() {
        if (!execAsap) {
          func.apply(obj, args);
        }

        timeout = null;
      }

      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) {
        func.apply(obj, args);
      }

      timeout = setTimeout(delayed, threshold || 250);
    };
  }

  var debouncedResizeName = 'debouncedResize';
  /**
   * Bind the smartResize method to $.fn()
   * @param {function} fn the callback function to be bound on debounced resize
   * @returns {void}
   */

  $.fn[debouncedResizeName] = function (fn) {
    if (fn) {
      return this.bind('resize', debounce(fn));
    }

    return this.trigger(debouncedResizeName);
  };

  var UTIL_NAME = 'environment';
  /**
   * @class {Environment}
   */

  var Environment = {
    browser: {},
    features: {
      resizeObserver: typeof ResizeObserver !== 'undefined',
      touch: 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
    },
    os: {},
    devicespecs: {},

    /**
     * @returns {boolean} true if the page locale is currently read Right-To-Left instead
     * of the default Left-to-Right.
     */
    get rtl() {
      return $('html').attr('dir') === 'rtl';
    },

    /**
     * Builds run-time environment settings
     */
    set: function set() {
      $('html').attr('data-sohoxi-version', version); // Set the viewport meta tag to limit scaling

      this.viewport = document.querySelector('meta[name=viewport]');

      if (this.viewport) {
        this.viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
      }

      this.addBrowserClasses();
      this.addGlobalResize();
      this.addDeviceSpecs();
    },

    /**
     * Global Classes for browser, version and device as needed.
     */
    addBrowserClasses: function addBrowserClasses() {
      var ua = navigator.userAgent || navigator.vendor || window.opera;
      var platform = navigator.platform;
      var html = $('html');
      var cssClasses = ''; // User-agent string

      if (ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Android') === -1) {
        cssClasses += 'is-safari ';
        this.browser.name = 'safari';
      }

      this.browser.isWKWebView = function () {
        return false;
      };

      if (navigator.platform.substr(0, 2) === 'iP') {
        var lte9 = /constructor/i.test(window.HTMLElement);
        var idb = !!window.indexedDB;

        if (window.webkit && window.webkit.messageHandlers || !lte9 || idb) {
          // WKWebView
          this.browser.name = 'wkwebview';
          cssClasses += 'is-safari is-wkwebview ';

          this.browser.isWKWebView = function () {
            return true;
          };
        }
      }

      if (ua.indexOf('Chrome') !== -1) {
        cssClasses += 'is-chrome ';
        this.browser.name = 'chrome';
      }

      var macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];

      if (macosPlatforms.indexOf(platform) > -1 && !/Linux/.test(platform)) {
        cssClasses += 'is-mac ';
        this.os.name = 'Mac OS X';
      }

      if (ua.indexOf('Firefox') > 0) {
        cssClasses += 'is-firefox ';
        this.browser.name = 'firefox';
      } // Class-based detection for IE


      if (ua.match(/Edge\//)) {
        cssClasses += 'ie ie-edge ';
        this.browser.name = 'edge';
        this.browser.version = navigator.appVersion.indexOf('Edge/18') > -1 ? '18' : '17';
        cssClasses += "ie-edge".concat(this.browser.version);
      }

      if (ua.match(/Trident/)) {
        cssClasses += 'ie ';
        this.browser.name = 'ie';
      }

      if (navigator.appVersion.indexOf('MSIE 8.0') > -1 || ua.indexOf('MSIE 8.0') > -1 || document.documentMode === 8) {
        cssClasses += 'ie8 ';
        this.browser.version = '8';
      }

      if (navigator.appVersion.indexOf('MSIE 9.0') > -1) {
        cssClasses += 'ie9 ';
        this.browser.version = '9';
      }

      if (navigator.appVersion.indexOf('MSIE 10.0') > -1) {
        cssClasses += 'ie10 ';
        this.browser.version = '10';
      } else if (ua.match(/Trident\/7\./)) {
        cssClasses += 'ie11 ';
        this.browser.version = '11';
      } // Class-based detection for iOS
      // /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/


      if (/iPhone|iPod|iPad/.test(ua)) {
        cssClasses += 'ios ';
        this.os.name = 'ios';
        var iDevices = ['iPod', 'iPad', 'iPhone'];

        for (var i = 0; i < iDevices.length; i++) {
          if (new RegExp(iDevices[i]).test(ua)) {
            cssClasses += "".concat(iDevices[i].toLowerCase(), " ");
            this.device = iDevices[i];
          }
        }
      }

      if (/Android/.test(ua)) {
        cssClasses += 'android ';
        this.os.name = 'android';
      }

      if (!this.os.name && /Linux/.test(platform)) {
        this.os.name = 'linux';
      }

      html.addClass(cssClasses);
    },
    addDeviceSpecs: function addDeviceSpecs() {
      var unknown = '-';
      var nAppVer = navigator.appVersion;
      var nUAgent = navigator.userAgent;
      var browser = navigator.appName;
      var version = " ".concat(parseFloat(navigator.appVersion));
      var majorVersion = parseInt(navigator.appVersion, 10);
      var nameOffset;
      var verOffset;
      var ix;
      var browserVersionName = '';

      if ((verOffset = nUAgent.indexOf('Opera')) !== -1) {
        //eslint-disable-line
        browser = 'Opera';
        version = nUAgent.substring(verOffset + 6);

        if ((verOffset = nUAgent.indexOf('Version')) !== -1) {
          //eslint-disable-line
          version = nUAgent.substring(verOffset + 8);
        }
      }

      if ((verOffset = nUAgent.indexOf('OPR')) !== -1) {
        //eslint-disable-line
        browser = 'Opera';
        version = nUAgent.substring(verOffset + 4);
      } else if ((verOffset = nUAgent.indexOf('Edge')) !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Edge';
        version = nUAgent.substring(verOffset + 5);
      } else if ((verOffset = nUAgent.indexOf('MSIE')) !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Internet Explorer';
        version = nUAgent.substring(verOffset + 5);
      } else if ((verOffset = nUAgent.indexOf('Chrome')) !== -1) {
        //eslint-disable-line
        browser = 'Chrome';
        version = nUAgent.substring(verOffset + 7);

        if (nUAgent.indexOf('Edg') > -1) {
          browserVersionName = 'Microsoft Edge';
        }
      } else if ((verOffset = nUAgent.indexOf('Safari')) !== -1) {
        //eslint-disable-line
        browser = 'Safari';
        version = nUAgent.substring(verOffset + 7);

        if ((verOffset = nUAgent.indexOf('Version')) !== -1) {
          //eslint-disable-line
          version = nUAgent.substring(verOffset + 8);
        }
      } else if (this.browser.isWKWebView()) {
        //eslint-disable-line
        browser = "WKWebView"; //eslint-disable-line

        version = '';
        majorVersion = '';
      } else if ((verOffset = nUAgent.indexOf('Firefox')) !== -1) {
        //eslint-disable-line
        browser = 'Firefox';
        version = nUAgent.substring(verOffset + 8);
      } else if (nUAgent.indexOf('Trident/') !== -1) {
        //eslint-disable-line
        browser = 'Microsoft Internet Explorer';
        version = nUAgent.substring(nUAgent.indexOf('rv:') + 3);
      } else if ((nameOffset = nUAgent.lastIndexOf(' ') + 1) < (verOffset = nUAgent.lastIndexOf('/'))) {
        //eslint-disable-line
        browser = nUAgent.substring(nameOffset, verOffset);
        version = nUAgent.substring(verOffset + 1);

        if (browser.toLowerCase() === browser.toUpperCase()) {
          browser = navigator.appName;
        }
      } // Trim the version string


      if ((ix = version.indexOf(';')) !== -1) version = version.substring(0, ix); //eslint-disable-line

      if ((ix = version.indexOf(' ')) !== -1) version = version.substring(0, ix); //eslint-disable-line

      if ((ix = version.indexOf(')')) !== -1) version = version.substring(0, ix); //eslint-disable-line

      majorVersion = " ".concat(parseInt(version, 10));

      if (isNaN(majorVersion)) {
        version = " ".concat(parseFloat(navigator.appVersion));
        majorVersion = parseInt(navigator.appVersion, 10);
      } // mobile version


      var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nAppVer);
      var os = unknown;
      var clientStrings = [{
        s: 'Windows 10',
        r: /(Windows 10.0|Windows NT 10.0)/
      }, {
        s: 'Windows 8.1',
        r: /(Windows 8.1|Windows NT 6.3)/
      }, {
        s: 'Windows 8',
        r: /(Windows 8|Windows NT 6.2)/
      }, {
        s: 'Windows 7',
        r: /(Windows 7|Windows NT 6.1)/
      }, {
        s: 'Android',
        r: /Android/
      }, {
        s: 'Open BSD',
        r: /OpenBSD/
      }, {
        s: 'Sun OS',
        r: /SunOS/
      }, {
        s: 'Linux',
        r: /(Linux|X11)/
      }, {
        s: 'iOS',
        r: /(iPhone|iPad|iPod)/
      }, {
        s: 'Mac OS X',
        r: /Mac OS X/
      }, {
        s: 'Mac OS',
        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
      }, {
        s: 'UNIX',
        r: /UNIX/
      }];

      for (var id in clientStrings) {
        //eslint-disable-line
        var cs = clientStrings[id];

        if (cs.r.test(nUAgent)) {
          os = cs.s;
          break;
        }
      }

      var osVersion = unknown;

      if (/Windows/.test(os)) {
        osVersion = /Windows (.*)/.exec(os)[1];
      }

      switch (os) {
        //eslint-disable-line
        case 'Mac OS X':
          osVersion = /Mac OS X ([1-9][0-9][\.\_\d]+)/.exec(nUAgent)[1].replace(/\_/g, '.'); //eslint-disable-line

          break;

        case 'Android':
          osVersion = /Android ([\.\_\d]+)/.exec(nUAgent)[1]; //eslint-disable-line

          break;

        case 'iOS':
          osVersion = /OS (\d+)_?(\d+)?/.exec(nUAgent); //eslint-disable-line

          osVersion = "".concat(osVersion[1], ".").concat(osVersion[2], ".").concat(osVersion[3] | 0); //eslint-disable-line

          break;
      }

      this.devicespecs = {
        currentBrowser: browser,
        browserVersion: version.trim(),
        browserMajorVersion: majorVersion,
        isMobile: mobile,
        os: os,
        currentOSVersion: osVersion,
        browserVersionName: browserVersionName
      };
    },

    /**
     * Setup a global resize event trigger for controls to listen to
     */
    addGlobalResize: function addGlobalResize() {
      // Global resize event
      $(window).debouncedResize(function () {
        $('body').triggerHandler('resize', [window]);
        breakpoints.compare();
      }); // Also detect whenenver a load or orientation change occurs

      $(window).on('orientationchange load', function () {
        return breakpoints.compare();
      });
    },

    /**
     * Tears down global UI-specific event handlers
     * @returns {void}
     */
    removeGlobalEvents: function removeGlobalEvents() {
      $(window).off("scroll.".concat(UTIL_NAME));
      $('body').off(["focusin.".concat(UTIL_NAME), "focusout.".concat(UTIL_NAME)].join(' '));
    }
  };
  /**
   * @returns {boolean} whether or not the current browser is MS Edge
   */

  Environment.browser.isEdge = function () {
    return Environment.browser.name === 'edge';
  };
  /**
   * @returns {boolean} whether or not the current browser is IE11
   */


  Environment.browser.isIE11 = function () {
    return Environment.browser.name === 'ie' && Environment.browser.version === '11';
  };
  /**
   * @returns {boolean} whether or not the current browser is Safari and includes wkWebView as safari
   */


  Environment.browser.isSafari = function () {
    return Environment.browser.name === 'safari' || Environment.browser.name === 'wkwebview';
  };
  /**
   * @returns {boolean} whether or not the current browser is IE10
   */


  Environment.browser.isIE10 = function () {
    return Environment.browser.name === 'ie' && Environment.browser.version === '10';
  };
  /**
   * Automatically set up the environment by virtue of including this script
   */


  Environment.set();

  /**
   * HideFocus Behavior
   * Only shows the focus state on key entry (tabs or arrows).
   * @param {HTMLElement|SVGElement} element the base element
   * @returns {HideFocus} component instance
   */

  function HideFocus(element) {
    return this.init(element);
  }

  HideFocus.prototype = {
    init: function init(element) {
      if (!this.element && (element instanceof HTMLElement || element instanceof SVGElement)) {
        this.element = element;
      }

      var $el = $(this.element);
      var isClick = false;
      var isFocused = false;
      var labelClicked = false; // Checkbox, Radio buttons or Switch

      if ($el.is('.checkbox, .radio, .switch')) {
        var label = $el.next();

        if (label.is('[type="hidden"]')) {
          label = label.next();
        }

        this.label = label[0];
        $el.addClass('hide-focus').on('focusin.hide-focus', function (e) {
          if (!isClick && !isFocused && !labelClicked) {
            $el.removeClass('hide-focus');
            $el.triggerHandler('hidefocusremove', [e]);
          }

          isClick = false;
          isFocused = true;
          labelClicked = false;
        }).on('focusout.hide-focus', function (e) {
          $el.addClass('hide-focus');
          labelClicked = label.is(labelClicked);
          isClick = false;
          isFocused = false;
          $el.triggerHandler('hidefocusadd', [e]);
        });
        label.on('mousedown.hide-focus', function (e) {
          labelClicked = this;
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        });
      } else {
        // All other elements (ie. Hyperlinks)
        var handleMousedown = function handleMousedown(e) {
          isClick = true;
          $el.addClass('hide-focus');
          $el.triggerHandler('hidefocusadd', [e]);
        };

        var isTouch = Environment.features.touch;

        if (isTouch) {
          $el.on('touchstart.hide-focus', function (e) {
            handleMousedown(e);
          });
        }

        $el.addClass('hide-focus').on('mousedown.hide-focus', function (e) {
          handleMousedown(e);
        }).on('focusin.hide-focus', function (e) {
          if (!isClick && !isFocused) {
            $el.removeClass('hide-focus');
            $el.triggerHandler('hidefocusremove', [e]);
          }

          isClick = false;
          isFocused = true;
        }).on('focusout.hide-focus', function (e) {
          $el.addClass('hide-focus');
          isClick = false;
          isFocused = false;
          $el.triggerHandler('hidefocusadd', [e]);
        });
      }

      return this;
    },
    updated: function updated() {
      return this.teardown().init();
    },
    teardown: function teardown() {
      if (this.label) {
        $(this.label).off('mousedown.hide-focus');
      }

      var elemEvents = ['focusin.hide-focus', 'focusout.hide-focus', 'mousedown.hide-focus', 'touchstart.hide-focus'];
      $(this.element).off(elemEvents.join(' '));
      this.element.classList.remove('hide-focus');
      return this;
    }
  };
  /**
   * jQuery component wrapper for the HideFocus behavior
   * @returns {jQuery[]} components being acted on
   */

  $.fn.hideFocus = function () {
    return this.each(function () {
      var instance = $.data(this, 'hidefocus');

      if (instance) {
        instance.updated();
      } else {
        instance = $.data(this, 'hidefocus', new HideFocus(this));

        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, 'hidefocus');
        };
      }
    });
  };
  /**
   * Allows for the smooth scrolling of an element's content area.
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated.
   * @param {number} target target distance.
   * @param {number} duration the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred} promise that resolved when scrolling completes.
   */


  function smoothScrollTo(el, target, duration) {
    var dfd = $.Deferred();

    if (!DOM.isElement(el)) {
      // Not a workable element
      return dfd.reject();
    } // Strip the jQuery


    if (el instanceof $ && el.length) {
      el = el[0];
    } // undefined (not zero) target should instantly resolve


    if (target === undefined || target === null) {
      return dfd.resolve();
    }

    if (isNaN(duration)) {
      duration = 0;
    }

    target = Math.round(target);
    duration = Math.round(duration);

    if (duration < 0) {
      // bad duration
      return dfd.fail();
    }

    if (duration === 0) {
      el.scrollLeft += target;
      return dfd.resolve();
    }

    var startTime = Date.now();
    var endTime = startTime + duration;
    var startLeft = el.scrollLeft;
    var distance = target; // based on http://en.wikipedia.org/wiki/Smoothstep

    function smoothStep(start, end, point) {
      if (point <= start) {
        return 0;
      }

      if (point >= end) {
        return 1;
      }

      var x = (point - start) / (end - start); // interpolation

      return x * x * (3 - 2 * x);
    } // This is to keep track of where the element's scrollLeft is
    // supposed to be, based on what we're doing


    var previousLeft = el.scrollLeft; // This is like a think function from a game loop

    function scrollFrame() {
      if (el.scrollLeft !== previousLeft) {
        // interrupted
        dfd.reject();
        return;
      } // set the scrollLeft for this frame


      var now = Date.now();
      var point = smoothStep(startTime, endTime, now);
      var frameLeft = Math.round(startLeft + distance * point);
      el.scrollLeft = frameLeft; // check if we're done!

      if (now >= endTime) {
        dfd.resolve();
        return;
      } // If we were supposed to scroll but didn't, then we
      // probably hit the limit, so consider it done; not
      // interrupted.


      if (el.scrollLeft === previousLeft && el.scrollLeft !== frameLeft) {
        dfd.resolve();
        return;
      }

      previousLeft = el.scrollLeft; // schedule next frame for execution

      setTimeout(scrollFrame, 0);
    } // boostrap the animation process


    setTimeout(scrollFrame, 0);
    return dfd;
  }
  /**
   * Binds the Soho Behavior _smoothScrollTo()_ to a jQuery selector
   * @param {number} target target distance to scroll the element
   * @param {number} duration the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred} promise that resolved when scrolling completes.
   */


  $.fn.smoothScroll = function (target, duration) {
    return smoothScrollTo(this, target, duration);
  };
  /**
   * Uses 'requestAnimationFrame' or 'setTimeout' to defer a function.
   * @param {function} callback the callback that runs on a deferment.
   * @param {number} timer how long to delay before running the callback.
   * @returns {function} either `requestAnimationFrame` or `setTimeout`
   */


  function defer(callback, timer) {
    var deferMethod = typeof window.requestAnimationFrame !== 'undefined' ? window.requestAnimationFrame : setTimeout;
    return deferMethod(callback, timer);
  }

  /**
   * Used for changing the stacking order of jQuery events.  This is needed to override certain
   * Events invoked by other plugins http://stackoverflow.com/questions/2360655
   * @private
   * @param {string} name the event name
   * @param {function} fn callback function that will be called during the supplied event name
   * @returns {void}
   */

  $.fn.bindFirst = function (name, fn) {
    this.on(name, fn);
    this.each(function () {
      var handlers = $._data(this, 'events')[name.split('.')[0]]; // eslint-disable-line
      // take out the handler we just inserted from the end


      var handler = handlers.pop(); // move it at the beginning

      handlers.splice(0, 0, handler);
    });
  };
  /**
   * @private
   * uniqueIdCount is a baseline unique number that will be used when generating
   * uniqueIds for elements and components.
   */


  var uniqueIdCount = []; // eslint-disable-line

  /**
   * Detect whether or not a text string represents a valid CSS property.  This check
   * includes an attempt at checking for vendor-prefixed versions of the CSS property
   * provided.
   * @private
   * @param {string} prop a possible CSS property
   * @returns {string|null} If the property exists, it will be returned in string format.
   *  If the property doesn't exist, a null result is returned.
   */

  $.fn.cssPropSupport = function (prop) {
    if (!prop) {
      return null;
    }

    var el = $('<div></div>')[0];
    var propStr = prop.toString();
    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var capitalizedProp = propStr.charAt(0).toUpperCase() + propStr.substr(1);

    if (prop in el.style) {
      $(el).remove();
      return prop;
    }

    for (var i = 0; i < prefixes.length; i++) {
      var vendorProp = prefixes[i] + capitalizedProp;

      if (vendorProp in el.style) {
        $(el).remove();
        return vendorProp;
      }
    }

    $(el).remove();
    return null;
  };
  /**
   * Returns the name of the TransitionEnd event.
   * @private
   * @returns {string} a (possibly) vendor-adjusted CSS transition property name.
   */


  $.fn.transitionEndName = function () {
    var prop = $.fn.cssPropSupport('transition');
    var eventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      MSTransition: 'msTransitionEnd',
      OTransition: 'oTransitionEnd',
      transition: 'transitionend'
    };
    return eventNames[prop] || null;
  };
  /**
   * Checks to see if a provided element is visible based on its CSS `visibility` property.
   * @private
   * @param {HTMLElement} element the element being checked.
   * @returns {boolean} whether or not the element is visible.
   */


  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, 'visibility') === 'hidden';
    }).length;
  }
  /**
   * From jQueryUI Core: https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js#L93
   * Adapted from:  http://stackoverflow.com/questions/7668525/is-there-a-jquery-selector-to-get-all-elements-that-can-get-focus
   * Adds the ':focusable' selector to Sizzle to allow for the selection of elements
   * that can currently be focused.
   * @private
   * @param {HTMLElement} element the element being checked
   * @returns {boolean} whether or not the element is focusable.
   */


  function _focusable(element) {
    var map;
    var mapName;
    var img;
    var nodeName = element.nodeName.toLowerCase();
    var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex'));

    if (nodeName === 'area') {
      map = element.parentNode;
      mapName = map.name;

      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }

      img = $("img[usemap=#".concat(mapName, "]"))[0];
      return !!img && visible(img);
    } // The element and all of its ancestors must be visible.
    // Return out fast if this isn't the case.


    if (!visible(element)) {
      return false;
    }

    var match = /input|select|textarea|button|object/.test(nodeName);

    if (match) {
      return !element.disabled;
    }

    if (nodeName === 'a') {
      return element.href !== undefined || isTabIndexNotNaN;
    }

    return isTabIndexNotNaN;
  } // Adds a `:focusable` selector to jQuery's selector library.


  $.extend($.expr[':'], {
    focusable: function focusable(element) {
      return _focusable(element, !isNaN($.attr(element, 'tabindex')));
    }
  });
  /**
   * Returns a key/value list of currently attached event listeners
   * @private
   * @returns {object} containing list of event names as keys, and event listener functions as values.
   */

  $.fn.listEvents = function () {
    var data = {};
    this.each(function () {
      data = $._data(this, 'events'); // eslint-disable-line
    });
    return data;
  };

  var utils = {};
  /**
   * Generates a unique ID for an element based on the element's configuration, any
   * Soho components that are generated against it, and provided prefixes/suffixes.
   * @private
   * @param {HTMLElement} element the element being used for uniqueId capture
   * @param {string} [className] CSS classname (will be interpreted automatically
   *  if it's not provided)
   * @param {string} [prefix] optional prefix
   * @param {string} [suffix] optional suffix
   * @returns {string} the compiled uniqueID
   */

  utils.uniqueId = function (element, className, prefix, suffix) {
    var predefinedId = element.id;

    if (predefinedId && $("#".concat(predefinedId)).length < 2) {
      return predefinedId;
    }

    prefix = !prefix ? '' : "".concat(prefix, "-");
    suffix = !suffix ? '' : "-".concat(suffix);
    className = !className ? utils.getArrayFromList(element.classList).join('-') : className;

    if (!uniqueIdCount[className]) {
      uniqueIdCount[className] = 1;
    }

    var str = "".concat(prefix).concat(className, "-").concat(uniqueIdCount[className]).concat(suffix);
    uniqueIdCount[className] += 1;
    return str;
  };
  /**
   * Grabs an attribute from an HTMLElement containing stringified JSON syntax,
   * and interprets it into options.
   * @private
   * @param {HTMLElement} element the element whose settings are being interpreted
   * @param {string} [attr] optional different attribute to parse for settings
   * @returns {object} a list of interpreted settings for this element
   */


  utils.parseSettings = function parseSettings(element, attr) {
    var options = {};

    if (!element || !(element instanceof HTMLElement) && !(element instanceof $) || element instanceof $ && !element.length) {
      return options;
    }

    if (element instanceof $) {
      element = element[0];
    } // Use `data-options` as a default.


    attr = attr || 'data-options';
    var str = element.getAttribute(attr);

    if (!str || typeof str !== 'string' || str.indexOf('{') === -1) {
      return options;
    } // replace single to double quotes, since single-quotes may be necessary
    // due to entry in markup.


    function replaceDoubleQuotes(changedStr) {
      return changedStr.replace(/'/g, '"');
    } // Manually parse a string more in-depth


    function manualParse(changedStr) {
      // get keys
      var regex = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g; // eslint-disable-line
      // add double quotes to keys

      changedStr = changedStr.replace(regex, '$1\"$2\":'); // eslint-disable-line
      // get strings in values

      regex = /:(?:\s*)(?!(true|false|null|undefined))([A-Za-z_$\.#][A-Za-z0-9_ \-\.$]*)/g; // eslint-disable-line
      // add double quotes to strings in values

      changedStr = changedStr.replace(regex, ':\"$2\"'); // eslint-disable-line

      changedStr = replaceDoubleQuotes(changedStr);
      return changedStr;
    }

    try {
      options = JSON.parse(replaceDoubleQuotes(str));
    } catch (err) {
      options = JSON.parse(manualParse(str));
    }

    return options;
  };
  /**
   * Deprecate `utils.parseOptions` in favor of `utils.parseSettings`.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @private
   * @deprecated as of v4.4.0. Please use `parseSettings()` instead.
   * @param {HTMLElement|jQuery[]} element the element whose options are being parsed
   * @param {string} [attr] an optional alternate attribute name to use when obtaining settings
   * @returns {Object|Object[]} an object representation of parsed settings.
   */


  utils.parseOptions = function parseOptions(element, attr) {
    return utils.parseSettings(element, attr);
  };
  /**
  * jQuery Behavior Wrapper for `utils.parseOptions`.
  * @deprecated as of v4.4.0. This is no longer necessary to call directly and should be avoided.
  * @private
  * @param {HTMLElement|jQuery[]} element the element whose options are being parsed
  * @param {string} [attr] an optional alternate attribute name to use when obtaining settings
  * @returns {Object|Object[]} an object representation of parsed settings.
  */


  $.fn.parseOptions = function (element, attr) {
    var results = [];
    var isCalledDirectly = element instanceof HTMLElement || element instanceof SVGElement || element instanceof $;
    var targets = this;

    if (isCalledDirectly) {
      targets = $(element);
    } else {
      attr = element;
      element = undefined;
    }

    targets.each(function (i, item) {
      results.push({
        element: this,
        options: utils.parseOptions(item, attr)
      });
    });

    if (results.length === 1) {
      return results[0].options;
    }

    return results;
  };
  /**
   * Performs the usual Boolean coercion with the exception of the strings "false"
   * (case insensitive) and "0"
   * @private
   * @param {boolean|string|number} b the value to be checked
   * @returns {boolean} whether or not the value passed coerces to true.
   */


  utils.coerceToBoolean = function (b) {
    return !/^(false|0)$/i.test(b) && !!b;
  };
  /**
   * Coerces all properties inside of a settings object to a boolean.
   * @param {Object} settings incoming settings
   * @param {String[]} [targetPropsArr=undefined] optional array of specific settings keys to target.
   *  If no keys are provided, all keys will be targeted.
   * @returns {Object} modified settings.
   */


  utils.coerceSettingsToBoolean = function (settings, targetPropsArr) {
    if (!targetPropsArr || !Array.isArray(targetPropsArr)) {
      Object.keys(settings).forEach(function (key) {
        targetPropsArr.push(key);
      });
    }

    var i;
    var l;

    for (i = 0, l = targetPropsArr.length; i < l; i++) {
      settings[targetPropsArr[i]] = utils.coerceToBoolean(settings[targetPropsArr[i]]);
    }

    return settings;
  };
  /**
   * Timer - can be used for play/pause or stop for given time.
   * Use as new instance [ var timer = new $.fn.timer(function() {}, 6000); ]
   * then can be listen events as:
   * [ $(timer.event).on('update', function(e, data){console.log(data.counter)}); ]
   * or can access as [ timer.cancel(); -or- timer.pause(); -or- timer.resume(); ]
   * @private
   * @param {function} [callback] method that will run on each timer update
   * @param {number} delay amount of time between timer ticks
   * @returns {object} containing methods that can be run on the timer
   */


  $.fn.timer = function (callback, delay) {
    var self = $(this);
    var speed = 10;
    var interval;
    var counter = 0;

    function cancel() {
      self.triggerHandler('cancel');
      clearInterval(interval);
      counter = 0;
    }

    function pause() {
      self.triggerHandler('pause');
      clearInterval(interval);
    }

    function update() {
      interval = setInterval(function () {
        counter += speed;
        self.triggerHandler('update', [{
          counter: counter
        }]);

        if (counter > delay) {
          self.triggerHandler('timeout');
          callback.apply(arguments); // eslint-disable-line

          clearInterval(interval);
          counter = 0;
        }
      }, speed);
    }

    function resume() {
      self.triggerHandler('resume');
      update();
    }

    update();
    return {
      event: this,
      cancel: cancel,
      pause: pause,
      resume: resume
    };
  };
  /**
   * Copies a string to the clipboard. Must be called from within an event handler such as click.
   * May return false if it failed, but this is not always
   * possible. Browser support for Chrome 43+, Firefox 42+, Edge and IE 10+.
   * No Safari support, as of (Nov. 2015). Returns false.
   * IE: The clipboard feature may be disabled by an adminstrator. By default a prompt is
   * shown the first time the clipboard is used (per session).
   * @private
   * @param {string} text incoming text content
   * @returns {string|boolean} copied text, or a false result if there was an error
   */


  $.copyToClipboard = function (text) {
    // eslint-disable-line
    if (window.clipboardData && window.clipboardData.setData) {
      // IE specific code path to prevent textarea being shown while dialog is visible.
      return window.clipboardData.setData('Text', text);
    }

    if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      var textarea = document.createElement('textarea');
      textarea.textContent = text;
      textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in MS Edge.

      document.body.appendChild(textarea);
      textarea.select();

      try {
        return document.execCommand('copy'); // Security exception may be thrown by some browsers.
      } catch (ex) {
        // console.warn('Copy to clipboard failed.', ex);
        return false;
      } finally {
        document.body.removeChild(textarea);
      }
    }
  };
  /**
   * Clearable (Shows an X to clear)
   * @private
   */


  $.fn.clearable = function () {
    var self = this;
    this.element = $(this);
    var COMPONENT_NAME = 'clearable'; // Create an X icon button styles in icons.scss

    this.xButton = this.element.find('.icon.close').first();

    if (!this.xButton || !this.xButton.length) {
      this.xButton = $.createIconElement({
        classes: 'close is-empty',
        icon: 'close'
      }).icon();
    } // Clears the contents of the base element


    this.clear = function () {
      self.element.val('').trigger('change').focus().trigger('cleared');
      self.checkContents();
    }; // Event listener for the xButton's `keydown` event


    this.handleKeydown = function (e) {
      var key = e.key;

      if (key === 'Enter' || e.altKey && (key === 'Delete' || key === 'Backspace')) {
        e.preventDefault();
        self.clear();
      }
    }; // Checks the contents of the base element (presumably an input field) for empty


    this.checkContents = function () {
      var text = self.element.val();

      if (!text || !text.length) {
        this.xButton.addClass('is-empty');
      } else {
        this.xButton.removeClass('is-empty');
      }

      this.element.trigger('contents-checked');
    }; // Add the button to field parent


    this.xButton.insertAfter(self.element);
    this.xButton[0].tabIndex = 0;
    this.xButton[0].setAttribute('focusable', true); // Handle Events

    this.xButton.off(["click.".concat(COMPONENT_NAME), "keydown.".concat(COMPONENT_NAME)].join(' ')).on('click.clearable', this.clear).on('keydown.clearable', this.handleKeydown);
    var elemEvents = ["blur.".concat(COMPONENT_NAME), "change.".concat(COMPONENT_NAME), "keyup.".concat(COMPONENT_NAME)].join(' ');
    this.element.off(elemEvents).on(elemEvents, function () {
      self.checkContents();
    }); // Set initial state

    this.checkContents();
  };
  /**
   * Replacement for String.fromCharCode() that takes meta keys into account when determining which
   * @private
   * character key was pressed.
   * @param {jQuery.Event} e jQuery-wrapped `keypress` event
   * @returns {string} text tcharacter
   */


  utils.actualChar = function (e) {
    var key = e.which;
    var character = '';
    var toAscii = {
      188: '44',
      // '109': '45', // changes "m" to "-" when using keypress
      190: '46',
      191: '47',
      192: '96',
      220: '92',
      222: '39',
      221: '93',
      219: '91',
      173: '45',
      187: '61',
      // IE Key codes
      186: '59',
      // IE Key codes
      189: '45' // IE Key codes

    };
    var shiftUps = {
      96: '~',
      49: '!',
      50: '@',
      51: '#',
      52: '$',
      53: '%',
      54: '^',
      55: '&',
      56: '*',
      57: '(',
      48: ')',
      45: '_',
      61: '+',
      91: '{',
      93: '}',
      92: '|',
      59: ':',
      37: '%',
      38: '&',
      39: '"',
      44: '<',
      46: '>',
      47: '?'
    }; // Normalize weird keycodes

    if (Object.prototype.hasOwnProperty.call(toAscii, key)) {
      key = toAscii[key];
    } // Handle Numpad keys


    if (key >= 96 && key <= 105) {
      key -= 48;
    } // Convert Keycode to Character String


    if (!e.shiftKey && key >= 65 && key <= 90) {
      character = String.fromCharCode(key + 32);
    } else if (!e.shiftKey && key >= 37 && key <= 40) {
      // arrow keys
      character = '';
    } else if (e.shiftKey && Object.prototype.hasOwnProperty.call(shiftUps, key)) {
      // User was pressing Shift + any key
      character = shiftUps[key];
    } else {
      character = String.fromCharCode(key);
    }

    return character;
  };
  /**
   * Get the actualy typed key from the event.
   * @private
   * @param  {object} e The event to check for the key.
   * @returns {string} The actual key typed.
   */


  $.actualChar = function (e) {
    return utils.actualChar(e);
  };
  /**
   * Equate two values quickly in a truthy fashion
   * @private
   * @param {any} a first value
   * @param {any} b second value
   * @returns {boolean} whether the two items compare in a truthy fashion.
   */


  utils.equals = function equals(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  };
  /**
   * Converts an element wrapped in a jQuery collection down to its original HTMLElement reference.
   * If an HTMLElement is passed in, simply returns it.
   * If anything besides HTMLElements or jQuery[] is passed in, returns undefined;
   * @private
   * @param {any} item the item being evaluated
   * @returns {HTMLElement|undefined} the unwrapped item, or nothing.
   */


  DOM.convertToHTMLElement = function convertToHTMLElement(item) {
    if (item instanceof HTMLElement) {
      return item;
    }

    if (item instanceof $) {
      if (item.length) {
        item = item[0];
      } else {
        item = undefined;
      }

      return item;
    }

    return undefined;
  };
  /**
   * Returns a list of all focusable elements contained within the current element.
   * Somewhat lifted from https://gomakethings.com/how-to-get-the-first-and-last-focusable-elements-in-the-dom/
   * @param {HTMLElement} el the element to search.
   * @param {array} [additionalSelectors] containing strings representing CSS selectors that should also be considered when making the query for focusable elements.
   * @param {array} [ignoreSelectors] containing strings representing CSS selectors that should be filtered out from selection.
   * @returns {array} containing the focusable elements.
   */


  DOM.focusableElems = function focusableElems(el) {
    var additionalSelectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var ignoreSelectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var focusableElemSelector = ['button:not([disabled]):not([tabindex="-1"])', '[href]:not([disabled]):not([tabindex="-1"])', 'input:not([disabled]):not([tabindex="-1"])', 'textarea:not([disabled]):not([tabindex="-1"])', '[focusable]:not([focusable="false"])', '[tabindex]:not([tabindex="-1"])', '[contenteditable]', 'iframe'].concat(additionalSelectors).filter(function (item) {
      return ignoreSelectors.indexOf(item) === -1;
    });

    var elems = _toConsumableArray(el.querySelectorAll(focusableElemSelector.join(', ')));

    return elems.filter(function (elem) {
      if (elem.tagName.toLowerCase() === 'use') {
        return false;
      }

      return true;
    });
  };
  /**
   * See if the object is simple or more complex (has a constructor).
   * @param {object} obj The object to check
   * @returns {boolean} Returns true if simple
   */


  utils.isPlainObject = function isPlainObject(obj) {
    if (!obj || Object.prototype.toString.call(obj) !== '[object Object]') {
      return false;
    } // Objects with no prototype (e.g., `Object.create( null )`) are plain


    var proto = Object.getPrototypeOf(obj);

    if (!proto) {
      return true;
    }

    return obj !== null && _typeof(obj) === 'object' && Object.getPrototypeOf(obj) === Object.prototype;
  };
  /**
   * Merge an array be each index position
   * @param  {array} arr1 The first array
   * @param  {array} arr2  The second array
   * @returns {array} The merged array
   */


  utils.mergeByPosition = function mergeByPosition(arr1, arr2) {
    var _arr;

    var len = Math.max(((_arr = arr1) === null || _arr === void 0 ? void 0 : _arr == null ? void 0 : _arr.length) || 0, (arr2 === null || arr2 === void 0 ? void 0 : arr2 == null ? void 0 : arr2.length) || 0);

    if (!arr1) {
      arr1 = [];
    }

    if (len === 0) {
      return [];
    }

    for (var i = 0; i < len; i++) {
      if (arr2[i] !== undefined && arr2[i] !== null) {
        arr1[i] = arr2[i];
      }
    }

    return arr1 || [];
  };
  /**
   * Merge the contents of two or more objects together into the first object.
   * @param {boolean|object} deepOrTarget If a boolean (true), the merge becomes recursive (aka. deep copy). Passing false for this argument is not supported. If an object then this object well get the extended objects applied.
   * @param {object} object1 An object containing additional properties to merge in.
   * @param {object} objectN Additional objects containing properties to merge in.
   * @returns {object} The merged object
   */


  utils.extend = function extend() {
    // Variables
    var extended = arguments[0] || {};
    var deep = false;
    var i = 0; // Check if a deep merge

    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
      deep = arguments[0];
      extended = Array.isArray(arguments[1]) ? [] : {};
      i++;
    } // Merge the object into the extended object


    var merge = function merge(obj) {
      for (var prop in obj) {
        //eslint-disable-line
        if (obj.hasOwnProperty(prop)) {
          //eslint-disable-line
          // If property is an object, merge properties - in several ways
          if (obj[prop] instanceof jQuery) {
            // Needed for now until jQuery is fully dropped
            extended[prop] = $(obj[prop]);
          } else if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
            var newObj = obj[prop];
            var isPlain = utils.isPlainObject(newObj);
            var emptyObj = Array.isArray(newObj) ? [] : {};
            extended[prop] = isPlain ? extend(true, emptyObj, extended[prop], newObj) : newObj;
          } else {
            if (Array.isArray(obj[prop])) {
              //eslint-disable-line
              extended[prop] = utils.mergeByPosition(extended[prop], obj[prop]);
            } else if (obj[prop] !== undefined) {
              extended[prop] = obj[prop] === undefined && extended[prop] !== undefined ? extended[prop] : obj[prop];
            }
          }
        } // Add functions and jQuery objects


        if (!obj.hasOwnProperty(prop) && !extended[prop] && Object.prototype.toString.call(obj[prop]) === '[object Function]') {
          //eslint-disable-line
          extended[prop] = obj[prop];
        }
      }
    }; // Loop through each object and conduct a merge


    for (; i < arguments.length; i++) {
      merge(arguments[i]); //eslint-disable-line
    }

    return extended;
  };
  /**
   * Hack for IE11 and SVGs that get moved around/appended at inconvenient times.
   * The action of changing the xlink:href attribute to something else and back will fix the problem.
   * @private
   * @param {HTMLElement} rootElement the base element
   * @returns {void}
   */


  utils.fixSVGIcons = function fixSVGIcons(rootElement) {
    if (Environment.browser.name !== 'ie' && Environment.browser.version !== '11') {
      return;
    }

    if (rootElement === undefined) {
      return;
    }

    var xlinkNS = 'http://www.w3.org/1999/xlink'; // Handle jQuery

    if (rootElement instanceof $) {
      if (!rootElement.length) {
        return;
      }

      if (rootElement.length === 1) {
        rootElement = rootElement[0];
      } else {
        rootElement.each(function (i, elem) {
          fixSVGIcons(elem);
        });
        return;
      }
    } // Handle NodeList in an IE-friendly way
    // https://developer.mozilla.org/en-US/docs/Web/API/NodeList#Example


    if (rootElement instanceof NodeList) {
      Array.prototype.forEach.call(rootElement, function (elem) {
        fixSVGIcons(elem);
      });
      return;
    }

    setTimeout(function () {
      var uses = rootElement.getElementsByTagName('use');

      for (var i = 0; i < uses.length; i++) {
        var attr = uses[i].getAttributeNS(xlinkNS, 'href');
        uses[i].setAttributeNS(xlinkNS, 'href', 'x');
        uses[i].setAttributeNS(xlinkNS, 'href', attr);
      }
    }, 1);
  };
  /**
   * Gets the current size of the viewport
   * @private
   * @returns {object} width/height of the viewport
   */


  utils.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };
  /**
   * Gets the various scrollable containers that an element is nested inside of, and returns
   *  their scrollHeight and scrollLeft values.
   * @private
   * @param {HTMLElement} element the base element to check for containment
   * @returns {object} containing references to the container element and its top/left
   */


  utils.getContainerScrollDistance = function getContainerScrollDistance(element) {
    if (!DOM.isElement(element)) {
      return [];
    }

    var containers = [];
    var scrollableElements = ['.scrollable', '.scrollable-x', '.scrollable-y', '.modal', '.card-content', '.widget-content', '.tab-panel', '.datagrid-content'];
    $(element).parents(scrollableElements.join(', ')).each(function () {
      var el = this;
      containers.push({
        element: el,
        left: el.scrollLeft,
        top: el.scrollTop
      });
    }); // Push the body's scroll area if it's not a "no-scroll" area

    if (!document.body.classList.contains('no-scroll')) {
      containers.push({
        element: document.body,
        left: document.body.scrollLeft,
        top: document.body.scrollTop
      });
    }

    return containers;
  };
  /**
   * Takes an element that is currently hidden by some means (FX: "display: none;")
   *  and gets its potential dimensions by checking a clone of the element that is NOT hidden.
   * @private
   * @param {HTMLElement|SVGElement|jQuery[]} el The element being manipulated.
   * @param {object} options incoming options.
   * @param {jQuery[]} [parentElement] the parent element where a clone of this
   *  hidden element will be attached.
   * @returns {object} containing various width/height properties of the element provided.
   */


  utils.getHiddenSize = function getHiddenSize(el, options) {
    var defaults = {
      dims: {
        width: 0,
        height: 0,
        innerWidth: 0,
        innerHeight: 0,
        outerWidth: 0,
        outerHeight: 0
      },
      parentElement: undefined,
      includeMargin: false
    };

    if (!DOM.isElement(el)) {
      return defaults.dims;
    }

    el = $(el);
    options = _objectSpread2(_objectSpread2({}, defaults), options); // element becomes clone and appended to a parentElement, if defined

    var hasDefinedParentElement = DOM.isElement(options.parentElement);

    if (hasDefinedParentElement) {
      el = el.clone().appendTo(options.parentElement);
    }

    var dims = options.dims;
    var hiddenParents = el.parents().add(el);
    var props = {
      transition: 'none',
      webkitTransition: 'none',
      mozTransition: 'none',
      msTransition: 'none',
      visibility: 'hidden',
      display: 'block'
    };
    var oldProps = [];
    hiddenParents.each(function () {
      var _this = this;

      var old = {};
      var propTypes = Object.keys(props);
      propTypes.forEach(function (name) {
        if (_this.style[name]) {
          old[name] = _this.style[name];
          _this.style[name] = props[name];
        }
      });
      oldProps.push(old);
    });
    dims.padding = {
      bottom: el.css('padding-bottom'),
      left: el.css('padding-left'),
      right: el.css('padding-right'),
      top: el.css('padding-top')
    };
    dims.width = el.width();
    dims.outerWidth = el.outerWidth(options.includeMargin);
    dims.innerWidth = el.innerWidth();
    dims.scrollWidth = el[0].scrollWidth;
    dims.height = el.height();
    dims.innerHeight = el.innerHeight();
    dims.outerHeight = el.outerHeight(options.includeMargin);
    dims.scrollHeight = el[0].scrollHeight;
    hiddenParents.each(function (i) {
      var _this2 = this;

      var old = oldProps[i];
      var propTypes = Object.keys(props);
      propTypes.forEach(function (name) {
        if (old[name]) {
          _this2.style[name] = old[name];
        }
      });
    }); // element is ONLY removed when a parentElement is defined because it was cloned.

    if (hasDefinedParentElement) {
      el.remove();
    }

    return dims;
  };
  /**
   * Binds the Soho Util _getHiddenSize()_ to a jQuery selector
   * @private
   * @param {object} options - incoming options
   * @returns {object} hidden size
   */


  $.fn.getHiddenSize = function (options) {
    return utils.getHiddenSize(this, options);
  };
  /**
   * Checks if a specific input is a String
   * @private
   * @param {any} value an object of unknown type to check
   * @returns {boolean} whether or not a specific input is a String
   */


  utils.isString = function isString(value) {
    return typeof value === 'string' || value instanceof String;
  };
  /**
   * Checks if a specific input is a Number
   * @private
   * @param {any} value an object of unknown type to check
   * @returns {boolean} whether or not a specific input is a Number
   */


  utils.isNumber = function isNumber(value) {
    return typeof value === 'number' && value.length === undefined && !isNaN(value);
  };
  /**
   * Safely changes the position of a text caret inside of an editable element.
   * In most cases, will call "setSelectionRange" on an editable element immediately, but in some
   * cases, will be deferred with `requestAnimationFrame` or `setTimeout`.
   * @private
   * @param {HTMLElement} element the element to get selection
   * @param {number} startPos starting position of the text caret
   * @param {number} endPos ending position of the text caret
   * @returns {void}
   */


  utils.safeSetSelection = function safeSetSelection(element, startPos, endPos) {
    // If this text field doesn't support text caret selection, return out
    var compatibleTypes = ['text', 'password', 'search', 'url', 'week', 'month'];

    if (!(element instanceof HTMLInputElement) || compatibleTypes.indexOf(element.type) === -1) {
      return;
    }

    if (startPos && endPos === undefined) {
      endPos = startPos;
    }

    if (document.activeElement === element) {
      if (Environment.os.name === 'android') {
        defer(function () {
          element.setSelectionRange(startPos, endPos, 'none');
        }, 0);
      } else {
        element.setSelectionRange(startPos, endPos, 'none');
      }
    }
  };
  /**
   * Checks to see if a variable is valid for containing Soho component options.
   * @private
   * @param {object|function} o an object or function
   * @returns {boolean} whether or not the object type is valid
   */


  function isValidOptions(o) {
    return _typeof(o) === 'object' || typeof o === 'function';
  }
  /**
   * In some cases, functions are passed to component constructors as the settings argument.
   * This method runs the settings function if it's present and returns the resulting object.
   * @private
   * @param {object|function} o represents settings
   * @returns {object} processed settings
   */


  function resolveFunctionBasedSettings(o) {
    if (typeof o === 'function') {
      return o();
    }

    return o;
  }
  /**
   * Merges various sets of options into a single object,
   * whose intention is to be set as options on a Soho component.
   * @private
   * @param {HTMLElement|SVGElement|jQuery[]} [element] the element to process for inline-settings
   * @param {Object|function} incomingOptions desired settings
   * @param {Object|function} [defaultOptions] optional base settings
   * @returns {object} processed settings
   */


  utils.mergeSettings = function mergeSettings(element, incomingOptions, defaultOptions) {
    if (!incomingOptions || !isValidOptions(incomingOptions)) {
      if (isValidOptions(defaultOptions)) {
        incomingOptions = defaultOptions;
      } else {
        incomingOptions = {};
      }
    }

    return utils.extend(true, {}, resolveFunctionBasedSettings(defaultOptions), resolveFunctionBasedSettings(incomingOptions), element !== undefined ? utils.parseSettings(element) : {});
  };
  /**
   * Test if a string is Html or not
   * @private
   * @param  {string} string The string to test.
   * @returns {boolean} True if it is html.
   */


  utils.isHTML = function (string) {
    return /(<([^>]+)>)/i.test(string);
  };

  var math = {};
  /**
   * Convert `setTimeout/Interval` delay values (CPU ticks) into frames-per-second
   * (FPS) numeric values.
   * @private
   * @param {number} delay CPU Ticks
   * @returns {number} Frames Per Second
   */

  math.convertDelayToFPS = function convertDelayToFPS(delay) {
    if (isNaN(delay)) {
      throw new Error('provided delay value is not a number');
    }

    return delay / 16.7;
  };
  /**
   * Convert `setTimeout/Interval` delay values (CPU ticks) into frames-per-second
   * (FPS) numeric values.
   * @private
   * @param {number} fps (Frames Per Second)
   * @returns {number} delay in CPU ticks
   */


  math.convertFPSToDelay = function convertFPSToDelay(fps) {
    if (isNaN(fps)) {
      throw new Error('provided delay value is not a number');
    }

    return fps * 16.7;
  };
  /**
   *  Determines whether the passed value is a finite number.
   * @private
   * @param {number} value The number
   * @returns {boolean} If it is finite or not.
   */


  math.isFinite = function isFinite(value) {
    // 1. If Type(number) is not Number, return false.
    if (typeof value !== 'number') {
      return false;
    } // 2. If number is NaN, +, or , return false.


    if (value !== value || value === Infinity || value === -Infinity) {
      //eslint-disable-line
      return false;
    } // 3. Otherwise, return true.


    return true;
  };
  /**
   * `Array.ForEach()`-style method that is also friendly to `NodeList` types.
   * @param {Array|NodeList} array incoming items
   * @param {function} callback the method to run
   * @param {object} scope the context in which to run the method
   */


  utils.forEach = function forEach(array, callback, scope) {
    for (var i = 0; i < array.length; i++) {
      callback.call(scope, array[i], i, array); // passes back stuff we need
    }
  };
  /**
   * Returns the sign of a number, indicating whether the number is positive, negative or zero
   * @param {number} x A number.
   * @returns {number} A number representing the sign of the given argument. If the argument is a positive number, negative number, positive zero or negative zero, the function will return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   */


  math.sign = function (x) {
    if (Math.sign) {
      // eslint-disable-line compat/compat
      return Math.sign(x); // eslint-disable-line compat/compat
    }

    x = +x;

    if (x === 0 || isNaN(x)) {
      return x;
    }

    return x > 0 ? 1 : -1;
  };
  /**
   * Convenience method for using `Array.prototype.slice()` on an Array-like object (or an actual array)
   * to make a copy.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
   * @param {Array|NodeList} listObj an array-like object
   * @returns {array} containing the list in array format.
   */


  utils.getArrayFromList = function (listObj) {
    var unboundSlice = Array.prototype.slice;
    return Function.prototype.call.bind(unboundSlice)(listObj);
  };
  /**
   * Gets the OS scollbar width in pixels.
   * @returns {number} The width as a number.
   */


  utils.getScrollbarWidth = function () {
    var outer = document.createElement('div');
    outer.style.visibility = 'hidden';
    outer.style.width = '100px';
    document.body.appendChild(outer);
    var widthNoScroll = outer.offsetWidth;
    outer.style.overflow = 'scroll';
    var inner = document.createElement('div');
    inner.style.width = '100%';
    outer.appendChild(inner);
    var widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    return widthNoScroll - widthWithScroll;
  };
  /**
   * Create deep copy for given array or object.
   * @param  {array|object} arrayOrObject The array or object to be copied.
   * @returns {array|object} The copied array or object.
   */


  utils.deepCopy = function (arrayOrObject) {
    return utils.extend(true, Array.isArray(arrayOrObject) ? [] : {}, arrayOrObject);
  };
  /**
   * Check if the event is subscribed to
   * @param {HTMLElement} elem The object to check
   * @param {object} e The event object to check
   * @param {string} eventName The event name to look for
   * @param {string} namespace The namespace to look for
   * @returns {boolean} True if the event is subscribed to
   */


  utils.isSubscribedTo = function (elem, e, eventName, namespace) {
    var events = $._data(elem).events; //eslint-disable-line


    for (var event in events) {
      //eslint-disable-line
      if (event === eventName && !(events[event].length === 1 && events[event][0].namespace === namespace)) {
        return true;
      }
    }

    return false;
  };
  /**
   * Check if given element is within the viewport.
   * @private
   * @param {object} element The element to check
   * @returns {boolean} Whether or not the element is in the viewport.
   */


  utils.isInViewport = function isInViewport(element) {
    var b = element.getBoundingClientRect();
    return b.top >= 0 && b.left >= 0 && b.bottom <= (window.innerHeight || document.documentElement.clientHeight) && b.right <= (window.innerWidth || document.documentElement.clientWidth);
  };
  /**
   * Get siblings height for given element.
   * @privateel
   * @param {object} el The element to get siblings height.
   * @returns {number} The calculated height.
   */


  utils.getSiblingsHeight = function getSiblingsHeight(el) {
    var siblings = DOM.getSiblings(el);
    return siblings.map(function (sibling) {
      return sibling.offsetHeight;
    }).reduce(function (a, h) {
      return a + h;
    }, 0);
  };
  /**
   * Get parent available height for given element.
   * @privateel
   * @param {object} el The element to get parent available height.
   * @returns {number} The calculated height.
   */


  utils.getParentAvailableHeight = function getParentAvailableHeight(el) {
    return el.parentNode.offsetHeight - utils.getSiblingsHeight(el);
  };
  /**
   * Clear all currently selected.
   * @privateel
   * @returns {void}
   */


  utils.clearSelection = function clearSelection() {
    if (window.getSelection) {
      window.getSelection().removeAllRanges();
    } else if (document.selection) {
      document.selection.empty();
    }
  };
  /**
   * Toggle the form compact mode and any child classes as need.
   * @param {HTMLElement} elem The top level element or form element
   * @returns {void}
   */


  utils.toggleCompactMode = function toggleCompactMode(elem) {
    var className = 'form-layout-compact';
    var hasClass = elem.classList.contains(className);

    if (hasClass) {
      elem.classList.remove(className);
    } else {
      elem.classList.add(className);
    }

    var datagrids = elem.querySelectorAll('.datagrid-container');

    for (var i = 0; i < datagrids.length; i++) {
      var api = $(datagrids[i]).data('datagrid');

      if (!api.rowHeight) {
        return;
      }

      if (hasClass) {
        api.rowHeight(api.oldRowHeight || 'large');
      } else {
        api.oldRowHeight = api.settings.rowHeight;
        api.rowHeight('extra-small');
      }
    }
  };
  /**
   * Generate additional attributes.
   * @private
   * @param {object} elem The DOM node to add to
   * @param {object} api The object base api
   * @param {object|Array} setting The attribute setting
   * @param {string} suffix Append an extra string at the end
   * @param {boolean} overrideExistingId Write over the current id value if there already
   */


  utils.addAttributes = function addAttributes(elem, api, setting, suffix, overrideExistingId) {
    if (!setting) {
      return;
    } // Add the given attribute to element, if not alreay exist


    var addAttr = function addAttr(name, value) {
      if (elem[0] && (overrideExistingId ? true : !elem[0].hasAttribute(name))) {
        elem.attr(name, value + (suffix ? "-".concat(suffix.toLowerCase()) : ''));
      }
    };

    if (Array.isArray(setting)) {
      setting.forEach(function (item) {
        var value = typeof item.value === 'function' ? item.value(api) : item.value;
        addAttr(item.name, value);
      });
      return;
    }

    var value = typeof setting.value === 'function' ? setting.value(api) : setting.value;
    addAttr(setting.name, value);
  };
  /**
   * Generate additional attributes as an html string
   * @private
   * @param {object} api The object base api
   * @param {object|Array} setting The attribute setting
   * @param {string} suffix Append an extra string at the end
   * @returns {string} the attrbibutes as a string
   */


  utils.stringAttributes = function addAttributes(api, setting, suffix) {
    var attributes = '';

    if (!setting) {
      return attributes;
    }

    if (Array.isArray(setting)) {
      setting.forEach(function (item) {
        var value = typeof item.value === 'function' ? item.value(api) : item.value;
        attributes += " ".concat(item.name, "=\"").concat(value + (suffix ? "-".concat(suffix) : ''), "\"");
      });
      return attributes;
    }

    var value = typeof setting.value === 'function' ? setting.value(api) : setting.value;
    attributes += " ".concat(setting.name, "=\"").concat(value + (suffix ? "-".concat(suffix.toLowerCase()) : ''), "\"");
    return attributes;
  };

  var objectUtils = {};
  /**
   * Checks to see if an object has any identifiable properties beyond standard Object properties
   * that can be used for comparison or evaluation.
   * @param {object} obj the object to check.
   * @returns {boolean} true if the object is empty, false if it contains properties.
   */

  objectUtils.isEmpty = function (obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
  };

  var stringUtils = {};
  /**
   * Re-usable Empty String that can be referenced everywhere to save small amounts of space.
   */

  stringUtils.EMPTY = '';
  /**
  * The splice() method changes the content of a string by removing a range of
  * characters and/or adding new characters.
  *
  * @param {string} str The string that will be manipulated.
  * @param {number} start Index at which to start changing the string.
  * @param {number} delCount An integer indicating the number of old chars to remove.
  * @param {string} newSubStr The String that is spliced in.
  * @returns {string} A new string with the spliced substring.
  */

  stringUtils.splice = function splice(str, start, delCount, newSubStr) {
    return str.slice(0, start) + newSubStr + str.slice(start + Math.abs(delCount));
  };
  /**
   * Takes a string with possible duplicate characters and returns a string
   * containing ALL unique characters.  Useful for construction of REGEX objects
   * with characters from an input field, etc.
   * @param {string} str The string to process
   * @returns {string} The processed string
   */


  stringUtils.removeDuplicates = function removeDuplicates(str) {
    return str.split('').filter(function (item, pos, self) {
      //eslint-disable-line
      return self.indexOf(item) === pos;
    }).join('');
  };
  /**
   * Takes a string and uses a regex test to detect the presence of HTML elements.
   * @param {string} str The string to search
   * @returns {boolean} True if the string is contained.
   */


  stringUtils.containsHTML = function containsHTML(str) {
    return /<[a-z][\s\S]*>/i.test(str);
  };
  /**
   * Takes a string containing HTML and strips it of extraneous white space.
   * @param {string} str The string to parse
   * @returns {string} The string minus extraneous white space.
   */


  stringUtils.stripWhitespace = function stripWhitespace(str) {
    return str.replace(/\n/g, '').replace(/[\t ]+</g, '<').replace(/>[\t ]+</g, '><').replace(/>[\t ]+$/g, '>');
  };
  /**
   * Capitalizes the first letter of a string
   * @param {string} str the incoming text
   * @returns {string} the modified text
   */


  stringUtils.capitalize = function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  /**
   * [capitalize description]
   * @param  {string} val A text string ("true" or "false") that can be converted to a boolean.
   * @returns {boolean} true or false
   */


  stringUtils.toBoolean = function capitalize(val) {
    var num = +val;
    return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
  };
  /**
   * Return the width in pixels, assuming fontsize 14 as a default
   * @param  {string} text A text string to measure.
   * @param  {string} fontsize The elements font size (defaults to 14)
   * @returns {number} The text width.
   */


  stringUtils.textWidth = function capitalize(text) {
    var fontsize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;
    this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
    var context = this.canvas.getContext('2d');
    context.font = "".concat(fontsize, "px arial");
    var metrics = context.measureText(text);
    return Math.round(metrics.width);
  };
  /**
   * Pad a date into a string with zeros added.
   * @private
   * @param {number} year The year to use.
   * @param {number} month The month to use.
   * @param {number} day The day to use.
   * @returns {void}
   */


  stringUtils.padDate = function padDate(year, month, day) {
    return year + "0".concat(month + 1).slice(-2) + "0".concat(day).slice(-2);
  };
  /**
   * Calculate the width for given text string.
   * @private
   * @param {string} text string to process
   * @param {number} padding value for left + right
   * @param {string} font size and family used with the given text string
   * @returns {number} calculated width
   */


  stringUtils.textWidth = function textWidth(text, padding, font) {
    this.canvasTW = this.canvasTW || (this.canvasTW = document.createElement('canvas'));
    var context = this.canvasTW.getContext('2d');
    context.font = font || '14px arial';
    var metrics = context.measureText(text);
    return Math.round(metrics.width + (padding || 0));
  };
  /**
   * Escape user input that will be treated as a literal string.  This prevents incorrect
   * RegExp matching when converting user input.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
   * @private
   * @param {string} s string to process.
   * @returns {string} string after escaping.
   */


  stringUtils.escapeRegExp = function escapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& whole matched string
  };
  /**
   * Return the count of a occurences in a string
   * @param  {string} string The string
   * @param  {string} subString The substring to count
   * @returns {number} The frequency
   */


  stringUtils.count = function count(string, subString) {
    return string.split(subString).length - 1;
  };
   //eslint-disable-line

  var numberUtils = {};
  /**
   * Truncates the number down by simply cutting off the number to the decimals provided.
   * Handles large numbers as strings up to 18, 6.
   * @param {string|number} number The number to truuncate.
   * @param  {number} [decimals=2] The decimals to truncate to.
   * @returns {string} The truncated number.
   */

  numberUtils.truncate = function truncate(number) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var numString = number.toString();
    var parts = numString.split('.');
    parts[1] = !parts[1] ? '' : parts[1].substr(0, decimals);
    return "".concat(parts[0], ".").concat(parts[1]);
  };
  /**
   * Rounds the number down by true rounding.
   * Handles large numbers as strings up to 18, 6.
   * @param {string|number} number The number to round.
   * @param  {number} [decimals=2] The decials to round to.
   * @returns {string} The rounded number.
   */


  numberUtils.round = function round(number) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return numberUtils.toFixed(number, decimals);
  };
  /**
   * Support function for toFixed that replaces JS toFixed and handles rounding properly.
   * This function does not handle big numbers.
   * @param  {string|number} number The number to fix.
   * @param  {decimals} [decimals=2] The decimal precision.
   * @returns {string} The string formatted to the precision.
   */


  numberUtils.fixTo = function toFixed(number) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return (+(Math.round(+(number + 'e' + decimals)) + 'e' + -decimals)).toFixed(decimals); //eslint-disable-line
  };
  /**
   * Returns a string representation of the number that does not use exponential notation
   * and has exactly digits after the decimal place. The number is rounded if necessary,
   * and the fractional part is padded with zeros if necessary so that it has the specified length.
   * This implementation handles greater or equal to 1e+21 so accepts string or number.
   * @param  {string|number} number The number to fix
   * @param  {decimals} [decimals=2] The decimal precision.
   * @returns {string} The string formatted to the precision.
   */


  numberUtils.toFixed = function toFixed(number) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    // Parse the number into three parts. Max supported number is 18.6
    var numStr = number.toString();
    var parsedNum = '';
    var noDecimals = numStr.split('.');
    var parts = [noDecimals[0].substr(0, 10), noDecimals[0].substr(10), noDecimals[1]];
    var firstPart = parts[0];
    var lastPart = parts[1];
    parsedNum = this.fixTo((lastPart || firstPart) + (parts[2] ? ".".concat(parts[2]) : ''), decimals).toString();

    if (lastPart && parsedNum.length === 11 && parsedNum === '10000000000') {
      parsedNum = '0000000000';
      firstPart = (parseInt(firstPart, 10) + 1).toString();
    }

    if (lastPart && lastPart.substr(0, 1) !== '0') {
      parsedNum = firstPart + parsedNum;
    }

    if (lastPart && lastPart.substr(0, 1) === '0') {
      parsedNum = "".concat(firstPart, "0").concat(parsedNum);
    }

    return parsedNum;
  };
  /**
   * Returns the number of decimal places in a number.
   * @param  {string|number} number The number to check.
   * @returns {number} The number of decimal places.
   */


  numberUtils.decimalPlaces = function decimalPlaces(number) {
    if (Math.floor(number) === number) {
      return 0;
    }

    if (number.toString().indexOf('.') === -1) {
      return 0;
    }

    return number.toString().split('.')[1].length || 0;
  };

  /* eslint-disable yoda */
  var colorUtils = {}; // Safely converts a single RGBA color component (R, G, B, or A) to
  // its corresponding two-digit hexidecimal value.

  function componentToHex(c) {
    var hex = Number(c).toString(16);
    return hex.length === 1 ? "0".concat(hex) : hex;
  }
  /**
   * Convert the provided hex to an RGBA with an opacity.
   * @private
   * @param {string} hex to set.
   * @param {string} opacity to check.
   * @returns {string} converted rgba
   */


  colorUtils.hexToRgba = function hexToRgba(hex, opacity) {
    var c;

    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
      c = hex.substring(1).split('');

      if (c.length === 3) {
        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
      }

      c = "0x".concat(c.join('')); // eslint-disable-next-line

      return "rgba(".concat([c >> 16 & 255, c >> 8 & 255, c & 255].join(','), ",").concat(opacity.toString(), ")");
    }

    return '';
  };
  /**
   * Converts a hex color to an object containing separate R, G, and B values.
   * @param {string} hex string representing a hexidecimal color
   * @returns {object|null} containing separate "r", "g", and "b" values.
   */


  colorUtils.hexToRgb = function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  };
  /**
   * Takes separate R, G, and B values, and converts them to a hexidecimal string
   * @param {number|string|obj} r a number between 0-255 representing the amount of red. Can also be an object with `r`, `g`, and `b` values.
   * @param {number|string} g a number between 0-255 representing the amount of green
   * @param {number|string} b a number between 0-255 representing the amount of blue
   * @returns {string} containing the matching hexidecimal color value
   */


  colorUtils.rgbToHex = function rgbToHex(r, g, b) {
    if (_typeof(r) === 'object' && (typeof r.r === 'number' || typeof r.r === 'string')) {
      g = r.g;
      b = r.b;
      r = r.r;
    }

    return "#".concat(componentToHex(r)).concat(componentToHex(g)).concat(componentToHex(b));
  };
  /**
   * Converts an RGB color value to an HSL color value
   * @param {number|string|obj} r a number between 0-255 representing the amount of red. Can also be an object with `r`, `g`, and `b` values.
   * @param {number|string} g a number between 0-255 representing the amount of green
   * @param {number|string} b a number between 0-255 representing the amount of blue
   * @returns {object} containing hue/saturation/lightness values (h, s, l).
   */


  colorUtils.rgbToHsl = function rgbToHsl(r, g, b) {
    if (_typeof(r) === 'object' && (typeof r.r === 'number' || typeof r.r === 'string')) {
      g = r.g;
      b = r.b;
      r = r.r;
    } // Ensure all values are numbers


    r = Number(r);
    g = Number(g);
    b = Number(b); // Make all the values fractions

    r /= 255;
    g /= 255;
    b /= 255; // Find greatest/smallest channel values

    var cmin = Math.min(r, g, b);
    var cmax = Math.max(r, g, b);
    var delta = cmax - cmin;
    var h = 0;
    var s = 0;
    var l = 0; // Calculate Hue
    // delta of `0` means there is no adjustment.

    if (delta === 0) {
      h = 0;
    } else if (cmax === r) {
      // Red is max
      h = (g - b) / delta % 6;
    } else if (cmax === g) {
      // Green is Max
      h = (b - r) / delta + 2;
    } else {
      // Blue is Max
      h = (r - g) / delta + 4;
    }

    h = Math.round(h * 60); // If the hue comes out negative, make it a positive

    if (h < 0) {
      h += 360;
    } // Calculate Lightness


    l = (cmax + cmin) / 2; // Calculate Saturation

    if (delta !== 0) {
      s = delta / (1 - Math.abs(2 * l - 1));
    } // multiply the final saturation/lightness values by 100 (make them percentages)


    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return {
      h: h,
      s: s,
      l: l
    };
  };
  /**
   * Converts an HSL color value to an RGB color value
   * @param {number|string|obj} h a number between 0-255 representing the amount of red. Can also be an object with `h`, `s`, and `l` properties.
   * @param {number|string} s a number between 0-255 representing the amount of green
   * @param {number|string} l a number between 0-255 representing the amount of blue
   * @returns {object} containing hue/saturation/lightness values (h, s, l).
   */


  colorUtils.hslToRgb = function hslToRgb(h, s, l) {
    if (_typeof(h) === 'object' && (typeof h.h === 'number' || typeof h.h === 'string')) {
      h = h.h;
      s = h.s;
      l = h.l;
    } // Ensure all values are numbers


    h = Number(h);
    s = Number(s);
    l = Number(l); // make saturation/lightness fractions of 1

    s /= 100;
    l /= 100; // chroma (c), second largest component (x),
    // and amount to add to each channel to match lightness (m)

    var c = (1 - Math.abs(2 * l - 1)) * s;
    var x = c * (1 - Math.abs(h / 60 % 2 - 1));
    var m = l - c / 2;
    var r = 0;
    var g = 0;
    var b = 0; // whichever 60deg slice of an entire 360deg pie the hue lies within
    // determines the values for r/g/b

    if (0 <= h && h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (60 <= h && h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (120 <= h && h < 180) {
      r = 0;
      g = x;
      b = c;
    } else if (180 <= h && h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (240 <= h && h < 300) {
      r = x;
      g = 0;
      b = c;
    } else if (300 <= h && h < 360) {
      r = c;
      g = 0;
      b = x;
    } // Add (m) to all channels, multiply each by 255, and round to get final values.


    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return {
      r: r,
      g: g,
      b: b
    };
  };
  /**
  * Takes a color and performs a change in luminosity of that color programatically.
  * @private
  * @param {string} hex  The original Hexadecimal base color.
  * @param {string} lum  A percentage used to set luminosity
  * change on the base color:  -0.1 would be 10% darker, 0.2 would be 20% brighter
  * @returns {string} hexadecimal color.
  */


  colorUtils.getLuminousColorShade = function getLuminousColorShade(hex, lum) {
    // validate hex string
    hex = this.validateHex(hex).substr(1);
    lum = lum || 0; // convert to decimal and change luminosity

    var rgb = '#';
    var c;
    var i;

    for (i = 0; i < 3; i++) {
      c = parseInt(hex.substr(i * 2, 2), 16);
      c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
      rgb += "00".concat(c).substr(c.length);
    }

    return rgb;
  };
  /**
   * Validates a string containing a hexadecimal number
   * @private
   * @param {string} hex A hex color.
   * @returns {string} a validated hexadecimal string.
   */


  colorUtils.validateHex = function validateHex(hex) {
    hex = String(hex).replace(/[^0-9a-f]/gi, '');

    if (hex.length < 6) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    return "#".concat(hex);
  };
  /**
   * Get calculated contrast color
   * @private
   * @param {string} hex A hex color.
   * @param {string} light Optional a custom hex color to return.
   * @param {string} dark Optional a custom hex color to return.
   * @returns {string} a calculated contrast color string.
   */


  colorUtils.getContrastColor = function getContrastColor(hex, light, dark) {
    hex = hex ? hex.replace('#', '') : '';

    var parse = function parse(x) {
      return parseInt(hex.substr(x, 2), 16);
    };

    var r = parse(0);
    var g = parse(2);
    var b = parse(4);
    var diff = (r * 299 + g * 587 + b * 114) / 1000;
    return diff >= 128 ? dark || 'black' : light || 'white';
  };
  /**
   * Returns a less saturated shade of a provided color.
   * @param {string} hex the starting hexadecimal color
   * @param {number} [sat=1] a number representing a percentage change (between 0 and 1) of saturation.
   * @returns {string} the modified hexidecimal color
   */


  colorUtils.getDesaturatedColor = function getDesaturatedColor(hex) {
    var sat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    hex = hex ? hex.replace('#', '') : '';
    var col = colorUtils.hexToRgb(hex); // Grayscale constants
    // https://en.m.wikipedia.org/wiki/Grayscale#Luma_coding_in_video_systems

    var gray = col.r * 0.3086 + col.g * 0.6094 + col.b * 0.0820;
    col.r = Math.round(col.r * sat + gray * (1 - sat));
    col.g = Math.round(col.g * sat + gray * (1 - sat));
    col.b = Math.round(col.b * sat + gray * (1 - sat));
    return colorUtils.rgbToHex(col.r, col.g, col.b);
  };
  /**
   * Compares the luminosity of two hex colors.
   * @param {string|obj} baseColorHex a string representing a hexadecimal color
   * @param {string|obj} compareColorHex a string representing a hexadecimal color
   * @returns {boolean} true if the base color is more luminous, false if the compared color is more luminous.
   */


  colorUtils.isLighter = function isLighter(baseColorHex, compareColorHex) {
    // Convert to RGB Objects
    var baseColorRGB = colorUtils.hexToRgb(baseColorHex);
    var compareColorRGB = colorUtils.hexToRgb(compareColorHex); // Convert to HSL Objects

    var baseColorHSL = colorUtils.rgbToHsl(baseColorRGB);
    var compareColorHSL = colorUtils.rgbToHsl(compareColorRGB); // Compare the HSL

    return baseColorHSL.l <= compareColorHSL.l;
  };
   //eslint-disable-line

  /* eslint-disable */
  // Modified version of Amro Osama's code. From at https://github.com/kbwood/calendars/blob/master/src/js/jquery.calendars.ummalqura.js
  var ummalquraData = [20, 50, 79, 109, 138, 168, 197, 227, 256, 286, 315, 345, 374, 404, 433, 463, 492, 522, 551, 581, 611, 641, 670, 700, 729, 759, 788, 818, 847, 877, 906, 936, 965, 995, 1024, 1054, 1083, 1113, 1142, 1172, 1201, 1231, 1260, 1290, 1320, 1350, 1379, 1409, 1438, 1468, 1497, 1527, 1556, 1586, 1615, 1645, 1674, 1704, 1733, 1763, 1792, 1822, 1851, 1881, 1910, 1940, 1969, 1999, 2028, 2058, 2087, 2117, 2146, 2176, 2205, 2235, 2264, 2294, 2323, 2353, 2383, 2413, 2442, 2472, 2501, 2531, 2560, 2590, 2619, 2649, 2678, 2708, 2737, 2767, 2796, 2826, 2855, 2885, 2914, 2944, 2973, 3003, 3032, 3062, 3091, 3121, 3150, 3180, 3209, 3239, 3268, 3298, 3327, 3357, 3386, 3416, 3446, 3476, 3505, 3535, 3564, 3594, 3623, 3653, 3682, 3712, 3741, 3771, 3800, 3830, 3859, 3889, 3918, 3948, 3977, 4007, 4036, 4066, 4095, 4125, 4155, 4185, 4214, 4244, 4273, 4303, 4332, 4362, 4391, 4421, 4450, 4480, 4509, 4539, 4568, 4598, 4627, 4657, 4686, 4716, 4745, 4775, 4804, 4834, 4863, 4893, 4922, 4952, 4981, 5011, 5040, 5070, 5099, 5129, 5158, 5188, 5218, 5248, 5277, 5307, 5336, 5366, 5395, 5425, 5454, 5484, 5513, 5543, 5572, 5602, 5631, 5661, 5690, 5720, 5749, 5779, 5808, 5838, 5867, 5897, 5926, 5956, 5985, 6015, 6044, 6074, 6103, 6133, 6162, 6192, 6221, 6251, 6281, 6311, 6340, 6370, 6399, 6429, 6458, 6488, 6517, 6547, 6576, 6606, 6635, 6665, 6694, 6724, 6753, 6783, 6812, 6842, 6871, 6901, 6930, 6960, 6989, 7019, 7048, 7078, 7107, 7137, 7166, 7196, 7225, 7255, 7284, 7314, 7344, 7374, 7403, 7433, 7462, 7492, 7521, 7551, 7580, 7610, 7639, 7669, 7698, 7728, 7757, 7787, 7816, 7846, 7875, 7905, 7934, 7964, 7993, 8023, 8053, 8083, 8112, 8142, 8171, 8201, 8230, 8260, 8289, 8319, 8348, 8378, 8407, 8437, 8466, 8496, 8525, 8555, 8584, 8614, 8643, 8673, 8702, 8732, 8761, 8791, 8821, 8850, 8880, 8909, 8938, 8968, 8997, 9027, 9056, 9086, 9115, 9145, 9175, 9205, 9234, 9264, 9293, 9322, 9352, 9381, 9410, 9440, 9470, 9499, 9529, 9559, 9589, 9618, 9648, 9677, 9706, 9736, 9765, 9794, 9824, 9853, 9883, 9913, 9943, 9972, 10002, 10032, 10061, 10090, 10120, 10149, 10178, 10208, 10237, 10267, 10297, 10326, 10356, 10386, 10415, 10445, 10474, 10504, 10533, 10562, 10592, 10621, 10651, 10680, 10710, 10740, 10770, 10799, 10829, 10858, 10888, 10917, 10947, 10976, 11005, 11035, 11064, 11094, 11124, 11153, 11183, 11213, 11242, 11272, 11301, 11331, 11360, 11389, 11419, 11448, 11478, 11507, 11537, 11567, 11596, 11626, 11655, 11685, 11715, 11744, 11774, 11803, 11832, 11862, 11891, 11921, 11950, 11980, 12010, 12039, 12069, 12099, 12128, 12158, 12187, 12216, 12246, 12275, 12304, 12334, 12364, 12393, 12423, 12453, 12483, 12512, 12542, 12571, 12600, 12630, 12659, 12688, 12718, 12747, 12777, 12807, 12837, 12866, 12896, 12926, 12955, 12984, 13014, 13043, 13072, 13102, 13131, 13161, 13191, 13220, 13250, 13280, 13310, 13339, 13368, 13398, 13427, 13456, 13486, 13515, 13545, 13574, 13604, 13634, 13664, 13693, 13723, 13752, 13782, 13811, 13840, 13870, 13899, 13929, 13958, 13988, 14018, 14047, 14077, 14107, 14136, 14166, 14195, 14224, 14254, 14283, 14313, 14342, 14372, 14401, 14431, 14461, 14490, 14520, 14550, 14579, 14609, 14638, 14667, 14697, 14726, 14756, 14785, 14815, 14844, 14874, 14904, 14933, 14963, 14993, 15021, 15051, 15081, 15110, 15140, 15169, 15199, 15228, 15258, 15287, 15317, 15347, 15377, 15406, 15436, 15465, 15494, 15524, 15553, 15582, 15612, 15641, 15671, 15701, 15731, 15760, 15790, 15820, 15849, 15878, 15908, 15937, 15966, 15996, 16025, 16055, 16085, 16114, 16144, 16174, 16204, 16233, 16262, 16292, 16321, 16350, 16380, 16409, 16439, 16468, 16498, 16528, 16558, 16587, 16617, 16646, 16676, 16705, 16734, 16764, 16793, 16823, 16852, 16882, 16912, 16941, 16971, 17001, 17030, 17060, 17089, 17118, 17148, 17177, 17207, 17236, 17266, 17295, 17325, 17355, 17384, 17414, 17444, 17473, 17502, 17532, 17561, 17591, 17620, 17650, 17679, 17709, 17738, 17768, 17798, 17827, 17857, 17886, 17916, 17945, 17975, 18004, 18034, 18063, 18093, 18122, 18152, 18181, 18211, 18241, 18270, 18300, 18330, 18359, 18388, 18418, 18447, 18476, 18506, 18535, 18565, 18595, 18625, 18654, 18684, 18714, 18743, 18772, 18802, 18831, 18860, 18890, 18919, 18949, 18979, 19008, 19038, 19068, 19098, 19127, 19156, 19186, 19215, 19244, 19274, 19303, 19333, 19362, 19392, 19422, 19452, 19481, 19511, 19540, 19570, 19599, 19628, 19658, 19687, 19717, 19746, 19776, 19806, 19836, 19865, 19895, 19924, 19954, 19983, 20012, 20042, 20071, 20101, 20130, 20160, 20190, 20219, 20249, 20279, 20308, 20338, 20367, 20396, 20426, 20455, 20485, 20514, 20544, 20573, 20603, 20633, 20662, 20692, 20721, 20751, 20780, 20810, 20839, 20869, 20898, 20928, 20957, 20987, 21016, 21046, 21076, 21105, 21135, 21164, 21194, 21223, 21253, 21282, 21312, 21341, 21371, 21400, 21430, 21459, 21489, 21519, 21548, 21578, 21607, 21637, 21666, 21696, 21725, 21754, 21784, 21813, 21843, 21873, 21902, 21932, 21962, 21991, 22021, 22050, 22080, 22109, 22138, 22168, 22197, 22227, 22256, 22286, 22316, 22346, 22375, 22405, 22434, 22464, 22493, 22522, 22552, 22581, 22611, 22640, 22670, 22700, 22730, 22759, 22789, 22818, 22848, 22877, 22906, 22936, 22965, 22994, 23024, 23054, 23083, 23113, 23143, 23173, 23202, 23232, 23261, 23290, 23320, 23349, 23379, 23408, 23438, 23467, 23497, 23527, 23556, 23586, 23616, 23645, 23674, 23704, 23733, 23763, 23792, 23822, 23851, 23881, 23910, 23940, 23970, 23999, 24029, 24058, 24088, 24117, 24147, 24176, 24206, 24235, 24265, 24294, 24324, 24353, 24383, 24413, 24442, 24472, 24501, 24531, 24560, 24590, 24619, 24648, 24678, 24707, 24737, 24767, 24796, 24826, 24856, 24885, 24915, 24944, 24974, 25003, 25032, 25062, 25091, 25121, 25150, 25180, 25210, 25240, 25269, 25299, 25328, 25358, 25387, 25416, 25446, 25475, 25505, 25534, 25564, 25594, 25624, 25653, 25683, 25712, 25742, 25771, 25800, 25830, 25859, 25888, 25918, 25948, 25977, 26007, 26037, 26067, 26096, 26126, 26155, 26184, 26214, 26243, 26272, 26302, 26332, 26361, 26391, 26421, 26451, 26480, 26510, 26539, 26568, 26598, 26627, 26656, 26686, 26715, 26745, 26775, 26805, 26834, 26864, 26893, 26923, 26952, 26982, 27011, 27041, 27070, 27099, 27129, 27159, 27188, 27218, 27248, 27277, 27307, 27336, 27366, 27395, 27425, 27454, 27484, 27513, 27542, 27572, 27602, 27631, 27661, 27691, 27720, 27750, 27779, 27809, 27838, 27868, 27897, 27926, 27956, 27985, 28015, 28045, 28074, 28104, 28134, 28163, 28193, 28222, 28252, 28281, 28310, 28340, 28369, 28399, 28428, 28458, 28488, 28517, 28547, 28577, // From 1356
  28607, 28636, 28665, 28695, 28724, 28754, 28783, 28813, 28843, 28872, 28901, 28931, 28960, 28990, 29019, 29049, 29078, 29108, 29137, 29167, 29196, 29226, 29255, 29285, 29315, 29345, 29375, 29404, 29434, 29463, 29492, 29522, 29551, 29580, 29610, 29640, 29669, 29699, 29729, 29759, 29788, 29818, 29847, 29876, 29906, 29935, 29964, 29994, 30023, 30053, 30082, 30112, 30141, 30171, 30200, 30230, 30259, 30289, 30318, 30348, 30378, 30408, 30437, 30467, 30496, 30526, 30555, 30585, 30614, 30644, 30673, 30703, 30732, 30762, 30791, 30821, 30850, 30880, 30909, 30939, 30968, 30998, 31027, 31057, 31086, 31116, 31145, 31175, 31204, 31234, 31263, 31293, 31322, 31352, 31381, 31411, 31441, 31471, 31500, 31530, 31559, 31589, 31618, 31648, 31676, 31706, 31736, 31766, 31795, 31825, 31854, 31884, 31913, 31943, 31972, 32002, 32031, 32061, 32090, 32120, 32150, 32180, 32209, 32239, 32268, 32298, 32327, 32357, 32386, 32416, 32445, 32475, 32504, 32534, 32563, 32593, 32622, 32652, 32681, 32711, 32740, 32770, 32799, 32829, 32858, 32888, 32917, 32947, 32976, 33006, 33035, 33065, 33094, 33124, 33153, 33183, 33213, 33243, 33272, 33302, 33331, 33361, 33390, 33420, 33450, 33479, 33509, 33539, 33568, 33598, 33627, 33657, 33686, 33716, 33745, 33775, 33804, 33834, 33863, 33893, 33922, 33952, 33981, 34011, 34040, 34069, 34099, 34128, 34158, 34187, 34217, 34247, 34277, 34306, 34336, 34365, 34395, 34424, 34454, 34483, 34512, 34542, 34571, 34601, 34631, 34660, 34690, 34719, 34749, 34778, 34808, 34837, 34867, 34896, 34926, 34955, 34985, 35015, 35044, 35074, 35103, 35133, 35162, 35192, 35222, 35251, 35280, 35310, 35340, 35370, 35399, 35429, 35458, 35488, 35517, 35547, 35576, 35605, 35635, 35665, 35694, 35723, 35753, 35782, 35811, 35841, 35871, 35901, 35930, 35960, 35989, 36019, 36048, 36078, 36107, 36136, 36166, 36195, 36225, 36254, 36284, 36314, 36343, 36373, 36403, 36433, 36462, 36492, 36521, 36551, 36580, 36610, 36639, 36669, 36698, 36728, 36757, 36786, 36816, 36845, 36875, 36904, 36934, 36963, 36993, 37022, 37052, 37081, 37111, 37141, 37170, 37200, 37229, 37259, 37288, 37318, 37347, 37377, 37406, 37436, 37465, 37495, 37524, 37554, 37584, 37613, 37643, 37672, 37701, 37731, 37760, 37790, 37819, 37849, 37878, 37908, 37938, 37967, 37997, 38027, 38056, 38085, 38115, 38144, 38174, 38203, 38233, 38262, 38292, 38322, 38351, 38381, 38410, 38440, 38469, 38499, 38528, 38558, 38587, 38617, 38646, 38676, 38705, 38735, 38764, 38794, 38823, 38853, 38882, 38912, 38941, 38971, 39001, 39030, 39059, 39089, 39118, 39148, 39178, 39208, 39237, 39267, 39297, 39326, 39355, 39385, 39414, 39444, 39473, 39503, 39532, 39562, 39592, 39621, 39650, 39680, 39709, 39739, 39768, 39798, 39827, 39857, 39886, 39916, 39946, 39975, 40005, 40035, 40064, 40094, 40123, 40153, 40182, 40212, 40241, 40271, 40300, 40330, 40359, 40389, 40418, 40448, 40477, 40507, 40536, 40566, 40595, 40625, 40655, 40685, 40714, 40744, 40773, 40803, 40832, 40862, 40892, 40921, 40951, 40980, 41009, 41039, 41068, 41098, 41127, 41157, 41186, 41216, 41245, 41275, 41304, 41334, 41364, 41393, 41422, 41452, 41481, 41511, 41540, 41570, 41599, 41629, 41658, 41688, 41718, 41748, 41777, 41807, 41836, 41865, 41894, 41924, 41953, 41983, 42012, 42042, 42072, 42102, 42131, 42161, 42190, 42220, 42249, 42279, 42308, 42337, 42367, 42397, 42426, 42456, 42485, 42515, 42545, 42574, 42604, 42633, 42662, 42692, 42721, 42751, 42780, 42810, 42839, 42869, 42899, 42929, 42958, 42988, 43017, 43046, 43076, 43105, 43135, 43164, 43194, 43223, 43253, 43283, 43312, 43342, 43371, 43401, 43430, 43460, 43489, 43519, 43548, 43578, 43607, 43637, 43666, 43696, 43726, 43755, 43785, 43814, 43844, 43873, 43903, 43932, 43962, 43991, 44021, 44050, 44080, 44109, 44139, 44169, 44198, 44228, 44258, 44287, 44317, 44346, 44375, 44405, 44434, 44464, 44493, 44523, 44553, 44582, 44612, 44641, 44671, 44700, 44730, 44759, 44788, 44818, 44847, 44877, 44906, 44936, 44966, 44996, 45025, 45055, 45084, 45114, 45143, 45172, 45202, 45231, 45261, 45290, 45320, 45350, 45380, 45409, 45439, 45468, 45498, 45527, 45556, 45586, 45615, 45644, 45674, 45704, 45733, 45763, 45793, 45823, 45852, 45882, 45911, 45940, 45970, 45999, 46028, 46058, 46088, 46117, 46147, 46177, 46206, 46236, 46265, 46295, 46324, 46354, 46383, 46413, 46442, 46472, 46501, 46531, 46560, 46590, 46620, 46649, 46679, 46708, 46738, 46767, 46797, 46826, 46856, 46885, 46915, 46944, 46974, 47003, 47033, 47063, 47092, 47122, 47151, 47181, 47210, 47240, 47269, 47298, 47328, 47357, 47387, 47417, 47446, 47476, 47506, 47535, 47565, 47594, 47624, 47653, 47682, 47712, 47741, 47771, 47800, 47830, 47860, 47890, 47919, 47949, 47978, 48008, 48037, 48066, 48096, 48125, 48155, 48184, 48214, 48244, 48273, 48303, 48333, 48362, 48392, 48421, 48450, 48480, 48509, 48538, 48568, 48598, 48627, 48657, 48687, 48717, 48746, 48776, 48805, 48834, 48864, 48893, 48922, 48952, 48982, 49011, 49041, 49071, 49100, 49130, 49160, 49189, 49218, 49248, 49277, 49306, 49336, 49365, 49395, 49425, 49455, 49484, 49514, 49543, 49573, 49602, 49632, 49661, 49690, 49720, 49749, 49779, 49809, 49838, 49868, 49898, 49927, 49957, 49986, 50016, 50045, 50075, 50104, 50133, 50163, 50192, 50222, 50252, 50281, 50311, 50340, 50370, 50400, 50429, 50459, 50488, 50518, 50547, 50576, 50606, 50635, 50665, 50694, 50724, 50754, 50784, 50813, 50843, 50872, 50902, 50931, 50960, 50990, 51019, 51049, 51078, 51108, 51138, 51167, 51197, 51227, 51256, 51286, 51315, 51345, 51374, 51403, 51433, 51462, 51492, 51522, 51552, 51582, 51611, 51641, 51670, 51699, 51729, 51758, 51787, 51816, 51846, 51876, 51906, 51936, 51965, 51995, 52025, 52054, 52083, 52113, 52142, 52171, 52200, 52230, 52260, 52290, 52319, 52349, 52379, 52408, 52438, 52467, 52497, 52526, 52555, 52585, 52614, 52644, 52673, 52703, 52733, 52762, 52792, 52822, 52851, 52881, 52910, 52939, 52969, 52998, 53028, 53057, 53087, 53116, 53146, 53176, 53205, 53235, 53264, 53294, 53324, 53353, 53383, 53412, 53441, 53471, 53500, 53530, 53559, 53589, 53619, 53648, 53678, 53708, 53737, 53767, 53796, 53825, 53855, 53884, 53914, 53943, 53973, 54003, 54032, 54062, 54092, 54121, 54151, 54180, 54209, 54239, 54268, 54297, 54327, 54357, 54387, 54416, 54446, 54476, 54505, 54535, 54564, 54593, 54623, 54652, 54681, 54711, 54741, 54770, 54800, 54830, 54859, 54889, 54919, 54948, 54977, 55007, 55036, 55066, 55095, 55125, 55154, 55184, 55213, 55243, 55273, 55302, 55332, 55361, 55391, 55420, 55450, 55479, 55508, 55538, 55567, 55597, 55627, 55657, 55686, 55716, 55745, 55775, 55804, 55834, 55863, 55892, 55922, 55951, 55981, 56011, 56040, 56070, 56100, 56129, 56159, 56188, 56218, 56247, 56276, 56306, 56335, 56365, 56394, 56424, 56454, 56483, 56513, 56543, 56572, 56601, 56631, 56660, 56690, 56719, 56749, 56778, 56808, 56837, 56867, 56897, 56926, 56956, 56985, 57015, 57044, 57074, 57103, 57133, 57162, 57192, 57221, 57251, 57280, 57310, 57340, 57369, 57399, 57429, 57458, 57487, 57517, 57546, 57576, 57605, 57634, 57664, 57694, 57723, 57753, 57783, 57813, 57842, 57871, 57901, 57930, 57959, 57989, 58018, 58048, 58077, 58107, 58137, 58167, 58196, 58226, 58255, 58285, 58314, 58343, 58373, 58402, 58432, 58461, 58491, 58521, 58551, 58580, 58610, 58639, 58669, 58698, 58727, 58757, 58786, 58816, 58845, 58875, 58905, 58934, 58964, 58994, 59023, 59053, 59082, 59111, 59141, 59170, 59200, 59229, 59259, 59288, 59318, 59348, 59377, 59407, 59436, 59466, 59495, 59525, 59554, 59584, 59613, 59643, 59672, 59702, 59731, 59761, 59791, 59820, 59850, 59879, 59909, 59939, 59968, 59997, 60027, 60056, 60086, 60115, 60145, 60174, 60204, 60234, 60264, 60293, 60323, 60352, 60381, 60411, 60440, 60469, 60499, 60528, 60558, 60588, 60618, 60647, 60677, 60707, 60736, 60765, 60795, 60824, 60853, 60883, 60912, 60942, 60972, 61002, 61031, 61061, 61090, 61120, 61149, 61179, 61208, 61237, 61267, 61296, 61326, 61356, 61385, 61415, 61445, 61474, 61504, 61533, 61563, 61592, 61621, 61651, 61680, 61710, 61739, 61769, 61799, 61828, 61858, 61888, 61917, 61947, 61976, 62006, 62035, 62064, 62094, 62123, 62153, 62182, 62212, 62242, 62271, 62301, 62331, 62360, 62390, 62419, 62448, 62478, 62507, 62537, 62566, 62596, 62625, 62655, 62685, 62715, 62744, 62774, 62803, 62832, 62862, 62891, 62921, 62950, 62980, 63009, 63039, 63069, 63099, 63128, 63157, 63187, 63216, 63246, 63275, 63305, 63334, 63363, 63393, 63423, 63453, 63482, 63512, 63541, 63571, 63600, 63630, 63659, 63689, 63718, 63747, 63777, 63807, 63836, 63866, 63895, 63925, 63955, 63984, 64014, 64043, 64073, 64102, 64131, 64161, 64190, 64220, 64249, 64279, 64309, 64339, 64368, 64398, 64427, 64457, 64486, 64515, 64545, 64574, 64603, 64633, 64663, 64692, 64722, 64752, 64782, 64811, 64841, 64870, 64899, 64929, 64958, 64987, 65017, 65047, 65076, 65106, 65136, 65166, 65195, 65225, 65254, 65283, 65313, 65342, 65371, 65401, 65431, 65460, 65490, 65520, 65549, 65579, 65608, 65638, 65667, 65697, 65726, 65755, 65785, 65815, 65844, 65874, 65903, 65933, 65963, 65992, 66022, 66051, 66081, 66110, 66140, 66169, 66199, 66228, 66258, 66287, 66317, 66346, 66376, 66405, 66435, 66465, 66494, 66524, 66553, 66583, 66612, 66641, 66671, 66700, 66730, 66760, 66789, 66819, 66849, 66878, 66908, 66937, 66967, 66996, 67025, 67055, 67084, 67114, 67143, 67173, 67203, 67233, 67262, 67292, 67321, 67351, 67380, 67409, 67439, 67468, 67497, 67527, 67557, 67587, 67617, 67646, 67676, 67705, 67735, 67764, 67793, 67823, 67852, 67882, 67911, 67941, 67971, 68000, 68030, 68060, 68089, 68119, 68148, 68177, 68207, 68236, 68266, 68295, 68325, 68354, 68384, 68414, 68443, 68473, 68502, 68532, 68561, 68591, 68620, 68650, 68679, 68708, 68738, 68768, 68797, 68827, 68857, 68886, 68916, 68946, 68975, 69004, 69034, 69063, 69092, 69122, 69152, 69181, 69211, 69240, 69270, 69300, 69330, 69359, 69388, 69418, 69447, 69476, 69506, 69535, 69565, 69595, 69624, 69654, 69684, 69713, 69743, 69772, 69802, 69831, 69861, 69890, 69919, 69949, 69978, 70008, 70038, 70067, 70097, 70126, 70156, 70186, 70215, 70245, 70274, 70303, 70333, 70362, 70392, 70421, 70451, 70481, 70510, 70540, 70570, 70599, 70629, 70658, 70687, 70717, 70746, 70776, 70805, 70835, 70864, 70894, 70924, 70954, 70983, 71013, 71042, 71071, 71101, 71130, 71159, 71189, 71218, 71248, 71278, 71308, 71337, 71367, 71397, 71426, 71455, 71485, 71514, 71543, 71573, 71602, 71632, 71662, 71691, 71721, 71751, 71781, 71810, 71839, 71869, 71898, 71927, 71957, 71986, 72016, 72046, 72075, 72105, 72135, 72164, 72194, 72223, 72253, 72282, 72311, 72341, 72370, 72400, 72429, 72459, 72489, 72518, 72548, 72577, 72607, 72637, 72666, 72695, 72725, 72754, 72784, 72813, 72843, 72872, 72902, 72931, 72961, 72991, 73020, 73050, 73080, 73109, 73139, 73168, 73197, 73227, 73256, 73286, 73315, 73345, 73375, 73404, 73434, 73464, 73493, 73523, 73552, 73581, 73611, 73640, 73669, 73699, 73729, 73758, 73788, 73818, 73848, 73877, 73907, 73936, 73965, 73995, 74024, 74053, 74083, 74113, 74142, 74172, 74202, 74231, 74261, 74291, 74320, 74349, 74379, 74408, 74437, 74467, 74497, 74526, 74556, 74585, 74615, 74645, 74675, 74704, 74733, 74763, 74792, 74822, 74851, 74881, 74910, 74940, 74969, 74999, 75029, 75058, 75088, 75117, 75147, 75176, 75206, 75235, 75264, 75294, 75323, 75353, 75383, 75412, 75442, 75472, 75501, 75531, 75560, 75590, 75619, 75648, 75678, 75707, 75737, 75766, 75796, 75826, 75856, 75885, 75915, 75944, 75974, 76003, 76032, 76062, 76091, 76121, 76150, 76180, 76210, 76239, 76269, 76299, 76328, 76358, 76387, 76416, 76446, 76475, 76505, 76534, 76564, 76593, 76623, 76653, 76682, 76712, 76741, 76771, 76801, 76830, 76859, 76889, 76918, 76948, 76977, 77007, 77036, 77066, 77096, 77125, 77155, 77185, 77214, 77243, 77273, 77302, 77332, 77361, 77390, 77420, 77450, 77479, 77509, 77539, 77569, 77598, 77627, 77657, 77686, 77715, 77745, 77774, 77804, 77833, 77863, 77893, 77923, 77952, 77982, 78011, 78041, 78070, 78099, 78129, 78158, 78188, 78217, 78247, 78277, 78307, 78336, 78366, 78395, 78425, 78454, 78483, 78513, 78542, 78572, 78601, 78631, 78661, 78690, 78720, 78750, 78779, 78808, 78838, 78867, 78897, 78926, 78956, 78985, 79015, 79044, 79074, 79104, 79133, 79163, 79192, 79222, 79251, 79281, 79310, 79340, 79369, 79399, 79428, 79458, 79487, 79517, 79546, 79576, 79606, 79635, 79665, 79695, 79724, 79753, 79783, 79812, 79841, 79871, 79900, 79930, 79960, 79990];

  // culture files. This allows manually setting the directory for the culture files.

  var existingCulturePath = '';
  var minifyCultures = false;

  if (_typeof(window.SohoConfig) === 'object') {
    if (typeof window.SohoConfig.culturesPath === 'string') {
      existingCulturePath = window.SohoConfig.culturesPath;
    }

    if (typeof window.SohoConfig.minifyCultures === 'boolean') {
      minifyCultures = window.SohoConfig.minifyCultures;
    }
  }
  /**
  * The Locale component handles i18n
  * Data From: http://www.unicode.org/repos/cldr-aux/json/22.1/main/
  * For Docs See: http://ibm.co/1nXyNxp
  * @class Locale
  * @constructor
  *
  * @param {string} currentLocale  The Currently Set Locale
  * @param {object} cultures  Contains all currently-stored cultures.
  * @param {string} culturesPath  the web-server's path to culture files.
  * @param {boolean} minify if true, adds a `.min.js` suffix to the culture's filename.
  */


  var Locale = {
    // eslint-disable-line
    currentLocale: {
      name: '',
      data: {}
    },
    // default
    currentLanguage: {
      name: ''
    },
    // default
    cultures: {},
    languages: {},
    dff: [],
    culturesPath: existingCulturePath,
    defaultLocales: [{
      lang: 'af',
      default: 'af-ZA'
    }, {
      lang: 'ar',
      default: 'ar-EG'
    }, {
      lang: 'bg',
      default: 'bg-BG'
    }, {
      lang: 'cs',
      default: 'cs-CZ'
    }, {
      lang: 'da',
      default: 'da-DK'
    }, {
      lang: 'de',
      default: 'de-DE'
    }, {
      lang: 'el',
      default: 'el-GR'
    }, {
      lang: 'en',
      default: 'en-US'
    }, {
      lang: 'es',
      default: 'es-ES'
    }, {
      lang: 'et',
      default: 'et-EE'
    }, {
      lang: 'fi',
      default: 'fi-FI'
    }, {
      lang: 'fr',
      default: 'fr-FR'
    }, {
      lang: 'he',
      default: 'he-IL'
    }, {
      lang: 'hi',
      default: 'hi-IN'
    }, {
      lang: 'hr',
      default: 'hr-HR'
    }, {
      lang: 'hu',
      default: 'hu-HU'
    }, {
      lang: 'id',
      default: 'id-ID'
    }, {
      lang: 'it',
      default: 'it-IT'
    }, {
      lang: 'iw',
      default: 'he-IL'
    }, {
      lang: 'ja',
      default: 'ja-JP'
    }, {
      lang: 'ko',
      default: 'ko-KR'
    }, {
      lang: 'lt',
      default: 'lt-LT'
    }, {
      lang: 'lv',
      default: 'lv-LV'
    }, {
      lang: 'ms',
      default: 'ms-bn'
    }, {
      lang: 'nb',
      default: 'no-NO'
    }, {
      lang: 'nn',
      default: 'no-NO'
    }, {
      lang: 'nl',
      default: 'nl-NL'
    }, {
      lang: 'no',
      default: 'no-NO'
    }, {
      lang: 'pl',
      default: 'pl-PL'
    }, {
      lang: 'pt',
      default: 'pt-PT'
    }, {
      lang: 'ro',
      default: 'ro-RO'
    }, {
      lang: 'ru',
      default: 'ru-RU'
    }, {
      lang: 'sk',
      default: 'sk-SK'
    }, {
      lang: 'sl',
      default: 'sl-SI'
    }, {
      lang: 'sv',
      default: 'sv-SE'
    }, {
      lang: 'th',
      default: 'th-TH'
    }, {
      lang: 'tr',
      default: 'tr-TR'
    }, {
      lang: 'uk',
      default: 'uk-UA'
    }, {
      lang: 'vi',
      default: 'vi-VN'
    }, {
      lang: 'zh',
      default: 'zh-CN'
    }],
    supportedLocales: ['af-ZA', 'ar-EG', 'ar-SA', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-AU', 'en-GB', 'en-IN', 'en-NZ', 'en-US', 'en-ZA', 'es-AR', 'es-ES', 'es-419', 'es-MX', 'es-US', 'et-EE', 'fi-FI', 'fr-CA', 'fr-FR', 'he-IL', 'hi-IN', 'hr-HR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'lt-LT', 'lv-LV', 'ms-bn', 'ms-my', 'nb-NO', 'nn-NO', 'nl-NL', 'no-NO', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sl-SI', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN', 'zh-Hans', 'zh-Hant', 'zh-TW'],
    translatedLocales: ['fr-CA', 'fr-FR', 'pt-BR', 'pt-PT'],
    defaultLocale: 'en-US',
    minify: minifyCultures,

    /**
     * Sets the current lang tag in the Html element
     * @private
     * @param  {string} locale The locale, if just a two digit code is passed we use the default.
     */
    updateLanguageTag: function updateLanguageTag(locale) {
      var html = $('html');

      if (locale.length === 2) {
        locale = this.defaultLocales.filter(function (a) {
          return a.lang === locale;
        });
      }

      html.attr('lang', locale);

      if (this.isRTL()) {
        html.attr('dir', 'rtl');
      } else {
        html.removeAttr('dir');
      } // ICONS: Right to Left Direction


      if (this.isRTL()) {
        Locale.flipIconsHorizontally();
      }

      $('body').removeClass('busy-loading-locale');
    },

    /**
     * Get the path to the directory with the cultures
     * @private
     * @returns {string} path containing culture files.
     */
    getCulturesPath: function getCulturesPath() {
      if (!this.culturesPath) {
        var scripts = document.getElementsByTagName('script');
        var partialPathRegexp = /sohoxi(.min){0,1}(.{0,1}[a-z0-9]*)\.js/;

        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src; // remove from ? to end

          var idx = src.indexOf('?');

          if (src !== '' && idx > -1) {
            src = src.substr(0, idx);
          }

          if (scripts[i].id === 'sohoxi-script') {
            return "".concat(src.substring(0, src.lastIndexOf('/')), "/");
          }

          if (src.match(partialPathRegexp)) {
            this.culturesPath = "".concat(src.replace(partialPathRegexp, ''), "cultures/");
          }
        }
      }

      return this.culturesPath;
    },

    /**
     * Checks if the culture is set as an inline script in the head tag.
     * @private
     * @returns {boolean} whether or not a culture file exists in the document header.
     */
    cultureInHead: function cultureInHead() {
      var isThere = false;
      var scripts = document.getElementsByTagName('script');
      var partialPath = 'cultures';

      for (var i = 0; i < scripts.length; i++) {
        var src = scripts[i].src;

        if (src.indexOf(partialPath) > -1) {
          isThere = true;
        }
      }

      return isThere;
    },

    /**
     * Internally stores a new culture file for future use.
     * @private
     * @param {string} locale The locale to check.
     * @returns {string} The actual locale to use.
     */
    correctLocale: function correctLocale(locale) {
      // Map incorrect java locale to correct locale
      if (locale === 'in-ID') {
        locale = 'id-ID';
      }

      if (locale.substr(0, 2) === 'iw') {
        locale = 'he-IL';
      }

      var lang = locale.split('-')[0];

      if (this.supportedLocales.indexOf(locale) === -1) {
        locale = this.defaultLocales.filter(function (a) {
          return a.lang === lang;
        });

        if (locale && locale[0]) {
          return locale[0].default;
        }

        locale = this.defaultLocale;
      }

      return locale;
    },

    /**
     * Check if the language is supported, if not return 'en'
     * and fix a few inconsistencies.
     * @private
     * @param {string} lang The locale to check.
     * @returns {string} The actual lang to use.
     */
    correctLanguage: function correctLanguage(lang) {
      var _lang;

      if (((_lang = lang) === null || _lang === void 0 ? void 0 : _lang == null ? void 0 : _lang.substr(0, 3)) === 'en-') {
        lang = lang.substr(0, 2);
      }

      var correctLanguage = this.defaultLocales.filter(function (a) {
        return a.lang === lang;
      });

      if (correctLanguage && correctLanguage[0]) {
        return this.remapLanguage(lang);
      }

      correctLanguage = this.remapLanguage(lang);
      return correctLanguage;
    },

    /**
     * Adjust some languages.
     * @private
     * @param  {[type]} lang The two digit language code.
     * @returns {string} Corrected language
     */
    remapLanguage: function remapLanguage(lang) {
      var correctLanguage = lang; // Map incorrect java locale to correct locale

      if (lang === 'in') {
        correctLanguage = 'id';
      }

      if (lang === 'iw') {
        correctLanguage = 'he';
      } // Another special case


      if (lang === 'nb' || lang === 'nn' || lang === 'nb-NO' || lang === 'nn-NO') {
        correctLanguage = 'no';
      }

      return correctLanguage;
    },

    /**
     * Internally stores a new culture file for future use.
     * @private
     * @param {string} locale The 4-character Locale ID
     * @param {object} data Translation data and locale-specific functions, such as calendars.
     * @param {object} langData Translation data if deperated.
     * @returns {void}
     */
    addCulture: function addCulture(locale, data, langData) {
      var lang = locale.substr(0, 2);
      this.cultures[locale] = data;
      this.cultures[locale].name = locale;

      if (!this.languages[lang] && data.messages) {
        this.languages[lang] = {
          name: lang,
          direction: data.direction || (langData ? langData.direction : ''),
          nativeName: data.nativeName || (langData ? langData.nativeName : ''),
          messages: data.messages || (langData ? langData.messages : {})
        };
        this.languages[locale] = {
          name: locale,
          direction: data.direction || (langData ? langData.direction : ''),
          nativeName: data.nativeName || (langData ? langData.nativeName : ''),
          messages: data.messages || (langData ? langData.messages : {})
        };
      } else if (!this.languages[lang] && !data.messages) {
        var parentLocale = this.parentLocale(locale);

        if (parentLocale.default && parentLocale.default !== locale && !this.cultures[parentLocale.default]) {
          this.appendLocaleScript(parentLocale.default);
        }
      }
    },

    /**
     * Find the parent locale (meaning shared translations), if it exists.
     * @private
     * @param {string} locale The locale we are checking.
     * @returns {string} The parent locale.
     */
    parentLocale: function parentLocale(locale) {
      var lang = locale.substr(0, 2);
      var match = this.defaultLocales.filter(function (a) {
        return a.lang === lang;
      });
      var parentLocale = match[0] || [{
        default: 'en-US'
      }]; // fr-FR and fr-CA are different / do not have a default

      if (this.translatedLocales.indexOf(locale) > -1) {
        return {
          lang: 'fr',
          default: 'fr-CA'
        };
      }

      return parentLocale;
    },
    appendedLocales: [],

    /**
     * Append the local script to the page.
     * @private
     * @param {string} locale The locale name to append.
     * @param {boolean} isCurrent If we should set this as the current locale
     * @param {string} parentLocale If we should resolve the promise base on locale
     * @param {string} filename Optional parameter to load locale with different filename
     * @returns {void}
     */
    appendLocaleScript: function appendLocaleScript(locale, isCurrent, parentLocale, filename) {
      var _this = this;

      var script = document.createElement('script');
      var min = this.minify ? '.min' : '';
      script.async = false;

      if (this.appendedLocales.indexOf(locale) > -1) {
        return;
      }

      this.appendedLocales.push(locale);

      if (!filename) {
        script.src = "".concat(this.getCulturesPath() + locale).concat(min, ".js");
      } else {
        script.src = "".concat(this.getCulturesPath() + filename).concat(min, ".js");
      }

      script.onload = function () {
        if (isCurrent && !parentLocale) {
          _this.setCurrentLocale(locale, _this.cultures[locale]);

          _this.dff[locale].resolve(locale);
        }

        if (parentLocale && _this.dff[parentLocale]) {
          _this.setCurrentLocale(locale, _this.cultures[locale]);

          _this.setCurrentLocale(parentLocale, _this.cultures[parentLocale]);

          _this.dff[parentLocale].resolve(parentLocale);
        }

        if (parentLocale && _this.dff[locale] && _this.cultures[locale]) {
          _this.setCurrentLocale(locale, _this.cultures[locale]);

          _this.dff[locale].resolve(locale);
        }

        if (!isCurrent && !parentLocale && _this.dff[locale]) {
          _this.dff[locale].resolve(locale);
        }
      };

      script.onerror = function () {
        if (_this.dff[locale]) {
          _this.dff[locale].reject();
        }
      };

      if (_typeof(window.SohoConfig) === 'object' && typeof window.SohoConfig.nonce === 'string') {
        script.setAttribute('nonce', window.SohoConfig.nonce);
      }

      document.head.appendChild(script);
    },

    /**
     * Sets the current locale.
     * @param {string} locale The locale to fetch and set.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    set: function set(locale) {
      var self = this;
      locale = this.correctLocale(locale);
      this.dff[locale] = $.Deferred();

      if (locale === '') {
        self.dff.resolve();
        return this.dff.promise();
      }

      if (!this.cultures['en-US']) {
        this.appendLocaleScript('en-US', locale === 'en-US');
      }

      var hasParentLocale = false;
      var parentLocale = this.parentLocale(locale);

      if (parentLocale.default && parentLocale.default !== locale && !this.cultures[parentLocale.default]) {
        hasParentLocale = true;
      }

      if (!hasParentLocale && locale && !this.cultures[locale] && this.currentLocale.name !== locale && locale !== 'en-US') {
        this.setCurrentLocale(locale); // Fetch the local and cache it

        this.appendLocaleScript(locale, true);
      } // Also load the default locale for that locale


      if (hasParentLocale) {
        if (parentLocale.default !== 'en-US') {
          this.appendLocaleScript(parentLocale.default, false);
        }

        this.appendLocaleScript(locale, false, parentLocale.default);
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        self.dff[locale].resolve(self.currentLocale.name);
      }

      self.setCurrentLocale(locale, self.cultures[locale]);

      if (self.cultures[locale] && this.cultureInHead()) {
        self.dff[locale].resolve(self.currentLocale.name);
      }

      return this.dff[locale].promise();
    },

    /**
     * Loads the locale without setting it.
     * @param {string} locale The locale to fetch and set.
     * @param {string} filename Optional Locale's filename if different from default.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    getLocale: function getLocale(locale, filename) {
      if (!locale) {
        return null;
      }

      locale = this.correctLocale(locale);
      this.dff[locale] = $.Deferred();

      if (locale === '') {
        var dff = $.Deferred();
        dff.resolve();
        return dff.promise();
      }

      if (locale && locale !== 'en-US' && !this.cultures['en-US']) {
        this.appendLocaleScript('en-US', false);
      }

      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale && locale !== 'en-US') {
        this.appendLocaleScript(locale, false, false, filename);
      }

      if (locale && this.currentLocale.data && this.currentLocale.dataName === locale) {
        this.dff[locale].resolve(locale);
      }

      if (this.cultures[locale] && this.cultureInHead()) {
        this.dff[locale].resolve(locale);
      }

      return this.dff[locale].promise();
    },

    /**
     * Sets the current language, this can be independent and different from the current locale.
     * @param {string} lang The two digit language code to use.
     * @returns {jquery.deferred} which is resolved once the locale culture is retrieved and set
     */
    setLanguage: function setLanguage(lang) {
      var _this2 = this;

      // If not call set and load it and then set back the locale after.
      // Make a new object for currentLanguage independent of currentLocale
      // Change translate to use the right one
      var currentLocale = this.currentLocale.name; // Map incorrect java locale to correct locale

      lang = this.correctLanguage(lang); // Ensure the language / culture is loaded.

      if (!this.languages[lang]) {
        this.set(lang).done(function () {
          _this2.set(currentLocale);

          _this2.setLanguage(lang);
        });
      }

      var correctLocale = this.correctLocale(lang);

      if (this.languages[lang]) {
        this.currentLanguage = this.languages[lang];
        this.updateLanguageTag(lang);
        this.dff[correctLocale] = $.Deferred();
        return this.dff[correctLocale].resolve();
      }

      this.currentLanguage.name = lang;
      return this.dff[correctLocale];
    },

    /**
     * Chooses a stored locale dataset and sets it as "current"
     * @private
     * @param {string} name the 4-character Locale ID
     * @param {object} data translation data and locale-specific functions, such as calendars.
     * @returns {void}
     */
    setCurrentLocale: function setCurrentLocale(name, data) {
      var lang = this.remapLanguage(name.substr(0, 2));
      this.currentLocale.name = name;

      if (data) {
        this.currentLocale.data = data;
        this.currentLocale.dataName = name;
        this.currentLanguage = {};
        this.currentLanguage.name = lang;

        if (this.languages[lang]) {
          this.currentLanguage = this.languages[lang];
          this.updateLanguageTag(name);
        }

        if (this.translatedLocales.indexOf(name) > -1) {
          this.languages[lang].direction = data.direction;
          this.languages[lang].messages = data.messages;
          this.languages[lang].name = lang;
          this.languages[lang].nativeName = data.nativeName;
          this.languages[name] = {
            direction: data.direction,
            messages: data.messages,
            name: name,
            nativeName: data.nativeName
          };
        }

        if ((typeof d3 === "undefined" ? "undefined" : _typeof(d3)) === 'object') {
          var _data$numbers, _data$numbers2, _data$numbers3, _data$numbers4, _data$numbers5;

          // Set the d3 locale for charts (unless disabled)
          d3.formatDefaultLocale({
            decimal: (data === null || data === void 0 ? void 0 : (_data$numbers = data == null ? void 0 : data.numbers) === null || _data$numbers === void 0 ? void 0 : _data$numbers == null ? void 0 : _data$numbers.decimal) || '.',
            thousands: (data === null || data === void 0 ? void 0 : (_data$numbers2 = data == null ? void 0 : data.numbers) === null || _data$numbers2 === void 0 ? void 0 : _data$numbers2 == null ? void 0 : _data$numbers2.group) || ',',
            grouping: (data === null || data === void 0 ? void 0 : (_data$numbers3 = data == null ? void 0 : data.numbers) === null || _data$numbers3 === void 0 ? void 0 : _data$numbers3 == null ? void 0 : _data$numbers3.groupSizes) || [3],
            percent: (data === null || data === void 0 ? void 0 : (_data$numbers4 = data == null ? void 0 : data.numbers) === null || _data$numbers4 === void 0 ? void 0 : _data$numbers4 == null ? void 0 : _data$numbers4.percentSign) || '%',
            currency: !(data !== null && data !== void 0 && (data == null ? void 0 : data.currencySign)) ? ['$', ''] : data.currencyFormat.split('')[0] === '' ? [data.currencySign, ''] : ['', data.currencySign],
            minus: (data === null || data === void 0 ? void 0 : (_data$numbers5 = data == null ? void 0 : data.numbers) === null || _data$numbers5 === void 0 ? void 0 : _data$numbers5 == null ? void 0 : _data$numbers5.minusSign) || '-'
          });
        }
      }
    },

    /**
    * Formats a date object and returns it parsed back using the current locale or settings.
    * The symbols for date formatting use the CLDR at https://bit.ly/2Jg0a6m
    * @param {date} value The date to show in the current locale.
    * @param {object} options Additional date formatting settings.
    * @returns {string} the formatted date.
    */
    formatDate: function formatDate(value, options) {
      if (!options) {
        options = {
          date: 'short'
        }; // can be date, time, datetime or pattern
      }

      var localeData = this.useLocale(options);

      if (!value) {
        return undefined;
      }

      if (value === '0000' || value === '000000' || value === '00000000') {
        // Means no date in some applications
        return '';
      } // Convert if a timezone string.


      if (typeof value === 'string' && /T|Z/g.test(value)) {
        value = this.newDateObj(value);
      } // Convert if a string..


      if (!(value instanceof Date) && typeof value === 'string') {
        var tDate2 = Locale.parseDate(value, options);

        if (isNaN(tDate2) && options.date === 'datetime' && value.substr(4, 1) === '-' && value.substr(7, 1) === '-') {
          tDate2 = new Date(value.substr(0, 4), value.substr(5, 2) - 1, value.substr(8, 2), value.substr(11, 2), value.substr(14, 2), value.substr(17, 2));
        }

        value = tDate2;
      }

      if (!(value instanceof Date) && typeof value === 'number') {
        var tDate3 = new Date(value);
        value = tDate3;
      }

      if (!value) {
        return undefined;
      }

      var pattern;
      var ret = '';
      var cal = localeData.calendars ? localeData.calendars[0] : null;

      if (options.pattern) {
        pattern = options.pattern;
      }

      if (options.date) {
        pattern = cal.dateFormat[options.date];
      }

      if (typeof options === 'string' && options !== '') {
        pattern = options;
      }

      if (!pattern) {
        pattern = cal.dateFormat.short;
      }

      var year = value instanceof Array ? value[0] : value.getFullYear();
      var month = value instanceof Array ? value[1] : value.getMonth();
      var day = value instanceof Array ? value[2] : value.getDate();
      var dayOfWeek = value.getDay ? value.getDay() : '';
      var hours = value instanceof Array ? value[3] : value.getHours();
      var mins = value instanceof Array ? value[4] : value.getMinutes();
      var seconds = value instanceof Array ? value[5] : value.getSeconds();
      var millis = value instanceof Array ? value[6] : value.getMilliseconds();

      if (options.fromGregorian || options.toUmalqura) {
        var islamicParts = this.gregorianToUmalqura(value);
        day = islamicParts[2];
        month = islamicParts[1];
        year = islamicParts[0];
      }

      if (options.toGregorian || options.fromUmalqura) {
        var gregorianDate = this.umalquraToGregorian(year, month, day);
        day = gregorianDate.getDate();
        month = gregorianDate.getMonth();
        year = gregorianDate.getFullYear();
      } // Special


      pattern = pattern.replace('de', 'nnnnn');
      pattern = pattern.replace('ngy', 'nnnn');
      pattern = pattern.replace('thng', 't1ng');
      pattern = pattern.replace('den', 'nnn'); // Day of Month

      ret = pattern.replace('dd', this.pad(day, 2));
      ret = ret.replace('d', day); // years

      ret = ret.replace('yyyy', year);
      ret = ret.replace('yy', year.toString().substr(2));
      ret = ret.replace('y', year); // Time

      var showDayPeriods = ret.indexOf(' a') > -1 || ret.indexOf('a') === 0;

      if (showDayPeriods && hours === 0) {
        ret = ret.replace('hh', 12);
        ret = ret.replace('h', 12);
      }

      ret = ret.replace('hh', hours > 12 ? this.pad(hours - 12, 2) : this.pad(hours, 2));
      ret = ret.replace('h', hours > 12 ? hours - 12 : hours);
      ret = ret.replace('HH', this.pad(hours, 2));
      ret = ret.replace('H', hours);
      ret = ret.replace('mm', this.pad(mins, 2));
      ret = ret.replace('ss', this.pad(seconds, 2));
      ret = ret.replace('SSS', this.pad(millis, 3)); // months

      ret = ret.replace('MMMM', cal ? cal.months.wide[month] : null); // full

      ret = ret.replace('MMM', cal ? cal.months.abbreviated[month] : null); // abreviation

      if (pattern.indexOf('MMM') === -1) {
        ret = ret.replace('MM', this.pad(month + 1, 2)); // number padded

        ret = ret.replace('M', month + 1); // number unpadded
      } // PM


      if (showDayPeriods && cal) {
        ret = ret.replace(' a', " ".concat(hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));

        if (ret.indexOf('a') === 0) {
          ret = ret.replace('a', " ".concat(hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));
        }

        ret = ret.replace('EEEE', cal.days.wide[dayOfWeek]); // Day of Week
      } // Day of Week


      if (cal) {
        ret = ret.replace('EEEE', cal.days.wide[dayOfWeek]); // Day of Week
      }

      if (cal) {
        ret = ret.replace('EEE', cal.days.abbreviated[dayOfWeek]); // Day of Week
      }

      if (cal) {
        ret = ret.replace('EE', cal.days.narrow[dayOfWeek]); // Day of Week
      }

      ret = ret.replace('nnnnn', 'de');
      ret = ret.replace('nnnn', 'ngy');
      ret = ret.replace('t1ng', 'thng');
      ret = ret.replace('nnn', 'den'); // Timezone

      if (ret.indexOf('zz') > -1) {
        var timezoneDate = new Date();
        var shortName = this.getTimeZone(timezoneDate, 'short');
        var longName = this.getTimeZone(timezoneDate, 'long');
        ret = ret.replace('zzzz', longName);
        ret = ret.replace('zz', shortName);
      }

      return ret.trim();
    },

    /**
     * Get date object by given date string.
     * @private
     * @param {string} dateStr The date string
     * @returns {object} The date object.
     */
    newDateObj: function newDateObj(dateStr) {
      var date = new Date(dateStr); // Safari was not render the right date/time with timezone string

      if (Environment.browser.name === 'safari' && typeof dateStr === 'string' && /T|Z/g.test(dateStr)) {
        var arr = dateStr.replace(/Z/, '').replace(/T|:/g, '-').split('-');
        arr = arr.map(function (x, i) {
          return +(i === 1 ? x - 1 : x);
        });
        date = _construct(Date, _toConsumableArray(arr));
      }

      return date;
    },

    /**
    * Formats a number into the locales hour format.
    * @param {number} hour The hours to show in the current locale.
    * @param {object} options Additional date formatting settings.
    * @returns {string} the hours in either 24 h or 12 h format
    */
    formatHour: function formatHour(hour, options) {
      var timeSeparator = this.calendar().dateFormat.timeSeparator;
      var locale = this.currentLocale.name;

      if (_typeof(options) === 'object') {
        locale = options.locale || locale;
        timeSeparator = options.timeSeparator || this.calendar(locale).dateFormat.timeSeparator;
      }

      if (typeof hour === 'string' && hour.indexOf(timeSeparator) === -1) {
        timeSeparator = ':';
      }

      var date = new Date();

      if (typeof hour === 'number') {
        var split = hour.toString().split('.');
        date.setHours(split[0]);
        date.setMinutes(split[1] ? parseFloat("0.".concat(split[1])) * 60 : 0);
      } else {
        var parts = hour.split(timeSeparator);
        date.setHours(parts[0]);
        date.setMinutes(parts[1] || 0);
      }

      return this.formatDate(date, {
        date: 'hour'
      });
    },

    /**
    * Formats a number into the locales hour format.
    * @param {number} startHour The hours to show in the current locale.
    * @param {number} endHour The hours to show in the current locale.
    * @param {object} options Additional date formatting settings.
    * @returns {string} the hours in either 24 h or 12 h format
    */
    formatHourRange: function formatHourRange(startHour, endHour, options) {
      var locale = this.currentLocale.name;
      var dayPeriods = this.calendar(locale).dayPeriods;
      var removePeriod = false;

      if (_typeof(options) === 'object') {
        locale = options.locale || locale;
        dayPeriods = this.calendar(locale).dayPeriods;
      }

      var range = "".concat(Locale.formatHour(startHour, options), " - ").concat(Locale.formatHour(endHour, options));

      if (range.indexOf(':00 AM -') > -1 || range.indexOf(':00 PM -') > -1) {
        removePeriod = true;
      }

      if (stringUtils.count(range, dayPeriods[0]) > 1) {
        range = range.replace(dayPeriods[0], '');
      }

      if (stringUtils.count(range, dayPeriods[1]) > 1) {
        range = range.replace(" ".concat(dayPeriods[1]), '');
      }

      range = range.replace('  ', ' ');

      if (removePeriod) {
        range = range.replace(':00 -', ' -');
      }

      return range;
    },

    /**
     * Get the timezone part of a date
     * @param  {date} date The date object to use.
     * @param  {string} timeZoneName Can be short or long.
     * @returns {string} The time zone as a string.
     */
    getTimeZone: function getTimeZone(date, timeZoneName) {
      var currentLocale = Locale.currentLocale.name || 'en-US';

      if (Environment.browser.name === 'ie' && Environment.browser.version === '11') {
        return date.toTimeString().match(new RegExp('[A-Z](?!.*[\(])', 'g')).join('');
      }

      var short = date.toLocaleDateString(currentLocale);
      var full = date.toLocaleDateString(currentLocale, {
        timeZoneName: timeZoneName === 'long' ? 'long' : 'short'
      }); // Trying to remove date from the string in a locale-agnostic way

      var shortIndex = full.indexOf(short);

      if (shortIndex >= 0) {
        var trimmed = full.substring(0, shortIndex) + full.substring(shortIndex + short.length); // by this time `trimmed` should be the timezone's name with some punctuation -
        // trim it from both sides

        return trimmed.replace(/^[\s,.\-:;]+|[\s,.\-:;]+$/g, '');
      } // in some magic case when short representation of date is not present in the long one, just return the long one as a fallback, since it should contain the timezone's name


      return full;
    },

    /**
    * Takes a date object in the current locale and adjusts it for the given timezone.
    * @param {date} date The utc date to show in the desired timezone.
    * @param {string} timeZone The timezone name to show.
    * @param {string} timeZoneName How to display the time zone name. Defaults to none. But can be short or long.
    * @returns {date} the utc date
    */
    dateToTimeZone: function dateToTimeZone(date, timeZone, timeZoneName) {
      if (Environment.browser.name === 'ie' && Environment.browser.version === '11') {
        return "".concat(date.toLocaleString(Locale.currentLocale.name), " ").concat(date.toTimeString().match(new RegExp('[A-Z](?!.*[\(])', 'g')).join(''));
      }

      return date.toLocaleString(Locale.currentLocale.name, {
        timeZone: timeZone,
        timeZoneName: timeZoneName
      });
    },

    /**
    * Formats a Date Object and return it in UTC format
    * @param {date} date The date to show in the current locale.
    * @returns {date} the utc date
    */
    dateToUTC: function dateToUTC(date) {
      return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
    },

    /**
    * Formats a number into the current locale using toLocaleString
    * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString#Using_locales
    * @param {number} number The number to convert
    * @param {string} locale The number to convert
    * @param {object} options The number to convert
    * @param {string} groupSeparator If provided will replace with browser default character
    * @returns {string} The converted number.
    */
    toLocaleString: function toLocaleString(number, locale, options, groupSeparator) {
      if (typeof number !== 'number') {
        return '';
      }

      var args = {
        locale: locale || Locale.currentLocale.name,
        options: options || undefined
      };
      var n = number.toLocaleString(args.locale, args.options);

      if (!/undefined|null/.test(_typeof(groupSeparator))) {
        var gSeparator = this.getSeparator(args.locale, 'group');

        if (gSeparator !== '.') {
          n = n.replace(new RegExp(gSeparator, 'g'), groupSeparator.toString());
        }
      }

      return n;
    },

    /**
    * Find browser default separator for given locale
    * @private
    * @param {string} locale The locale
    * @param {string} separatorType The separator type be found `group`|`decimal`
    * @returns {string} The browser default separator character
    */
    getSeparator: function getSeparator(locale, separatorType) {
      var number = 1000.1;
      return Intl.NumberFormat(locale).formatToParts(number).find(function (part) {
        return part.type === separatorType;
      }).value;
    },

    /**
     * Convert a number in arabic/chinese or hindi numerals to an "english" number.
     * @param  {[type]} string The string number in arabic/chinese or hindi
     * @returns {number} The english number.
     */
    convertNumberToEnglish: function convertNumberToEnglish(string) {
      var arabic = ['', '', '', '', '', '', '', '', '', ''];
      var devanagari = ['', '', '', '', '', '', '', '', '', '']; // Hindi

      var chineseFinancialTraditional = ['', '', '', '', '', '', '', '', '', ''];
      var chineseFinancialSimplified = ['', '', '', '', '', '', '', '', '', ''];
      var chinese = ['', '', '', '', '', '', '', '', '', ''];

      for (var i = 0; i <= 9; i++) {
        string = string.replace(arabic[i], i);
        string = string.replace('', '');
        string = string.replace(',', '');
        string = string.replace(devanagari[i], i);
        string = string.replace(chineseFinancialTraditional[i], i);
        string = string.replace(chineseFinancialSimplified[i], i);
        string = string.replace(chinese[i], i);

        if (i === 0) {
          // Second option for zero in chinese
          string = string.replace('', i);
        }
      }

      return parseFloat(string);
    },

    /**
     * Check if the date is valid using the current locale to do so.
     * @param {date} date  The date to show in the current locale.
     * @returns {boolean} whether or not the date is valid.
     */
    isValidDate: function isValidDate(date) {
      if (Object.prototype.toString.call(date) === '[object Date]') {
        // it is a date
        if (isNaN(date.getTime())) {
          // d.valueOf() could also work
          return false;
        }

        return true;
      }

      return false;
    },

    /**
     * Takes a formatted date string and parses back it into a date object
     * @param {string} dateString  The string to parse in the current format
     * @param {string|object} options  The source format for example 'yyyy-MM-dd' or { dateFormat: 'yyyy-MM-dd', locale: 'nl-NL'}
     * @param {boolean} isStrict  If true missing date parts will be considered invalid. If false the current month/day.
     * @returns {date|array|undefined} A correct date object, if islamic calendar then an array is used or undefined if invalid.
     */
    parseDate: function parseDate(dateString, options, isStrict) {
      if (!dateString) {
        return undefined;
      }

      var dateFormat = options;
      var locale = this.currentLocale.name;
      var thisLocaleCalendar = this.calendar();

      if (_typeof(options) === 'object') {
        locale = options.locale || locale;
        dateFormat = options.dateFormat || this.calendar(locale).dateFormat[dateFormat.date];
      }

      if (_typeof(options) === 'object' && options.pattern) {
        dateFormat = options.dateFormat || options.pattern;
      }

      if (_typeof(options) === 'object' && options.calendarName && options.locale) {
        thisLocaleCalendar = this.calendar(options.locale, options.language, options.calendarName);
      }

      if (!dateFormat) {
        dateFormat = this.calendar(locale).dateFormat.short;
      }

      var orgDatestring = dateString;

      if (dateString === '0000' || dateString === '000000' || dateString === '00000000') {
        // Means no date in some applications
        return undefined;
      }

      if (dateFormat.pattern) {
        dateFormat = dateFormat.pattern;
      }

      var formatParts;
      var dateStringParts;
      var dateObj = {};
      var isDateTime = dateFormat.toLowerCase().indexOf('h') > -1;
      var isUTC = dateString.toLowerCase().indexOf('z') > -1;
      var i;
      var l;
      var hasDot = (dateFormat.match(/M/g) || []).length === 3 && thisLocaleCalendar && thisLocaleCalendar.months && thisLocaleCalendar.months.abbreviated && thisLocaleCalendar.months.abbreviated.filter(function (v) {
        return /\./.test(v);
      }).length;

      if (isDateTime) {
        // Remove Timezone
        var shortTimeZone = Locale.getTimeZone(new Date(), 'short');
        var longTimeZone = Locale.getTimeZone(new Date(), 'long');
        dateString = dateString.replace(" ".concat(shortTimeZone), '');
        dateString = dateString.replace(" ".concat(longTimeZone), '');
        dateFormat = dateFormat.replace(' zzzz', '').replace(' zz', ''); // Replace [space & colon & dot] with "/"

        var regex = hasDot ? /[T\s:-]/g : /[T\s:.-]/g;
        dateFormat = dateFormat.replace(regex, '/').replace(/z/i, '');
        dateString = dateString.replace(regex, '/').replace(/z/i, '');
      } // Remove spanish de


      dateFormat = dateFormat.replace(' de ', ' ');
      dateString = dateString.replace(' de ', ' '); // Fix ah

      dateFormat = dateFormat.replace('/ah/', '/a/h/');
      dateString = dateString.replace('', '/'); // Remove commas

      dateFormat = dateFormat.replace(',', '');
      dateString = dateString.replace(',', ''); // Adjust short dates where no separators or special characters are present.

      var hasMdyyyy = dateFormat.indexOf('Mdyyyy');
      var hasdMyyyy = dateFormat.indexOf('dMyyyy');
      var startIndex = -1;
      var endIndex = -1;

      if (hasMdyyyy > -1 || hasdMyyyy > -1) {
        startIndex = hasMdyyyy > -1 ? hasMdyyyy : hasdMyyyy > -1 ? hasdMyyyy : 0;
        endIndex = startIndex + dateString.indexOf('/') > -1 ? dateString.indexOf('/') : dateString.length;
        dateString = "".concat(dateString.substr(startIndex, endIndex - 4), "/").concat(dateString.substr(endIndex - 4, dateString.length));
        dateString = "".concat(dateString.substr(startIndex, dateString.indexOf('/') / 2), "/").concat(dateString.substr(dateString.indexOf('/') / 2, dateString.length));
      }

      if (hasMdyyyy > -1) {
        dateFormat = dateFormat.replace('Mdyyyy', 'M/d/yyyy');
      }

      if (hasdMyyyy > -1) {
        dateFormat = dateFormat.replace('dMyyyy', 'd/M/yyyy');
      }

      if (dateFormat.indexOf(' ') !== -1) {
        var _regex = hasDot ? /[\s:]/g : /[\s:.]/g;

        dateFormat = dateFormat.replace(_regex, '/');
        dateString = dateString.replace(_regex, '/');
      } // Extra Check in case month has spaces


      if (dateFormat.indexOf('MMMM') > -1 && Locale.isRTL() && dateFormat && dateFormat !== 'MMMM/dd' && dateFormat !== 'dd/MMMM') {
        var lastIdx = dateString.lastIndexOf('/');
        dateString = dateString.substr(0, lastIdx - 1).replace('/', ' ') + dateString.substr(lastIdx);
      }

      if (dateFormat.indexOf(' ') === -1 && dateFormat.indexOf('.') === -1 && dateFormat.indexOf('/') === -1 && dateFormat.indexOf('-') === -1) {
        // Remove delimeter for the data string.
        if (dateString.indexOf(' ') !== -1) {
          dateString = dateString.split(' ').join('');
        } else if (dateString.indexOf('.') !== -1) {
          dateString = dateString.split('.').join('');
        } else if (dateString.indexOf('/') !== -1) {
          dateString = dateString.split('/').join('');
        } else if (dateString.indexOf('-') !== -1) {
          dateString = dateString.split('-').join('');
        }

        var lastChar = dateFormat[0];
        var newFormat = '';
        var newDateString = '';

        for (i = 0, l = dateFormat.length; i < l; i++) {
          newDateString += dateFormat[i] !== lastChar ? "/".concat(dateString[i]) : dateString[i];
          newFormat += dateFormat[i] !== lastChar ? "/".concat(dateFormat[i]) : dateFormat[i];

          if (i > 1) {
            lastChar = dateFormat[i];
          }
        }

        dateString = newDateString;
        dateFormat = newFormat;
      }

      formatParts = dateFormat.split('/');
      dateStringParts = dateString.split('/');

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('.');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('.');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('-');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('-');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split(' ');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split(' ');
      } // Check the incoming date string's parts to make sure the values are
      // valid against the localized Date pattern.


      var month = this.getDatePart(formatParts, dateStringParts, 'M', 'MM', 'MMM', 'MMMM');
      var year = this.getDatePart(formatParts, dateStringParts, 'yy', 'yyyy');
      var hasDays = false;
      var hasAmFirst = false;
      var amSetting = thisLocaleCalendar.dayPeriods[0].replace(/\./g, '');
      var pmSetting = thisLocaleCalendar.dayPeriods[1].replace(/\./g, '');

      for (i = 0, l = dateStringParts.length; i < l; i++) {
        var pattern = "".concat(formatParts[i]);
        var value = dateStringParts[i];
        var numberValue = parseInt(value, 10);

        if (!hasDays) {
          hasDays = pattern.toLowerCase().indexOf('d') > -1;
        }

        var lastDay = void 0;
        var abrMonth = void 0;
        var textMonths = void 0;

        switch (pattern) {
          case 'd':
            lastDay = new Date(year, month, 0).getDate();

            if (numberValue < 1 || numberValue > 31 || numberValue > lastDay) {
              return undefined;
            }

            dateObj.day = value;
            break;

          case 'dd':
            if (numberValue < 1 || numberValue > 31 || numberValue < 10 && value.substr(0, 1) !== '0') {
              return undefined;
            }

            dateObj.day = value;
            break;

          case 'M':
            if (numberValue < 1 || numberValue > 12) {
              return undefined;
            }

            dateObj.month = value - 1;
            break;

          case 'MM':
            if (numberValue < 1 || numberValue > 12 || numberValue < 10 && value.substr(0, 1) !== '0') {
              return undefined;
            }

            dateObj.month = value - 1;
            break;

          case 'MMM':
            abrMonth = this.calendar(locale).months.abbreviated;

            for (var len = 0; len < abrMonth.length; len++) {
              if (orgDatestring.indexOf(abrMonth[len]) > -1) {
                dateObj.month = len;
              }
            }

            break;

          case 'MMMM':
            textMonths = this.calendar(locale).months.wide;

            for (var k = 0; k < textMonths.length; k++) {
              if (orgDatestring.indexOf(textMonths[k]) > -1) {
                dateObj.month = k;
              }
            }

            break;

          case 'yy':
            dateObj.year = this.twoToFourDigitYear(value);
            break;

          case 'yyyy':
            dateObj.year = value.length === 2 ? this.twoToFourDigitYear(value) : value;
            break;

          case 'h':
            if (numberValue < 0 || numberValue > 12) {
              return undefined;
            }

            dateObj.h = hasAmFirst ? dateObj.h : value;
            break;

          case 'hh':
            if (numberValue < 0 || numberValue > 12) {
              return undefined;
            }

            dateObj.h = hasAmFirst ? dateObj.h : value.length === 1 ? "0".concat(value) : value;
            break;

          case 'H':
            if (numberValue < 0 || numberValue > 24) {
              return undefined;
            }

            dateObj.h = hasAmFirst ? dateObj.h : value;
            break;

          case 'HH':
            if (numberValue < 0 || numberValue > 24) {
              return undefined;
            }

            dateObj.h = hasAmFirst ? dateObj.h : value.length === 1 ? "0".concat(value) : value;
            break;

          case 'ss':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.ss = 0;
              break;
            }

            dateObj.ss = value;
            break;

          case 'SSS':
            dateObj.ms = value;
            break;

          case 'mm':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.mm = 0;
              break;
            }

            dateObj.mm = value;
            break;

          case 'a':
            if (value.toLowerCase() === amSetting || value.toUpperCase() === amSetting) {
              dateObj.a = 'AM';

              if (!dateObj.h && formatParts[i + 1] && formatParts[i + 1].toLowerCase().substr(0, 1) === 'h') {
                // in a few cases am/pm is before hours
                dateObj.h = dateStringParts[i + 1];
                hasAmFirst = true;
              }

              if (dateObj.h) {
                if (dateObj.h === 12 || dateObj.h === '12') {
                  dateObj.h = 0;
                }
              }
            }

            if (value.toLowerCase() === pmSetting || value.toUpperCase() === pmSetting) {
              dateObj.a = 'PM';

              if (dateObj.h) {
                if (dateObj.h < 12) {
                  dateObj.h = parseInt(dateObj.h, 10) + 12;
                }
              }
            }

            break;
        }
      }

      var isLeap = function isLeap(y) {
        return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0;
      };

      var closestLeap = function closestLeap(y) {
        var closestLeapYear = typeof y === 'number' && !isNaN(y) ? y : new Date().getFullYear();

        for (var i2 = 0; i2 < 4; i2++) {
          if (isLeap(closestLeapYear)) {
            break;
          }

          closestLeapYear--;
        }

        return closestLeapYear;
      };

      dateObj.return = undefined;
      dateObj.leapYear = isLeap(dateObj.year);

      if (isDateTime && !dateObj.h && !dateObj.mm) {
        return undefined;
      }

      if (!dateObj.year && dateObj.year !== 0 && !isStrict) {
        dateObj.isUndefindedYear = true;

        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('y') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedYear = false;
            break;
          }
        }

        if (dateObj.isUndefindedYear) {
          var isFeb29 = parseInt(dateObj.day, 10) === 29 && parseInt(dateObj.month, 10) === 1;
          dateObj.year = isFeb29 ? closestLeap() : new Date().getFullYear();

          if (thisLocaleCalendar.name === 'islamic-umalqura') {
            var umDate = this.gregorianToUmalqura(new Date(dateObj.year, 0, 1));
            dateObj.year = umDate[0];
          }
        } else {
          delete dateObj.year;
        }
      } // Fix incomelete 2 and 3 digit years


      if (dateObj.year && dateObj.year.length === 2) {
        dateObj.year = "20".concat(dateObj.year);
      }

      dateObj.year = $.trim(dateObj.year);
      dateObj.day = $.trim(dateObj.day);

      if (dateObj.year === '' || dateObj.year && !("".concat(dateObj.year).length === 2 || "".concat(dateObj.year).length === 4)) {
        delete dateObj.year;
      }

      if (!dateObj.month && dateObj.month !== 0 && !isStrict) {
        dateObj.isUndefindedMonth = true;

        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('M') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedMonth = false;
            break;
          }
        }

        if (dateObj.isUndefindedMonth) {
          dateObj.month = new Date().getMonth();
        }
      }

      if (!dateObj.day && dateObj.day !== 0 && (!isStrict || !hasDays)) {
        dateObj.isUndefindedDay = true;

        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('d') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedDay = false;
            break;
          }
        }

        if (dateObj.isUndefindedDay) {
          dateObj.day = 1;
        } else {
          delete dateObj.day;
        }
      }

      if (isDateTime) {
        if (isUTC) {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm)); //eslint-disable-line
          }

          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss)); //eslint-disable-line
          }

          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms)); //eslint-disable-line
          }
        } else {
          if (dateObj.h !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm); //eslint-disable-line
          }

          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss); //eslint-disable-line
          }

          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms); //eslint-disable-line
          }
        }
      } else {
        dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day);
      }

      if (thisLocaleCalendar.name === 'islamic-umalqura') {
        return [parseInt(dateObj.year, 10), parseInt(dateObj.month, 10), parseInt(dateObj.day, 10), parseInt(dateObj.h || 0, 10), parseInt(dateObj.mm || 0, 10), parseInt(dateObj.ss || 0, 10), parseInt(dateObj.ms || 0, 10)];
      }

      return this.isValidDate(dateObj.return) ? dateObj.return : undefined;
    },

    /**
     * Convert the two digit year year to the correct four digit year.
     * @private
     * @param  {number} twoDigitYear The two digit year.
     * @returns {number} Converted 3 digit year.
     */
    twoToFourDigitYear: function twoToFourDigitYear(twoDigitYear) {
      return parseInt((twoDigitYear > 39 ? '19' : '20') + twoDigitYear, 10);
    },

    /**
     * Format out the date into parts.
     * @private
     * @param  {array} formatParts An array of the format bits.
     * @param  {array} dateStringParts An array of the date parts.
     * @param  {string} filter1 The first option to filter.
     * @param  {string} filter2 The second option to filter.
     * @param  {string} filter3 The third option to filter.
     * @param  {string} filter4 The fourth option to filter.
     * @returns {string} The filtered out date part.
     */
    getDatePart: function getDatePart(formatParts, dateStringParts, filter1, filter2, filter3, filter4) {
      var ret = 0;
      $.each(dateStringParts, function (i) {
        if (filter1 === formatParts[i] || filter2 === formatParts[i] || filter3 === formatParts[i] || filter4 === formatParts[i]) {
          ret = dateStringParts[i];
        }
      });
      return ret;
    },

    /**
     * Use the current locale data or the one passed in.
     * @private
     * @param  {object} options The options to parse.
     * @returns {object} The locale data.
     */
    useLocale: function useLocale(options) {
      var localeData = this.currentLocale.data;

      if (options && options.locale && this.cultures[options.locale]) {
        localeData = this.cultures[options.locale];
      }

      if (options && options.language && this.languages[options.language]) {
        var newData = utils.extend(true, {}, this.currentLocale.data);

        if (newData.calendars) {
          newData.calendars[0] = this.calendar(options.locale || this.currentLocale.name, options.language);
          return newData;
        }
      }

      if (!localeData.numbers) {
        localeData.numbers = this.numbers();
      }

      return localeData;
    },

    /**
     * Use the current language data or the one passed in.
     * @private
     * @param  {object} options The options to parse.
     * @returns {object} The language data.
     */
    useLanguage: function useLanguage(options) {
      var languageData = this.currentLanguage;

      if (options && options.locale) {
        var lang = options.locale.split('-')[0];
        languageData = this.languages[lang];
      }

      if (options && options.locale && this.currentLanguage.name !== this.currentLocale.name.substr(0, 2) && this.languages[this.currentLanguage.name]) {
        languageData = this.languages[this.currentLanguage.name];
      }

      if (options && options.language && this.languages[options.language]) {
        languageData = this.languages[options.language];
      }

      return languageData;
    },

    /**
    * Formats a decimal with thousands and padding in the current locale or settings.
    * @param {number} number The source number.
    * @param {object} options additional options (see Number Format Patterns)
    * @returns {string} the formatted number.
    */
    formatNumber: function formatNumber(number, options) {
      var localeData = this.useLocale(options);
      var formattedNum;
      var curFormat;
      var percentFormat;
      var decimal = options && options.decimal ? options.decimal : localeData.numbers.decimal;
      var minimumFractionDigits = options && options.minimumFractionDigits !== undefined ? options.minimumFractionDigits : options && options.style && options.style === 'currency' ? 2 : options && options.style && options.style === 'percent' ? 0 : 2;
      var maximumFractionDigits = options && options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : options && options.style && (options.style === 'currency' || options.style === 'percent') ? 2 : options && options.minimumFractionDigits ? options.minimumFractionDigits : 3;

      if (number === undefined || number === null || number === '') {
        return undefined;
      }

      if (options && options.style === 'integer') {
        maximumFractionDigits = 0;
        minimumFractionDigits = 0;
      }

      if (options && options.style === 'currency') {
        var sign = options && options.currencySign ? options.currencySign : localeData.currencySign;
        var format = options && options.currencyFormat ? options.currencyFormat : localeData.currencyFormat;

        if (!format) {
          format = '#,##0.00'; // default to en-us
        }

        curFormat = format.replace('', sign);
      }

      if (options && options.style === 'percent') {
        var percentSign = !localeData.numbers ? '%' : localeData.numbers.percentSign;
        percentFormat = !localeData.numbers ? '### %' : localeData.numbers.percentFormat;
        percentFormat = percentFormat.replace('', percentSign);
      }

      if (typeof number === 'string') {
        number = Locale.parseNumber(number);
      }

      if (number.toString().indexOf('e') > -1) {
        number = number.toFixed(maximumFractionDigits + 1);
      }

      if (options && options.style === 'percent') {
        // the toFixed for maximumFractionDigits + 1 means we won't loose any precision
        number = (number * 100).toFixed(minimumFractionDigits);
      }

      var parts = this.truncateDecimals(number, minimumFractionDigits, maximumFractionDigits, options && options.round).split('.');
      var groupSizes = [3, 3]; // In case there is no data

      if (localeData && localeData.numbers && localeData.numbers.groupSizes) {
        groupSizes = localeData.numbers.groupSizes;
      }

      if (options && options.groupSizes) {
        groupSizes = options.groupSizes;
      }

      var sep = options && options.group !== undefined ? options.group : localeData.numbers.group;
      var expandedNum = this.expandNumber(parts[0], groupSizes, sep);
      parts[0] = expandedNum;
      formattedNum = parts.join(decimal); // Position the negative at the front - There is no CLDR info for this.

      var minusSign = localeData && localeData.numbers && localeData.numbers.minusSign ? localeData.numbers.minusSign : '-';
      var isNegative = formattedNum.indexOf(minusSign) > -1;
      formattedNum = formattedNum.replace(minusSign, '');

      var escape = function escape(str) {
        return str.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      };

      var expr = '';

      if (minimumFractionDigits === 0) {
        // Not default
        expr = new RegExp("(".concat(escape(decimal), "[0-9]*?)0+$"));
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
      }

      if (minimumFractionDigits > 0) {
        expr = new RegExp("(".concat(escape(decimal), ".{").concat(minimumFractionDigits, "}[0-9]*?)0+$"));
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
      }

      expr = new RegExp("".concat(escape(decimal), "$"));
      formattedNum = formattedNum.replace(expr, ''); // remove trailing decimal

      if (options && options.style === 'currency') {
        formattedNum = curFormat.replace('###', formattedNum);
      }

      if (options && options.style === 'percent') {
        formattedNum = percentFormat.replace('###', formattedNum);
      }

      if (isNegative) {
        formattedNum = minusSign + formattedNum;
      }

      return formattedNum;
    },

    /**
     * Expand the number to the groupsize.
     * @private
     * @param  {string} numberString The number to expand
     * @param  {array} groupSizes The groupSizes option.
     * @param  {string} sep The thousands separator option.
     * @returns {string} The expanded number.
     */
    expandNumber: function expandNumber(numberString, groupSizes, sep) {
      var len = numberString.length;
      var isNegative = false;

      if (numberString.substr(0, 1) === '-') {
        numberString = numberString.substr(1);
        len = numberString.length;
        isNegative = true;
      }

      if (len <= 3) {
        return (isNegative ? '-' : '') + numberString;
      }

      if (groupSizes[0] === 0) {
        return (isNegative ? '-' : '') + numberString;
      }

      var firstGroup = numberString.substr(numberString.length - groupSizes[0]);
      var nthGroup = numberString.substr(0, numberString.length - groupSizes[0]);

      if (groupSizes[1] === 0) {
        return (isNegative ? '-' : '') + nthGroup + (nthGroup === '' ? '' : sep) + firstGroup;
      }

      var reversed = nthGroup.split('').reverse().join('');
      var regex = new RegExp(".{1,".concat(groupSizes[1], "}"), 'g');
      var reversedSplit = reversed.match(regex).join(sep);
      return (isNegative ? '-' : '') + reversedSplit.split('').reverse().join('') + sep + firstGroup;
    },

    /**
     * Truncate a number to a specific min and max digits.
     * @private
     * @param  {number} number The starting number.
     * @param  {number} minDigits Minimum number of digits to show on the decimal portion.
     * @param  {number} maxDigits Maximum number of digits to show on the decimal portion.
     * @param  {boolean} round If true round, if false truncate.
     * @returns {string} The updated number as a string.
     */
    truncateDecimals: function truncateDecimals(number, minDigits, maxDigits, round) {
      var processed = number;

      if (round) {
        processed = numberUtils.round(number, maxDigits);
      } else {
        processed = numberUtils.truncate(number, maxDigits);
      } // Add zeros


      var actualDecimals = numberUtils.decimalPlaces(processed);

      if (actualDecimals < minDigits) {
        processed = processed.toString() + new Array(minDigits - actualDecimals + 1).join('0');
      }

      return processed.toString();
    },

    /**
     * Takes a formatted number string and returns back real number object.
     * @param {string} input  The source number (as a string).
     * @param {object} options  Any special options to pass in such as the locale.
     * @returns {number} The number as an actual Number type unless the number is a big int (19 significant digits), in this case a string will be returned
     */
    parseNumber: function parseNumber(input, options) {
      var localeData = this.useLocale(options);
      var numSettings = localeData.numbers;
      var numString;
      numString = input;

      if (!numString) {
        return NaN;
      }

      if (typeof input === 'number') {
        numString = numString.toString();
      }

      var group = numSettings ? numSettings.group : ',';
      var decimal = numSettings ? numSettings.decimal : '.';
      var percentSign = numSettings ? numSettings.percentSign : '%';
      var currencySign = localeData.currencySign || '$';
      var exp = group === ' ' ? new RegExp(/\s/g) : new RegExp("\\".concat(group), 'g');
      numString = numString.replace(exp, '');
      numString = numString.replace(decimal, '.');
      numString = numString.replace(percentSign, '');
      numString = numString.replace(currencySign, '');
      numString = numString.replace('$', '');
      numString = numString.replace(' ', '');
      return numString.length >= 19 ? numString : parseFloat(numString);
    },

    /**
     * Takes a translation key and returns the translation in the current locale.
     * @param {string} key  The key to search for on the string.
     * @param {object} [options] A list of options, supported are a non default locale and showAsUndefined and showBrackets which causes a translated phrase to be shown in square brackets
     * instead of defaulting to the default locale's version of the string.
     * @returns {string|undefined} a translated string, or nothing, depending on configuration
     */
    translate: function translate(key, options) {
      var languageData = this.useLanguage(options);
      var showAsUndefined = false;
      var showBrackets = true;

      if (key === '&nsbp;') {
        return '';
      }

      if (typeof options === 'boolean') {
        showAsUndefined = options;
      }

      if (_typeof(options) === 'object' && options.showAsUndefined !== undefined) {
        showAsUndefined = options.showAsUndefined;
      }

      if (_typeof(options) === 'object' && options.showBrackets !== undefined) {
        showBrackets = options.showBrackets;
      }

      if (languageData === undefined || languageData.messages === undefined) {
        return showAsUndefined ? undefined : "".concat(showBrackets ? '[' : '').concat(key).concat(showBrackets ? ']' : '');
      }

      if (languageData.messages[key] === undefined) {
        var enLang = 'en'; // Substitue English Expression if missing

        if (!this.languages || !this.languages[enLang] || !this.languages[enLang].messages || this.languages[enLang].messages[key] === undefined) {
          return showAsUndefined ? undefined : "".concat(showBrackets ? '[' : '').concat(key).concat(showBrackets ? ']' : '');
        }

        return this.languages[enLang].messages[key].value;
      }

      return languageData.messages[key].value;
    },

    /**
     * Add an object full of translations to the given locale.
     * @param {string} lang The language to add them to.
     * @param  {object} messages Strings in the form of
     */
    extendTranslations: function extendTranslations(lang, messages) {
      if (!this.languages[lang]) {
        return;
      }

      var base = this.languages[lang].messages;
      this.languages[lang].messages = utils.extend(true, base, messages);
    },

    /**
     * Shortcut function to get 'first' calendar
     * @private
     * @param {string} locale The locale to use
     * @param {string} lang The translations of the calendar items
     * @param {string} name the name of the calendar (fx: "gregorian", "islamic-umalqura")
     * @returns {object} containing calendar data.
     */
    calendar: function calendar(locale, lang, name) {
      var calendars = [];

      if (this.currentLocale.data.calendars && !locale) {
        calendars = this.currentLocale.data.calendars;
      }

      if (lang && lang.length > 2) {
        lang = lang.substr(0, 2);
      }

      if (locale && this.cultures[locale]) {
        calendars = this.cultures[locale].calendars;
      }

      if (name && calendars) {
        for (var i = 0; i < calendars.length; i++) {
          var cal = calendars[i];

          if (cal.name === name) {
            return cal;
          }
        }
      }

      if (!calendars[0]) {
        // Defaults to en-US
        return {
          dateFormat: {
            separator: '/',
            timeSeparator: ':',
            short: 'M/d/yyyy',
            medium: 'MMM d, yyyy',
            long: 'MMMM d, yyyy',
            full: 'EEEE, MMMM d, y',
            month: 'MMMM d',
            year: 'MMMM yyyy',
            timestamp: 'h:mm:ss a',
            datetime: 'M/d/yyyy h:mm a'
          },
          timeFormat: 'HH:mm:ss',
          dayPeriods: ['AM', 'PM']
        };
      }

      var calendar = utils.extend(true, {}, calendars[0]);

      if (lang && locale.substr(0, 2) !== lang) {
        var defaultLocale = this.defaultLocales.filter(function (a) {
          return a.lang === lang;
        });

        if (defaultLocale[0]) {
          var culture = this.cultures[defaultLocale[0].default];
          calendar.days = culture.calendars[0].days;
          calendar.months = culture.calendars[0].months;
          calendar.dayPeriods = culture.calendars[0].dayPeriods;
        }
      }

      return calendar;
    },

    /**
     * Shortcut function to get numbers
     * @private
     * @returns {object} containing information for formatting numbers
     */
    numbers: function numbers() {
      return this.currentLocale.data.numbers ? this.currentLocale.data.numbers : {
        percentSign: '%',
        percentFormat: '### %',
        minusSign: '-',
        decimal: '.',
        group: ','
      };
    },

    /**
     * Padd a number to the given width and decimals
     * @private
     * @param {string} n the number
     * @param {number} width the decimal with
     * @param {string} z the padding character
     * @returns {string} the padded string
     */
    pad: function pad(n, width, z) {
      z = z || '0';
      n += '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    },

    /**
     * Describes whether or not this locale is one that is read in "right-to-left" fashion.
     * @returns {boolean} whether or not this locale is "right-to-left".
     */
    isRTL: function isRTL() {
      return !this.currentLanguage ? false : this.currentLanguage.direction === 'right-to-left';
    },

    /**
     * Describes whether or not the default calendar is islamic.
     * @param {string} locale The locale to check if not the current.
     * @returns {boolean} whether or not this locale is "right-to-left".
     */
    isIslamic: function isIslamic(locale) {
      var _this$calendar;

      return ((_this$calendar = this.calendar(locale)) === null || _this$calendar === void 0 ? void 0 : _this$calendar == null ? void 0 : _this$calendar.name) === 'islamic-umalqura';
    },

    /**
     * Takes a string and converts its contents to upper case, taking into account
     * Locale-specific character conversions.  In most cases this method will simply
     * pipe the string to `String.prototype.toUpperCase()`.
     * @private
     * @param {string} str the incoming string
     * @returns {string} modified string
     */
    toUpperCase: function toUpperCase(str) {
      if (typeof this.currentLocale.data.toUpperCase === 'function') {
        return this.currentLocale.data.toUpperCase(str);
      }

      return str.toLocaleUpperCase();
    },

    /**
     * Takes a string and converts its contents to lower case, taking into account
     * Locale-specific character conversions. In most cases this method will simply
     * pipe the string to `String.prototype.toLowerCase()`
     * @private
     * @param {string} str - the incoming string
     * @returns {string} The localized string
     */
    toLowerCase: function toLowerCase(str) {
      if (typeof this.currentLocale.data.toLowerCase === 'function') {
        return this.currentLocale.data.toLowerCase(str);
      }

      return str.toString().toLocaleLowerCase();
    },

    /**
     * Takes a string and capitalizes the first letter, taking into account Locale-specific
     * character conversions. In most cases this method will simply use a simple algorithm
     * for captializing the first letter of the string.
     * @private
     * @param {string} str the incoming string
     * @returns {string} the modified string
     */
    capitalize: function capitalize(str) {
      return this.toUpperCase(str.charAt(0)) + str.slice(1);
    },

    /**
     * Takes a string and capitalizes the first letter of each word in a string, taking
     * into account Locale-specific character conversions. In most cases this method
     * will simply use a simple algorithm for captializing the first letter of the string.
     * @private
     * @param {string} str the incoming string
     * @returns {string} the modified string
     */
    capitalizeWords: function capitalizeWords(str) {
      var words = str.split(' ');

      for (var i = 0; i < words.length; i++) {
        words[i] = this.capitalize(words[i]);
      }

      return words.join(' ');
    },

    /**
     * Convert gregorian to umalqura date.
     * @param {object} date the date
     * @returns {array} year, month, day, hours, minutes, seconds, milliseconds
     */
    gregorianToUmalqura: function gregorianToUmalqura(date) {
      // fromGregorian
      // Modified version of Amro Osama's code. From at https://github.com/kbwood/calendars/blob/master/src/js/jquery.calendars.ummalqura.js
      if (typeof date.getMonth !== 'function') {
        return null;
      }

      var getJd = function getJd(year, month, day) {
        if (year < 0) {
          year++;
        }

        if (month < 3) {
          month += 12;
          year--;
        }

        var a = Math.floor(year / 100);
        var b = 2 - a + Math.floor(a / 4);
        return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
      };

      var jd = getJd(date.getFullYear(), date.getMonth() + 1, date.getDate());

      var julianToUmalqura = function julianToUmalqura(julianDate) {
        var mcjdn = julianDate - 2400000 + 0.5;
        var index = 0;

        for (var i = 0; i < ummalquraData.length; i++) {
          if (ummalquraData[i] > mcjdn) {
            break;
          }

          index++;
        }

        var lunation = index + 15292;
        var ii = Math.floor((lunation - 1) / 12);
        var year = ii + 1;
        var month = lunation - 12 * ii;
        var day = mcjdn - ummalquraData[index - 1] + 1;
        return {
          year: year,
          month: month - 1,
          day: day
        };
      };

      var umalquraDate = julianToUmalqura(jd);
      return [umalquraDate.year, umalquraDate.month, umalquraDate.day, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
    },

    /**
     * Convert umalqura to gregorian date.
     * @param {number|array} year the year
     * @param {number} month the month
     * @param {number} day the day
     * @param {number} hours the day
     * @param {number} mins the day
     * @param {number} secs the day
     * @param {number} mills the day
     * @returns {object} the date
     */
    umalquraToGregorian: function umalquraToGregorian(year, month, day) {
      var hours = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var mins = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var secs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var mills = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

      // Modified version of Amro Osama's code. From at https://github.com/kbwood/calendars/blob/master/src/js/jquery.calendars.ummalqura.js
      // Handle if an array is passed
      if (Array.isArray(year)) {
        month = year[1];
        day = year[2] || 0;
        hours = year[3] || 0;
        mins = year[4] || 0;
        secs = year[5] || 0;
        mills = year[6] || 0;
        year = year[0];
      }

      var isNumber = function isNumber(n) {
        return typeof n === 'number' && !isNaN(n);
      };

      if (!isNumber(year) || !isNumber(month) || !isNumber(day)) {
        return null;
      }

      var getJd = function getJd(y, m, d) {
        var index = 12 * (y - 1) + m - 15292;
        var mcjdn = d + ummalquraData[index - 1] - 1;
        return mcjdn + 2400000 - 0.5;
      };

      var jd = getJd(year, month + 1, day);

      var julianToGregorian = function julianToGregorian(julianDate) {
        var z = Math.floor(julianDate + 0.5);
        var a = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + a - Math.floor(a / 4);
        var b = a + 1524;
        var c = Math.floor((b - 122.1) / 365.25);
        var d = Math.floor(365.25 * c);
        var e = Math.floor((b - d) / 30.6001);
        var gday = b - d - Math.floor(e * 30.6001);
        var gmonth = e - (e > 13.5 ? 13 : 1);
        var gyear = c - (gmonth > 2.5 ? 4716 : 4715); // No zero year

        if (gyear <= 0) {
          gyear--;
        }

        return {
          year: gyear,
          month: gmonth - 1,
          day: gday
        };
      };

      var gregorianDateObj = julianToGregorian(jd);
      var gregorianDate = new Date(gregorianDateObj.year, gregorianDateObj.month, gregorianDateObj.day, hours, mins, secs, mills);
      return gregorianDate;
    },

    /**
     * Modifies a specified list of icons by flipping them horizontally to make them
     * compatible for RTL-based locales.
     * @private
     * @returns {void}
     */
    flipIconsHorizontally: function flipIconsHorizontally() {
      var icons = ['attach', 'bottom-aligned', 'bullet-list', 'cancel', 'cart', 'collapse-app-tray', 'cut', 'document', 'drilldown', 'duplicate', 'expand-app-tray', 'export', 'first-page', 'folder', 'import', 'last-page', 'launch', 'left-align', 'left-text-align', 'left-arrow', 'new-document', 'next-page', 'number-list', 'paste', 'previous-page', 'quote', 'redo', 'refresh', 'right-align', 'right-arrow', 'right-text-align', 'save', 'search-folder', 'search-list', 'search', 'send', 'tack', 'tree-collapse', 'tree-expand', 'undo', 'unlocked', 'add-grid-record', 'add-grid-row', 'additional-help', 'bubble', 'bullet-steps', 'cascade', 'change-font', 'clear-screen', 'script', 'clockwise-90', 'close-cancel', 'close-save', 'contacts', 'copy-from', 'copy-mail', 'copy-url', 'counter-clockwise-90', 'create-report', 'delete-grid-record', 'delete-grid-row', 'display', 'employee-directory', 'export-2', 'export-to-pdf', 'generate-key', 'get-more-rows', 'group-selection', 'headphones', 'help', 'helper-list-select', 'history', 'invoice-released', 'language', 'logout', 'key', 'lasso', 'line-bar-chart', 'line-chart', 'new-expense-report', 'new-payment-request', 'new-time-sheet', 'new-travel-plan', 'no-attachment', 'no-comment', 'no-filter', 'overlay-line', 'pdf-file', 'phone', 'payment-request', 'pie-chart', 'queries', 'quick-access', 'refresh-current', 'restore-user', 'run-quick-access', 'save-close', 'save-new', 'search-results-history', 'select', 'send-submit', 'show-last-x-days', 'special-item', 'stacked', 'timesheet', 'unsubscribe', 'update-preview', 'zoom-100', 'zoom-in', 'zoom-out', 'caret-left', 'caret-right'];
      $('svg').each(function () {
        var iconName = $(this).getIconName();

        if (iconName && $.inArray(iconName, icons) !== -1 && $(this).closest('.monthview').length === 0) {
          $(this).addClass('icon-rtl-rotate');
        }
      });
    }
  };

  /**
   * Safely gets the name of a method
   * @param {function|string} method the method to be checked (or method name to be reported)
   * @returns {string} the name of the method
   */
  function methodName(method) {
    if (typeof method !== 'function') {
      if (typeof method === 'string') {
        return method;
      }

      throw new Error("".concat(_typeof(method), " was provided where a function was expected."));
    } // ES6-friendly


    if (typeof method.name === 'string') {
      return "".concat(method.name, "()");
    } // Regex for ES5 (IE11)
    // See https://stackoverflow.com/a/17923727/4024149


    var result = /^function\s+([\w$]+)\s*\(/.exec(method.toString());
    return result ? "".concat(result[1], "()") : '(anonymous function)';
  }
  /**
   * Warns about a deprecated property/method via a console warning
   * @param {function|string} newMethod the new method to call
   * @param {function|string} oldMethod the name of the old method
   * @param {string} [context=''] optional additional context
   * @returns {void}
   */


  function warnAboutDeprecation(newMethod, oldMethod) {
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    if ((typeof console === "undefined" ? "undefined" : _typeof(console)) !== 'object') {
      return;
    }

    var newMethodName = methodName(newMethod);
    var oldMethodName = methodName(oldMethod);

    if (context.length) {
      context = " (".concat(context, ")");
    } // eslint-disable-next-line no-console


    console.warn("IDS Enterprise".concat(context, ": \"").concat(oldMethodName, "\" is deprecated. Please use \"").concat(newMethodName, "\" instead."));
  }
  /**
   * Warns about an upcoming removal of a piece of code with no replacement.
   * @param {function|string} removedName the name of the removed code
   * @returns {void}
   */


  function warnAboutRemoval(removedName) {
    if ((typeof console === "undefined" ? "undefined" : _typeof(console)) !== 'object') {
      return;
    } // eslint-disable-next-line no-console


    console.warn("IDS Enterprise: \"".concat(removedName, "\" is deprecated and will be later removed. Please adjust your code accordingly."));
  }
  /**
   * Deprecates a method in the codebase
   * @param {function} newMethod the new method to call
   * @param {function} oldMethod the name of the old method
   * @param {...object} [args] arguments that will be passed to the new function
   * @returns {function} wrapper method
   */


  function deprecateMethod(newMethod, oldMethod) {
    var wrapper = function deprecatedMethodWrapper() {
      warnAboutDeprecation(newMethod, oldMethod);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      newMethod.apply(this, args);
    };

    wrapper.prototype = newMethod.prototype;
    return wrapper;
  }

  /**
   * Provides a global object that detects the existence of a Base Tag,
   * and provides some methods that can be used to get an accurate relative
   * URL using the base tag.
   * @class Base
   * @constructor
   * @param {HTMLElement} element the Base Tag Element
   * @returns {Base} component instance
   */

  function Base(element) {
    this.element = $(element);
    return this;
  }

  Base.prototype = {
    /**
     * @private
     * @returns {string} current page URL
     */
    get url() {
      return window.location.href.replace(window.location.hash, '');
    },

    /**
     * @private
     * @returns {string} the base tag's `href` attribute
     */
    get href() {
      return this.element[0].getAttribute('href');
    },

    /**
     * This method is slated to be removed in a future v4.18.0 or v5.0.0.
     * @deprecated as of v4.12.0. Please use the `url` property instead.
     * @returns {string} current page URL
     */
    getCurrentURL: function getCurrentURL() {
      warnAboutDeprecation('url', 'getCurrentURL');
      return this.url;
    },

    /**
     * Gets a copy of a URL prepended with the contents of the Base Tag's hash.
     * If there's no base tag present, this simply returns the hash provided.
     * @param {string} hash the URL to be checked.
     * @returns {string} the current URL prepended with the Base Tag's ref, if necessary
     */
    getBaseURL: function getBaseURL(hash) {
      // If no valid base tag exists, just return the hash provided.
      if (!this.element.length || !this.href || this.href === '/') {
        if (!hash) {
          return '';
        }

        return hash;
      }

      if (hash) {
        if (hash.indexOf('/') === 0) {
          return hash;
        }

        hash = (hash.indexOf('#') === -1 ? '#' : '') + hash;
        return this.url + hash;
      }

      return this.url;
    }
  }; // Setup a Base Tag Component instance

  var base = new Base($('base[href]'));
  /**
   * Setup a default function that just returns the contents of the hash,
   * if no base tag is present.
   * @param {string} hash the URL to be checked.
   * @returns {string} the current URL prepended with the Base Tag's ref, if necessary
   */

  $.getBaseURL = function (hash) {
    return base.getBaseURL(hash);
  };

  var RENDERLOOP_DEFAULTS = {
    noAutoStart: false
  }; // Only start the renderloop if it's not disabled by a Global config setting.

  var instanceSettings = {};

  if (_typeof(window.SohoConfig) === 'object' && _typeof(window.SohoConfig.renderLoop) === 'object') {
    instanceSettings = utils.extend({}, RENDERLOOP_DEFAULTS, window.SohoConfig.renderLoop);
  }
  /**
   * Gets an accurate timestamp from
   * @private
   * @returns {number} a current timestamp
   */


  function timestamp() {
    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
  }
  /**
   * RenderLoop Queue items
   * @param {object} opts options
   * @returns {this} RenderLoopItem
   */


  function RenderLoopItem(opts) {
    // Either ID or a duration is required
    this.id = opts.id;
    this.duration = opts.duration || -1;

    if (this.duration < 1 && (typeof this.id !== 'string' || !this.id.length)) {
      throw new Error('cannot build a RenderLoopItem with no duration and no namespace');
    }

    this.updateDuration = opts.updateDuration || 1; // functions

    this.setFuncs(opts); // internal state

    this.paused = false;
    this.elapsedTime = 0;
    this.startTime = timestamp();
    return this;
  }

  RenderLoopItem.prototype = {
    /**
     * @private
     * @param {object} opts incoming settings
     */
    setFuncs: function setFuncs(opts) {
      if (typeof opts.updateCallback !== 'function' && typeof opts.timeoutCallback !== 'function') {
        throw new Error('cannot register callback to RenderLoop because callback is not a function');
      }

      if (typeof opts.updateCallback === 'function') {
        this.updateCallback = opts.updateCallback;
      }

      if (typeof opts.timeoutCallback === 'function') {
        this.timeoutCallback = opts.timeoutCallback;
      }
    },
    pause: function pause() {
      this.paused = true;
    },
    resume: function resume() {
      this.paused = false;
    },

    /**
     * @param {boolean} noTimeout causes the item to be destroyed without triggering the `timeoutCallback` function
     */
    destroy: function destroy(noTimeout) {
      if (noTimeout) {
        this.noTimeout = true;
      }

      this.doRemoveOnNextTick = true;
    }
  };
  /**
   * Sets up a timed rendering loop that can be used for controlling animations
   * globally in an application that implements Soho.
   * @constructor
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.noAutoStart] if true, will not auto-start the renderLoop
   */

  function RenderLoop(settings) {
    this.items = [];
    this.element = $('body');
    this.settings = utils.mergeSettings(null, settings, RENDERLOOP_DEFAULTS);

    if (this.settings.noAutoStart !== true) {
      this.start();
    }

    return this;
  }

  RenderLoop.prototype = {
    /**
     * Start the entire render loop
     * @returns {void}
     */
    start: function start() {
      this.doLoop = true;
      this.startTime = timestamp();
      var self = this;
      var last = timestamp();
      var now;
      var deltaTime;

      function tick() {
        // Don't continue if the loop is stopped externally
        if (!self.doLoop) {
          return;
        }

        now = timestamp();
        deltaTime = (now - last) / 1000; // Iterate through each item stored in the queue and "update" each one.
        // In some cases, items will be removed from the queue automatically.
        // In some cases, `update` events will be triggered on loop items, if they are
        // ready to be externally updated.

        self.items.forEach(function (loopItem) {
          // Remove if we've set the `doRemoveOnNextTick` flag.
          if (loopItem.doRemoveOnNextTick) {
            self.remove(loopItem);
            return;
          } // Add to elapsedTime


          if (!loopItem.paused) {
            loopItem.elapsedTime++;
          } // Check duration


          if (typeof loopItem.duration === 'number' && loopItem.duration > -1) {
            if (!loopItem.startTime) {
              loopItem.startTime = now;
            }

            if (loopItem.elapsedTime >= loopItem.duration) {
              loopItem.destroy();
              return;
            }
          } // Call the updateCallback, if applicable.


          var modifiedArgs;

          if (typeof loopItem.updateCallback === 'function') {
            // If this item doesn't update on each tick, simply count down.
            // Otherwise, call the update function
            if (loopItem.updateDuration && loopItem.updateDuration > 1) {
              if (isNaN(loopItem.timeUntilNextUpdate)) {
                loopItem.timeUntilNextUpdate = loopItem.updateDuration;
              }

              if (loopItem.timeUntilNextUpdate > 0) {
                --loopItem.timeUntilNextUpdate;
                return;
              }
            } // Arguments produced for the updateCallback contain:
            // [0] the current RenderLoopItem
            // [1] overall timing values for the RenderLoop


            modifiedArgs = [loopItem, {
              last: last,
              delta: deltaTime,
              now: now
            }];
            loopItem.updateCallback.apply(null, modifiedArgs);
          }
        }); // Continue the loop

        last = now;
        requestAnimationFrame(tick);
      }

      tick();
    },

    /**
     * Stops the entire render loop
     * @returns {void}
     */
    stop: function stop() {
      this.doLoop = false;
    },

    /**
     * @returns {number} amount of time that has passed since the RenderLoop was started.
     */
    totalDuration: function totalDuration() {
      return timestamp() - this.startTime;
    },

    /**
     * External method for getting the callback queue contents
     * @returns {array} list of internal RenderLoopItems
     */
    queue: function queue() {
      return this.items;
    },

    /**
     * @private
     * @param {function} updateCallback - (can also be the "updateCallback" function)
     * @param {function} [timeoutCallback] callback function that gets fired at
     *  the end of this item's lifecycle
     * @param {number} [duration] the amount of time in frames that this item should exist
     * @param {string} [namespace] the namespace for this item
     * @returns {RenderLoopItem} the item that was registered
     */
    buildRenderLoopItem: function buildRenderLoopItem(updateCallback, timeoutCallback, duration, namespace) {
      var noNamespace = typeof namespace !== 'string' || !namespace.length; // valid for a callback not to have a duration, as long as it's
      // namespaced for future manual removal

      if (typeof duration === 'string') {
        if (noNamespace) {
          namespace = duration;
          duration = -1;
          noNamespace = false;
        } else {
          var numberDuration = Number(duration);

          if (!isNaN(numberDuration)) {
            duration = numberDuration;
          }
        }
      } else if (typeof duration !== 'number') {
        duration = -1;
      }

      if (typeof namespace !== 'string' || !namespace.length) {
        namespace = ''; // TODO: make unique
      }

      var loopItem = new RenderLoopItem({
        id: namespace,
        updateCallback: updateCallback,
        timeoutCallback: timeoutCallback,
        duration: duration
      });
      return loopItem;
    },

    /**
     * @param {RenderLoopItem|function} loopItem - (can also be the "updateCallback" function)
     * @param {function} [timeoutCallback] callback function that gets fired at
     *  the end of this item's lifecycle
     * @param {number} [duration] the amount of time in frames that this item should exist
     * @param {string} [namespace] the namespace for this item
     * @returns {RenderLoopItem} the item that was registered
     */
    register: function register(loopItem, timeoutCallback, duration, namespace) {
      // If we're not working with a RenderLoopItem off the bat, take arguments
      // and convert to a RenderLoopItem.  Consider the first argument
      // to be the "updateCallback" function
      if (!(loopItem instanceof RenderLoopItem)) {
        loopItem = this.buildRenderLoopItem(loopItem, timeoutCallback, duration, namespace);
      }

      this.items.push(loopItem);
      return loopItem;
    },

    /**
     * @param {function} callback callback function to be unregistered
     * @param {string} [namespace] namespace to be unregistered
     * @returns {RenderLoopItem} the item that was unregistered
     */
    unregister: function unregister(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to remove an entry from the RenderLoop queue.');
      } // If callback is defined as a string, simply swap it for the namespace.


      if (typeof callback === 'string') {
        namespace = callback;
        callback = undefined;
      }

      return this.remove({
        cb: callback,
        id: namespace
      });
    },

    /**
     * @private
     * Uses a callback function, or a defined namespace, to grab a RenderLoop item from the queue.
     * @param {function} updateCallback callback function to be retrieved
     * @param {string} [namespace] namespace to be retrieved
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was paused.
     */
    getFromQueue: function getFromQueue(updateCallback, namespace) {
      // If callback is defined as a string, simply swap it for the namespace.
      if (typeof callback === 'string') {
        namespace = updateCallback;
        updateCallback = undefined;
      }

      var retreivedItem;

      if (typeof callback === 'function') {
        // Remove by callback method
        this.items.forEach(function (item) {
          if ("".concat(item.updateCallback) !== "".concat(updateCallback)) {
            return true;
          }

          retreivedItem = item;
          return false;
        });
      } else if (typeof namespace === 'string') {
        // Remove by namespace
        this.items.forEach(function (item) {
          if (item.id !== namespace) {
            return true;
          }

          retreivedItem = item;
          return false;
        });
      }

      return retreivedItem;
    },

    /**
     * @private
     * Actually does the removal of a registered callback from the queue
     * Pulled out into its own function because it can be automatically called by
     * the tick, or manually triggered from an external API call.
     * @param {renderLoopItem|Object} obj the renderLoopItem
     * @returns {RenderLoopItem} reference to the removed renderLoopItem
     */
    remove: function remove(obj) {
      var removedItem;

      if (obj instanceof RenderLoopItem) {
        removedItem = obj;
        this.items = this.items.filter(function (item) {
          return item !== obj;
        });
      } else if (typeof obj.updateCallback === 'function') {
        // Remove by callback method
        this.items = this.items.filter(function (item) {
          if ("".concat(item.updateCallback) !== "".concat(obj.updateCallback)) {
            return true;
          }

          removedItem = item;
          return false;
        });
      } else if (typeof obj.id === 'string') {
        // Remove by namespace
        this.items = this.items.filter(function (item) {
          if (item.id !== obj.id) {
            return true;
          }

          removedItem = item;
          return false;
        });
      }

      if (typeof removedItem.timeoutCallback === 'function' && !removedItem.noTimeout) {
        removedItem.timeoutCallback.apply(null, removedItem);
      }

      this.element.triggerHandler('remove.renderLoop', [removedItem]); // If this is undefined, an item was NOT removed from the queue successfully.

      return removedItem;
    },

    /**
     * @param {function} callback callback function to be paused
     * @param {string} [namespace] namespace to be paused
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was paused.
     */
    pause: function pause(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to pause an entry in the RenderLoop queue.');
      }

      var pausedItem = this.getFromQueue(callback, namespace);
      pausedItem.pause();
      return pausedItem;
    },

    /**
     * @param {function} callback callback function to be resumed
     * @param {string} [namespace] namespace to be resumed
     * @returns {RenderLoopItem} the RenderLoopItem that represents the item that was resumed.
     */
    resume: function resume(callback, namespace) {
      if (typeof callback !== 'function' && typeof callback !== 'string' && typeof namespace !== 'string') {
        throw new Error('must provide either a callback function or a namespace string to pause an entry in the RenderLoop queue.');
      }

      var resumableItem = this.getFromQueue(callback, namespace);
      resumableItem.resume();
      return resumableItem;
    }
  }; // Setup a single instance of RenderLoop for export.

  var renderLoop = new RenderLoop(instanceSettings);

  var UTIL_NAME$1 = 'keyboard';

  function Keyboard() {
    this.pressedKeys = new Map();
    this.init();
  }

  Keyboard.prototype = {
    /**
     * Initializes the keyboard management system
     * @private
     */
    init: function init() {
      var _this = this;

      $(document).on("keydown.".concat(UTIL_NAME$1), function (e) {
        _this.press(e.key);

        _this.announceKeys();
      }).on("keyup.".concat(UTIL_NAME$1), function (e) {
        _this.unpress(e.key);

        _this.announceKeys();
      });
    },

    /**
     * Triggers a 'keys' event on the body tag that passes the current list of keys pressed.
     * @private
     */
    announceKeys: function announceKeys() {
      var keys = [];
      this.pressedKeys.forEach(function (val, key) {
        keys.push(key);
      });
      $('body').triggerHandler('keys', [keys]);
    },

    /**
     * Add a key to the pressedKeys Map.
     * @private
     * @param {string} key a string representing a {KeyboardEvent.key} that was pressed.
     * @returns {Map} the current set of pressed keys
     */
    press: function press(key) {
      return this.pressedKeys.set("".concat(key), true);
    },

    /**
     * Remove a key from the pressedKeys map.
     * @private
     * @param {string} key a string representing a {KeyboardEvent.key} that is no longer being pressed.
     * @returns {boolean} whether or not the key had been previously logged as "pressed".
     */
    unpress: function unpress(key) {
      return this.pressedKeys.delete("".concat(key));
    },

    /**
     * Describes whether or not a key is currently being pressed.
     * @param {string} key a string representing the {KeyboardEvent.key} that needs to be checked.
     * @returns {boolean} whether or not the key is currently logged as "pressed".
     */
    isPressed: function isPressed(key) {
      return this.pressedKeys.has("".concat(key));
    }
  };
  var keyboard = new Keyboard();

  var EVENT_NAMESPACE = 'modalmanager'; // Used for z-index tracking

  var zCounter = 1020; // Checks to see if an object can be identified as a Modal instance.
  // NOTE: This is not 100% accurate, we should find a better way to do this.
  // Pulling in an import of the Modal prototype causes circular dependencies.

  function isModalAPI(obj) {
    return obj !== undefined && obj.element instanceof $ && typeof obj.destroy === 'function';
  }
  /**
   * Top-level component that manages all modal instances. This component is responsible for handling global
   * events that apply to all modals, as well as for retaining a proper stacking order for nested modals.
   * @class ModalManager
   * @returns {ModalManager} component instance
   */


  function ModalManager() {
    this.modals = [];
    this.handleEvents();
    return this;
  }

  ModalManager.prototype = {
    /**
     * @returns {number} representing the Fade in/out duration of the Modal Overlay,
     * measured in IDS RenderLoop ticks.
     */
    get modalFadeDuration() {
      return 10;
    },

    /**
     * @returns {array} containing references to all currently visible (not necessarily "displayed") modals.
     */
    get currentlyOpen() {
      return this.modals.filter(function (api) {
        return api.visible;
      });
    },

    /**
     * @returns {Modal} api containing a reference to the current modal window that is displayed.
     */
    get currentlyActive() {
      var active;
      this.modals.forEach(function (api) {
        if (api.active) {
          active = api;
        }
      });
      return active;
    },

    /**
     * @param {Modal} api the incoming Modal API to set as displayed
     */
    set currentlyActive(api) {
      if (!isModalAPI(api)) {
        throw new Error('Cannot set the provided Modal API to currently displayed.');
      }

      this.modals.forEach(function (thisAPI, i) {
        // Set Active
        thisAPI.active = $(thisAPI.element).is(api.element);

        if (thisAPI.active) {
          // Active Modal sits at the top
          thisAPI.element[0].style.zIndex = "".concat(zCounter + i);
        } else if (thisAPI.visible) {
          // Inactive Modals are open, but sit behind the overlay
          thisAPI.element[0].style.zIndex = "".concat(zCounter - 100 + i);
        } else {
          // All others disappear
          thisAPI.element[0].style.zIndex = '';
        }
      });
      this.refresh();
    },

    /**
     * @returns {Modal} api representing the furthest-down Modal on the stack.
     */
    get last() {
      var api;
      var currentlyOpen = this.currentlyOpen;
      var size = currentlyOpen.length;

      if (size) {
        api = currentlyOpen[size - 1];
      }

      return api;
    },

    /**
     * Builds the modal containment structure and overlay elements that are reused between modals.
     * @private
     * @returns {void}
     */
    render: function render() {
      var fragment = document.createDocumentFragment();
      var rootElem = document.createElement('div');
      var overlay = document.createElement('div');
      rootElem.id = 'ids-modal-root';
      rootElem.classList.add('modal-page-container');
      rootElem.setAttribute('aria-hidden', true);
      fragment.appendChild(rootElem);
      overlay.classList.add('overlay');
      overlay.setAttribute('aria-hidden', true);
      rootElem.appendChild(overlay);
      document.body.appendChild(rootElem);
      this.rootElem = rootElem;
      this.overlayElem = overlay;
    },

    /**
     * Updates the visual state of the overlay/root containers
     * @returns {void}
     */
    refresh: function refresh() {
      var active = this.currentlyActive;

      if (!active) {
        active = this.activateLast();
      }

      this.checkOverlayVisibility();

      if (active) {
        this.showContainers(active);
      } else {
        this.hideContainers(active);
      }
    },

    /**
     * Shows the root container and fades in the overlay to the correct opacity.
     * DO NOT CALL THIS DIRECTLY.
     * @private
     */
    showContainers: function showContainers() {
      this.rootElem.removeAttribute('aria-hidden');
      this.overlayElem.removeAttribute('aria-hidden'); // Add the 'modal-engaged' class after all the HTML markup and CSS classes have a
      // chance to be established
      // (Fixes an issue in non-V8 browsers (FF, IE) where animation doesn't work correctly).
      // http://stackoverflow.com/questions/12088819/css-transitions-on-new-elements

      $('body')[0].classList.add('modal-engaged');
    },

    /**
     * Hides the root container and fades out the overlay.
     * DO NOT CALL THIS DIRECTLY.
     * @private
     * @param {Modal} api the active Modal API
     */
    hideContainers: function hideContainers() {
      this.rootElem.setAttribute('aria-hidden', true);
      this.overlayElem.setAttribute('aria-hidden', true);
      $('body')[0].classList.remove('modal-engaged');
    },

    /**
     * @param {Modal} api the modal API to unregister
     * @returns {void}
     */
    register: function register(api) {
      if (!isModalAPI(api)) {
        throw new Error('The provided API is not a Modal API, and cannot be registered.');
      }

      this.checkRootElements();
      var hasInstance = this.modals.filter(function (thisAPI) {
        return $(thisAPI.element).is(api);
      }) > 0;

      if (!hasInstance) {
        this.modals.push(api);
      }
    },

    /**
     * @param {Modal} api the modal API to unregister
     * @returns {void}
     */
    unregister: function unregister(api) {
      if (!isModalAPI(api)) {
        throw new Error('The provided API is not a Modal API, and cannot be unregistered.');
      }

      this.checkRootElements();
      this.modals = this.modals.filter(function (thisAPI) {
        return !$(thisAPI.element).is(api.element);
      });
    },

    /**
     * Adjusts the overlay's visiblity/opacity.  If no modals are present, the overlay "hides".
     * Otherwise, the overlay is adjusted to the currently active Modal's `opacity` setting.
     * @private
     * @returns {void}
     */
    checkOverlayVisibility: function checkOverlayVisibility() {
      var opacity = 0;
      var active = this.currentlyActive;

      if (active) {
        opacity = this.currentlyActive.settings.overlayOpacity;
      }

      this.overlayElem.style.opacity = opacity ? "".concat(opacity) : '';
    },

    /**
     * Checks that the root element and the overlay exist.  In some environments (Angular),
     * the root node may become modified after these elements are drawn, and links may need
     * to be re-established.
     * @private
     * @returns {void}
     */
    checkRootElements: function checkRootElements() {
      var rootElem = document.querySelector('#ids-modal-root');

      if (rootElem instanceof HTMLElement) {
        this.rootElem = rootElem;
        var overlayElem = rootElem.querySelector('.overlay');

        if (overlayElem instanceof HTMLElement) {
          this.overlayElem = overlayElem;
        }

        return;
      }

      if (this.rootElem instanceof HTMLElement) {
        document.body.appendChild(this.rootElem);
      } else {
        this.render();
      }
    },

    /**
     * Closes a Modal on the page globally by its element
     * @param {jQuery|HTMLElement} [elem] the `.modal` element to close. If this is not provided, the last Modal API on the stack is used.
     * @param {boolean} [cancelled=false] passes along a flag that designates this close action as "cancelled" to the Modal API.
     * @returns {void}
     */
    close: function close(elem) {
      var cancelled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var api;

      if (!elem || !(elem instanceof HTMLElement || elem instanceof $ && elem.length)) {
        api = this.last;
      } else {
        api = $(elem).data('modal');
      }

      if (!api) {
        return;
      }

      if (cancelled) {
        api.isCancelled = true;
      }

      api.close();
    },

    /**
     * Closes all registered modals
     * @param {boolean} [cancelled=false] passes along a flag that designates this close action as "cancelled" to the Modal API.
     * @returns {void}
     */
    closeAll: function closeAll() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.modals.forEach(function (api) {
        if (cancelled) {
          api.isCancelled = true;
        }

        api.close(undefined, true);
      });
      this.refresh();
    },

    /**
     * Destroys all registered modals
     * @param {boolean} [capsOnly=true] If true, nly destroy the caps.
     * @returns {void}
     */
    destroyAll: function destroyAll() {
      var capsOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.modals.forEach(function (api) {
        var okToDestroy = !capsOnly || api.capAPI;

        if (okToDestroy) {
          api.close(undefined, true);
          api.destroy();
        }
      });
      this.refresh();
    },

    /**
     * Closes the last open modal in the stack
     * @param {boolean} [cancelled=false] passes along a flag that designates this close action as "cancelled" to the Modal API.
     * @returns {void}
     */
    closeLast: function closeLast() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.close(undefined, cancelled);
    },

    /**
     * Activates the last currently open Modal on the stack.
     * @returns {Modal} representing the API that was activated.
     */
    activateLast: function activateLast() {
      var api = this.last;

      if (api) {
        this.currentlyActive = api;
      }

      return api;
    },

    /**
     * Find a modal instance if the modal has been opened and not destroyed.
     * @param  {string} id The id to look for
     * @returns {Modal|undefined} a matching Modal API instance, if available
     */
    findById: function findById(id) {
      if (!id) {
        return undefined;
      }

      var results = this.modals.filter(function (api) {
        return api.id === id;
      });
      return results[0] || undefined;
    },

    /**
     * Sets up the events
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      if (this.hasEstablishedEvents) {
        this.teardown();
      } // Setup a global keydown event that can handle the closing of modals in the proper order.


      $(document).on("keydown.".concat(EVENT_NAMESPACE), function (e) {
        var modalTargetElem = $(e.target).parents('.modal');
        var keyCode = e.which || e.keyCode;

        switch (keyCode) {
          // Escape Key
          case 27:
            _this.close(modalTargetElem, true);

            break;

          case 9:
            _this.setModalFocus(e.shiftKey ? 'last' : 'first', e);

            break;
        }
      }); // Setup a listener for building out core Modal container markup.
      // If state is being refreshed, simply run the method.

      var self = this;

      if (!this.preRendered) {
        $(document).ready(function () {
          self.checkRootElements();
          self.preRendered = true;
        });
      } else {
        this.checkRootElements();
      }

      this.hasEstablishedEvents = true;
    },

    /**
     * Redirects the page's focus to an element within the currently active Modal.
     * @param {string} place the location to set the Modal's current focus
     * @param {jQuery.Event} e the original jquery event
     * @returns {void}
     */
    setModalFocus: function setModalFocus(place, e) {
      var api = this.currentlyActive;

      if (!api) {
        return;
      } // If focus already exists within the modal, with the exception of certain placements
      // on certain elements, return out and allow change of focus to occur as normal.


      if (api.isFocused) {
        if (!($(api.focusableElems.last).is(document.activeElement) && place === 'first') && !($(api.focusableElems.first).is(document.activeElement) && place === 'last')) {
          return;
        }
      }

      e.preventDefault();
      api.setFocus(place);
    },

    /**
     * @returns {void}
     */
    teardown: function teardown() {
      $(document).off("keydown.".concat(EVENT_NAMESPACE));
      delete this.hasEstablishedEvents;

      if (this.preRendered) {
        this.rootElem.parentNode.remove(this.rootElem);
        delete this.overlayElem;
        delete this.rootElem;
        delete this.preRendered;
      }
    }
  }; // Export a single instance

  var modalManager = new ModalManager();

  var color = {
  	themeName: "theme-soho",
  	palette: {
  		amber: {
  			"10": {
  				name: "ids-color-palette-amber-10",
  				value: "#fbe9bf"
  			},
  			"20": {
  				name: "ids-color-palette-amber-20",
  				value: "#f8e09c"
  			},
  			"30": {
  				name: "ids-color-palette-amber-30",
  				value: "#f7d475"
  			},
  			"40": {
  				name: "ids-color-palette-amber-40",
  				value: "#f4c951"
  			},
  			"50": {
  				name: "ids-color-palette-amber-50",
  				value: "#f2bc41"
  			},
  			"60": {
  				name: "ids-color-palette-amber-60",
  				value: "#efa836"
  			},
  			"70": {
  				name: "ids-color-palette-amber-70",
  				value: "#ee9a36"
  			},
  			"80": {
  				name: "ids-color-palette-amber-80",
  				value: "#e4882b"
  			},
  			"90": {
  				name: "ids-color-palette-amber-90",
  				value: "#db7726"
  			},
  			"100": {
  				name: "ids-color-palette-amber-100",
  				value: "#d66221"
  			}
  		},
  		amethyst: {
  			"10": {
  				name: "ids-color-palette-amethyst-10",
  				value: "#ede3fc"
  			},
  			"20": {
  				name: "ids-color-palette-amethyst-20",
  				value: "#daccec"
  			},
  			"30": {
  				name: "ids-color-palette-amethyst-30",
  				value: "#c7b4db"
  			},
  			"40": {
  				name: "ids-color-palette-amethyst-40",
  				value: "#b59eca"
  			},
  			"50": {
  				name: "ids-color-palette-amethyst-50",
  				value: "#a38db7"
  			},
  			"60": {
  				name: "ids-color-palette-amethyst-60",
  				value: "#9279a6"
  			},
  			"70": {
  				name: "ids-color-palette-amethyst-70",
  				value: "#806594"
  			},
  			"80": {
  				name: "ids-color-palette-amethyst-80",
  				value: "#6e5282"
  			},
  			"90": {
  				name: "ids-color-palette-amethyst-90",
  				value: "#5d3e70"
  			},
  			"100": {
  				name: "ids-color-palette-amethyst-100",
  				value: "#4b2a5e"
  			}
  		},
  		azure: {
  			"10": {
  				name: "ids-color-palette-azure-10",
  				value: "#c8e9f4"
  			},
  			"20": {
  				name: "ids-color-palette-azure-20",
  				value: "#addbeb"
  			},
  			"30": {
  				name: "ids-color-palette-azure-30",
  				value: "#8dc9e6"
  			},
  			"40": {
  				name: "ids-color-palette-azure-40",
  				value: "#69b5dd"
  			},
  			"50": {
  				name: "ids-color-palette-azure-50",
  				value: "#54a1d3"
  			},
  			"60": {
  				name: "ids-color-palette-azure-60",
  				value: "#368ac0"
  			},
  			"70": {
  				name: "ids-color-palette-azure-70",
  				value: "#2578a9"
  			},
  			"80": {
  				name: "ids-color-palette-azure-80",
  				value: "#1d5f8a"
  			},
  			"90": {
  				name: "ids-color-palette-azure-90",
  				value: "#134d71"
  			},
  			"100": {
  				name: "ids-color-palette-azure-100",
  				value: "#133c59"
  			}
  		},
  		emerald: {
  			"10": {
  				name: "ids-color-palette-emerald-10",
  				value: "#d5f6c0"
  			},
  			"20": {
  				name: "ids-color-palette-emerald-20",
  				value: "#c3e8ac"
  			},
  			"30": {
  				name: "ids-color-palette-emerald-30",
  				value: "#afdc91"
  			},
  			"40": {
  				name: "ids-color-palette-emerald-40",
  				value: "#9cce7c"
  			},
  			"50": {
  				name: "ids-color-palette-emerald-50",
  				value: "#89bf65"
  			},
  			"60": {
  				name: "ids-color-palette-emerald-60",
  				value: "#76b051"
  			},
  			"70": {
  				name: "ids-color-palette-emerald-70",
  				value: "#66a140"
  			},
  			"80": {
  				name: "ids-color-palette-emerald-80",
  				value: "#56932e"
  			},
  			"90": {
  				name: "ids-color-palette-emerald-90",
  				value: "#488421"
  			},
  			"100": {
  				name: "ids-color-palette-emerald-100",
  				value: "#397514"
  			}
  		},
  		graphite: {
  			"10": {
  				name: "ids-color-palette-graphite-10",
  				value: "#f0f0f0"
  			},
  			"20": {
  				name: "ids-color-palette-graphite-20",
  				value: "#d8d8d8"
  			},
  			"30": {
  				name: "ids-color-palette-graphite-30",
  				value: "#bdbdbd"
  			},
  			"40": {
  				name: "ids-color-palette-graphite-40",
  				value: "#999999"
  			},
  			"50": {
  				name: "ids-color-palette-graphite-50",
  				value: "#737373"
  			},
  			"60": {
  				name: "ids-color-palette-graphite-60",
  				value: "#5c5c5c"
  			},
  			"70": {
  				name: "ids-color-palette-graphite-70",
  				value: "#454545"
  			},
  			"80": {
  				name: "ids-color-palette-graphite-80",
  				value: "#383838"
  			},
  			"90": {
  				name: "ids-color-palette-graphite-90",
  				value: "#292929"
  			},
  			"100": {
  				name: "ids-color-palette-graphite-100",
  				value: "#1a1a1a"
  			}
  		},
  		ruby: {
  			"10": {
  				name: "ids-color-palette-ruby-10",
  				value: "#f6caca"
  			},
  			"20": {
  				name: "ids-color-palette-ruby-20",
  				value: "#eb9d9d"
  			},
  			"30": {
  				name: "ids-color-palette-ruby-30",
  				value: "#de8181"
  			},
  			"40": {
  				name: "ids-color-palette-ruby-40",
  				value: "#d26d6d"
  			},
  			"50": {
  				name: "ids-color-palette-ruby-50",
  				value: "#c65f5f"
  			},
  			"60": {
  				name: "ids-color-palette-ruby-60",
  				value: "#b94e4a"
  			},
  			"70": {
  				name: "ids-color-palette-ruby-70",
  				value: "#ad4242"
  			},
  			"80": {
  				name: "ids-color-palette-ruby-80",
  				value: "#a13030"
  			},
  			"90": {
  				name: "ids-color-palette-ruby-90",
  				value: "#941e1e"
  			},
  			"100": {
  				name: "ids-color-palette-ruby-100",
  				value: "#880e0e"
  			}
  		},
  		slate: {
  			"10": {
  				name: "ids-color-palette-slate-10",
  				value: "#dee1e8"
  			},
  			"20": {
  				name: "ids-color-palette-slate-20",
  				value: "#c8cbd4"
  			},
  			"30": {
  				name: "ids-color-palette-slate-30",
  				value: "#abaeb7"
  			},
  			"40": {
  				name: "ids-color-palette-slate-40",
  				value: "#888b94"
  			},
  			"50": {
  				name: "ids-color-palette-slate-50",
  				value: "#656871"
  			},
  			"60": {
  				name: "ids-color-palette-slate-60",
  				value: "#50535a"
  			},
  			"70": {
  				name: "ids-color-palette-slate-70",
  				value: "#414247"
  			},
  			"80": {
  				name: "ids-color-palette-slate-80",
  				value: "#313236"
  			},
  			"90": {
  				name: "ids-color-palette-slate-90",
  				value: "#212224"
  			},
  			"100": {
  				name: "ids-color-palette-slate-100",
  				value: "#1c1819"
  			}
  		},
  		turquoise: {
  			"10": {
  				name: "ids-color-palette-turquoise-10",
  				value: "#c0ede3"
  			},
  			"20": {
  				name: "ids-color-palette-turquoise-20",
  				value: "#a9e1d6"
  			},
  			"30": {
  				name: "ids-color-palette-turquoise-30",
  				value: "#8ed1c6"
  			},
  			"40": {
  				name: "ids-color-palette-turquoise-40",
  				value: "#7cc0b5"
  			},
  			"50": {
  				name: "ids-color-palette-turquoise-50",
  				value: "#69ada3"
  			},
  			"60": {
  				name: "ids-color-palette-turquoise-60",
  				value: "#579e95"
  			},
  			"70": {
  				name: "ids-color-palette-turquoise-70",
  				value: "#448d83"
  			},
  			"80": {
  				name: "ids-color-palette-turquoise-80",
  				value: "#317c73"
  			},
  			"90": {
  				name: "ids-color-palette-turquoise-90",
  				value: "#206b62"
  			},
  			"100": {
  				name: "ids-color-palette-turquoise-100",
  				value: "#0e5b52"
  			}
  		},
  		white: {
  			name: "ids-color-palette-white",
  			value: "#ffffff",
  			paletteName: "#ffffff"
  		},
  		black: {
  			name: "ids-color-palette-black",
  			value: "#000000",
  			paletteName: "#000000"
  		}
  	},
  	status: {
  		base: {
  			name: "ids-color-status-base",
  			value: "#2578a9",
  			paletteName: "{ids.color.brand.primary.alt.value}"
  		},
  		caution: {
  			name: "ids-color-status-caution",
  			value: "#ffd726",
  			paletteName: "#ffd726"
  		},
  		danger: {
  			name: "ids-color-status-danger",
  			value: "#e84f4f",
  			paletteName: "#e84f4f"
  		},
  		success: {
  			name: "ids-color-status-success",
  			value: "#80ce4d",
  			paletteName: "#80ce4d"
  		},
  		warning: {
  			name: "ids-color-status-warning",
  			value: "#ff9426",
  			paletteName: "#ff9426"
  		}
  	},
  	brand: {
  		primary: {
  			lighter: {
  				name: "ids-color-brand-primary-lighter",
  				value: "#69b5dd"
  			},
  			base: {
  				name: "ids-color-brand-primary-base",
  				value: "#368ac0"
  			},
  			alt: {
  				name: "ids-color-brand-primary-alt",
  				value: "#2578a9"
  			},
  			contrast: {
  				name: "ids-color-brand-primary-contrast",
  				value: "#ffffff"
  			}
  		},
  		secondary: {
  			lighter: {
  				name: "ids-color-brand-secondary-lighter",
  				value: "#d8d8d8"
  			},
  			base: {
  				name: "ids-color-brand-secondary-base",
  				value: "#bdbdbd"
  			},
  			alt: {
  				name: "ids-color-brand-secondary-alt",
  				value: "#999999"
  			},
  			contrast: {
  				name: "ids-color-brand-secondary-contrast",
  				value: "#383838"
  			}
  		}
  	},
  	components: {
  		body: {
  			primary: {
  				background: {
  					name: "body-color-primary-background",
  					value: "#f0f0f0"
  				},
  				font: {
  					name: "body-color-primary-font",
  					value: "#1a1a1a"
  				}
  			},
  			secondary: {
  				background: {
  					name: "body-color-secondary-background",
  					value: "#ffffff"
  				}
  			}
  		}
  	}
  };

  var color$1 = {
  	themeName: "theme-soho-dark",
  	palette: {
  		amber: {
  			"10": {
  				name: "ids-color-palette-amber-10",
  				value: "#fbe9bf"
  			},
  			"20": {
  				name: "ids-color-palette-amber-20",
  				value: "#f8e09c"
  			},
  			"30": {
  				name: "ids-color-palette-amber-30",
  				value: "#f7d475"
  			},
  			"40": {
  				name: "ids-color-palette-amber-40",
  				value: "#f4c951"
  			},
  			"50": {
  				name: "ids-color-palette-amber-50",
  				value: "#f2bc41"
  			},
  			"60": {
  				name: "ids-color-palette-amber-60",
  				value: "#efa836"
  			},
  			"70": {
  				name: "ids-color-palette-amber-70",
  				value: "#ee9a36"
  			},
  			"80": {
  				name: "ids-color-palette-amber-80",
  				value: "#e4882b"
  			},
  			"90": {
  				name: "ids-color-palette-amber-90",
  				value: "#db7726"
  			},
  			"100": {
  				name: "ids-color-palette-amber-100",
  				value: "#d66221"
  			}
  		},
  		amethyst: {
  			"10": {
  				name: "ids-color-palette-amethyst-10",
  				value: "#ede3fc"
  			},
  			"20": {
  				name: "ids-color-palette-amethyst-20",
  				value: "#daccec"
  			},
  			"30": {
  				name: "ids-color-palette-amethyst-30",
  				value: "#c7b4db"
  			},
  			"40": {
  				name: "ids-color-palette-amethyst-40",
  				value: "#b59eca"
  			},
  			"50": {
  				name: "ids-color-palette-amethyst-50",
  				value: "#a38db7"
  			},
  			"60": {
  				name: "ids-color-palette-amethyst-60",
  				value: "#9279a6"
  			},
  			"70": {
  				name: "ids-color-palette-amethyst-70",
  				value: "#806594"
  			},
  			"80": {
  				name: "ids-color-palette-amethyst-80",
  				value: "#6e5282"
  			},
  			"90": {
  				name: "ids-color-palette-amethyst-90",
  				value: "#5d3e70"
  			},
  			"100": {
  				name: "ids-color-palette-amethyst-100",
  				value: "#4b2a5e"
  			}
  		},
  		azure: {
  			"10": {
  				name: "ids-color-palette-azure-10",
  				value: "#c8e9f4"
  			},
  			"20": {
  				name: "ids-color-palette-azure-20",
  				value: "#addbeb"
  			},
  			"30": {
  				name: "ids-color-palette-azure-30",
  				value: "#8dc9e6"
  			},
  			"40": {
  				name: "ids-color-palette-azure-40",
  				value: "#69b5dd"
  			},
  			"50": {
  				name: "ids-color-palette-azure-50",
  				value: "#54a1d3"
  			},
  			"60": {
  				name: "ids-color-palette-azure-60",
  				value: "#368ac0"
  			},
  			"70": {
  				name: "ids-color-palette-azure-70",
  				value: "#2578a9"
  			},
  			"80": {
  				name: "ids-color-palette-azure-80",
  				value: "#1d5f8a"
  			},
  			"90": {
  				name: "ids-color-palette-azure-90",
  				value: "#134d71"
  			},
  			"100": {
  				name: "ids-color-palette-azure-100",
  				value: "#133c59"
  			}
  		},
  		emerald: {
  			"10": {
  				name: "ids-color-palette-emerald-10",
  				value: "#d5f6c0"
  			},
  			"20": {
  				name: "ids-color-palette-emerald-20",
  				value: "#c3e8ac"
  			},
  			"30": {
  				name: "ids-color-palette-emerald-30",
  				value: "#afdc91"
  			},
  			"40": {
  				name: "ids-color-palette-emerald-40",
  				value: "#9cce7c"
  			},
  			"50": {
  				name: "ids-color-palette-emerald-50",
  				value: "#89bf65"
  			},
  			"60": {
  				name: "ids-color-palette-emerald-60",
  				value: "#76b051"
  			},
  			"70": {
  				name: "ids-color-palette-emerald-70",
  				value: "#66a140"
  			},
  			"80": {
  				name: "ids-color-palette-emerald-80",
  				value: "#56932e"
  			},
  			"90": {
  				name: "ids-color-palette-emerald-90",
  				value: "#488421"
  			},
  			"100": {
  				name: "ids-color-palette-emerald-100",
  				value: "#397514"
  			}
  		},
  		graphite: {
  			"10": {
  				name: "ids-color-palette-graphite-10",
  				value: "#f0f0f0"
  			},
  			"20": {
  				name: "ids-color-palette-graphite-20",
  				value: "#d8d8d8"
  			},
  			"30": {
  				name: "ids-color-palette-graphite-30",
  				value: "#bdbdbd"
  			},
  			"40": {
  				name: "ids-color-palette-graphite-40",
  				value: "#999999"
  			},
  			"50": {
  				name: "ids-color-palette-graphite-50",
  				value: "#737373"
  			},
  			"60": {
  				name: "ids-color-palette-graphite-60",
  				value: "#5c5c5c"
  			},
  			"70": {
  				name: "ids-color-palette-graphite-70",
  				value: "#454545"
  			},
  			"80": {
  				name: "ids-color-palette-graphite-80",
  				value: "#383838"
  			},
  			"90": {
  				name: "ids-color-palette-graphite-90",
  				value: "#292929"
  			},
  			"100": {
  				name: "ids-color-palette-graphite-100",
  				value: "#1a1a1a"
  			}
  		},
  		ruby: {
  			"10": {
  				name: "ids-color-palette-ruby-10",
  				value: "#f6caca"
  			},
  			"20": {
  				name: "ids-color-palette-ruby-20",
  				value: "#eb9d9d"
  			},
  			"30": {
  				name: "ids-color-palette-ruby-30",
  				value: "#de8181"
  			},
  			"40": {
  				name: "ids-color-palette-ruby-40",
  				value: "#d26d6d"
  			},
  			"50": {
  				name: "ids-color-palette-ruby-50",
  				value: "#c65f5f"
  			},
  			"60": {
  				name: "ids-color-palette-ruby-60",
  				value: "#b94e4a"
  			},
  			"70": {
  				name: "ids-color-palette-ruby-70",
  				value: "#ad4242"
  			},
  			"80": {
  				name: "ids-color-palette-ruby-80",
  				value: "#a13030"
  			},
  			"90": {
  				name: "ids-color-palette-ruby-90",
  				value: "#941e1e"
  			},
  			"100": {
  				name: "ids-color-palette-ruby-100",
  				value: "#880e0e"
  			}
  		},
  		slate: {
  			"10": {
  				name: "ids-color-palette-slate-10",
  				value: "#dee1e8"
  			},
  			"20": {
  				name: "ids-color-palette-slate-20",
  				value: "#c8cbd4"
  			},
  			"30": {
  				name: "ids-color-palette-slate-30",
  				value: "#abaeb7"
  			},
  			"40": {
  				name: "ids-color-palette-slate-40",
  				value: "#888b94"
  			},
  			"50": {
  				name: "ids-color-palette-slate-50",
  				value: "#656871"
  			},
  			"60": {
  				name: "ids-color-palette-slate-60",
  				value: "#50535a"
  			},
  			"70": {
  				name: "ids-color-palette-slate-70",
  				value: "#414247"
  			},
  			"80": {
  				name: "ids-color-palette-slate-80",
  				value: "#313236"
  			},
  			"90": {
  				name: "ids-color-palette-slate-90",
  				value: "#212224"
  			},
  			"100": {
  				name: "ids-color-palette-slate-100",
  				value: "#1c1819"
  			}
  		},
  		turquoise: {
  			"10": {
  				name: "ids-color-palette-turquoise-10",
  				value: "#c0ede3"
  			},
  			"20": {
  				name: "ids-color-palette-turquoise-20",
  				value: "#a9e1d6"
  			},
  			"30": {
  				name: "ids-color-palette-turquoise-30",
  				value: "#8ed1c6"
  			},
  			"40": {
  				name: "ids-color-palette-turquoise-40",
  				value: "#7cc0b5"
  			},
  			"50": {
  				name: "ids-color-palette-turquoise-50",
  				value: "#69ada3"
  			},
  			"60": {
  				name: "ids-color-palette-turquoise-60",
  				value: "#579e95"
  			},
  			"70": {
  				name: "ids-color-palette-turquoise-70",
  				value: "#448d83"
  			},
  			"80": {
  				name: "ids-color-palette-turquoise-80",
  				value: "#317c73"
  			},
  			"90": {
  				name: "ids-color-palette-turquoise-90",
  				value: "#206b62"
  			},
  			"100": {
  				name: "ids-color-palette-turquoise-100",
  				value: "#0e5b52"
  			}
  		},
  		white: {
  			name: "ids-color-palette-white",
  			value: "#ffffff",
  			paletteName: "#ffffff"
  		},
  		black: {
  			name: "ids-color-palette-black",
  			value: "#000000",
  			paletteName: "#000000"
  		}
  	},
  	status: {
  		base: {
  			name: "ids-color-status-base",
  			value: "#2578a9",
  			paletteName: "{ids.color.brand.primary.alt.value}"
  		},
  		caution: {
  			name: "ids-color-status-caution",
  			value: "#ffd726",
  			paletteName: "#ffd726"
  		},
  		danger: {
  			name: "ids-color-status-danger",
  			value: "#e84f4f",
  			paletteName: "#e84f4f"
  		},
  		success: {
  			name: "ids-color-status-success",
  			value: "#80ce4d",
  			paletteName: "#80ce4d"
  		},
  		warning: {
  			name: "ids-color-status-warning",
  			value: "#ff9426",
  			paletteName: "#ff9426"
  		}
  	},
  	brand: {
  		primary: {
  			lighter: {
  				name: "ids-color-brand-primary-lighter",
  				value: "#69b5dd"
  			},
  			base: {
  				name: "ids-color-brand-primary-base",
  				value: "#368ac0"
  			},
  			alt: {
  				name: "ids-color-brand-primary-alt",
  				value: "#2578a9"
  			},
  			contrast: {
  				name: "ids-color-brand-primary-contrast",
  				value: "#ffffff"
  			}
  		},
  		secondary: {
  			lighter: {
  				name: "ids-color-brand-secondary-lighter",
  				value: "#d8d8d8"
  			},
  			base: {
  				name: "ids-color-brand-secondary-base",
  				value: "#bdbdbd"
  			},
  			alt: {
  				name: "ids-color-brand-secondary-alt",
  				value: "#999999"
  			},
  			contrast: {
  				name: "ids-color-brand-secondary-contrast",
  				value: "#383838"
  			}
  		}
  	},
  	components: {
  		body: {
  			primary: {
  				background: {
  					name: "body-color-primary-background",
  					value: "#313236"
  				},
  				font: {
  					name: "body-color-primary-font",
  					value: "#ffffff"
  				}
  			},
  			secondary: {
  				background: {
  					name: "body-color-secondary-background",
  					value: "#414247"
  				}
  			}
  		}
  	}
  };

  var color$2 = {
  	themeName: "theme-soho-contrast",
  	palette: {
  		amber: {
  			"10": {
  				name: "ids-color-palette-amber-10",
  				value: "#fbe9bf"
  			},
  			"20": {
  				name: "ids-color-palette-amber-20",
  				value: "#f8e09c"
  			},
  			"30": {
  				name: "ids-color-palette-amber-30",
  				value: "#f7d475"
  			},
  			"40": {
  				name: "ids-color-palette-amber-40",
  				value: "#f4c951"
  			},
  			"50": {
  				name: "ids-color-palette-amber-50",
  				value: "#f2bc41"
  			},
  			"60": {
  				name: "ids-color-palette-amber-60",
  				value: "#efa836"
  			},
  			"70": {
  				name: "ids-color-palette-amber-70",
  				value: "#ee9a36"
  			},
  			"80": {
  				name: "ids-color-palette-amber-80",
  				value: "#e4882b"
  			},
  			"90": {
  				name: "ids-color-palette-amber-90",
  				value: "#db7726"
  			},
  			"100": {
  				name: "ids-color-palette-amber-100",
  				value: "#d66221"
  			}
  		},
  		amethyst: {
  			"10": {
  				name: "ids-color-palette-amethyst-10",
  				value: "#ede3fc"
  			},
  			"20": {
  				name: "ids-color-palette-amethyst-20",
  				value: "#daccec"
  			},
  			"30": {
  				name: "ids-color-palette-amethyst-30",
  				value: "#c7b4db"
  			},
  			"40": {
  				name: "ids-color-palette-amethyst-40",
  				value: "#b59eca"
  			},
  			"50": {
  				name: "ids-color-palette-amethyst-50",
  				value: "#a38db7"
  			},
  			"60": {
  				name: "ids-color-palette-amethyst-60",
  				value: "#9279a6"
  			},
  			"70": {
  				name: "ids-color-palette-amethyst-70",
  				value: "#806594"
  			},
  			"80": {
  				name: "ids-color-palette-amethyst-80",
  				value: "#6e5282"
  			},
  			"90": {
  				name: "ids-color-palette-amethyst-90",
  				value: "#5d3e70"
  			},
  			"100": {
  				name: "ids-color-palette-amethyst-100",
  				value: "#4b2a5e"
  			}
  		},
  		azure: {
  			"10": {
  				name: "ids-color-palette-azure-10",
  				value: "#c8e9f4"
  			},
  			"20": {
  				name: "ids-color-palette-azure-20",
  				value: "#addbeb"
  			},
  			"30": {
  				name: "ids-color-palette-azure-30",
  				value: "#8dc9e6"
  			},
  			"40": {
  				name: "ids-color-palette-azure-40",
  				value: "#69b5dd"
  			},
  			"50": {
  				name: "ids-color-palette-azure-50",
  				value: "#54a1d3"
  			},
  			"60": {
  				name: "ids-color-palette-azure-60",
  				value: "#368ac0"
  			},
  			"70": {
  				name: "ids-color-palette-azure-70",
  				value: "#2578a9"
  			},
  			"80": {
  				name: "ids-color-palette-azure-80",
  				value: "#1d5f8a"
  			},
  			"90": {
  				name: "ids-color-palette-azure-90",
  				value: "#134d71"
  			},
  			"100": {
  				name: "ids-color-palette-azure-100",
  				value: "#133c59"
  			}
  		},
  		emerald: {
  			"10": {
  				name: "ids-color-palette-emerald-10",
  				value: "#d5f6c0"
  			},
  			"20": {
  				name: "ids-color-palette-emerald-20",
  				value: "#c3e8ac"
  			},
  			"30": {
  				name: "ids-color-palette-emerald-30",
  				value: "#afdc91"
  			},
  			"40": {
  				name: "ids-color-palette-emerald-40",
  				value: "#9cce7c"
  			},
  			"50": {
  				name: "ids-color-palette-emerald-50",
  				value: "#89bf65"
  			},
  			"60": {
  				name: "ids-color-palette-emerald-60",
  				value: "#76b051"
  			},
  			"70": {
  				name: "ids-color-palette-emerald-70",
  				value: "#66a140"
  			},
  			"80": {
  				name: "ids-color-palette-emerald-80",
  				value: "#56932e"
  			},
  			"90": {
  				name: "ids-color-palette-emerald-90",
  				value: "#488421"
  			},
  			"100": {
  				name: "ids-color-palette-emerald-100",
  				value: "#397514"
  			}
  		},
  		graphite: {
  			"10": {
  				name: "ids-color-palette-graphite-10",
  				value: "#f0f0f0"
  			},
  			"20": {
  				name: "ids-color-palette-graphite-20",
  				value: "#d8d8d8"
  			},
  			"30": {
  				name: "ids-color-palette-graphite-30",
  				value: "#bdbdbd"
  			},
  			"40": {
  				name: "ids-color-palette-graphite-40",
  				value: "#999999"
  			},
  			"50": {
  				name: "ids-color-palette-graphite-50",
  				value: "#737373"
  			},
  			"60": {
  				name: "ids-color-palette-graphite-60",
  				value: "#5c5c5c"
  			},
  			"70": {
  				name: "ids-color-palette-graphite-70",
  				value: "#454545"
  			},
  			"80": {
  				name: "ids-color-palette-graphite-80",
  				value: "#383838"
  			},
  			"90": {
  				name: "ids-color-palette-graphite-90",
  				value: "#292929"
  			},
  			"100": {
  				name: "ids-color-palette-graphite-100",
  				value: "#1a1a1a"
  			}
  		},
  		ruby: {
  			"10": {
  				name: "ids-color-palette-ruby-10",
  				value: "#f6caca"
  			},
  			"20": {
  				name: "ids-color-palette-ruby-20",
  				value: "#eb9d9d"
  			},
  			"30": {
  				name: "ids-color-palette-ruby-30",
  				value: "#de8181"
  			},
  			"40": {
  				name: "ids-color-palette-ruby-40",
  				value: "#d26d6d"
  			},
  			"50": {
  				name: "ids-color-palette-ruby-50",
  				value: "#c65f5f"
  			},
  			"60": {
  				name: "ids-color-palette-ruby-60",
  				value: "#b94e4a"
  			},
  			"70": {
  				name: "ids-color-palette-ruby-70",
  				value: "#ad4242"
  			},
  			"80": {
  				name: "ids-color-palette-ruby-80",
  				value: "#a13030"
  			},
  			"90": {
  				name: "ids-color-palette-ruby-90",
  				value: "#941e1e"
  			},
  			"100": {
  				name: "ids-color-palette-ruby-100",
  				value: "#880e0e"
  			}
  		},
  		slate: {
  			"10": {
  				name: "ids-color-palette-slate-10",
  				value: "#dee1e8"
  			},
  			"20": {
  				name: "ids-color-palette-slate-20",
  				value: "#c8cbd4"
  			},
  			"30": {
  				name: "ids-color-palette-slate-30",
  				value: "#abaeb7"
  			},
  			"40": {
  				name: "ids-color-palette-slate-40",
  				value: "#888b94"
  			},
  			"50": {
  				name: "ids-color-palette-slate-50",
  				value: "#656871"
  			},
  			"60": {
  				name: "ids-color-palette-slate-60",
  				value: "#50535a"
  			},
  			"70": {
  				name: "ids-color-palette-slate-70",
  				value: "#414247"
  			},
  			"80": {
  				name: "ids-color-palette-slate-80",
  				value: "#313236"
  			},
  			"90": {
  				name: "ids-color-palette-slate-90",
  				value: "#212224"
  			},
  			"100": {
  				name: "ids-color-palette-slate-100",
  				value: "#1c1819"
  			}
  		},
  		turquoise: {
  			"10": {
  				name: "ids-color-palette-turquoise-10",
  				value: "#c0ede3"
  			},
  			"20": {
  				name: "ids-color-palette-turquoise-20",
  				value: "#a9e1d6"
  			},
  			"30": {
  				name: "ids-color-palette-turquoise-30",
  				value: "#8ed1c6"
  			},
  			"40": {
  				name: "ids-color-palette-turquoise-40",
  				value: "#7cc0b5"
  			},
  			"50": {
  				name: "ids-color-palette-turquoise-50",
  				value: "#69ada3"
  			},
  			"60": {
  				name: "ids-color-palette-turquoise-60",
  				value: "#579e95"
  			},
  			"70": {
  				name: "ids-color-palette-turquoise-70",
  				value: "#448d83"
  			},
  			"80": {
  				name: "ids-color-palette-turquoise-80",
  				value: "#317c73"
  			},
  			"90": {
  				name: "ids-color-palette-turquoise-90",
  				value: "#206b62"
  			},
  			"100": {
  				name: "ids-color-palette-turquoise-100",
  				value: "#0e5b52"
  			}
  		},
  		white: {
  			name: "ids-color-palette-white",
  			value: "#ffffff",
  			paletteName: "#ffffff"
  		},
  		black: {
  			name: "ids-color-palette-black",
  			value: "#000000",
  			paletteName: "#000000"
  		}
  	},
  	status: {
  		base: {
  			name: "ids-color-status-base",
  			value: "#133c59",
  			paletteName: "{ids.color.brand.primary.alt.value}"
  		},
  		caution: {
  			name: "ids-color-status-caution",
  			value: "#ffd726",
  			paletteName: "#ffd726"
  		},
  		danger: {
  			name: "ids-color-status-danger",
  			value: "#e84f4f",
  			paletteName: "#e84f4f"
  		},
  		success: {
  			name: "ids-color-status-success",
  			value: "#80ce4d",
  			paletteName: "#80ce4d"
  		},
  		warning: {
  			name: "ids-color-status-warning",
  			value: "#ff9426",
  			paletteName: "#ff9426"
  		}
  	},
  	brand: {
  		primary: {
  			lighter: {
  				name: "ids-color-brand-primary-lighter",
  				value: "#69b5dd"
  			},
  			base: {
  				name: "ids-color-brand-primary-base",
  				value: "#134d71"
  			},
  			alt: {
  				name: "ids-color-brand-primary-alt",
  				value: "#133c59"
  			},
  			contrast: {
  				name: "ids-color-brand-primary-contrast",
  				value: "#ffffff"
  			}
  		},
  		secondary: {
  			lighter: {
  				name: "ids-color-brand-secondary-lighter",
  				value: "#d8d8d8"
  			},
  			base: {
  				name: "ids-color-brand-secondary-base",
  				value: "#bdbdbd"
  			},
  			alt: {
  				name: "ids-color-brand-secondary-alt",
  				value: "#999999"
  			},
  			contrast: {
  				name: "ids-color-brand-secondary-contrast",
  				value: "#383838"
  			}
  		}
  	},
  	components: {
  		body: {
  			primary: {
  				background: {
  					name: "body-color-primary-background",
  					value: "#d8d8d8"
  				},
  				font: {
  					name: "body-color-primary-font",
  					value: "#000000"
  				}
  			},
  			secondary: {
  				background: {
  					name: "body-color-secondary-background",
  					value: "#d8d8d8"
  				}
  			}
  		}
  	}
  };

  var color$3 = {
  	themeName: "theme-uplift",
  	palette: {
  		amber: {
  			"10": {
  				name: "ids-color-palette-amber-10",
  				value: "#FEF2E5"
  			},
  			"20": {
  				name: "ids-color-palette-amber-20",
  				value: "#FDDFBD"
  			},
  			"30": {
  				name: "ids-color-palette-amber-30",
  				value: "#FCC888"
  			},
  			"40": {
  				name: "ids-color-palette-amber-40",
  				value: "#FBAF50"
  			},
  			"50": {
  				name: "ids-color-palette-amber-50",
  				value: "#FA9601"
  			},
  			"60": {
  				name: "ids-color-palette-amber-60",
  				value: "#F98300"
  			},
  			"70": {
  				name: "ids-color-palette-amber-70",
  				value: "#DF6F00"
  			},
  			"80": {
  				name: "ids-color-palette-amber-80",
  				value: "#CD6200"
  			},
  			"90": {
  				name: "ids-color-palette-amber-90",
  				value: "#BB5500"
  			},
  			"100": {
  				name: "ids-color-palette-amber-100",
  				value: "#A14100"
  			}
  		},
  		amethyst: {
  			"10": {
  				name: "ids-color-palette-amethyst-10",
  				value: "#F1EBFC"
  			},
  			"20": {
  				name: "ids-color-palette-amethyst-20",
  				value: "#DDCBF7"
  			},
  			"30": {
  				name: "ids-color-palette-amethyst-30",
  				value: "#C2A1F1"
  			},
  			"40": {
  				name: "ids-color-palette-amethyst-40",
  				value: "#A876EB"
  			},
  			"50": {
  				name: "ids-color-palette-amethyst-50",
  				value: "#8D4BE5"
  			},
  			"60": {
  				name: "ids-color-palette-amethyst-60",
  				value: "#7928E1"
  			},
  			"70": {
  				name: "ids-color-palette-amethyst-70",
  				value: "#6C23C9"
  			},
  			"80": {
  				name: "ids-color-palette-amethyst-80",
  				value: "#591DA8"
  			},
  			"90": {
  				name: "ids-color-palette-amethyst-90",
  				value: "#4E1A91"
  			},
  			"100": {
  				name: "ids-color-palette-amethyst-100",
  				value: "#3B1470"
  			}
  		},
  		azure: {
  			"10": {
  				name: "ids-color-palette-azure-10",
  				value: "#E6F1FD"
  			},
  			"20": {
  				name: "ids-color-palette-azure-20",
  				value: "#BEDCFA"
  			},
  			"30": {
  				name: "ids-color-palette-azure-30",
  				value: "#8ABFF7"
  			},
  			"40": {
  				name: "ids-color-palette-azure-40",
  				value: "#55A3F3"
  			},
  			"50": {
  				name: "ids-color-palette-azure-50",
  				value: "#1C86EF"
  			},
  			"60": {
  				name: "ids-color-palette-azure-60",
  				value: "#0072ED"
  			},
  			"70": {
  				name: "ids-color-palette-azure-70",
  				value: "#0066D4"
  			},
  			"80": {
  				name: "ids-color-palette-azure-80",
  				value: "#0054B1"
  			},
  			"90": {
  				name: "ids-color-palette-azure-90",
  				value: "#004A99"
  			},
  			"100": {
  				name: "ids-color-palette-azure-100",
  				value: "#003876"
  			}
  		},
  		emerald: {
  			"10": {
  				name: "ids-color-palette-emerald-10",
  				value: "#EBF9F1"
  			},
  			"20": {
  				name: "ids-color-palette-emerald-20",
  				value: "#CBEFDC"
  			},
  			"30": {
  				name: "ids-color-palette-emerald-30",
  				value: "#A1E4BF"
  			},
  			"40": {
  				name: "ids-color-palette-emerald-40",
  				value: "#78D8A3"
  			},
  			"50": {
  				name: "ids-color-palette-emerald-50",
  				value: "#4DCC86"
  			},
  			"60": {
  				name: "ids-color-palette-emerald-60",
  				value: "#2AC371"
  			},
  			"70": {
  				name: "ids-color-palette-emerald-70",
  				value: "#25AF65"
  			},
  			"80": {
  				name: "ids-color-palette-emerald-80",
  				value: "#1F9254"
  			},
  			"90": {
  				name: "ids-color-palette-emerald-90",
  				value: "#1C7F49"
  			},
  			"100": {
  				name: "ids-color-palette-emerald-100",
  				value: "#156138"
  			}
  		},
  		graphite: {
  			"10": {
  				name: "ids-color-palette-graphite-10",
  				value: "#EEEEEE"
  			},
  			"20": {
  				name: "ids-color-palette-graphite-20",
  				value: "#D3D3D3"
  			},
  			"30": {
  				name: "ids-color-palette-graphite-30",
  				value: "#B1B1B1"
  			},
  			"40": {
  				name: "ids-color-palette-graphite-40",
  				value: "#8F8F8F"
  			},
  			"50": {
  				name: "ids-color-palette-graphite-50",
  				value: "#6C6C6C"
  			},
  			"60": {
  				name: "ids-color-palette-graphite-60",
  				value: "#535353"
  			},
  			"70": {
  				name: "ids-color-palette-graphite-70",
  				value: "#4A4A4A"
  			},
  			"80": {
  				name: "ids-color-palette-graphite-80",
  				value: "#3E3E3E"
  			},
  			"90": {
  				name: "ids-color-palette-graphite-90",
  				value: "#363636"
  			},
  			"100": {
  				name: "ids-color-palette-graphite-100",
  				value: "#292929"
  			}
  		},
  		ruby: {
  			"10": {
  				name: "ids-color-palette-ruby-10",
  				value: "#FBE7E8"
  			},
  			"20": {
  				name: "ids-color-palette-ruby-20",
  				value: "#F5C3C4"
  			},
  			"30": {
  				name: "ids-color-palette-ruby-30",
  				value: "#EE9496"
  			},
  			"40": {
  				name: "ids-color-palette-ruby-40",
  				value: "#E66467"
  			},
  			"50": {
  				name: "ids-color-palette-ruby-50",
  				value: "#DF3539"
  			},
  			"60": {
  				name: "ids-color-palette-ruby-60",
  				value: "#DA1217"
  			},
  			"70": {
  				name: "ids-color-palette-ruby-70",
  				value: "#C31014"
  			},
  			"80": {
  				name: "ids-color-palette-ruby-80",
  				value: "#A30D11"
  			},
  			"90": {
  				name: "ids-color-palette-ruby-90",
  				value: "#8D0B0E"
  			},
  			"100": {
  				name: "ids-color-palette-ruby-100",
  				value: "#6C080B"
  			}
  		},
  		slate: {
  			"10": {
  				name: "ids-color-palette-slate-10",
  				value: "#EFEFF0"
  			},
  			"20": {
  				name: "ids-color-palette-slate-20",
  				value: "#D7D7D8"
  			},
  			"30": {
  				name: "ids-color-palette-slate-30",
  				value: "#B7B7BA"
  			},
  			"40": {
  				name: "ids-color-palette-slate-40",
  				value: "#97979B"
  			},
  			"50": {
  				name: "ids-color-palette-slate-50",
  				value: "#77777C"
  			},
  			"60": {
  				name: "ids-color-palette-slate-60",
  				value: "#606066"
  			},
  			"70": {
  				name: "ids-color-palette-slate-70",
  				value: "#56565B"
  			},
  			"80": {
  				name: "ids-color-palette-slate-80",
  				value: "#47474C"
  			},
  			"90": {
  				name: "ids-color-palette-slate-90",
  				value: "#3E3E42"
  			},
  			"100": {
  				name: "ids-color-palette-slate-100",
  				value: "#2F2F32"
  			}
  		},
  		turquoise: {
  			"10": {
  				name: "ids-color-palette-turquoise-10",
  				value: "#ECF8F8"
  			},
  			"20": {
  				name: "ids-color-palette-turquoise-20",
  				value: "#CFEEEE"
  			},
  			"30": {
  				name: "ids-color-palette-turquoise-30",
  				value: "#A8E1E1"
  			},
  			"40": {
  				name: "ids-color-palette-turquoise-40",
  				value: "#82D4D4"
  			},
  			"50": {
  				name: "ids-color-palette-turquoise-50",
  				value: "#5CC6C7"
  			},
  			"60": {
  				name: "ids-color-palette-turquoise-60",
  				value: "#40BDBE"
  			},
  			"70": {
  				name: "ids-color-palette-turquoise-70",
  				value: "#39A9AA"
  			},
  			"80": {
  				name: "ids-color-palette-turquoise-80",
  				value: "#2F8D8E"
  			},
  			"90": {
  				name: "ids-color-palette-turquoise-90",
  				value: "#297B7B"
  			},
  			"100": {
  				name: "ids-color-palette-turquoise-100",
  				value: "#1F5E5E"
  			}
  		},
  		white: {
  			name: "ids-color-palette-white",
  			value: "#ffffff",
  			paletteName: "#ffffff"
  		},
  		black: {
  			name: "ids-color-palette-black",
  			value: "#000000",
  			paletteName: "#000000"
  		}
  	},
  	status: {
  		base: {
  			name: "ids-color-status-base",
  			value: "#0066D4",
  			paletteName: "{ids.color.brand.primary.alt.value}"
  		},
  		caution: {
  			name: "ids-color-status-caution",
  			value: "#FFD726",
  			paletteName: "#FFD726"
  		},
  		danger: {
  			name: "ids-color-status-danger",
  			value: "#DA1217",
  			paletteName: "#DA1217"
  		},
  		success: {
  			name: "ids-color-status-success",
  			value: "#2AC371",
  			paletteName: "#2AC371"
  		},
  		warning: {
  			name: "ids-color-status-warning",
  			value: "#F98300",
  			paletteName: "#F98300"
  		}
  	},
  	brand: {
  		primary: {
  			lighter: {
  				name: "ids-color-brand-primary-lighter",
  				value: "#55A3F3"
  			},
  			base: {
  				name: "ids-color-brand-primary-base",
  				value: "#0072ED"
  			},
  			alt: {
  				name: "ids-color-brand-primary-alt",
  				value: "#0066D4"
  			},
  			contrast: {
  				name: "ids-color-brand-primary-contrast",
  				value: "#ffffff"
  			}
  		},
  		secondary: {
  			lighter: {
  				name: "ids-color-brand-secondary-lighter",
  				value: "#97979B"
  			},
  			base: {
  				name: "ids-color-brand-secondary-base",
  				value: "#606066"
  			},
  			alt: {
  				name: "ids-color-brand-secondary-alt",
  				value: "#56565B"
  			},
  			contrast: {
  				name: "ids-color-brand-secondary-contrast",
  				value: "#3E3E42"
  			}
  		}
  	},
  	components: {
  		body: {
  			primary: {
  				background: {
  					name: "body-color-primary-background",
  					value: "#EFEFF0"
  				},
  				font: {
  					name: "body-color-primary-font",
  					value: "#2F2F32"
  				}
  			},
  			secondary: {
  				background: {
  					name: "body-color-secondary-background",
  					value: "#ffffff"
  				}
  			}
  		}
  	}
  };

  var color$4 = {
  	themeName: "theme-uplift-dark",
  	palette: {
  		amber: {
  			"10": {
  				name: "ids-color-palette-amber-10",
  				value: "#FEF2E5"
  			},
  			"20": {
  				name: "ids-color-palette-amber-20",
  				value: "#FDDFBD"
  			},
  			"30": {
  				name: "ids-color-palette-amber-30",
  				value: "#FCC888"
  			},
  			"40": {
  				name: "ids-color-palette-amber-40",
  				value: "#FBAF50"
  			},
  			"50": {
  				name: "ids-color-palette-amber-50",
  				value: "#FA9601"
  			},
  			"60": {
  				name: "ids-color-palette-amber-60",
  				value: "#F98300"
  			},
  			"70": {
  				name: "ids-color-palette-amber-70",
  				value: "#DF6F00"
  			},
  			"80": {
  				name: "ids-color-palette-amber-80",
  				value: "#CD6200"
  			},
  			"90": {
  				name: "ids-color-palette-amber-90",
  				value: "#BB5500"
  			},
  			"100": {
  				name: "ids-color-palette-amber-100",
  				value: "#A14100"
  			}
  		},
  		amethyst: {
  			"10": {
  				name: "ids-color-palette-amethyst-10",
  				value: "#F1EBFC"
  			},
  			"20": {
  				name: "ids-color-palette-amethyst-20",
  				value: "#DDCBF7"
  			},
  			"30": {
  				name: "ids-color-palette-amethyst-30",
  				value: "#C2A1F1"
  			},
  			"40": {
  				name: "ids-color-palette-amethyst-40",
  				value: "#A876EB"
  			},
  			"50": {
  				name: "ids-color-palette-amethyst-50",
  				value: "#8D4BE5"
  			},
  			"60": {
  				name: "ids-color-palette-amethyst-60",
  				value: "#7928E1"
  			},
  			"70": {
  				name: "ids-color-palette-amethyst-70",
  				value: "#6C23C9"
  			},
  			"80": {
  				name: "ids-color-palette-amethyst-80",
  				value: "#591DA8"
  			},
  			"90": {
  				name: "ids-color-palette-amethyst-90",
  				value: "#4E1A91"
  			},
  			"100": {
  				name: "ids-color-palette-amethyst-100",
  				value: "#3B1470"
  			}
  		},
  		azure: {
  			"10": {
  				name: "ids-color-palette-azure-10",
  				value: "#E6F1FD"
  			},
  			"20": {
  				name: "ids-color-palette-azure-20",
  				value: "#BEDCFA"
  			},
  			"30": {
  				name: "ids-color-palette-azure-30",
  				value: "#8ABFF7"
  			},
  			"40": {
  				name: "ids-color-palette-azure-40",
  				value: "#55A3F3"
  			},
  			"50": {
  				name: "ids-color-palette-azure-50",
  				value: "#1C86EF"
  			},
  			"60": {
  				name: "ids-color-palette-azure-60",
  				value: "#0072ED"
  			},
  			"70": {
  				name: "ids-color-palette-azure-70",
  				value: "#0066D4"
  			},
  			"80": {
  				name: "ids-color-palette-azure-80",
  				value: "#0054B1"
  			},
  			"90": {
  				name: "ids-color-palette-azure-90",
  				value: "#004A99"
  			},
  			"100": {
  				name: "ids-color-palette-azure-100",
  				value: "#003876"
  			}
  		},
  		emerald: {
  			"10": {
  				name: "ids-color-palette-emerald-10",
  				value: "#EBF9F1"
  			},
  			"20": {
  				name: "ids-color-palette-emerald-20",
  				value: "#CBEFDC"
  			},
  			"30": {
  				name: "ids-color-palette-emerald-30",
  				value: "#A1E4BF"
  			},
  			"40": {
  				name: "ids-color-palette-emerald-40",
  				value: "#78D8A3"
  			},
  			"50": {
  				name: "ids-color-palette-emerald-50",
  				value: "#4DCC86"
  			},
  			"60": {
  				name: "ids-color-palette-emerald-60",
  				value: "#2AC371"
  			},
  			"70": {
  				name: "ids-color-palette-emerald-70",
  				value: "#25AF65"
  			},
  			"80": {
  				name: "ids-color-palette-emerald-80",
  				value: "#1F9254"
  			},
  			"90": {
  				name: "ids-color-palette-emerald-90",
  				value: "#1C7F49"
  			},
  			"100": {
  				name: "ids-color-palette-emerald-100",
  				value: "#156138"
  			}
  		},
  		graphite: {
  			"10": {
  				name: "ids-color-palette-graphite-10",
  				value: "#EEEEEE"
  			},
  			"20": {
  				name: "ids-color-palette-graphite-20",
  				value: "#D3D3D3"
  			},
  			"30": {
  				name: "ids-color-palette-graphite-30",
  				value: "#B1B1B1"
  			},
  			"40": {
  				name: "ids-color-palette-graphite-40",
  				value: "#8F8F8F"
  			},
  			"50": {
  				name: "ids-color-palette-graphite-50",
  				value: "#6C6C6C"
  			},
  			"60": {
  				name: "ids-color-palette-graphite-60",
  				value: "#535353"
  			},
  			"70": {
  				name: "ids-color-palette-graphite-70",
  				value: "#4A4A4A"
  			},
  			"80": {
  				name: "ids-color-palette-graphite-80",
  				value: "#3E3E3E"
  			},
  			"90": {
  				name: "ids-color-palette-graphite-90",
  				value: "#363636"
  			},
  			"100": {
  				name: "ids-color-palette-graphite-100",
  				value: "#292929"
  			}
  		},
  		ruby: {
  			"10": {
  				name: "ids-color-palette-ruby-10",
  				value: "#FBE7E8"
  			},
  			"20": {
  				name: "ids-color-palette-ruby-20",
  				value: "#F5C3C4"
  			},
  			"30": {
  				name: "ids-color-palette-ruby-30",
  				value: "#EE9496"
  			},
  			"40": {
  				name: "ids-color-palette-ruby-40",
  				value: "#E66467"
  			},
  			"50": {
  				name: "ids-color-palette-ruby-50",
  				value: "#DF3539"
  			},
  			"60": {
  				name: "ids-color-palette-ruby-60",
  				value: "#DA1217"
  			},
  			"70": {
  				name: "ids-color-palette-ruby-70",
  				value: "#C31014"
  			},
  			"80": {
  				name: "ids-color-palette-ruby-80",
  				value: "#A30D11"
  			},
  			"90": {
  				name: "ids-color-palette-ruby-90",
  				value: "#8D0B0E"
  			},
  			"100": {
  				name: "ids-color-palette-ruby-100",
  				value: "#6C080B"
  			}
  		},
  		slate: {
  			"10": {
  				name: "ids-color-palette-slate-10",
  				value: "#EFEFF0"
  			},
  			"20": {
  				name: "ids-color-palette-slate-20",
  				value: "#D7D7D8"
  			},
  			"30": {
  				name: "ids-color-palette-slate-30",
  				value: "#B7B7BA"
  			},
  			"40": {
  				name: "ids-color-palette-slate-40",
  				value: "#97979B"
  			},
  			"50": {
  				name: "ids-color-palette-slate-50",
  				value: "#77777C"
  			},
  			"60": {
  				name: "ids-color-palette-slate-60",
  				value: "#606066"
  			},
  			"70": {
  				name: "ids-color-palette-slate-70",
  				value: "#56565B"
  			},
  			"80": {
  				name: "ids-color-palette-slate-80",
  				value: "#47474C"
  			},
  			"90": {
  				name: "ids-color-palette-slate-90",
  				value: "#3E3E42"
  			},
  			"100": {
  				name: "ids-color-palette-slate-100",
  				value: "#2F2F32"
  			}
  		},
  		turquoise: {
  			"10": {
  				name: "ids-color-palette-turquoise-10",
  				value: "#ECF8F8"
  			},
  			"20": {
  				name: "ids-color-palette-turquoise-20",
  				value: "#CFEEEE"
  			},
  			"30": {
  				name: "ids-color-palette-turquoise-30",
  				value: "#A8E1E1"
  			},
  			"40": {
  				name: "ids-color-palette-turquoise-40",
  				value: "#82D4D4"
  			},
  			"50": {
  				name: "ids-color-palette-turquoise-50",
  				value: "#5CC6C7"
  			},
  			"60": {
  				name: "ids-color-palette-turquoise-60",
  				value: "#40BDBE"
  			},
  			"70": {
  				name: "ids-color-palette-turquoise-70",
  				value: "#39A9AA"
  			},
  			"80": {
  				name: "ids-color-palette-turquoise-80",
  				value: "#2F8D8E"
  			},
  			"90": {
  				name: "ids-color-palette-turquoise-90",
  				value: "#297B7B"
  			},
  			"100": {
  				name: "ids-color-palette-turquoise-100",
  				value: "#1F5E5E"
  			}
  		},
  		white: {
  			name: "ids-color-palette-white",
  			value: "#ffffff",
  			paletteName: "#ffffff"
  		},
  		black: {
  			name: "ids-color-palette-black",
  			value: "#000000",
  			paletteName: "#000000"
  		}
  	},
  	status: {
  		base: {
  			name: "ids-color-status-base",
  			value: "#0072ED",
  			paletteName: "{ids.color.brand.primary.base.value}"
  		},
  		caution: {
  			name: "ids-color-status-caution",
  			value: "#FFD726",
  			paletteName: "#FFD726"
  		},
  		danger: {
  			name: "ids-color-status-danger",
  			value: "#DA1217",
  			paletteName: "#DA1217"
  		},
  		success: {
  			name: "ids-color-status-success",
  			value: "#2AC371",
  			paletteName: "#2AC371"
  		},
  		warning: {
  			name: "ids-color-status-warning",
  			value: "#F98300",
  			paletteName: "#F98300"
  		}
  	},
  	brand: {
  		primary: {
  			lighter: {
  				name: "ids-color-brand-primary-lighter",
  				value: "#55A3F3"
  			},
  			base: {
  				name: "ids-color-brand-primary-base",
  				value: "#0072ED"
  			},
  			alt: {
  				name: "ids-color-brand-primary-alt",
  				value: "#0066D4"
  			},
  			contrast: {
  				name: "ids-color-brand-primary-contrast",
  				value: "#ffffff"
  			}
  		},
  		secondary: {
  			lighter: {
  				name: "ids-color-brand-secondary-lighter",
  				value: "#97979B"
  			},
  			base: {
  				name: "ids-color-brand-secondary-base",
  				value: "#606066"
  			},
  			alt: {
  				name: "ids-color-brand-secondary-alt",
  				value: "#56565B"
  			},
  			contrast: {
  				name: "ids-color-brand-secondary-contrast",
  				value: "#3E3E42"
  			}
  		}
  	},
  	components: {
  		body: {
  			primary: {
  				background: {
  					name: "body-color-primary-background",
  					value: "#3E3E42"
  				},
  				font: {
  					name: "body-color-primary-font",
  					value: "#EFEFF0"
  				}
  			},
  			secondary: {
  				background: {
  					name: "body-color-secondary-background",
  					value: "#47474C"
  				}
  			}
  		}
  	}
  };

  var color$5 = {
  	themeName: "theme-uplift-contrast",
  	palette: {
  		amber: {
  			"10": {
  				name: "ids-color-palette-amber-10",
  				value: "#FEF2E5"
  			},
  			"20": {
  				name: "ids-color-palette-amber-20",
  				value: "#FDDFBD"
  			},
  			"30": {
  				name: "ids-color-palette-amber-30",
  				value: "#FCC888"
  			},
  			"40": {
  				name: "ids-color-palette-amber-40",
  				value: "#FBAF50"
  			},
  			"50": {
  				name: "ids-color-palette-amber-50",
  				value: "#FA9601"
  			},
  			"60": {
  				name: "ids-color-palette-amber-60",
  				value: "#F98300"
  			},
  			"70": {
  				name: "ids-color-palette-amber-70",
  				value: "#DF6F00"
  			},
  			"80": {
  				name: "ids-color-palette-amber-80",
  				value: "#CD6200"
  			},
  			"90": {
  				name: "ids-color-palette-amber-90",
  				value: "#BB5500"
  			},
  			"100": {
  				name: "ids-color-palette-amber-100",
  				value: "#A14100"
  			}
  		},
  		amethyst: {
  			"10": {
  				name: "ids-color-palette-amethyst-10",
  				value: "#F1EBFC"
  			},
  			"20": {
  				name: "ids-color-palette-amethyst-20",
  				value: "#DDCBF7"
  			},
  			"30": {
  				name: "ids-color-palette-amethyst-30",
  				value: "#C2A1F1"
  			},
  			"40": {
  				name: "ids-color-palette-amethyst-40",
  				value: "#A876EB"
  			},
  			"50": {
  				name: "ids-color-palette-amethyst-50",
  				value: "#8D4BE5"
  			},
  			"60": {
  				name: "ids-color-palette-amethyst-60",
  				value: "#7928E1"
  			},
  			"70": {
  				name: "ids-color-palette-amethyst-70",
  				value: "#6C23C9"
  			},
  			"80": {
  				name: "ids-color-palette-amethyst-80",
  				value: "#591DA8"
  			},
  			"90": {
  				name: "ids-color-palette-amethyst-90",
  				value: "#4E1A91"
  			},
  			"100": {
  				name: "ids-color-palette-amethyst-100",
  				value: "#3B1470"
  			}
  		},
  		azure: {
  			"10": {
  				name: "ids-color-palette-azure-10",
  				value: "#E6F1FD"
  			},
  			"20": {
  				name: "ids-color-palette-azure-20",
  				value: "#BEDCFA"
  			},
  			"30": {
  				name: "ids-color-palette-azure-30",
  				value: "#8ABFF7"
  			},
  			"40": {
  				name: "ids-color-palette-azure-40",
  				value: "#55A3F3"
  			},
  			"50": {
  				name: "ids-color-palette-azure-50",
  				value: "#1C86EF"
  			},
  			"60": {
  				name: "ids-color-palette-azure-60",
  				value: "#0072ED"
  			},
  			"70": {
  				name: "ids-color-palette-azure-70",
  				value: "#0066D4"
  			},
  			"80": {
  				name: "ids-color-palette-azure-80",
  				value: "#0054B1"
  			},
  			"90": {
  				name: "ids-color-palette-azure-90",
  				value: "#004A99"
  			},
  			"100": {
  				name: "ids-color-palette-azure-100",
  				value: "#003876"
  			}
  		},
  		emerald: {
  			"10": {
  				name: "ids-color-palette-emerald-10",
  				value: "#EBF9F1"
  			},
  			"20": {
  				name: "ids-color-palette-emerald-20",
  				value: "#CBEFDC"
  			},
  			"30": {
  				name: "ids-color-palette-emerald-30",
  				value: "#A1E4BF"
  			},
  			"40": {
  				name: "ids-color-palette-emerald-40",
  				value: "#78D8A3"
  			},
  			"50": {
  				name: "ids-color-palette-emerald-50",
  				value: "#4DCC86"
  			},
  			"60": {
  				name: "ids-color-palette-emerald-60",
  				value: "#2AC371"
  			},
  			"70": {
  				name: "ids-color-palette-emerald-70",
  				value: "#25AF65"
  			},
  			"80": {
  				name: "ids-color-palette-emerald-80",
  				value: "#1F9254"
  			},
  			"90": {
  				name: "ids-color-palette-emerald-90",
  				value: "#1C7F49"
  			},
  			"100": {
  				name: "ids-color-palette-emerald-100",
  				value: "#156138"
  			}
  		},
  		graphite: {
  			"10": {
  				name: "ids-color-palette-graphite-10",
  				value: "#EEEEEE"
  			},
  			"20": {
  				name: "ids-color-palette-graphite-20",
  				value: "#D3D3D3"
  			},
  			"30": {
  				name: "ids-color-palette-graphite-30",
  				value: "#B1B1B1"
  			},
  			"40": {
  				name: "ids-color-palette-graphite-40",
  				value: "#8F8F8F"
  			},
  			"50": {
  				name: "ids-color-palette-graphite-50",
  				value: "#6C6C6C"
  			},
  			"60": {
  				name: "ids-color-palette-graphite-60",
  				value: "#535353"
  			},
  			"70": {
  				name: "ids-color-palette-graphite-70",
  				value: "#4A4A4A"
  			},
  			"80": {
  				name: "ids-color-palette-graphite-80",
  				value: "#3E3E3E"
  			},
  			"90": {
  				name: "ids-color-palette-graphite-90",
  				value: "#363636"
  			},
  			"100": {
  				name: "ids-color-palette-graphite-100",
  				value: "#292929"
  			}
  		},
  		ruby: {
  			"10": {
  				name: "ids-color-palette-ruby-10",
  				value: "#FBE7E8"
  			},
  			"20": {
  				name: "ids-color-palette-ruby-20",
  				value: "#F5C3C4"
  			},
  			"30": {
  				name: "ids-color-palette-ruby-30",
  				value: "#EE9496"
  			},
  			"40": {
  				name: "ids-color-palette-ruby-40",
  				value: "#E66467"
  			},
  			"50": {
  				name: "ids-color-palette-ruby-50",
  				value: "#DF3539"
  			},
  			"60": {
  				name: "ids-color-palette-ruby-60",
  				value: "#DA1217"
  			},
  			"70": {
  				name: "ids-color-palette-ruby-70",
  				value: "#C31014"
  			},
  			"80": {
  				name: "ids-color-palette-ruby-80",
  				value: "#A30D11"
  			},
  			"90": {
  				name: "ids-color-palette-ruby-90",
  				value: "#8D0B0E"
  			},
  			"100": {
  				name: "ids-color-palette-ruby-100",
  				value: "#6C080B"
  			}
  		},
  		slate: {
  			"10": {
  				name: "ids-color-palette-slate-10",
  				value: "#EFEFF0"
  			},
  			"20": {
  				name: "ids-color-palette-slate-20",
  				value: "#D7D7D8"
  			},
  			"30": {
  				name: "ids-color-palette-slate-30",
  				value: "#B7B7BA"
  			},
  			"40": {
  				name: "ids-color-palette-slate-40",
  				value: "#97979B"
  			},
  			"50": {
  				name: "ids-color-palette-slate-50",
  				value: "#77777C"
  			},
  			"60": {
  				name: "ids-color-palette-slate-60",
  				value: "#606066"
  			},
  			"70": {
  				name: "ids-color-palette-slate-70",
  				value: "#56565B"
  			},
  			"80": {
  				name: "ids-color-palette-slate-80",
  				value: "#47474C"
  			},
  			"90": {
  				name: "ids-color-palette-slate-90",
  				value: "#3E3E42"
  			},
  			"100": {
  				name: "ids-color-palette-slate-100",
  				value: "#2F2F32"
  			}
  		},
  		turquoise: {
  			"10": {
  				name: "ids-color-palette-turquoise-10",
  				value: "#ECF8F8"
  			},
  			"20": {
  				name: "ids-color-palette-turquoise-20",
  				value: "#CFEEEE"
  			},
  			"30": {
  				name: "ids-color-palette-turquoise-30",
  				value: "#A8E1E1"
  			},
  			"40": {
  				name: "ids-color-palette-turquoise-40",
  				value: "#82D4D4"
  			},
  			"50": {
  				name: "ids-color-palette-turquoise-50",
  				value: "#5CC6C7"
  			},
  			"60": {
  				name: "ids-color-palette-turquoise-60",
  				value: "#40BDBE"
  			},
  			"70": {
  				name: "ids-color-palette-turquoise-70",
  				value: "#39A9AA"
  			},
  			"80": {
  				name: "ids-color-palette-turquoise-80",
  				value: "#2F8D8E"
  			},
  			"90": {
  				name: "ids-color-palette-turquoise-90",
  				value: "#297B7B"
  			},
  			"100": {
  				name: "ids-color-palette-turquoise-100",
  				value: "#1F5E5E"
  			}
  		},
  		white: {
  			name: "ids-color-palette-white",
  			value: "#ffffff",
  			paletteName: "#ffffff"
  		},
  		black: {
  			name: "ids-color-palette-black",
  			value: "#000000",
  			paletteName: "#000000"
  		}
  	},
  	status: {
  		base: {
  			name: "ids-color-status-base",
  			value: "#003876",
  			paletteName: "{ids.color.brand.primary.alt.value}"
  		},
  		caution: {
  			name: "ids-color-status-caution",
  			value: "#FFD726",
  			paletteName: "#FFD726"
  		},
  		danger: {
  			name: "ids-color-status-danger",
  			value: "#7B0F11",
  			paletteName: "#7B0F11"
  		},
  		success: {
  			name: "ids-color-status-success",
  			value: "#2AC371",
  			paletteName: "#2AC371"
  		},
  		warning: {
  			name: "ids-color-status-warning",
  			value: "#F98300",
  			paletteName: "#F98300"
  		}
  	},
  	brand: {
  		primary: {
  			lighter: {
  				name: "ids-color-brand-primary-lighter",
  				value: "#55A3F3"
  			},
  			base: {
  				name: "ids-color-brand-primary-base",
  				value: "#004A99"
  			},
  			alt: {
  				name: "ids-color-brand-primary-alt",
  				value: "#003876"
  			},
  			contrast: {
  				name: "ids-color-brand-primary-contrast",
  				value: "#ffffff"
  			}
  		},
  		secondary: {
  			lighter: {
  				name: "ids-color-brand-secondary-lighter",
  				value: "#47474C"
  			},
  			base: {
  				name: "ids-color-brand-secondary-base",
  				value: "#3E3E42"
  			},
  			alt: {
  				name: "ids-color-brand-secondary-alt",
  				value: "#2F2F32"
  			},
  			contrast: {
  				name: "ids-color-brand-secondary-contrast",
  				value: "#3E3E42"
  			}
  		}
  	},
  	components: {
  		body: {
  			primary: {
  				background: {
  					name: "body-color-primary-background",
  					value: "#EFEFF0"
  				},
  				font: {
  					name: "body-color-primary-font",
  					value: "#3E3E42"
  				}
  			},
  			secondary: {
  				background: {
  					name: "body-color-secondary-background",
  					value: "#ffffff"
  				}
  			}
  		}
  	}
  };

  /**
  * The Theme Component is a lightweight wrapper for theme information, which contains the colors
  * that are used on the theme.
  * @class Theme
  */

  var theme = {
    /**
     * @property {object} [currentTheme]
     * @property {string} [currentTheme.id]
     * @property {string} [currentTheme.name]
     */
    currentTheme: {
      id: 'theme-soho-light',
      name: Locale.translate('SohoLightTheme'),
      legacyId: 'light'
    },

    /**
     * Get all of the colors for all themes
     * @returns {object[]} An array of color objects
     */
    allColors: [{
      id: 'theme-soho-light',
      colors: color,
      legacyId: 'light'
    }, {
      id: 'theme-soho-dark',
      colors: color$1,
      legacyId: 'dark'
    }, {
      id: 'theme-soho-contrast',
      colors: color$2,
      legacyId: 'high-contrast'
    }, {
      id: 'theme-uplift-light',
      colors: color$3
    }, {
      id: 'theme-uplift-dark',
      colors: color$4
    }, {
      id: 'theme-uplift-contrast',
      colors: color$5
    }],

    /**
     * Return a list of all the available themes
     * @returns {object[]} The list of themes
     */
    themes: function themes() {
      return [{
        id: 'theme-soho-light',
        name: Locale.translate('SohoLightTheme'),
        themeId: 'theme-soho',
        variantId: 'light',
        variantName: Locale.translate('Light'),
        legacyId: 'light'
      }, {
        id: 'theme-soho-dark',
        name: Locale.translate('SohoDarkTheme'),
        themeId: 'theme-soho',
        variantId: 'dark',
        variantName: Locale.translate('Dark'),
        legacyId: 'dark'
      }, {
        id: 'theme-soho-contrast',
        name: Locale.translate('SohoHighContrastTheme'),
        themeId: 'theme-soho',
        variantId: 'contrast',
        variantName: Locale.translate('Contrast'),
        legacyId: 'high-contrast'
      }, {
        id: 'theme-uplift-light',
        name: Locale.translate('UpliftLightTheme'),
        themeId: 'theme-uplift',
        variantId: 'light',
        variantName: Locale.translate('Light')
      }, {
        id: 'theme-uplift-dark',
        name: Locale.translate('UpliftDarkTheme'),
        themeId: 'theme-uplift',
        variantId: 'dark',
        variantName: Locale.translate('Dark')
      }, {
        id: 'theme-uplift-contrast',
        name: Locale.translate('UpliftHighContrastTheme'),
        themeId: 'theme-uplift',
        variantId: 'contrast',
        variantName: Locale.translate('Contrast')
      }];
    },

    /**
     * Get the colors used in the current theme
     * @param {string} themeId The id of the theme.
     * @returns {object} An object full of the colors 01-10
     */
    themeColors: function themeColors() {
      var _this = this;

      var result = this.allColors.filter(function (color) {
        return color.id === _this.currentTheme.id;
      });

      if (!result[0]) {
        return {
          palette: {},
          colors: {},
          brand: {}
        };
      }

      return result[0].colors;
    },

    /**
     * Get the colors used in the current theme that are reccomended for personalization
     * @returns {object} An object full of the colors with id, name abd hex value
     */
    personalizationColors: function personalizationColors() {
      var palette = this.themeColors().palette;
      var brand = this.themeColors().brand;
      var personalize = {};
      var opts = {
        showBrackets: false
      };
      personalize.default = {
        id: 'default',
        name: Locale.translate('Default', opts),
        backgroundColorClass: 'primary-bg-color',
        value: brand.primary.base.value
      };
      personalize.amber = {
        id: 'amber',
        name: Locale.translate('Amber', opts),
        backgroundColorClass: 'amber09',
        value: palette.amber['90'].value
      };
      personalize.amethyst = {
        id: 'amethyst',
        name: Locale.translate('Amethyst', opts),
        backgroundColorClass: 'amethyst06',
        value: palette.amethyst['60'].value
      };
      personalize.azure = {
        id: 'azure',
        name: Locale.translate('Azure', opts),
        backgroundColorClass: 'azure07',
        value: palette.azure['70'].value
      };
      personalize.emerald = {
        id: 'emerald',
        name: Locale.translate('Emerald', opts),
        backgroundColorClass: 'emerald08',
        value: palette.emerald['80'].value
      };
      personalize.graphite = {
        id: 'graphite',
        name: Locale.translate('Graphite', opts),
        backgroundColorClass: 'graphite06',
        value: palette.graphite['60'].value
      };
      personalize.ruby = {
        id: 'ruby',
        name: Locale.translate('Ruby', opts),
        backgroundColorClass: 'ruby09',
        value: palette.ruby['90'].value
      };
      personalize.slate = {
        id: 'slate',
        name: Locale.translate('Slate', opts),
        backgroundColorClass: 'slate06',
        value: palette.slate['60'].value
      };
      personalize.turquoise = {
        id: 'turquoise',
        name: Locale.translate('Turquoise', opts),
        backgroundColorClass: 'turquoise09',
        value: palette.turquoise['90'].value
      };
      return personalize;
    },

    /**
     * Set the current application theme
     * @param {string} themeId The id of the theme
     * @returns {[type]} [description]
     */
    setTheme: function setTheme(themeId) {
      var result = this.themes().filter(function (themeObj) {
        return themeObj.id === themeId || themeObj.legacyId && themeObj.legacyId === themeId;
      }); //eslint-disable-line

      if (result.length === 0) {
        return '';
      }

      this.currentTheme = result[0];
      return result;
    },

    /**
     * @returns {boolean} whether or not the current theme is an Uplift variant
     */
    get uplift() {
      return this.currentTheme.id.indexOf('-uplift-') > -1;
    }

  };

  function personalizeStyles(colors) {
    var baseColorObj = colorUtils.hexToRgb(colors.base);
    var hyperlinkColorObj = colorUtils.hexToRgb(colors.hyperlinkText);
    return "\n\n.is-personalizable ::selection {\n  background: ".concat(colors.selection, " !important\n}\n\n.is-personalizable .btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane),\n.btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane).is-personalizable {\n  background-color: ").concat(colors.base, " !important;\n  border-color: ").concat(colors.base, " !important;\n}\n\n.is-personalizable .btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):disabled,\n.btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane).is-personalizable:disabled {\n  background-color: ").concat(colors.baseDisabled, " !important;\n  border-color: ").concat(colors.baseDisabled, " !important;\n}\n\n.is-personalizable .btn-link:not(:disabled),\n.btn-link.is-personalizable:not(:disabled) {\n  color: ").concat(colors.light, " !important;\n}\n\n.is-personalizable .btn-link:not(:disabled) .icon,\n.btn-link.is-personalizable:not(:disabled) .icon {\n  color: ").concat(colors.light, " !important;\n}\n\n.is-personalizable button.is-pressed,\nbutton.is-personalizable.is-pressed {\n  color: ").concat(colors.base, ";\n}\n\n.is-personalizable button.is-pressed .icon,\nbutton.is-personalizable.is-pressed .icon {\n  color: ").concat(colors.base, ";\n}\n\n.is-personalizable .btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):hover:not(:disabled),\n.btn-primary.is-personalizable:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):hover:not(:disabled) {\n  background-color: ").concat(colors.darker, " !important;\n  border-color: ").concat(colors.darker, " !important;\n}\n\n.is-personalizable .btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):hover:not(:disabled),\n.btn-primary.is-personalizable:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):hover:not(:disabled) {\n  background-color: ").concat(colors.darker, " !important;\n  border-color: ").concat(colors.darker, " !important;\n}\n\n.is-personalizable button:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):focus:not(.hide-focus),\nbutton.is-personalizable button:focus:not(.hide-focus),\n.is-personalizable a.btn:focus:not(.hide-focus),\na.btn.is-personalizable:focus:not(.hide-focus),\n.is-personalizable a.btn-menu:focus:not(.hide-focus),\na.btn-menu.is-personalizable:focus:not(.hide-focus),\n.is-personalizable a.btn-icon:focus:not(.hide-focus),\na.btn-icon.is-personalizable:focus:not(.hide-focus),\n.is-personalizable a.btn-tertiary:focus:not(.hide-focus),\na.btn-tertiary.is-personalizable:focus:not(.hide-focus),\n.is-personalizable a.btn-close:focus:not(.hide-focus),\na.btn-close.is-personalizable:focus:not(.hide-focus) {\n  box-shadow: 0 0 0 2px transparent,\n    0 0 0 1px ").concat(colors.base, ",\n    0 0 4px 2px rgba(").concat(baseColorObj.r, ", ").concat(baseColorObj.g, ", ").concat(baseColorObj.b, ", 0.3);\n}\n\n.is-personalizable .btn-primary:not(.is-select):not(.is-select-month-pane):not(.is-cancel):not(.is-cancel-month-pane):focus:not(.hide-focus),\n.btn-primary.is-personalizable button:focus:not(.hide-focus),\n.is-personalizable .btn-secondary:focus:not(.hide-focus),\n.btn-secondary.is-personalizable button:focus:not(.hide-focus) {\n  box-shadow: 0 0 0 2px ").concat(colors.theme.bg, ",\n    0 0 0 3px ").concat(colors.base, ",\n    0 0 4px 2px rgba(").concat(baseColorObj.r, ", ").concat(baseColorObj.g, ", ").concat(baseColorObj.b, ", 0.3);\n}\n\n.is-personalizable .btn-menu:not(.btn-primary):not(.btn-secondary).is-open,\n.btn-menu:not(.btn-primary):not(.btn-secondary).is-personalizable.is-open,\n.is-personalizable .btn-actions:not(.btn-primary):not(.btn-secondary).is-open,\n.btn-actions:not(.btn-primary):not(.btn-secondary).is-personalizable.is-open {\n  color: ").concat(colors.base, ";\n}\n\n.is-personalizable .btn-menu:not(.btn-primary):not(.btn-secondary).is-open .icon,\n.btn-menu:not(.btn-primary):not(.btn-secondary).is-personalizable.is-open .icon,\n.is-personalizable .btn-actions:not(.btn-primary):not(.btn-secondary).is-open .icon,\n.btn-actions:not(.btn-primary):not(.btn-secondary).is-personalizable.is-open .icon {\n  color: ").concat(colors.base, ";\n}\n\n.is-personalizable .hyperlink:not(.today),\n.hyperlink:not(.today).is-personalizable {\n  color: ").concat(colors.hyperlinkText, "\n}\n.is-personalizable .hyperlink:not(.today):hover,\n.hyperlink:not(.today).is-personalizable:hover {\n  color: ").concat(colors.hyperlinkTextHover, ";\n}\n.is-personalizable .hyperlink:not(.today):focus:not(.hide-focus),\n.hyperlink:not(.today).is-personalizable:focus:not(.hide-focus) {\n  border-color: ").concat(colors.hyperlinkText, ";\n  box-shadow: 0 0 4px 3px rgba(").concat(hyperlinkColorObj.r, ", ").concat(hyperlinkColorObj.g, ", ").concat(hyperlinkColorObj.b, ", 0.3);\n}\n\n.is-personalizable button:not(.btn-monthyear-pane):not(.btn-editor) svg.ripple-effect,\nbutton:not(.btn-monthyear-pane):not(.btn-editor).is-personalizable svg.ripple-effect,\n.is-personalizable a svg.ripple-effect,\na.is-personalizable svg.ripple-effect {\n  background-color: ").concat(colors.base, " !important;\n}\n\n.is-personalizable .btn-primary svg.ripple-effect,\n.btn-primary.is-personalizable svg.ripple-effect,\n.is-personalizable .btn-secondary svg.ripple-effect,\n.btn-secondary.is-personalizable svg.ripple-effect {\n  background-color: ").concat(colors.contrast, " !important;\n  border-color: ").concat(colors.contrast, " !important;\n}\n\n.tab-container.module-tabs.is-personalizable {\n  border-top: 1px solid ").concat(colors.darkest, " !important;\n  border-bottom: 1px solid ").concat(colors.darkest, " !important;\n}\n\n.module-tabs.is-personalizable .tab:not(:first-child) {\n  border-left: 1px solid ").concat(colors.darkest, " !important;\n}\n\n.module-tabs.is-personalizable {\n  background-color: ").concat(colors.darker, " !important;\n}\n\n.module-tabs.is-personalizable .tab.is-selected {\n  background-color: ").concat(colors.base, " !important;\n}\n\n.tab-container.vertical.is-personalizable > .tab-list-container > .tab-list > .tab.is-selected {\n  background-color: ").concat(colors.base, " !important;\n}\n\n.tab-container.vertical.is-personalizable .tab-focus-indicator.is-visible {\n  border-color: ").concat(colors.base, " !important;\n  box-shadow: 0 0 4px 3px rgba(").concat(baseColorObj.r, ", ").concat(baseColorObj.g, ", ").concat(baseColorObj.b, ", 0.3);\n}\n\n.accordion.panel .accordion-header.is-selected {\n  background-color: ").concat(colors.lighter, " !important;\n  color: ").concat(colors.contrast, " !important;\n}\n\n.builder-header.is-personalizable{\n  background-color: ").concat(colors.lighter, ";\n}\n\n.header.is-personalizable {\n  background-color: ").concat(colors.base, ";\n}\n\n.header.is-personalizable .title {\n  color: ").concat(colors.contrast, ";\n}\n\n.header.is-personalizable h1 {\n  color: ").concat(colors.contrast, ";\n}\n\n.header.is-personalizable button svg.ripple-effect {\n  background-color: ").concat(colors.contrast, " !important;\n}\n\n.header.is-personalizable button:not(:disabled),\n.header.is-personalizable button:not(:disabled) .icon,\n.header.is-personalizable button:not(:disabled) .app-header.icon > span {\n  color: ").concat(colors.contrast, " !important;\n  opacity: .8;\n}\n\n.header.is-personalizable .header.is-personalizable button:not(:disabled) .app-header.icon > span {\n  background-color: ").concat(colors.contrast, " !important;\n  opacity: .8;\n}\n\n.header.is-personalizable button:not(:disabled):hover,\n.header.is-personalizable button:not(:disabled):hover .icon,\n.header.is-personalizable button:not(:disabled):hover .app-header.icon > span,\n.header.is-personalizable .toolbar [class^='btn']:hover:not([disabled]) {\n  color: ").concat(colors.contrast, " !important;\n  opacity: 1;\n}\n\n.header.is-personalizable button:not(:disabled) .app-header.icon > span {\n  background-color: ").concat(colors.contrast, " !important;\n  opacity: 1;\n}\n\n.header.is-personalizable .go-button.is-personalizable {\n  background-color: ").concat(colors.lightest, ";\n  border-color:").concat(colors.lightest, ";\n  color: ").concat(colors.contrast, ";\n}\n\n.header.is-personalizable.has-tabs .tab-container.header-tabs > .tab-list-container .tab.is-selected:not(.is-disabled) {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.header.is-personalizable.has-tabs .tab-container.header-tabs > .tab-list-container .tab,\n.is-personalizable.tab-container.header-tabs > .tab-list-container .tab  {\n  color: ").concat(colors.contrast, " !important;\n  opacity: .8;\n}\n\n.header.is-personalizable.has-tabs .tab-container.header-tabs > .tab-list-container .tab:hover:not(.is-disabled),\n.is-personalizable.tab-container.header-tabs > .tab-list-container .tab:hover:not(.is-disabled)  {\n  color: ").concat(colors.contrast, " !important;\n  opacity: 1;\n}\n\nhtml[class*=\"theme-uplift-\"] .header.is-personalizable.has-tabs .tab-container.header-tabs > .tab-list-container .tab,\nhtml[class*=\"theme-uplift-\"] .is-personalizable.tab-container.header-tabs > .tab-list-container .tab  {\n  opacity: 1;\n}\n\n.header.is-personalizable.has-tabs .tab-container.header-tabs > .tab-list-container .tab:hover:not(.is-disabled)::before {\n  background-color: ").concat(colors.contrast, ";\n}\n\n.header.is-personalizable.has-tabs .animated-bar {\n  background-color: ").concat(colors.contrast, ";\n}\n\n.header.is-personalizable.has-tabs .tab-list-container .tab.is-selected:not(.is-disabled):hover::before {\n  background-color: ").concat(colors.contrast, " !important;\n}\n\n.subheader.is-personalizable .go-button.is-personalizable {\n  background-color: ").concat(colors.dark, ";\n  border-color: ").concat(colors.dark, ";\n  color: ").concat(colors.contrast, ";\n}\n\n.is-personalizable .breadcrumb .hyperlink,\n.breadcrumb.is-personalizable .hyperlink {\n  color: ").concat(colors.theme.text, ";\n}\n.is-personalizable .breadcrumb .hyperlink:hover,\n.breadcrumb.is-personalizable .hyperlink:hover {\n  color: ").concat(colors.theme.text, ";\n}\n.is-personalizable .breadcrumb .hyperlink:focus:not(.hide-focus),\n.breadcrumb.is-personalizable .hyperlink:focus:not(.hide-focus) {\n  box-shadow: none;\n}\n.is-personalizable .breadcrumb .hyperlink[disabled],\n.breadcrumb.is-personalizable .hyperlink[disabled],\n.is-personalizable .breadcrumb .hyperlink[disabled]:hover,\n.breadcrumb.is-personalizable .hyperlink[disabled]:hover {\n  color: ").concat(colors.theme.disabledText, ";\n}\n\n.is-personalizable .scrollable-flex-header .breadcrumb:not(.alternate),\n.scrollable-flex-header.is-personalizable .breadcrumb:not(.alternate) {\n  background-color: ").concat(colors.base, ";\n}\n.is-personalizable .scrollable-flex-header .breadcrumb.truncated:not(.alternate) .breadcrumb-list::before,\n.scrollable-flex-header.is-personalizable .breadcrumb.truncated:not(.alternate) .breadcrumb-list::before {\n  background-image: linear-gradient(to right, ").concat(colors.base, ", ").concat(colorUtils.hexToRgba(colors.base, 0), ");\n}\nhtml[dir='rtl'] .is-personalizable .scrollable-flex-header .breadcrumb.truncated:not(.alternate) .breadcrumb-list::before,\nhtml[dir='rtl'] .scrollable-flex-header.is-personalizable .breadcrumb.truncated:not(.alternate) .breadcrumb-list::before {\n  background-image: linear-gradient(to right, ").concat(colorUtils.hexToRgba(colors.base, 0), ", ").concat(colors.base, ");\n}\n.is-personalizable .scrollable-flex-header .breadcrumb:not(.alternate) .hyperlink,\n.scrollable-flex-header.is-personalizable .breadcrumb:not(.alternate) .hyperlink {\n  color: ").concat(colors.contrast, ";\n}\n.is-personalizable .scrollable-flex-header .breadcrumb:not(.alternate) .hyperlink:hover,\n.scrollable-flex-header.is-personalizable .breadcrumb:not(.alternate) .hyperlink:hover  {\n  color: ").concat(colors.contrast, ";\n}\n\n.is-personalizable .scrollable-flex-header .breadcrumb:not(.alternate) .btn-actions.is-open .icon,\n.scrollable-flex-header.is-personalizable .breadcrumb:not(.alternate) .btn-actions.is-open .icon {\n  color: ").concat(colors.contrast, ";\n}\n.is-personalizable .scrollable-flex-header .breadcrumb:not(.alternate) .btn-actions:focus:not(.hide-focus),\n.scrollable-flex-header.is-personalizable .breadcrumb:not(.alternate) .btn-actions:focus:not(.hide-focus) {\n  box-shadow: 0 0 0 2px transparent, 0 0 0 1px ").concat(colors.contrast, ", 0 0 1px 2px ").concat(colorUtils.hexToRgba(colors.contrast, 0.3), " !important;\n}\n\n.module-tabs.is-personalizable .tab-more {\n  border-left-color: ").concat(colors.darkest, " !important;\n}\n\n.module-tabs.is-personalizable .tab-more:hover {\n  background-color: ").concat(colors.hover, " !important;\n}\n\n.module-tabs.is-personalizable .tab-more.is-open {\n  background-color: ").concat(colors.hover, " !important;\n}\n\n.module-tabs.is-personalizable .tab-more.is-selected {\n  background-color: ").concat(colors.base, " !important;\n}\n\n.header .toolbar > .toolbar-searchfield-wrapper.active .searchfield {\n  background-color: ").concat(colors.hover, " !important;\n  border-bottom-color: ").concat(colors.hover, " !important;\n}\n\n.header .toolbar > .toolbar-searchfield-wrapper.active .searchfield-category-button {\n  background-color: ").concat(colors.hover, " !important;\n  border-bottom-color: ").concat(colors.hover, " !important;\n}\n\n.subheader.is-personalizable {\n  background-color: ").concat(colors.lighter, " !important;\n}\n\n.builder .sidebar .header {\n  border-right: 1px solid ").concat(colors.hover, " !important;\n}\n\n.module-tabs.is-personalizable .tab:hover {\n  background-color: ").concat(colors.darker, " !important;\n}\n\n.module-tabs.has-toolbar.is-personalizable .tab-list-container + .toolbar {\n  border-left-color: ").concat(colors.darkest, " !important;\n}\n\n.module-tabs.is-personalizable [class^=\"btn\"] {\n  background-color: transparent !important;\n  color: ").concat(colors.contrast, " !important;\n}\n\n.module-tabs.is-personalizable .tab.is-disabled {\n  background-color: ").concat(colors.darker, " !important;\n  color: ").concat(colors.contrast, " !important;\n}\n\n.module-tabs.is-personalizable .tab.is-disabled > svg {\n  fill: ").concat(colors.contrast, " !important;\n}\n\n.module-tabs.is-personalizable .add-tab-button {\n  border-left-color: ").concat(colors.darkest, " !important;\n}\n\n.module-tabs.is-personalizable .add-tab-button:hover {\n  background-color: ").concat(colors.darker, " !important;\n}\n\n.module-tabs.is-personalizable .toolbar-searchfield-wrapper > .searchfield {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.module-tabs.is-personalizable .toolbar-searchfield-wrapper > svg {\n  fill: ").concat(colors.contrast, " !important;\n}\n\n.is-personalizable .tab-container.header-tabs:not(.alternate)::before,\n.is-personalizable.tab-container.header-tabs:not(.alternate)::before {\n  background-image: linear-gradient(to right, ").concat(colors.dark, " , ").concat(colorUtils.hexToRgba(colors.dark, 0), ") !important;\n}\n\n.is-personalizable .tab-container.header-tabs:not(.alternate)::after,\n.is-personalizable.tab-container.header-tabs:not(.alternate)::after {\n  background-image: linear-gradient(to right, ").concat(colorUtils.hexToRgba(colors.dark, 0), ", ").concat(colors.dark, ") !important;\n}\n\n.hero-widget.is-personalizable {\n  background-color: ").concat(colors.lighter, ";\n}\n\n.hero-widget.is-personalizable .hero-bottom {\n  background-color: ").concat(colors.base, ";\n}\n\n.hero-widget.is-personalizable .hero-footer .hero-footer-nav li::before {\n  color: ").concat(colors.light, ";\n}\n\n.hero-widget.is-personalizable .chart-container .arc {\n  stroke: ").concat(colors.lighter, ";\n}\n\n.hero-widget.is-personalizable .chart-container .bar {\n  stroke: ").concat(colors.lighter, ";\n}\n\n.hero-widget.is-personalizable .chart-container.line-chart .dot {\n  stroke: ").concat(colors.lighter, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable button .icon,\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable button span,\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .hyperlink {\n  color: ").concat(colors.contrast, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable button:not(:disabled):hover .icon,\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable button:not(:disabled):hover span,\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .hyperlink:hover {\n  color: ").concat(colors.contrast, ";\n  opacity: 1;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel {\n  background-color: ").concat(colors.lighter, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .name-xl,\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .name,\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion-heading {\n  color: ").concat(colors.contrast, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel .accordion-header {\n  background-color: ").concat(colors.lighter, " !important;\n  border: 1px solid transparent !important;\n  color: ").concat(colors.contrast, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel .accordion-header .icon {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.application-menu.is-personalizable .btn-icon:focus:not(.hide-focus) {\n  box-shadow: 0 0 0 2px transparent,\n    0 0 0 1px ").concat(colors.lighter, ",\n    0 0 2px 1px ").concat(colors.lighter, ";\n}\n\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-selected {\n  background-color: ").concat(colors.base, " !important;\n}\n\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-selected:hover {\n  border-bottom-color: ").concat(colors.dark, " !important;\n}\n\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-selected > a,\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-selected:hover > a,\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-selected > a,\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-selected .icon {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.application-menu.is-personalizable .accordion.panel .accordion-header.is-focused:not(.hide-focus) {\n  border: 1px solid ").concat(colors.contrast, " !important;\n  box-shadow: none !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-pane {\n  background-color: ").concat(colors.lighter, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-pane .accordion-header {\n  border: 1px solid ").concat(colors.lighter, ";\n}\n\n.application-menu.is-personalizable .accordion.panel.inverse .accordion-header .icon.plus-minus::before,\n.application-menu.is-personalizable .accordion.panel.inverse .accordion-header .icon.plus-minus::after {\n  background-color: ").concat(colors.contrast, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable button:focus:not(.hide-focus),\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .hyperlink:focus:not(.hide-focus)::after {\n  border-color: ").concat(colors.contrast, " !important;\n  box-shadow: none !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu .application-menu-header button:hover,\nhtml[class*=\"theme-uplift-\"] .application-menu .application-menu-footer button:hover {\n  background-color: ").concat(colors.base, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .searchfield-wrapper .searchfield {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.application-menu.is-personalizable .accordion-header.has-filtered-children > a,\n.application-menu.is-personalizable .accordion.panel .accordion-header.has-filtered-children.is-focused {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.application-menu.is-personalizable .searchfield-wrapper .searchfield::placeholder {\n  color: ").concat(colors.contrast, ";\n  opacity: .5;\n}\n\n.application-menu.is-personalizable .searchfield-wrapper .icon {\n  color: ").concat(colors.contrast, ";\n  opacity: .8;\n}\n\n.application-menu.is-personalizable .searchfield-wrapper.active .icon {\n  color: ").concat(colors.contrast, ";\n  opacity: 1;\n}\n\n.application-menu.is-personalizable .application-menu-switcher-panel,\n.application-menu.is-personalizable .application-menu-switcher-panel .accordion.panel,\n.application-menu.is-personalizable .application-menu-switcher-panel .accordion.panel .accordion-header {\n  background-color: ").concat(colors.base, " !important;\n  border-top-color: transparent;\n}\n\n.application-menu.is-personalizable .application-menu-switcher-panel .accordion.panel .accordion-header:hover {\n  background-color: ").concat(colors.darkest, " !important;\n}\n\n.application-menu.is-personalizable .application-menu-switcher-panel .accordion-heading {\n  border-top-color: ").concat(colors.darkest, ";\n}\n\n.application-menu.is-personalizable .searchfield-wrapper {\n  background-color: ").concat(colors.base, ";\n  border-bottom: none !important;\n}\n\nhtml[dir='rtl'] .application-menu.is-personalizable {\n  background-color: ").concat(colors.lighter, ";\n  border-left: ").concat(colors.light, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable button svg.ripple-effect {\n  background-color: ").concat(colors.contrast, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable {\n  background-color: ").concat(colors.lighter, ";\n  border-right: ").concat(colors.light, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .application-menu-header {\n  background-color: ").concat(colors.lighter, ";\n  border-bottom-color: ").concat(colors.light, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .application-menu-footer {\n  background-color: ").concat(colors.lighter, ";\n  border-top-color: ").concat(colors.light, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .searchfield-wrapper {\n  background-color: ").concat(colors.dark, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-header {\n  background-color: transparent !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-header:hover {\n  background-color: ").concat(colors.darkest, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-header.is-selected {\n  background-color: ").concat(colors.darkest, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-header .icon.plus-minus::before {\n  background-color: ").concat(colors.subtext, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-header .icon.plus-minus::after {\n  background-color: ").concat(colors.subtext, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-pane {\n  background-color: transparent !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse .accordion-pane .accordion-header {\n  color: ").concat(colors.subtext, ";\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-expanded {\n  background-color: ").concat(colors.dark, " !important;\n  color: ").concat(colors.subtext, " !important;\n}\n\nhtml[class*=\"theme-uplift\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-focused:not(.hide-focus):not(.is-expanded) {\n  border-color: ").concat(colors.contrast, " !important;\n}\n\nhtml[class*=\"theme-uplift\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-focused.is-expanded {\n  border-color: transparent !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-expanded.is-selected::before {\n  background-color: ").concat(colors.darker, " !important;\n  border-color: ").concat(colors.darker, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-expanded.is-focused::before {\n  border-color: ").concat(colors.contrast, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-expanded + .accordion-pane {\n  background-color: ").concat(colors.dark, " !important;\n}\n\nhtml[class*=\"theme-uplift-\"] .application-menu.is-personalizable .accordion.panel.inverse > .accordion-header.is-expanded:hover::before {\n  border-color: ").concat(colors.darkest, " !important;\n  background-color: ").concat(colors.darkest, " !important;\n}\n\n.is-personalizable .personalize-header,\n.is-personalizable.tab-container {\n  background-color: ").concat(colors.dark, " !important;\n}\n\n.is-personalizable .personalize-subheader {\n  background-color: ").concat(colors.lighter, " !important;\n}\n\n.is-personalizable .personalize-text {\n  color: ").concat(colors.contrast, " !important;\n}\n\n.is-personalizable .personalize-actionable,\n.is-personalizable .personalize-actionable svg {\n  color: ").concat(colors.contrast, ";\n  opacity: .8;\n}\n\n.is-personalizable .personalize-actionable:hover:not([disabled]),\n.is-personalizable .personalize-actionable:hover:not([disabled]) svg {\n  color: ").concat(colors.contrast, ";\n  opacity: 1;\n}\n\n.is-personalizable .personalize-actionable.is-focused:not(.hide-focus),\n.is-personalizable .personalize-actionable:focus:not(.hide-focus) {\n  border-color: ").concat(colors.contrast, ";\n  box-shadow: 0 0 4px 3px rgba(0, 0, 0, 0.2);\n}\n\n.is-personalizable .personalize-actionable.hyperlink:focus:not(.hide-focus)::after {\n  border-color: ").concat(colors.contrast, ";\n  opacity: 1;\n  box-shadow: 0 0 4px 3px rgba(0, 0, 0, 0.2);\n}\n\n.is-personalizable .personalize-vertical-border {\n  border-color: ").concat(colors.light, ";\n}\n\n.is-personalizable .personalize-horizontal-bottom-border {\n  border-bottom: 1px solid ").concat(colors.darkest, ";\n}\n\n.is-personalizable .personalize-horizontal-top-border {\n  border-top: 1px solid: ").concat(colors.darkest, ";\n}\n\n.is-personalizable .personalize-chart-targeted .total.bar {\n  background-color: rgba(255, 255, 255, .8);\n}\n\n.is-personalizable .personalize-chart-targeted .chart-percent-text,\n.is-personalizable .personalize-chart-targeted .label {\n  color: ").concat(colors.text, ";\n}\n\n.is-personalizable .info-message,\n.is-personalizable .info-message .icon,\n.is-personalizable .info-message p {\n  color: ").concat(colors.text, " !important;\n}\n\n.is-personalizable .personalize-actionable-disabled,\n.is-personalizable .personalize-actionable-disabled:hover {\n  opacity: .4 !important;\n  cursor: default;\n}\n\n.hero-widget.is-personalizable .hero-header .chart-container .arc,\n.hero-widget.is-personalizable .hero-header .chart-container .bar,\n.hero-widget.is-personalizable .hero-header .chart-container.line-chart .dot,\n.hero-widget.is-personalizable .hero-content .chart-container .arc,\n.hero-widget.is-personalizable .hero-content .chart-container .bar,\n.hero-widget.is-personalizable .hero-content .chart-container.line-chart .dot,\n.hero-widget.is-personalizable .hero-footer .chart-container .arc,\n.hero-widget.is-personalizable .hero-footer .chart-container .bar,\n.hero-widget.is-personalizable .hero-footer .chart-container.line-chart .dot {\n    stroke: ").concat(colors.lighter, " !important;\n}\n\n.hero-widget.is-personalizable .hero-header .chart-container text,\n.hero-widget.is-personalizable .hero-content .chart-container text,\n.hero-widget.is-personalizable .hero-footer .chart-container text {\n    fill: ").concat(colors.text, " !important;\n}\n\n.hero-widget.is-personalizable .hero-header .chart-container .chart-legend-item-text,\n.hero-widget.is-personalizable .hero-content .chart-container .chart-legend-item-text,\n.hero-widget.is-personalizable .hero-footer .chart-container .chart-legend-item-text {\n  color: ").concat(colors.text, ";\n  fill: ").concat(colors.text, ";\n}\n\n.hero-widget.is-personalizable .hero-header .chart-container .axis path, .chart-container .axis line,\n.hero-widget.is-personalizable .hero-header .chart-container .axis .tick0 line {\n  stroke: ").concat(colors.subtext, " !important;\n}\n\n.hero-widget.is-personalizable .hero-header .title,\n.hero-widget.is-personalizable .hero-content .title,\n.hero-widget.is-personalizable .hero-footer .title {\n  color: ").concat(colors.subtext, ";\n}\n\n.hero-widget.is-personalizable .hero-header .btn-tertiary,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary),\n.hero-widget.is-personalizable .hero-content .btn-tertiary,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary),\n.hero-widget.is-personalizable .hero-footer .btn-tertiary,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary),\n.hero-widget.is-personalizable .hero-header .btn-tertiary .icon,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span .icon,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary) .icon,\n.hero-widget.is-personalizable .hero-content .btn-tertiary .icon,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span .icon,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary) .icon,\n.hero-widget.is-personalizable .hero-footer .btn-tertiary .icon,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span .icon,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary) .icon\n {\n  color: ").concat(colors.subtext, ";\n}\n\n.hero-widget.is-personalizable .hero-header .btn-tertiary:hover,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:hover,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):hover,\n.hero-widget.is-personalizable .hero-content .btn-tertiary:hover,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:hover,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):hover,\n.hero-widget.is-personalizable .hero-footer .btn-tertiary:hover,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:hover,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):hover,\n.hero-widget.is-personalizable .hero-header .btn-tertiary:hover .icon,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:hover .icon,\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):hover .icon,\n.hero-widget.is-personalizable .hero-content .btn-tertiary:hover .icon,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:hover .icon,\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):hover .icon,\n.hero-widget.is-personalizable .hero-footer .btn-tertiary:hover .icon,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:hover .icon,\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):hover .icon\n {\n  color: ").concat(colors.text, ";\n}\n\n.hero-widget.is-personalizable .hero-header .btn-tertiary:focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-header .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-content .btn-tertiary:focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-content .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-footer .btn-tertiary:focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary).is-open span:focus:not(.hide-focus),\n.hero-widget.is-personalizable .hero-footer .btn-menu:not(.btn):not(.btn-primary):not(.btn-secondary):not(.btn-tertiary):focus:not(.hide-focus) {\n  box-shadow: 0 0 0 2px transparent,\n    0 0 0 1px ").concat(colors.subtext, ",\n    0 0 2px 1px ").concat(colors.subtext, ";\n}\n\n.header.is-personalizable .toolbar [class^='btn']:focus:not(.hide-focus),\n.header.is-personalizable .flex-toolbar [class^='btn']:focus:not(.hide-focus),\n.subheader.is-personalizable .toolbar [class^='btn']:focus:not(.hide-focus),\n.subheader.is-personalizable .flex-toolbar [class^='btn']:focus:not(.hide-focus) {\n  box-shadow: 0 0 0 2px transparent,\n    0 0 0 1px ").concat(colors.subtext, ",\n    0 0 2px 1px ").concat(colors.subtext, ";\n}\n\n/*\n.tooltip.is-personalizable {\n  background-color: ").concat(colors.darkest, ";\n  border-color: ").concat(colors.darkest, ";\n}\n.tooltip.is-personalizable .chart-swatch .swatch-row div {\n  border-bottom-color: ").concat(colors.darkest, ";\n}\n.tooltip.is-personalizable,\n.tooltip.is-personalizable p,\n.tooltip.is-personalizable .chart-swatch .swatch-row span,\n.tooltip.is-personalizable .chart-swatch .swatch-row b {\n  color: ").concat(colors.tooltipText, ";\n}\n.tooltip.is-personalizable.top .arrow::after {\n  border-top-color: ").concat(colors.darkest, ";\n}\n.tooltip.is-personalizable.right .arrow::after {\n  border-right-color: ").concat(colors.darkest, ";\n}\n.tooltip.is-personalizable.bottom .arrow::after {\n  border-bottom-color: ").concat(colors.darkest, ";\n}\n.tooltip.is-personalizable.left .arrow::after {\n  border-left-color: ").concat(colors.darkest, ";\n}\n*/\n    ");
  }

  var COMPONENT_NAME = 'personalize'; // Component Defaults

  var PERSONALIZE_DEFAULTS = {
    colors: '',
    theme: '',
    font: '',
    blockUI: true,
    noInit: false
  };
  /**
   * The personalization routines for setting custom company colors.
   *
   * @class Personalize
   * @param {HTMLElement|jQuery[]} element The base element
   * @param {object} [settings] Incoming settings
   * @param {string} [settings.colors]  The list of colors
   * @param {string} [settings.theme] The theme name (light, dark or high-contrast)
   * @param {string} [settings.font] Use the newer source sans font
   * @param {boolean} [settings.blockUI=true] Cover the UI and animate when changing theme.
   * @param {boolean} [settings.noInit=false] If true, prevents automatic setup of personalized theme/colors/font, allowing for manual triggering at a more convenient time.
   */

  function Personalize(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, PERSONALIZE_DEFAULTS);
    this.init();
  } // Plugin Methods


  Personalize.prototype = {
    /**
     * Runs on each initialization
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      this.handleEvents(); // Skip automatic setup of theme/colors/font.

      if (this.settings.noInit) {
        return this;
      }

      if (this.settings.theme) {
        this.setTheme(this.settings.theme);
      } else {
        this.setTheme(this.getThemeFromStylesheet());
      }

      if (this.settings.colors) {
        this.setColors(this.settings.colors);
      }

      if (this.settings.font) {
        this.setFont(this.settings.font);
      }

      return this;
    },

    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.element.off("updated.".concat(COMPONENT_NAME)).on("updated.".concat(COMPONENT_NAME), function () {
        self.updated();
      });
      return this;
    },

    /**
     * Create new CSS rules in head and override any existing
     * @private
     * @param {object} cssRules The rules to append.
     */
    appendStyleSheet: function appendStyleSheet(cssRules) {
      var sheet = document.getElementById('soho-personalization');

      if (sheet) {
        sheet.parentNode.removeChild(sheet);
      } // Create the <style> tag


      sheet = document.createElement('style');
      sheet.setAttribute('id', 'soho-personalization');
      sheet.appendChild(document.createTextNode(cssRules)); // Add the <style> element to the page

      document.head.appendChild(sheet);
    },

    /**
     * Generate a style sheet to append in the page.
     * @private
     * @param {array} colors The rules to append.
     * @returns {string} The string of css to append.
     */
    getColorStyleSheet: function getColorStyleSheet(colors) {
      if (!colors) {
        colors = {};
      } // Use an incoming `colors` param defined as a string, as the desired
      // "header" color (backwards compatibility)


      if (typeof colors === 'string') {
        colors = {
          header: colors
        };
      }

      if (!colors || colors === '') {
        return this;
      } // Default Colors...
      // (Color)07 for the main color (fx headers)
      // (Color)06 for the secondary color (fx sub-headers)
      // Light or Dark (fff or 000) for the contrast color
      // (Color)06 for the vertical borders between module tabs - 133C59
      // (Color)07 for the page header and active module tab - 2578A9 DEFAULT
      // (Color)08 for the inactive module tab - 1d5f8a
      // (Color)09 for the horizontal border - 134D71
      // (Color)10 for the hover state on module tab - 133C59


      var defaultColors = {
        header: '2578A9'
      }; // Pass in a standard set of theme-specific colors.
      // These colors aren't personalized, but they may need to be referenced
      // within the personalization colors CSS generator.

      var themeColors = theme.themeColors();
      colors.theme = {};
      colors.theme.bg = themeColors.components.body.primary.background.value;
      colors.theme.altbg = themeColors.components.body.secondary.background.value;
      colors.theme.text = themeColors.components.body.primary.font.value;
      colors.theme.altText = themeColors.components.body.secondary.background.value;
      colors.theme.disabledText = themeColors.brand.secondary.alt.value;
      var dark = false;
      var contrast = false;
      var uplift = false;

      if (themeColors.themeName.indexOf('contrast') > -1) {
        contrast = true;
      }

      if (themeColors.themeName.indexOf('dark') > -1) {
        dark = true;
      }

      if (themeColors.themeName.indexOf('uplift') > -1) {
        uplift = true;
      }

      colors.theme.props = {
        contrast: contrast,
        dark: dark,
        uplift: uplift
      }; // Force to be light text on custom colors { color: ['soho', 'uplift'] }

      var forceToBeLightTextOn = {
        amber: ['#db7726', '#bb5500'],
        // amber 09
        amethyst: ['#9279a6', '#7834dd'],
        // amethyst 06
        azure: ['#2578a9', '#0563c2', '#368AC0', '#368ac0'],
        // azure 07/08
        emerald: ['#56932e', '#1f9254'],
        // emerald 08
        graphite: ['#5c5c5c', '#808080'],
        // graphite 06
        ruby: ['#941e1e', '#7b0f11'],
        // ruby 09
        slate: ['#50535a', '#98949e'],
        // slate 06
        turquoise: ['#206b62', '#297b7b'] // turquoise 09

      };
      var foundColor = false;
      var isDark = "".concat(colors.header || defaultColors.header).toLowerCase();
      isDark = colorUtils.validateHex(isDark);
      Object.keys(forceToBeLightTextOn).forEach(function (color) {
        foundColor = foundColor || forceToBeLightTextOn[color].indexOf(isDark) > -1;
      });
      isDark = foundColor ? 'white' : null; // Evaluate text contrast colors.
      // If the primary color is too "bright", this will flip the text color to black.

      var lightest = colorUtils.validateHex(colors.lightest || colorUtils.getLuminousColorShade(colors.header || defaultColors.header, 0.3));
      var textContrastColor = colorUtils.getContrastColor(lightest, null, isDark);

      if (textContrastColor === 'white') {
        defaultColors.text = 'ffffff';
        defaultColors.subtext = 'f0f0f0';
      } else {
        defaultColors.text = '000000';
        defaultColors.subtext = '292929';
      } // If an event sends a blank string through instead of a hex,
      // reset any color values back to the theme defaults.  Otherwise, get a valid hex value.


      colors.header = colorUtils.validateHex(colors.header || defaultColors.header);
      colors.text = colorUtils.validateHex(colors.text || defaultColors.text);
      colors.subtext = colorUtils.validateHex(colors.subtext || defaultColors.subtext);
      colors.btnColorHeader = colorUtils.validateHex(colors.btnColorHeader || colorUtils.getLuminousColorShade(colors.header, 0.3));
      colors.subheader = colorUtils.validateHex(colors.subheader || colorUtils.getLuminousColorShade(colors.header, 0.2));
      colors.verticalBorder = colorUtils.validateHex(colors.verticalBorder || colorUtils.getLuminousColorShade(colors.header, 0.1)); // Darker

      colors.btnColorSubheader = colorUtils.validateHex(colors.btnColorSubheader || colorUtils.getLuminousColorShade(colors.header, -0.1));
      colors.inactive = colorUtils.validateHex(colors.inactive || colorUtils.getLuminousColorShade(colors.header, -0.2));
      colors.horizontalBorder = colorUtils.validateHex(colors.horizontalBorder || colorUtils.getLuminousColorShade(colors.header, -0.3)); // Legacy

      colors.hover = colorUtils.validateHex(colors.hover || colorUtils.getLuminousColorShade(colors.header, -0.5));
      colors.button = colorUtils.validateHex(colors.button || colorUtils.getLuminousColorShade(colors.text, -0.8));
      colors.lightest = colors.btnColorHeader;
      colors.lighter = colors.subheader;
      colors.light = colors.verticalBorder;
      colors.base = colors.header;
      colors.contrast = colors.text;
      colors.dark = colors.btnColorSubheader;
      colors.darker = colors.inactive;
      colors.darkest = colors.horizontalBorder; // Some disabled colors on some preset color schemes come out terrible,
      // unless they are adjusted here. { color: ['soho', 'uplift'] }
      // The alternate color is generally less luminous and less color-saturated (more gray).

      var alternateDisabledColors = {
        amber: ['#db7726', '#bb5500'],
        // amber 09
        amethyst: ['#9279a6', '#7834dd'],
        // amethyst 06
        emerald: ['#56932e', '#1f9254'],
        // emerald 08
        slate: ['#50535a', '#98949e'] // slate 06

      };
      var useAlternates = false;
      var fixedVal = colorUtils.validateHex("".concat(colors.header || defaultColors.header).toLowerCase());
      Object.keys(alternateDisabledColors).forEach(function (color) {
        useAlternates = useAlternates || alternateDisabledColors[color].indexOf(fixedVal) > -1;
      }); // Start with standard Soho values

      var baseColor = colors.light;
      var lum = useAlternates ? 0.5 : 0.7;
      var sat = useAlternates ? 0.3 : 0.5;

      if (!uplift) {
        // Soho adjustments go here
        if (dark) {
          baseColor = colors.darkest;
          lum = -0.1;
        } else if (contrast) {
          lum = 0.3;
        }
      } else {
        // Uplift adjustments go here
        lum = useAlternates ? 0.6 : 0.8;
        sat = useAlternates ? 0.6 : 0.8;

        if (dark) {
          baseColor = colors.darkest;
          lum = 0.1;
        } else if (contrast) {
          lum = 0.8;
          sat = 0.4;
        }
      }

      var disabledBGColor = colorUtils.getLuminousColorShade(baseColor, lum);
      disabledBGColor = colorUtils.getDesaturatedColor(disabledBGColor, sat);
      colors.baseDisabled = disabledBGColor; // Hyperlink/Text Selection

      colors.hyperlinkText = dark ? colors.dark : colors.lighter;
      colors.hyperlinkTextHover = dark ? colors.darker : colors.lightest;
      colors.selection = dark ? colors.darker : colors.lightest;
      var tooltipContrast = colorUtils.getContrastColor(colors.darkest);
      defaultColors.tooltipText = tooltipContrast === 'white' ? 'ffffff' : '000000';
      colors.tooltipText = colorUtils.validateHex(colors.tooltipText || defaultColors.tooltipText);
      return personalizeStyles(colors);
    },

    /**
     * Set the font
     * @param {string} font The font name
     */
    setFont: function setFont(font) {
      $('html').addClass("font-".concat(font));
    },

    /**
    * Sets the personalization color(s)
    * @param {array} colors The original hex color as a string or an object with all the Colors
    * @returns {this} component instance
    */
    setColors: function setColors(colors) {
      if (colors === '') {
        this.setColorsToDefault();
        return this;
      }

      if (!colors) {
        return this;
      }

      this.appendStyleSheet(this.getColorStyleSheet(colors)); // record state of colors in settings

      this.settings.colors = colors;
      /**
      * Fires after the colors are changed.
      * @event colorschanged
      * @memberof Personalize
      * @property {object} event - The jquery event object
      * @property {object} args - The event args
      * @property {string} args.colors - The color(s) changed to.
      */

      this.element.triggerHandler('colorschanged', {
        colors: this.settings.colors.header || this.settings.colors || theme.themeColors().brand.primary.alt.value,
        isDefault: false,
        theme: this.currentTheme || 'theme-soho-light'
      });
      return this;
    },

    /**
     * Sets the colors back to the default color (by removing the geneated stylesheet).
     */
    setColorsToDefault: function setColorsToDefault() {
      this.settings.colors = '';
      var sheet = document.getElementById('soho-personalization');

      if (sheet) {
        sheet.parentNode.removeChild(sheet);
      }

      this.element.triggerHandler('colorschanged', {
        colors: theme.themeColors().brand.primary.alt.value,
        isDefault: true,
        theme: this.currentTheme || 'theme-soho-light'
      });
    },

    /**
     * Detect the current theme based on the style sheet.
     * @private
     * @returns {string} The current theme.
     */
    getThemeFromStylesheet: function getThemeFromStylesheet() {
      var css = $('#stylesheet, #sohoxi-stylesheet');
      var thisTheme = '';

      if (css.length > 0) {
        var path = css.attr('href');
        thisTheme = path.substring(path.lastIndexOf('/') + 1); // trim query string off the end if it exists
        // something like ?v=123 may be used for cache busting or build identifiers

        var queryParamIndex = thisTheme.lastIndexOf('?');

        if (queryParamIndex > -1) {
          thisTheme = thisTheme.slice(0, queryParamIndex);
        } // trim the file extensions off the end


        thisTheme = thisTheme.replace('.min', '').replace('.css', '');
      }

      return thisTheme;
    },

    /**
    * Sets the current theme, blocking the ui during the change.
    * @param {string} incomingTheme  Represents the file name of a color
    * scheme (can be dark, light or high-contrast)
    */
    setTheme: function setTheme(incomingTheme) {
      var $html = $('html');

      if (!incomingTheme) {
        return;
      } // Somehow colorpicker uses this, so keep it


      this.currentTheme = incomingTheme;

      if (theme.currentTheme.id === incomingTheme) {
        if (!$html.hasClass(incomingTheme)) {
          $html.addClass(incomingTheme);
        }

        return;
      } // Adapt them for backwards compatibility


      var legacyThemeNames = ['light', 'dark', 'high-contrast'];

      if (legacyThemeNames.indexOf(incomingTheme) > -1) {
        incomingTheme += '-theme';
      }

      $html.removeClass(function (idx, val) {
        var classes = val.split(' ');
        var toRemove = classes.filter(function (c) {
          return c.indexOf('theme') > -1;
        });
        return toRemove.join();
      }).addClass(incomingTheme);
      this.blockUi();
      var self = this;
      var originalCss = $('#stylesheet, #sohoxi-stylesheet');
      var newCss = $('<link rel="stylesheet">');
      var path = originalCss.attr('href');
      newCss.on('load', function () {
        originalCss.remove();
        self.unBlockUi();
        self.triggerEvent(incomingTheme);
      }).on('error', function () {
        self.unBlockUi();
      });
      var themePath = path ? path.substring(0, path.lastIndexOf('/')) : '';
      var isMin = path ? path.indexOf('.min') > -1 : false;
      newCss.attr({
        id: originalCss.attr('id'),
        href: xssUtils.stripTags("".concat(themePath, "/").concat(incomingTheme).concat(isMin ? '.min' : '', ".css"))
      });
      originalCss.removeAttr('id'); // Add new stylesheet before current stylesheet
      // to give it time to parse/render before revealing it

      originalCss.before(newCss); // record state of theme in settings

      this.settings.theme = incomingTheme;
      theme.setTheme(incomingTheme); // Do another color reset, if applicable

      this.setColors(this.settings.colors);
    },

    /**
     * Builds a temporary page overlay that prevents end users from experiencing FOUC
     * @private
     * @returns {void}
     */
    blockUi: function blockUi() {
      var self = this;

      if (!self.settings.blockUI) {
        return;
      }

      var backgroundColor = '#bdbdbd';

      switch (theme) {
        case 'light':
          backgroundColor = '#f0f0f0';
          break;

        case 'dark':
          backgroundColor = '#313236';
          break;

        case 'high-contrast':
          backgroundColor = '#d8d8d8';
          break;

        default:
          backgroundColor = '#f0f0f0';
      }

      this.pageOverlay = this.pageOverlay || $('<div class="personalize-overlay"></div>');
      this.pageOverlay.css('background', backgroundColor);
      $('body').append(this.pageOverlay);
    },

    /**
     * Trigger the change events.
     * @private
     * @param {string} incomingTheme Represents the file name of a color
     * @returns {void}
     */
    triggerEvent: function triggerEvent(incomingTheme) {
      /**
      * Fires after the theme is changed
      * @event themechanged
      * @memberof Personalize
      * @property {object} event - The jquery event object
      * @property {object} args - The event args
      * @property {string} args.theme - The theme id changed to.
      */
      this.element.triggerHandler('themechanged', {
        colors: this.settings.colors.header || this.settings.colors || theme.themeColors().brand.primary.alt.value,
        theme: incomingTheme || 'theme-soho-light'
      });
      $('body').trigger('resize');
    },

    /**
     * Removes a temporary page overlay built by `blockUi()`
     * @private
     * @returns {void}
     */
    unBlockUi: function unBlockUi() {
      var self = this;

      if (!self.settings.blockUI || !self.pageOverlay) {
        return;
      }

      self.pageOverlay.fadeOut(300, function () {
        self.pageOverlay.remove();
        self.pageOverlay = undefined;
      });
    },

    /**
     * Handle Updating Settings
     * @param {object} settings Incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (!settings) {
        return this;
      } // Copy the old settings to compare


      var prevSettings = utils.extend({}, this.settings); // Merge in the new settings

      this.settings = utils.mergeSettings(this.element[0], settings, this.settings);

      if (this.settingsDidChange(prevSettings, 'theme')) {
        this.setTheme(this.settings.theme);
      }

      if (this.settingsDidChange(prevSettings, 'colors')) {
        this.setColors(this.settings.colors);
      }

      if (this.settingsDidChange(prevSettings, 'font')) {
        this.setFont(this.settings.font);
      }

      return this;
    },

    /**
     * Compare previous settings to current settings
     * @param {object} prevSettings The previous settings object
     * @param {string} prop The property to compare
     * @returns {boolean} If the settings changed
     */
    settingsDidChange: function settingsDidChange(prevSettings, prop) {
      return this.settings[prop] && this.settings[prop] !== prevSettings[prop];
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * Ideally this will do non-destructive things that make it possible to easily rebuild
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off("updated.".concat(COMPONENT_NAME));
      return this;
    },

    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME);
    }
  };

  var instanceSettings$1 = {
    theme: 'theme-soho-light'
  };

  if (_typeof(window.SohoConfig) === 'object' && _typeof(window.SohoConfig.personalize) === 'object') {
    instanceSettings$1 = window.SohoConfig.personalize;
  }
  /**
   * Setup a single instance of the Personalization system on the HTML tag.
   * Personalization is top-level.
   */


  var personalization = new Personalize(document.documentElement, instanceSettings$1);

  /**
   * Hooks that match up to methods in the Personalization system,
   * that need to exist on the Soho object for backwards-compatibility reasons.
   * These exported functions end up on the Soho object during the bootstrapping process.
   * TODO: make this not the preferred way of accessing these methods, and instead
   * prefer access to the global `Personalize`
   */
  function setTheme(theme) {
    return personalization.setTheme(theme);
  }
  function setColors(colors) {
    return personalization.setColors(colors);
  }
  function getColorStyleSheet(colors) {
    return personalization.getColorStyleSheet(colors);
  }

  /**
   * jQuery Component Wrapper for Personalize
   * NOTE: One instance of the Personalzation system can exist at any time, and is applied
   * to the <body> tag. When an app developer calls this directly, it's assumed that the
   * personalization system has already been established (during bootstrapping) and simply
   * needs to be updated with current settings.
   * @param {object} [settings] incoming Settings
   * @returns {jQuery[]} elements to be acted on
   */

  $.fn.personalize = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME);

      if (!instance) {
        instance = $.data(this, COMPONENT_NAME, personalization);
      }

      instance.updated(settings);
    });
  };

  // ====================================================
  // Soho Form/Element Utilities
  // ====================================================
  // Note marked these private so the doc generator doesnt work on them.
  // These should be refactored into an ES6 FormUtils component.

  /*
   * Make elements in the jQuery selector disabled if they support the prop disabled.
   * Or has a disable method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */
  $.fn.disable = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.disable) {
        value.disable();
      }
    });
    this.prop('disabled', true);
    this.attr('disabled', true).closest('.field').addClass('is-disabled');
    return this;
  };
  /*
   * Make elements in the jQuery selector enabled if they support the prop disabled.
   * Or has a enable method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */


  $.fn.enable = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.enable) {
        value.enable();
      }
    });
    this.prop({
      disabled: false,
      readonly: false
    });
    this.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    return this;
  };
  /*
   * Make elements in the jQuery selector readonly if they support the prop readonly.
   * Or has a readonly method.
   * @private
   * @returns {jQuery[]} processed, jQuery-wrapped elements
   */


  $.fn.readonly = function () {
    $.each(this.data(), function (index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value && value.readonly) {
        value.readonly();
      }
    });
    this.prop('readonly', true);
    return this;
  };
  /*
   * Make password fields have a reveal text to obsucure or not obsucure the text value.
   */


  $.fn.revealText = function (settings) {
    if (!this) {
      return this;
    }

    var input = this; // Set the initial state

    input.addClass((settings === null || settings === void 0 ? void 0 : settings == null ? void 0 : settings.initialState) === 'show' ? 'input-show-text' : 'input-hide-text');
    input.addClass('input-hidepass'); // Add a text span and click events

    var textSpan = $("<span class=\"input-hideshow-text\">".concat(Soho.Locale.translate((settings === null || settings === void 0 ? void 0 : settings == null ? void 0 : settings.initialState) === 'show' ? 'Hide' : 'Show'), "</span>")); // eslint-disable-line

    input.after(textSpan); // Handle Events

    var toggleText = function toggleText() {
      var textHidden = input.hasClass('input-hide-text');

      if (textHidden) {
        input.removeClass('input-hide-text').addClass('input-show-text');
        input.attr('type', 'text');
        textSpan.text(Soho.Locale.translate('Hide')); // eslint-disable-line

        return;
      }

      input.removeClass('input-show-text').addClass('input-hide-text');
      input.attr('type', 'password');
      textSpan.text(Soho.Locale.translate('Show')); // eslint-disable-line
    };

    textSpan.on('click', function () {
      toggleText();
    });
    input.on('keypress', function (e) {
      // Toggle on Ctrl + R
      if (e.keyCode === 18 && e.ctrlKey) {
        toggleText();
      }
    });
    return this;
  }; // Fix: Labels without the "for" attribute


  $(function () {
    var str;
    var control;
    var labelText = $('.label-text');
    var labels = labelText.closest('label, .label');
    labels.each(function () {
      control = $('input, textarea, select', this);
      str = control.attr('class'); // Add "inline" and "inline-{control}" class to label
      // assuming control class is first thing in class string

      $(this).addClass(function () {
        return "inline".concat(str ? " inline-".concat(str.indexOf(' ') === -1 ? str : str.substr(0, str.indexOf(' '))) : '');
      });
    });
  }); // Fix: Radio buttons was not selecting when click and than use arrow keys on Firefox

  $(function () {
    $('input:radio').on('click.radios', function () {
      this.focus();
    });
  }); // Add css classes to parent for apply special rules

  $(function () {
    var addCssClassToParent = function addCssClassToParent(elemArray, cssClass) {
      for (var i = 0, l = elemArray.length; i < l; i++) {
        $(elemArray[i]).parent().addClass(cssClass);
      }
    };

    addCssClassToParent($('.field > input:checkbox, .field > .inline-checkbox'), 'field-checkbox');
    addCssClassToParent($('.field > input:radio, .field > .inline-radio'), 'field-radio');
  });
  $(function () {
    // Add `*` to required labels
    var selector = 'label.required .label-text, .label.required .label-text, label:not(.inline).required, .label:not(.inline).required';
    var labels = [].slice.call(document.body.querySelectorAll(selector));
    labels.forEach(function (label) {
      if (label.className.indexOf('accessible') === -1) {
        return;
      }

      var asterisk = label.querySelector('.required-asterisk');

      if (!asterisk) {
        label.insertAdjacentHTML('beforeend', '<span class="required-asterisk" aria-hidden="true">*</span>');
      }
    }); // Add `aria-required` to required elements

    var elements = [].slice.call(document.body.querySelectorAll('[data-validate]'));
    elements.forEach(function (el) {
      var rules = el.getAttribute('data-validate');

      if (rules && rules.indexOf('required') > -1) {
        el.setAttribute('aria-required', true);
      }
    }); // Add `aria-hidden` to hidden elements label

    elements = [].slice.call(document.body.querySelectorAll('input[type="hidden"]'));
    elements.forEach(function (el) {
      var id = el.getAttribute('id');

      if (id) {
        var label = document.body.querySelector("label[for=\"".concat(id, "\"]"));

        if (label) {
          label.setAttribute('aria-hidden', true);
        }
      }
    });
  });

  // Text Highlight/Unhighlight Control
  // Originally called "highlight v5" by Johann Burkard
  // http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
  //
  // Modified for IDS Enterprise (TODO: bit.ly link to docs)
  function innerHighlight(node, pat) {
    var skip = 0;
    var pos;
    var spannode;
    var middlebit;
    var middleclone;

    if (node.nodeType === 3) {
      pos = node.data.toUpperCase().indexOf(pat);
      pos -= node.data.substr(0, pos).toUpperCase().length - node.data.substr(0, pos).length;

      if (pos >= 0) {
        spannode = document.createElement('mark');
        spannode.className = 'highlight';
        middlebit = node.splitText(pos);
        middlebit.splitText(pat.length);
        middleclone = middlebit.cloneNode(true);
        spannode.appendChild(middleclone);
        middlebit.parentNode.replaceChild(spannode, middlebit);
        skip = 1;
      }
    } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
      for (var i = 0; i < node.childNodes.length; ++i) {
        i += innerHighlight(node.childNodes[i], pat);
      }
    }

    return skip;
  }
  /**
   * Highlight a portion of text inside an element
   * @param {string} pat portion of text that's being highlighted
   * @returns {this} this
   */


  $.fn.highlight = function (pat) {
    if (this.length && pat && pat.length) {
      return this.each(function () {
        innerHighlight(this, pat.toUpperCase());
      });
    }

    return this;
  };
  /**
   * Removes highlighting from portions of text inside an element
   * @returns {this} this
   */


  $.fn.unhighlight = function () {
    return this.find('mark.highlight').each(function () {
      var node = this.parentNode;
      node.replaceChild(this.firstChild, this);
      node.normalize();
    }).end();
  };

  var COMPONENT_NAME$1 = 'arrange';
  /**
  * The Arrange Component allows touch and drag support to sort UI items.
  * @class Arrange
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.handle] The CSS class name of the handle element to connect
  * @param {string} [settings.itemsSelector] The CSS selector to match all the sortable elements.
  * @param {string} [settings.connectWith] Optional CSS Selector to connect with when using two lists
  * @param {boolean} [settings.isVisualItems] Use only index of visual items to trigger
  * @param {string} [settings.placeholder] The html for the element that appears while dragging
  * @param {string} [settings.placeholderCssClass='arrange-placeholder'] The class to add to the ghost element that is being dragged.
  */

  var ARRANGE_DEFAULTS = {
    handle: null,
    // The Class of the handle element
    itemsSelector: null,
    connectWith: false,
    isVisualItems: false,
    placeholder: null,
    placeholderCssClass: 'arrange-placeholder'
  };

  function Arrange(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ARRANGE_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Arrange Methods


  Arrange.prototype = {
    // example from: https://github.com/farhadi/html5arrangeable/blob/master/jquery.arrangeable.js
    init: function init() {
      this.isTouch = Environment.features.touch;
      this.isIe = Environment.browser.name === 'ie';
      this.handleEvents();
    },

    /**
     * Get Element By Touch In List
     * @private
     * @param {object} list element.
     * @param {number} x value.
     * @param {number} y value.
     * @returns {object} item found in list
     */
    getElementByTouchInList: function getElementByTouchInList(list, x, y) {
      var returns = false;
      var listJq = $(list);

      for (var i = 0, l = listJq.length; i < l; i++) {
        var item = $(listJq[i]);
        var offset = item.offset();

        if (!(x <= offset.left || x >= offset.left + item.outerWidth() || y <= offset.top || y >= offset.top + item.outerHeight())) {
          returns = item;
        }
      }

      return returns;
    },

    /**
     * Dragg touch element
     * @private
     * @param {object} e as event.
     * @param {object} elm as element.
     * @returns {void}
     */
    dragTouchElement: function dragTouchElement(e, elm) {
      var orig = e.originalEvent.changedTouches[0];
      elm[0].style.top = "".concat(orig.pageY - this.offset.y, "px");
      elm[0].style.left = "".concat(orig.pageX - this.offset.x, "px");
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.items.removeClass('draggable').removeAttr('draggable').off("selectstart.arrange ".concat(this.dragStart, " ").concat(this.dragEnd, " ").concat(this.dragWhileDragging));
      $(this.handle, this.items).removeClass('draggable').off('mousedown.arrange mouseup.arrange touchstart.arrange touchend.arrange');
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, ARRANGE_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$1);
    },

    /**
     * Find out the visual index to trigger
     * @private
     * @param {object} elem to get index number.
     * @returns {number} the index
     */
    getVisualIndex: function getVisualIndex(elem) {
      var s = this.settings;
      var idx = null;

      if (s.isVisualItems) {
        var items = this.element.children().not('[data-arrange-exclude="true"]');

        if (s.itemsSelector) {
          items = $(s.itemsSelector, this.element).not('[data-arrange-exclude="true"]');
        }

        idx = items.index(elem);
      }

      return idx;
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var s = this.settings;
      var index;
      var isHandle;
      var status = {};
      var items = this.element.children().not('[data-arrange-exclude="true"]');
      var placeholder = $("<".concat(/^(ul|ol)$/i.test(this.element[0].tagName) ? 'li' : 'div', ">"));

      if (s.itemsSelector) {
        items = $(s.itemsSelector, this.element).not('[data-arrange-exclude="true"]');
        placeholder = $("<".concat(items.first()[0].tagName, " />"));
      }

      if (s.placeholder) {
        placeholder = $(s.placeholder);
      }

      this.dragStart = 'dragstart.arrange touchstart.arrange gesturestart.arrange';
      this.dragEnd = 'dragend.arrange touchend.arrange touchcancel.arrange gestureend.arrange';
      this.dragWhileDragging = 'dragover.arrange dragenter.arrange drop.arrange touchmove.arrange gesturechange.arrange';
      this.handle = s.handle || this.element.attr('data-arrange-handle');
      this.connectWith = this.element.attr('data-arrange-connectWith');
      this.placeholders = placeholder;

      if (!this.isTouch) {
        this.placeholders.addClass("".concat(s.placeholderCssClass, " draggable"));
      } // Use Handle if available


      $(this.handle, items).addClass('draggable').on('mousedown.arrange touchstart.arrange', function () {
        isHandle = true;
      }).on('mouseup.arrange touchend.arrange', function () {
        isHandle = false;
      }); // Add connect with

      if (this.connectWith) {
        items = items.add($(this.connectWith).children().not('[data-arrange-exclude="true"]')).data('connectWith', this.connectWith);
      }

      this.items = items; // Draggable Items

      this.items.attr('draggable', true).addClass(this.handle ? '' : 'draggable').add([this, placeholder]).not('a[href], img').on('selectstart.arrange', function () {
        if (this.dragDrop) {
          this.dragDrop(); // ie9
        }

        return this.isIe;
      });
      this.items.add(placeholder).each(function () {
        $(this) // Drag start --------------------------------------------------------------------------
        .on(self.dragStart, function (e) {
          if (self.handle && !isHandle) {
            if (self.isTouch) {
              return;
            }

            return false; // eslint-disable-line
          }

          isHandle = false;
          self.dragging = $(this);
          index = self.dragging.addClass('arrange-dragging').index();
          var idx = s.isVisualItems ? self.getVisualIndex(self.dragging) : index;
          $.extend(status, {
            start: self.dragging,
            startIndex: idx
          });
          /**
          * Fires before moving an element allowing you to access the ui to
           customize the draggable item.
          *
          * @event beforearrange
          * @memberof Arrange
          * @property {object} event - The jquery event object
          * @property {object} status - Status for this item
          */

          var result = self.element.triggerHandler('beforearrange', status);

          if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
            self.dragging = null;
            return;
          }

          if (self.isTouch) {
            var rect = self.dragging[0].getBoundingClientRect();
            var touch = e.originalEvent.changedTouches[0]; // Save offset

            self.offset = {
              x: touch.pageX - rect.left,
              y: touch.pageY - rect.top
            };
            self.placeholderTouch = self.dragging.clone().addClass('is-touch').attr('id', 'arrange-placeholder-touch').insertBefore(self.dragging);
            self.dragTouchElement(e, self.placeholderTouch);
          } else {
            var dt = e.originalEvent.dataTransfer;
            dt.effectAllowed = 'move';
            dt.setData('Text', 'dummy');
          }
        }) // Drag end ----------------------------------------------------------
        .on(self.dragEnd, function () {
          if (!self.dragging) {
            return;
          }

          if (self.isTouch) {
            self.dragging.css('opacity', 1);
            self.placeholderTouch.remove();
          }

          self.placeholders.filter(':visible').after(self.dragging);
          self.dragging.removeClass('arrange-dragging').show();
          self.placeholders.detach();

          if (index !== self.dragging.index()) {
            var idx = s.isVisualItems ? self.getVisualIndex(self.dragging) : self.dragging.index();
            $.extend(status, {
              end: self.dragging,
              endIndex: idx
            });
            /**
            * Fires after moving an element allowing you do any follow up updating.
            *
            * @event arrangeupdate
            * @memberof Arrange
            * @property {object} event - The jquery event object
            * @property {object} status - Status for this item
            */

            self.element.triggerHandler('arrangeupdate', status);
          }

          self.dragging = null;
          self.placeholderTouch = null;
        }) // While dragging ----------------------------------------------------
        .on(self.dragWhileDragging, function (e) {
          if (!self.dragging) {
            return;
          }

          var overItem = this;
          var overIndex;
          e.preventDefault();
          /**
          * Fires after finishing an arrange action.
          *
          * @event dragend
          * @memberof ApplicationMenu
          * @param {object} event - The jquery event object
          */

          if (e.type === 'drop') {
            e.stopPropagation();
            self.dragging.trigger('dragend.arrange');
            return false; // eslint-disable-line
          }

          if (self.isTouch) {
            var touch = e.originalEvent.touches[0];
            overItem = self.getElementByTouchInList(items, touch.pageX, touch.pageY) || overItem;
          }

          overItem = $(overItem);

          if (!self.isTouch) {
            e.originalEvent.dataTransfer.dropEffect = 'move';
          }

          if (items.is(overItem) && placeholder.index() !== overItem.index()) {
            if (self.isTouch) {
              self.dragging.css('opacity', 0);
            } else {
              self.dragging.hide();
            }

            var idx;

            if (placeholder.index() < overItem.index()) {
              placeholder.insertAfter(overItem);
              overIndex = overItem.index();
              idx = s.isVisualItems ? self.getVisualIndex(overItem) : overIndex;
            } else {
              placeholder.insertBefore(overItem);
              overIndex = placeholder.index();
              idx = s.isVisualItems ? self.getVisualIndex(placeholder) : overIndex;
            }

            $.extend(status, {
              over: overItem,
              overIndex: idx
            });
            self.element.triggerHandler('draggingarrange', status); // Fix: IE-11 on windows-10 svg was disappering

            utils.fixSVGIcons(overItem);
            self.placeholders.not(placeholder).detach();
          } else if (!self.placeholders.is(this)) {
            self.placeholders.detach();
            self.element.append(placeholder);
          }

          if (self.isTouch) {
            self.dragTouchElement(e, self.placeholderTouch);
            return;
          }

          return false; // eslint-disable-line
        }); //-----------------------------------------------------------------
      }); // end each items
    }
  };

  /**
   * jQuery component wrapper for Arrange
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.arrange = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1, new Arrange(this, settings));
      }
    });
  };

  /* eslint-disable no-cond-assign */
  // Similar: https://github.com/desandro/draggabilly
  // The name of this plugin

  var COMPONENT_NAME$2 = 'drag';
  /**
   * Drag/Drop functions with touch support.
   * @class Drag
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.axis]  Constrains dragging to either axis. Possible values: null, 'x', 'y'
   * @param {boolean} [settings.clone=false] Set to true to clone the object to drag. In many situations this is
   *  needed to break out of layout.
   * @param {string} [settings.cloneCssClass='is-clone'] Css class added to clone element (defaults is 'is-clone')
   * @param {boolean} [settings.clonePosIsFixed=false] If true cloned object will use css style "position: fixed"
   * @param {string} [settings.cloneAppendTo] Selector to append to for the clone
   * ['body'|'parent'|'jquery object'] default:'body'
   * @param {boolean} [settings.containment=false] Constrains dragging to within the bounds of the specified element
   *  or region. Possible values: "parent", "document", "window".
   * @param {string} [settings.obstacle] jQuery Selector of object(s) that you cannot drag into,
   * @param {boolean} [settings.underElements=false] If set to true will return list of elements that are
   * underneath the drag element
   * @param {object} [settings.containmentOffset={left: 0, top: 0}] How close to the containment object should we be allowed
   * to drag in position form. `{left: 0, top: 0}`
  */

  var DRAG_DEFAULTS = {
    axis: null,
    clone: false,
    cloneCssClass: 'is-clone',
    clonePosIsFixed: false,
    cloneAppendTo: null,
    containment: false,
    obstacle: false,
    underElements: false,
    containmentOffset: {
      left: 0,
      top: 0
    }
  };

  function Drag(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, DRAG_DEFAULTS);
    this.init();
  } // Plugin Methods


  Drag.prototype = {
    init: function init() {
      this.handleEvents();
    },

    /**
    * Trigger events and remove clone
    * @private
    * @param {number} left Current left position
    * @param {number} top Current top position
    */
    finish: function finish(left, top) {
      var pos = {
        top: top,
        left: left
      };
      this.element.off('mouseup.draggable');
      $(document).off('mousemove.draggable mouseup.draggable');

      if (this.settings.underElements) {
        pos.underElements = this.getElementsFromPoint(pos.left, pos.top);
      }

      pos.offset = this.offset;
      pos.clone = this.clone;
      /**
      * Fires after the drag is completed. Use this to remove / set drag feedback off.
      * @event dragend
      * @memberof Drag
      * @property {object} event - The jquery event object.
      * @property {object} ui - The dialog object
      */

      this.element.trigger('dragend', pos);
      this.element.removeClass('is-dragging');

      if (this.clone) {
        if (this.settings.axis === 'x') {
          delete pos.top;
        }

        if (this.settings.axis === 'y') {
          delete pos.left;
        } // this.element.css(pos);


        this.clone.remove();
        this.clone = null;
      } // Clear Cached Sizes


      if (this.obstacle) {
        this.obstacle = null;
      }

      if (this.upperYLimit) {
        this.upperYLimit = null;
      }

      if (this.upperXLimit) {
        this.upperXLimit = null;
      }

      $('body').removeClass('disable-select');
    },
    // Move the object from the event coords
    move: function move(left, top) {
      var self = this;
      var css = {
        left: left,
        top: top
      }; // X-Y Axis

      if (this.settings.axis === 'x') {
        delete css.top;
      }

      if (this.settings.axis === 'y') {
        delete css.left;
      }

      if (this.settings.containment) {
        if (this.settings.containment instanceof jQuery) {
          this.container = this.settings.containment;
        } else if (this.settings.containment === 'parent') {
          this.container = this.element.parent();
        } else if (this.settings.containment === 'window') {
          this.container = $(window);
        } else if (this.settings.containment === 'container') {
          this.container = this.element.closest('.page-container');
        } else {
          this.container = $(document);
        }

        if (!this.upperXLimit) {
          this.upperXLimit = this.container.width() - this.element.outerWidth() + this.settings.containmentOffset.left;
        }

        if (!this.upperYLimit) {
          this.upperYLimit = this.container.height() - this.element.outerHeight() + this.settings.containmentOffset.top;
        }

        if (css.top > this.upperYLimit) {
          css.top = this.upperYLimit;
        }

        if (css.left > this.upperXLimit) {
          css.left = this.upperXLimit;
        }

        if (css.top < 0) {
          css.top = 0;
        }

        if (css.left < 0) {
          css.left = 0;
        }

        if (this.settings.containment === 'container' && css.left <= 1) {
          css.left = 1;
        }
      }

      if (this.settings.obstacle) {
        var elemOffset = this.clone ? this.clone.offset() : this.element.offset();
        var elemWidth = this.clone ? this.clone.outerWidth() : this.element.outerWidth();
        var movingRight = css.left > elemOffset.left; // Caching this so drag is not jaggie

        if (!this.obstacle) {
          this.obstacle = $(this.settings.obstacle).not(this.element);
          var obstacleOffset = $(this.obstacle).offset();
          this.constraints = {
            top: obstacleOffset.top,
            left: obstacleOffset.left,
            bottom: obstacleOffset.top + this.obstacle.outerHeight(),
            right: obstacleOffset.left + this.obstacle.outerWidth()
          };
        }

        if (!movingRight && self.originalPos.left > this.constraints.left && css.left <= this.constraints.right) {
          css.left = this.constraints.right;
        }

        if (movingRight && self.originalPos.left + elemWidth <= this.constraints.left && css.left + elemWidth >= this.constraints.left) {
          css.left = this.constraints.left - this.obstacle.outerWidth();
        }
      }

      var applyCssStyle = function applyCssStyle(el, applyCss, prop) {
        if (typeof applyCss[prop] !== 'undefined') {
          el[0].style[prop] = "".concat(applyCss[prop], "px");
        }
      };

      applyCssStyle(this.clone || this.element, css, 'top');
      applyCssStyle(this.clone || this.element, css, 'left');

      if (this.settings.underElements) {
        css.underElements = this.getElementsFromPoint(css.left, css.top);
      }

      css.offset = this.offset;
      css.clone = this.clone;
      /**
      * Fires (many times) while dragging is occuring. Use this for DOM feedback but
      * be careful about what you do in here for performance.
      * @event drag
      * @memberof Drag
      * @property {object} event - The jquery event object.
      * @property {object} ui - The dialog object
      */

      this.element.trigger('drag', css);
    },

    /**
    * Get elements from given point.
    * @param {number} x The x-coordinate of the Point.
    * @param {number} y The y-coordinate of the Point.
    * @Returns {array} List of all elements at the given point.
    */
    getElementsFromPoint: function getElementsFromPoint(x, y) {
      var elements = [];

      if (document.elementsFromPoint) {
        elements = document.elementsFromPoint(x, y);
      } else if (document.msElementsFromPoint) {
        elements = document.msElementsFromPoint(x, y);
      } else {
        var i;
        var l;
        var d;
        var current;
        var max = 999;
        var pointerEvents = [];

        while ((current = document.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current !== null && max > -1) {
          max--; // push the element and its current style

          elements.push(current);
          pointerEvents.push({
            value: current.style.getPropertyValue('pointer-events') || '',
            priority: current.style.getPropertyPriority('pointer-events')
          }); // add "pointer-events: none", to get to the underlying element

          current.style.setProperty('pointer-events', 'none', 'important');
        } // restore the previous pointer-events values


        for (i = 0, l = elements.length; i < l; i++) {
          d = pointerEvents[i];
          elements[i].style.setProperty('pointer-events', d.value, d.priority);
        }
      }

      return elements;
    },

    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },

    /**
     * Detach all functionality and events.
     */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$2);
      this.element.off('touchstart.draggable MSPointerDown.draggable pointerdown.draggable touchmove.draggable touchend.draggable touchcancel.draggable mousedown.draggable');
    },
    handleEvents: function handleEvents() {
      var self = this;
      self.offset = null; // Touch and Drag Support

      self.element.attr('draggable', !Environment.features.touch);

      if ('onpointerdown' in window || 'onmspointerdown' in window) ; else {
        // Touch-only Drag Support
        self.element.on('touchstart.draggable gesturestart.draggable', function (e) {
          var pos = $(this).position();
          var orig = e.originalEvent;
          self.offset = {
            x: orig.changedTouches[0].pageX - pos.left,
            y: orig.changedTouches[0].pageY - pos.top
          };
          self.originalPos = pos;
          self.element.addClass('is-dragging');
          pos.offset = self.offset;
          pos.clone = self.clone;
          /**
          * When the dragging is initiated. Use this to customize/style
          * the drag/drop objects in the DOM.
          * @event dragstart
          * @memberof Drag
          * @property {object} event - The jquery event object.
          * @property {object} ui - The dialog object
          */

          self.element.trigger('dragstart', pos);
        }) // Move
        .on('touchmove.draggable gesturechange.draggable', function (e) {
          e.preventDefault();
          var orig = e.originalEvent; // do now allow two touch points to drag the same element

          if (orig.targetTouches.length > 1) {
            return;
          }

          var xpos = orig.changedTouches[0].pageX - self.offset.x;
          var ypos = orig.changedTouches[0].pageY - self.offset.y;
          self.move(xpos, ypos);
        }) // Finish Touch Dragging
        .on('touchend.draggable gestureend.draggable touchcancel.draggable', function (e) {
          e.preventDefault();
          var touch = e.originalEvent.changedTouches[0];
          self.finish(touch.pageX - self.offset.x, touch.pageY - self.offset.y);
        });
      } // Always bind mousedown in either scenario, in the event that a mouse is used


      self.element.on('mousedown.draggable', function (e) {
        e.preventDefault();
        var pos = self.settings.clonePosIsFixed ? self.element[0].getBoundingClientRect() : self.element.position(); // Save offset

        self.offset = {
          x: e.pageX - pos.left,
          y: e.pageY - pos.top
        };
        self.originalPos = pos; // Prevent Text Selection

        $('body').addClass('disable-select'); // Handle Mouse Press over draggable element

        $(document).on('mousemove.draggable', function (mouseMoveEvent) {
          mouseMoveEvent.preventDefault();
          self.move(mouseMoveEvent.pageX - self.offset.x, mouseMoveEvent.pageY - self.offset.y);
        }); // Handle Mouse release over draggable element close out events and trigger

        $(document).on('mouseup.draggable', function (docMouseUpEvent) {
          docMouseUpEvent.preventDefault();
          self.finish(e.pageX - self.offset.x, docMouseUpEvent.pageY - self.offset.y);
        });
        self.element.on('mouseup.draggable', function (mouseUpEvent) {
          mouseUpEvent.preventDefault();
          self.finish(mouseUpEvent.pageX - self.offset.x, mouseUpEvent.pageY - self.offset.y);
        }); // Trigger dragging
        // Clone

        if (!self.clone && self.settings.clone) {
          self.clone = self.element.clone(true);

          if (self.settings.cloneAppendTo === 'parent') {
            self.settings.cloneAppendTo = self.element.parent();
          }

          self.clone.addClass(self.settings.cloneCssClass).appendTo(self.settings.cloneAppendTo || 'body');
        }

        self.element.addClass('is-dragging');
        self.element.trigger('dragstart', [pos, self.clone]);
      });
    }
  };

  /**
   * jQuery Component Wrapper for Drag
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.drag = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$2);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$2, new Drag(this, settings));
      }
    });
  };

  var COMPONENT_NAME$3 = 'place'; // Default Component Options

  var DEFAULT_PLACE_SETTINGS = {
    bleedFromContainer: false,
    callback: null,
    container: null,
    parent: null,
    parentXAlignment: 'center',
    parentYAlignment: 'center',
    placement: 'bottom',
    strategies: ['nudge']
  }; // Constants used throughout

  var PLACE_STRATEGIES = ['nudge', 'clockwise', 'flip', 'shrink', 'shrink-x', 'shrink-y'];
  var PLACE_POSITIONS = ['top', 'left', 'right', 'bottom', 'center'];
  var PLACE_X_ALIGNMENTS = ['left', 'center', 'right'];
  var PLACE_Y_ALIGNMENTS = ['top', 'center', 'bottom'];
  var PLACEMENT_OBJECT_SETTING_KEYS = ['x', 'y', 'container', 'containerOffsetX', 'containerOffsetY', 'callback', 'parent', 'parentXAlignment', 'parentYAlignment', 'useParentWidth', 'useParentHeight', 'placement', 'strategies'];
  /**
   * Object that contains coordinates along with temporary, changeable properties.
   * This object gets passed around the Place Behavior and modified during each phase of positioning.
   * This object is also passed to all callbacks and event listeners for further modification.
   * @private
   * @param {object} [placementOptions] object containing settings for placement
   * @returns {void}
   */

  function PlacementObject(placementOptions) {
    var self = this;
    PLACEMENT_OBJECT_SETTING_KEYS.forEach(function (val) {
      if (placementOptions[val] === null) {
        return;
      }

      if (val === 'x' || val === 'y') {
        self.setCoordinate(val, placementOptions[val]);
        self["original".concat(val)] = placementOptions[val];
        return;
      }

      self[val] = placementOptions[val];
    });
    this.modified = false;
    return this.sanitize();
  }

  PlacementObject.prototype = {
    isReasonableDefault: function isReasonableDefault(setting, limits) {
      return $.inArray(setting, limits) > -1;
    },
    sanitize: function sanitize() {
      var self = this;
      this.bleedFromContainer = this.bleedFromContainer === true;
      this.callback = typeof this.callback === 'function' ? this.callback : DEFAULT_PLACE_SETTINGS.callback;
      this.container = this.container instanceof $ && this.container.length ? this.container : DEFAULT_PLACE_SETTINGS.container;
      this.containerOffsetX = !isNaN(parseInt(this.containerOffsetX, 10)) ? this.containerOffsetX : 0;
      this.containerOffsetY = !isNaN(parseInt(this.containerOffsetY, 10)) ? this.containerOffsetY : 0;
      this.parent = this.parent instanceof $ && this.parent.length ? this.parent : DEFAULT_PLACE_SETTINGS.parent;
      this.parentXAlignment = this.isReasonableDefault(this.parentXAlignment, PLACE_X_ALIGNMENTS) ? this.parentXAlignment : DEFAULT_PLACE_SETTINGS.parentXAlignment;
      this.parentYAlignment = this.isReasonableDefault(this.parentYAlignment, PLACE_Y_ALIGNMENTS) ? this.parentYAlignment : DEFAULT_PLACE_SETTINGS.parentYAlignment;
      this.placement = this.isReasonableDefault(this.placement, PLACE_POSITIONS) ? this.placement : DEFAULT_PLACE_SETTINGS.placement;
      this.useParentHeight = this.useParentHeight === true;
      this.useParentWidth = this.useParentWidth === true;

      if (!$.isArray(this.strategies) || !this.strategies.length) {
        this.strategies = ['nudge'];
      }

      this.strategies.forEach(function (strat, i) {
        self.strategies[i] = self.isReasonableDefault(strat, PLACE_STRATEGIES) ? strat : self.strategies[i];
      });
    },
    setCoordinate: function setCoordinate(coordinate, value) {
      var coordinates = ['x', 'y'];

      if (!this.isReasonableDefault(coordinate, coordinates)) {
        return;
      }

      if (isNaN(value)) {
        value = 0;
      }

      this[coordinate] = Math.round(value);
    }
  };
  /**
   * The Place API which handles internal placement of popups, menus ect.
   * @class Place
   * @param {HTMLElement|jQuery[]} element the base element being placed
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.bleedFromContainer = false] If true, allows positioned content to bleed
   *  outside of a defined container.
   * @param {function} [settings.callback] If defined, provides extra placement adjustments
   *  after the main calculation is performed.
   * @param {HTMLElement} [settings.container] If defined, contains the placement of the
   *  element to the boundaries of a specific container element.
   * @param {HTMLElement} [settings.parent] If defined, will be used as the reference
   *  element for placement this element.
   * @param {string} [settings.parentXAlignment = 'center'] Only used for parent-based placement.
   *  Determines the X-coordinate alignment of the placed element against its parent.
   * @param {string} [settings.parentYAlignment = 'center'] Only used for parent-based placement.
   *  Determines the Y-coordinate alignment of the placed element against its parent.
   * @param {string} [settings.placement = 'bottom'] If defined, changes the direction in which
   *  placement of the element happens
   * @param {string[]} [settings.strategies = ['nudge']] Determines the "strategy" for alternatively
   *  placing the element if it doesn't fit in the defined boundaries.  Only matters
   *  when "parent" is a defined setting.  It's possible to define multiple strategies
   *  and execute them in order.
   */

  function Place(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DEFAULT_PLACE_SETTINGS);
    this.element = $(element);
    this.init();
  }

  Place.prototype = {
    /**
     * Do other init (change/normalize settings, load externals, etc)
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.build().handleEvents();
    },

    /**
     * Add markup to the control
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      if (!this.element.hasClass('placeable')) {
        this.element.addClass('placeable');
      } // Setup a hash of original styles that will retain width/height whenever
      // the placement for this element is recalculated.


      this.originalStyles = {};
      var h = this.element[0].style.height;
      var w = this.element[0].style.width;

      if (h) {
        this.originalStyles.height = h;
      }

      if (w) {
        this.originalStyles.width = w;
      }

      return this;
    },

    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.element.on("place.".concat(COMPONENT_NAME$3), function (e, x, y) {
        self.place(new PlacementObject({
          x: x,
          y: y
        }));
      }).on("updated.".concat(COMPONENT_NAME$3), function () {
        self.updated();
      });
      return this;
    },

    /**
     * Actually renders an element with coordinates inside the DOM
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {void}
     */
    render: function render(placementObj) {
      var unitRegex = /(px|%)/i;
      this.element.offset({
        left: placementObj.x,
        top: placementObj.y
      });

      if (placementObj.height) {
        this.element[0].style.height = placementObj.height + (unitRegex.test("".concat(placementObj.height)) ? '' : 'px');
      }

      if (placementObj.width) {
        this.element[0].style.width = placementObj.width + (unitRegex.test("".concat(placementObj.width)) ? '' : 'px');
      }
    },

    /**
     * Main placement API Method (external)
     * Can either take a PlacementObject as a single argument, or can take 2 coordinates (x, y) and
     * will use the pre-defined settings.
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {void}
     */
    place: function place(placementObj) {
      var curr = [this.element[0].style.left, this.element[0].style.top]; // Cancel placement with return:false; from a "beforeplace" event

      var canBePlaced = this.element.trigger('beforeplace', [curr]);

      if (!canBePlaced) {
        return curr;
      }

      if (!(placementObj instanceof PlacementObject)) {
        placementObj = new PlacementObject(placementObj);
      } // If no values are defined, simply return the current coordinates with a warning.


      if (placementObj.x == null && placementObj.y == null) {
        // TODO: Log a warning about not positioning stuff?
        return curr;
      } // Remove any previous placement styles


      this.clearOldStyles(); // Use different methods if placement against a parent, versus straight-up coordinate placement

      if (placementObj.parent) {
        return this.placeWithParent(placementObj);
      }

      return this.placeWithCoords(placementObj);
    },

    /**
     * Placement Routine that expects a parent to be used as a base placement marking.
     * In this case, "x" and "y" integers are "relative" adjustments to the original
     * numbers generated by the parent. Can be modified by using a callback in the settings.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    placeWithParent: function placeWithParent(placementObj) {
      if (!placementObj.parent || !placementObj.parent.length) {
        // can't simply return x and y here because if there is no parent element,
        // these numbers are not coordinates, they are offsets.
        return [undefined, undefined];
      }

      var self = this;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var containerRect; // If this tooltip is confined to a container, in some situtions we need to make sure
      // the placed element is within the browser viewport before we attempt to get its
      // dimensions. This simply puts the element within the viewport boundary beforehand
      // for accurate measurements.
      // See Github infor-design/enterprise#3119

      if (Environment.rtl && container.length) {
        containerRect = DOM.getDimensions(container[0]);
        this.element.css({
          left: "".concat(containerRect.left, "px"),
          top: "".concat(containerRect.right, "px")
        });
      }

      var parentRect = DOM.getDimensions(placementObj.parent[0]);
      var elRect = DOM.getDimensions(this.element[0]); // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.

      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();

      if (placementObj.useParentWidth) {
        placementObj.width = parentRect.width;
      }

      if (placementObj.useParentHeight) {
        placementObj.height = parentRect.height;
      }

      function getCoordsFromPlacement(incomingPlacementObj) {
        var p = incomingPlacementObj.placement;
        var aX = incomingPlacementObj.parentXAlignment;
        var aY = incomingPlacementObj.parentYAlignment;
        var cX;
        var cY; // Set initial placements

        switch (p) {
          case 'top':
            cY = parentRect.top - elRect.height - incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
            break;

          case 'left':
            cX = parentRect.left - elRect.width - incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
            break;

          case 'right':
            cX = parentRect.right + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
            break;

          default:
            // Bottom
            cY = parentRect.bottom + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
            break;
        } // Set X alignments on bottom/top placements


        if (p === 'top' || p === 'bottom') {
          var cW = Math.round(containerIsBody ? document.body.offsetWidth : null);

          switch (aX) {
            case 'left':
              if (containerIsBody && cW < Math.round(elRect.left) + Math.round(elRect.width)) {
                cX = parentRect.left + incomingPlacementObj.x + scrollX;
              } else {
                cX = parentRect.left - incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              }

              break;

            case 'right':
              if (containerIsBody && Math.round(elRect.right) - Math.round(elRect.width) < 0) {
                cX = parentRect.left - incomingPlacementObj.x + scrollX;
              } else {
                cX = parentRect.right - elRect.width + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              }

              break;

            default:
              // center
              cX = parentRect.left + (parentRect.width - elRect.width) / 2 + incomingPlacementObj.x + (containerIsBody ? scrollX : 0);
              break;
          }
        } // Set Y alignments on left/right placements


        if (p === 'right' || p === 'left') {
          switch (aY) {
            case 'top':
              cY = parentRect.top - incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;

            case 'bottom':
              cY = parentRect.bottom - elRect.height + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;

            default:
              // center
              cY = parentRect.top + (parentRect.height - elRect.height) / 2 + incomingPlacementObj.y + (containerIsBody ? scrollY : 0);
              break;
          }
        }

        return [cX, cY];
      }

      function doPlacementAgainstParent(incomingPlacementObj) {
        var coords = getCoordsFromPlacement(incomingPlacementObj);
        incomingPlacementObj.setCoordinate('x', coords[0]);
        incomingPlacementObj.setCoordinate('y', coords[1]);
        self.render(incomingPlacementObj);
        incomingPlacementObj = self.handlePlacementCallback(incomingPlacementObj);
        return incomingPlacementObj;
      } // Simple placement logic


      placementObj = doPlacementAgainstParent(placementObj); // Adjusts the placement coordinates based on a defined strategy
      // Will only adjust the current strategy if bleeding outside the
      // viewport/container are detected.

      placementObj.strategies.forEach(function (strat) {
        placementObj = self.checkBleeds(placementObj);

        if (placementObj.bleeds) {
          placementObj = function () {
            switch (strat) {
              case 'nudge':
                return self.nudge(placementObj);

              case 'clockwise':
                return self.clockwise(placementObj);

              case 'flip':
                placementObj = self.flip(placementObj);
                placementObj.setCoordinate('x', placementObj.originalx);
                placementObj.setCoordinate('y', placementObj.originaly);
                placementObj = doPlacementAgainstParent(placementObj);
                return placementObj;

              case 'shrink':
                return self.shrink(placementObj);

              case 'shrink-x':
                return self.shrink(placementObj, 'x');

              case 'shrink-y':
                return self.shrink(placementObj, 'y');

              default:
                return placementObj;
            }
          }();

          self.render(placementObj);
        }
      }); // Trigger an event to notify placement has ended

      placementObj.element = this.element;
      this.element.trigger('afterplace', [placementObj]);
      return placementObj;
    },

    /**
     * Basic Placement Routine that simply accepts X and Y coordinates.
     * In this case, "x" and "y" integers are "absolute" and will be the base point for placement.
     * Can be modified by using a callback in the settings.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    placeWithCoords: function placeWithCoords(placementObj) {
      this.render(placementObj);
      placementObj = this.handlePlacementCallback(placementObj);
      this.render(placementObj); // Coordinate placement can only be "nudged" (strategy is not used in this style of placement).

      placementObj = this.checkBleeds(placementObj);

      if (placementObj.bleeds) {
        placementObj = this.nudge(placementObj);
      } // Place again


      this.render(placementObj);
      placementObj = this.checkBleeds(placementObj);

      if (placementObj.bleeds) {
        placementObj = this.shrink(placementObj);
      }

      this.render(placementObj);
      this.element.trigger('afterplace', [placementObj]);
      return placementObj;
    },

    /**
     * Perform callback, if it exists.
     * Callback should return an array containing the modified coordinate values: [x, y];
     * NOTE: These are actual coordinates in all cases.
     * NOTE: They are not relative values - they are absolute.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {PlacementObject} modified placementObject with updated settings
     */
    handlePlacementCallback: function handlePlacementCallback(placementObj) {
      var cb = placementObj.callback || this.settings.callback;
      placementObj.element = this.element;

      if (cb && typeof cb === 'function') {
        placementObj = cb(placementObj);
      }

      this.render(placementObj);
      return placementObj;
    },

    /**
     * Detects for elements with fixed positioning, or an absolutely-positioned containment.
     * If either condition is true, this placement should not account for container scrolling.
     * @private
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {boolean} whether or not the values calculated should account for scrolling.
     */
    accountForScrolling: function accountForScrolling(placementObj) {
      var container = placementObj.container;
      var pos = window.getComputedStyle(this.element[0]).position; // fixed-positoned, placed elements don't account for scrolling

      if (pos === 'fixed') {
        return false;
      } // Check the container element.
      // If we can't find a valid container element, do account for scrolling.


      if (!container || !container.length) {
        container = this.element.parents().filter(function () {
          var containerPos = window.getComputedStyle(this).position;
          return containerPos === 'absolute' || pos === 'fixed';
        });
      }

      if (!container || !container.length) {
        return true;
      }

      if (container[0] === document.body) {
        return false;
      }

      var containerStyle = window.getComputedStyle(container[0]);
      pos = containerStyle.position;

      if (pos === 'fixed') {
        return false;
      }

      if (pos === 'absolute' && containerStyle.overflow === 'hidden') {
        return false;
      }

      return true;
    },

    /**
     * Gets a parent container element.
     * @param {PlacementObject} placementObj settings for the placement routine
     * @returns {HTMLElement|jQuery[]} container element
     */
    getContainer: function getContainer(placementObj) {
      if (placementObj.container instanceof $ && placementObj.container.length) {
        return placementObj.container;
      }

      var modalParent = this.element.parents('.modal');

      if (modalParent.length) {
        return modalParent;
      }

      return $(document.body);
    },

    /**
     * Re-adjust a previously-placed element to account for bleeding off the edges.
     * Element must fit within the boundaries of the page or it's current scrollable pane.
     * @param {PlacementObject} placementObj settings for the placement routine.
     * @returns {PlacementObject} modified placementObject with updated settings.
     */
    checkBleeds: function checkBleeds(placementObj) {
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var BoundingRect = this.element[0].getBoundingClientRect();
      var rect = {};
      var containerRect = container ? container[0].getBoundingClientRect() : {}; // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.

      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var padding = 20;
      var d;
      rect.width = BoundingRect.width;
      rect.height = BoundingRect.height;
      rect.top = BoundingRect.top;
      rect.right = BoundingRect.right;
      rect.bottom = BoundingRect.bottom;
      rect.left = BoundingRect.left;

      function getBoundary(edge) {
        switch (edge) {
          case 'top':
            return (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? 0 : scrollY * -1);
          // 0 === top edge of viewport

          case 'left':
            return (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? 0 : scrollX * -1);
          // 0 === left edge of viewport

          case 'right':
            return (containerBleed ? windowW : containerRect.right) - (!containerIsBody ? 0 : scrollX * -1);

          default:
            // bottom
            return (containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? 0 : scrollY * -1);
        }
      } // If element width is greater than window width, shrink to fit


      var rightViewportEdge = getBoundary('right');

      if (rect.width >= rightViewportEdge) {
        d = rect.width - rightViewportEdge + padding;
        var newWidth = rect.width - d;
        placementObj.width = newWidth;
        this.element[0].style.width = "".concat(newWidth, "px");
        rect.width = newWidth; // reset the rect because the size changed
      } // If element height is greater than window height, shrink to fit


      var bottomViewportEdge = getBoundary('bottom');

      if (rect.height >= bottomViewportEdge) {
        d = rect.height - bottomViewportEdge + padding;
        var newHeight = rect.height - d;
        placementObj.height = newHeight;
        this.element[0].style.height = "".concat(newHeight, "px");
        rect.height = newHeight; // reset the rect because the size changed
      } // build conditions


      var offRightEdge = rect.right > getBoundary('right');
      var offLeftEdge = rect.left < getBoundary('left');
      var offTopEdge = rect.top < getBoundary('top');
      var offBottomEdge = rect.bottom > getBoundary('bottom'); // Return if no bleeding is detected (no need to fix anything!)

      if (!offRightEdge && !offLeftEdge && !offTopEdge && !offBottomEdge) {
        placementObj.bleeds = undefined;
        return placementObj;
      } // Keep a record of bleeds that need to be adjusted, and by what values


      placementObj.bleeds = {};
      placementObj.bleeds.right = offRightEdge ? rect.right - getBoundary('right') : null;
      placementObj.bleeds.left = offLeftEdge ? -(rect.left - getBoundary('left')) : null;
      placementObj.bleeds.top = offTopEdge ? -(rect.top - getBoundary('top')) : null;
      placementObj.bleeds.bottom = offBottomEdge ? rect.bottom - getBoundary('bottom') : null;
      return placementObj;
    },
    // Bumps the element around in each direction
    nudge: function nudge(placementObj) {
      if (!placementObj.nudges) {
        placementObj.nudges = {
          x: 0,
          y: 0
        };
      }

      var d = 0;

      if (placementObj.bleeds.right) {
        d = Math.abs(placementObj.bleeds.right) + Math.abs(placementObj.containerOffsetX);
        placementObj.setCoordinate('x', placementObj.x - d);
        placementObj.nudges.x -= d;
      }

      if (placementObj.bleeds.left) {
        d = Math.abs(placementObj.bleeds.left) + Math.abs(placementObj.containerOffsetX);
        placementObj.setCoordinate('x', placementObj.x + d);
        placementObj.nudges.x += d;
      }

      if (placementObj.bleeds.top) {
        d = Math.abs(placementObj.bleeds.top) + Math.abs(placementObj.containerOffsetY);
        placementObj.setCoordinate('y', placementObj.y + d);
        placementObj.nudges.y += d;
      }

      if (placementObj.bleeds.bottom) {
        d = Math.abs(placementObj.bleeds.bottom) + Math.abs(placementObj.containerOffsetY);
        placementObj.setCoordinate('y', placementObj.y - d);
        placementObj.nudges.y -= d;
      }

      placementObj.wasNudged = true;
      placementObj.bleeds = undefined;
      return placementObj;
    },
    flip: function flip(placementObj) {
      // Don't attempt to flip if there was no bleeding on the edge we're attempting to leave from.
      if (!placementObj.bleeds[placementObj.placement]) {
        return placementObj;
      }

      if (!placementObj.attemptedFlips) {
        placementObj.attemptedFlips = [];
      }

      placementObj.attemptedFlips.push(placementObj.placement); // If we've tried flipping in all directions, give up and use the default placement.

      if (placementObj.attemptedFlips.length > 3) {
        placementObj = this.giveup(placementObj);
        return placementObj;
      }

      var accountForScrolling = this.accountForScrolling(placementObj);
      var isXCoord = ['left', 'right'].indexOf(placementObj.placement) > -1;
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerIsBody = container.length && container[0] === document.body;
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      var parentRect = placementObj.parent[0].getBoundingClientRect(); // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.

      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

      function getOppositeDir(dir) {
        switch (dir) {
          case 'left':
            return 'right';

          case 'right':
            return 'left';

          case 'top':
            return 'bottom';

          default:
            // bottom
            return 'top';
        }
      } // Gets the distance between an edge on the target element, and its opposing viewport border


      function getDistance(dir) {
        var d = 0;

        switch (dir) {
          case 'left':
            d = (containerBleed ? 0 : containerRect.left) - (accountForScrolling ? scrollX : 0) - parentRect.left + placementObj.containerOffsetX;
            break;

          case 'right':
            d = (containerBleed ? windowW : containerRect.right) - (accountForScrolling ? scrollX : 0) - parentRect.right - placementObj.containerOffsetX;
            break;

          case 'top':
            d = (containerBleed ? 0 : containerRect.top) - (accountForScrolling ? scrollY : 0) - parentRect.top + placementObj.containerOffsetY;
            break;

          default:
            // bottom
            d = (containerBleed ? windowH : containerRect.bottom) - (accountForScrolling ? scrollY : 0) - parentRect.bottom - placementObj.containerOffsetY;
            break;
        }

        return Math.abs(d);
      }

      function tried(placement) {
        return $.inArray(placement, placementObj.attemptedFlips) > -1;
      }

      function performFlip(originalDir) {
        var newDir = getOppositeDir(originalDir);
        var perpendicularDir = isXCoord ? 'top' : 'left';
        var oppPerpendicularDir = getOppositeDir(perpendicularDir);
        var originalDistance = getDistance(originalDir);
        var targetDistance = getDistance(newDir);

        if (!tried(newDir)) {
          if (originalDistance >= targetDistance) {
            return originalDir;
          }

          placementObj.wasFlipped = true;
          return newDir;
        } // switch the coordinate definitions
        // since the axis for placement is flipped, our coordinate offsets should also flip


        var tmp = placementObj.originalx;
        placementObj.originalx = placementObj.originaly;
        placementObj.originaly = tmp;
        var perpendicularDistance = getDistance(perpendicularDir);
        var oppPerpendicularDistance = getDistance(oppPerpendicularDir);

        if (!tried(perpendicularDir)) {
          if (perpendicularDistance >= oppPerpendicularDistance) {
            return perpendicularDir;
          }

          if (!tried(oppPerpendicularDir)) {
            return oppPerpendicularDir;
          }
        }

        return originalDir;
      }

      placementObj.placement = performFlip(placementObj.placement);
      return placementObj;
    },
    // TODO: Move Clockwise
    clockwise: function clockwise(placementObj) {
      return placementObj;
    },
    // If element height/width is greater than window height/width, shrink to fit
    shrink: function shrink(placementObj, dimension) {
      var dX = 0;
      var dY = 0;
      var useX = dimension === undefined || dimension === null || dimension === 'x';
      var useY = dimension === undefined || dimension === null || dimension === 'y';
      var accountForScrolling = this.accountForScrolling(placementObj);
      var menuRect = DOM.getDimensions(this.element[0]);
      var containerBleed = this.settings.bleedFromContainer;
      var container = this.getContainer(placementObj);
      var containerRect = container ? container[0].getBoundingClientRect() : {};
      var containerIsBody = container.length && container[0] === document.body;
      var coordinateShrink = placementObj.parent === null; // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
      // Firefox $('body').scrollTop() will always return zero.

      var scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft();
      var scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0); // Figure out the viewport boundaries

      var leftViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? 0 : containerRect.left) + placementObj.containerOffsetX;
      var topViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? 0 : containerRect.top) + placementObj.containerOffsetY;
      var rightViewportEdge = (accountForScrolling ? scrollX : 0) + (containerBleed ? windowW : containerRect.right) - placementObj.containerOffsetX;
      var bottomViewportEdge = (accountForScrolling ? scrollY : 0) + (containerBleed ? windowH : containerRect.bottom) - placementObj.containerOffsetY; // If shrinking a coordinate-placed object (no parent), the full range between top/bottom
      // and left/right boundaries will be used.
      // If shrinking a parent-placed object, the distance between the parent and whichever
      // boundary is further will be used.

      var availableX = rightViewportEdge - leftViewportEdge;
      var availableY = bottomViewportEdge - topViewportEdge;

      if (!coordinateShrink) {
        var parentRect = DOM.getDimensions(placementObj.parent[0]);
        var availableTop = parentRect.top - topViewportEdge;
        var availableBottom = bottomViewportEdge - parentRect.bottom;
        var availableLeft = parentRect.left - leftViewportEdge;
        var availableRight = rightViewportEdge - parentRect.right;
        availableX = availableLeft > availableRight ? availableLeft : availableRight;
        availableY = availableTop > availableBottom ? availableTop : availableBottom;
      } // Shrink in each direction.
      // The value of the "containerOffsets" is "factored out" of each calculation,
      // if for some reason the element is larger than the viewport/container space allowed.


      if (useX) {
        if (menuRect.width > availableX) {
          placementObj.width = availableX;
        } // Shift back into the viewport if off the Left


        if (menuRect.left < leftViewportEdge) {
          dX = leftViewportEdge - menuRect.left;
          placementObj.setCoordinate('x', placementObj.x + dX);
        }
      }

      if (useY) {
        if (menuRect.height > availableY) {
          placementObj.height = availableY;
        } // Shift back into the viewport if off the Top


        if (menuRect.top < topViewportEdge) {
          dY = topViewportEdge - menuRect.top;
          placementObj.setCoordinate('y', placementObj.y + dY);
        }
      }

      return placementObj;
    },
    // Giving up causes all the placementObj settings to revert
    giveup: function giveup(placementObj) {
      placementObj.giveup = true;
      placementObj.strategy = this.settings.strategy;
      placementObj.placement = this.settings.placement;
      return placementObj;
    },
    // Clears the old styles that may be present
    clearOldStyles: function clearOldStyles() {
      this.element[0].style.left = '';
      this.element[0].style.top = '';
      this.element[0].style.width = '';
      this.element[0].style.height = '';
      var os = this.originalStyles;

      if (os) {
        if (os.width) {
          this.element[0].style.width = os.width;
        }

        if (os.height) {
          this.element[0].style.height = os.height;
        }
      }

      return this;
    },
    // Built-in method for handling positon of optional arrow elements.
    // Used for tooltip/popovers/popupmenus
    setArrowPosition: function setArrowPosition(e, placementObj, element) {
      var target = placementObj.parent;
      var arrow = element.find('div.arrow');
      var dir = placementObj.placement;
      var targetRect = {};
      var elementRect = element[0].getBoundingClientRect();
      var arrowRect = {};
      var newArrowRect = {};
      var hideArrow = false;

      if (!target || !target.length || !arrow.length) {
        return;
      }

      arrow[0].removeAttribute('style');
      element.removeClass('top right bottom left').addClass(dir); // Custom target for some scenarios

      if (target.is('.colorpicker')) {
        target = target.next('.trigger');
      }

      if (target.is('.datepicker, .timepicker')) {
        target = target.next('.icon');
      }

      if (target.is('.btn-split-menu, .btn-menu, .btn-actions, .btn-filter, .tab, .tab-more')) {
        target = target.find('.icon').last();
      }

      if (target.is('.searchfield-category-button')) {
        target = target.find('.icon.icon-dropdown');
      }

      if (target.is('.colorpicker-editor-button')) {
        target = target.find('.trigger .icon');
      }

      if (target.is('.fontpicker')) {
        target = target.find('.icon.icon-dropdown');
      } // reset if we borked the target


      if (!target.length) {
        target = placementObj.parent;
      }

      targetRect = target.length ? target[0].getBoundingClientRect() : targetRect;
      arrowRect = arrow.length ? arrow[0].getBoundingClientRect() : arrowRect;
      newArrowRect = {};

      function getMargin(placement) {
        return placement === 'right' || placement === 'left' ? 'margin-top' : 'margin-left';
      }

      function getDistance() {
        var targetCenter = 0;
        var currentArrowCenter = 0;
        var d = 0;

        if (dir === 'left' || dir === 'right') {
          targetCenter = targetRect.top + targetRect.height / 2;
          currentArrowCenter = arrowRect.top + arrowRect.height / 2;
          d = targetCenter - currentArrowCenter;
          newArrowRect.top = arrowRect.top + d;
          newArrowRect.bottom = arrowRect.bottom + d;

          if (newArrowRect.top <= elementRect.top || newArrowRect.bottom >= elementRect.bottom) {
            hideArrow = true;
          }
        }

        if (dir === 'top' || dir === 'bottom') {
          targetCenter = targetRect.left + targetRect.width / 2;
          currentArrowCenter = arrowRect.left + arrowRect.width / 2;
          d = targetCenter - currentArrowCenter;
          newArrowRect.left = arrowRect.left + d;
          newArrowRect.right = arrowRect.right + d;

          if (newArrowRect.left <= elementRect.left || newArrowRect.right >= elementRect.right) {
            hideArrow = true;
          }
        }

        return d;
      } // line the arrow up with the target element's "dropdown icon", if applicable


      var positionOpts = {};
      positionOpts[getMargin(dir)] = getDistance();

      if (hideArrow) {
        positionOpts.display = 'none';
      }

      arrow.css(positionOpts);
    },
    // Handle Updating Settings
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },
    // Simple Teardown - remove events & rebuildable markup.
    teardown: function teardown() {
      this.clearOldStyles();
      this.element.removeClass('placeable');
      this.element.off("updated.".concat(COMPONENT_NAME$3, " place.").concat(COMPONENT_NAME$3));
      this.element.trigger('afterteardown');
      return this;
    },
    // Teardown - Remove added markup and events
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$3);
    }
  };

  /**
   * jQuery Component Wrapper for Place
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.place = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$3);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$3, new Place(this, settings));
      }
    });
  };

  var COMPONENT_NAME$4 = 'icon'; // Default Options

  var ICON_DEFAULTS = {
    use: 'user-profile',
    // Match this to one of the IDS Enterprise icons, prefixed with an ID of '#icon-'
    focusable: false
  };
  /**
   * Icon Control
   * Wraps SVG Icons with a Javascript control that can change the icon type, reference
   * relative or absolute URLs, and clean up after itself.  Works with the Base tag.
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.use = 'user-profile'] the type of icon that will appear.
   *  (gets added to the `<use>` tag's `href` property)
   * @param {boolean} [settings.focusable = false] whether or not this icon gets a `tabIndex` and
   *  becomes a focusable element on the page.
   */

  function Icon(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ICON_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  Icon.prototype = {
    /**
     * @private
     * @chainable
     * @returns {this} component instance
     */
    init: function init() {
      this.getExistingUseTag(); // Do other init (change/normalize settings, load externals, etc)

      return this.render().handleEvents();
    },

    /**
     * Add markup to the control
     * @private
     * @chainable
     * @returns {this} component instance
     */
    render: function render() {
      var self = this;
      this.element.addClass('icon');

      if (!this.element.is('svg')) {
        // TODO: Possibly work with span-based icons here?
        return this;
      } // Get a "base-tag-proof" version of the Use tag's definition.
      // jQuery can't work with SVG elements, so we just modify it with regular DOM APIs


      var use = this.element[0].getElementsByTagName('use')[0];

      if (!use) {
        return this;
      }

      if (use.getAttribute('href') !== self.getBasedUseTag()) {
        use.setAttribute('href', self.getBasedUseTag());
      }

      return this;
    },

    /**
     * Gets the currently used base tag.
     * @returns {string} a version of this icon's definition prefixed with the current base tag's URL.
     */
    getBasedUseTag: function getBasedUseTag() {
      return base.getBaseURL("#icon-".concat(this.settings.use));
    },

    /**
     * Changes this icon instance's `use` setting to match an existing `<use> tag's
     * `href` attribute. In the event that a <use> tag pre-exists on an icon,
     * we want to retain it, and simply replace the settings.
     * @chainable
     * @returns {this} component instance
     */
    getExistingUseTag: function getExistingUseTag() {
      if (!this.element.is('svg')) {
        return this;
      }

      var useTag = this.element.children('use');

      if (!useTag.length) {
        return this;
      } // Store the icon's name under the `use` setting.
      // Strip out all extraneous items including the `base` URL.


      var href = useTag.attr('href');

      if (!href && useTag.attr('xlink:href')) {
        href = useTag.attr('xlink:href');
      }

      var baseUrl = base.url;

      if (href && base.element.length && baseUrl.length) {
        href = href.replace(baseUrl, '');
      }

      href = href.replace('#icon-', '');
      this.settings.use = href;
      return this;
    },

    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @chainable
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.element.on("updated.".concat(COMPONENT_NAME$4), function () {
        self.updated();
      });
      return this;
    },

    /**
     * Handle Updating Settings
     * @chainable
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @chainable
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off("updated.".concat(COMPONENT_NAME$4));
      return this;
    },

    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$4);
    }
  };

  /**
   * jQuery component wrappers
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on.
   */

  $.fn.icon = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$4);

      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$4, new Icon(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };
  /**
   * Factory Function for instantly building icons.
   * Use this for building icons that don't exist yet.
   * Scoped Privately on purpose...
   */


  (function () {
    function normalizeIconOptions(options) {
      var defaults = {
        icon: 'user-profile',
        // omit the "icon-" if you want; this code strips it out.
        classes: ['icon']
      };
      options = options || $.extend({}, defaults);

      if (typeof options === 'string') {
        options = $.extend({}, defaults, {
          icon: options.replace('icon-', '')
        });
      } // reroute "options.class" if that exists


      if (!options.classes && options.class) {
        options.classes = options.class;
        delete options.class;
      }

      if (!options.classes) {
        options.classes = [].concat(defaults.classes);
      }

      if (typeof options.classes === 'string') {
        options.classes = options.classes.split(' ');
      }

      if (options.classes.indexOf('icon') === -1) {
        options.classes.push('icon');
      }

      if (!options.icon) {
        options.icon = '';
      }

      return options;
    } // Returns the RAW HTML for creating a new icon in string form


    $.createIcon = function createIcon(options) {
      options = normalizeIconOptions(options);
      return ["<svg class=\"".concat(options.classes.join(' '), "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">") + "<use href=\"#icon-".concat(options.icon, "\"></use>") + '</svg>'].join('');
    }; // Returns a jQuery-wrapped element containing a new icon


    $.createIconElement = function createIconElement(options) {
      return $($.createIcon(options));
    }; // Returns just the path part


    $.createIconPath = function createIconElement(options) {
      options = normalizeIconOptions(options);
      return $.getBaseURL("#icon-".concat(options.icon.replace('icon-', '')));
    }; // Toggle the use or entire svg icon in the case of the polyfill


    $.fn.changeIcon = function (icon) {
      if (!icon) {
        return;
      }

      $(this).find('use').attr('href', $.createIconPath({
        icon: icon
      }));
    };

    $.fn.getIconName = function () {
      var svg = $(this);
      var use = svg.find('use');

      if (use.length === 1 && use.attr('href')) {
        return use.attr('href').substr(use.attr('href').indexOf('#icon-') + 6);
      }

      if (use.length === 1 && use.attr('xlink:href')) {
        return use.attr('xlink:href').substr(use.attr('xlink:href').indexOf('#icon-') + 6);
      }

      return svg.attr('data-icon');
    };
  })();

  var COMPONENT_NAME$5 = 'tooltip'; // Trigger Methods

  var TOOLTIP_TRIGGER_METHODS = ['hover', 'immediate', 'click', 'focus'];
  /**
   * Tooltip and Popover Control
   * @class Tooltip
   * @constructor
   *
   * @param {htmlelement|jquery[]} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string|function} [settings.content] Takes title attribute or feed content. Can be a string or jQuery markup.
   * @param {object} [settings.offset={top: 10, left: 10}] How much room to leave.
   * @param {string} [settings.placement='top'] Supports 'top'|'bottom'|'right'|'offset'.
   * @param {string} [settings.trigger='hover'] Supports click and immediate and hover and focus
   * @param {string} [settings.showOnKeyboardFocus] If the object with the tooltip is tabbed to, will also show the tooltip.
   * @param {string} [settings.title] Title for Infor Tips.
   * @param {string} [settings.beforeShow] Call back for ajax tooltip.
   * @param {string} [settings.onHidden] Call back for hiding.
   * @param {string} [settings.popover] force it to be a popover (no content).
   * @param {string} [settings.closebutton] Show X close button next to title in popover.
   * @param {boolean} [settings.isError=false] Add error classes.
   * @param {boolean} [settings.isErrorColor=false] Add error color only not description.
   * @param {string} [settings.tooltipElement] ID selector for an alternate element to use to contain the tooltip classes.
   * @param {object} [settings.parentElement] jQuery-wrapped element that gets.
    passed to the 'place' behavior as the element to place the tooltip against.
   * @param {boolean} [settings.keepOpen=false] Forces the tooltip to stay open in situations where it would normally close.
   * @param {string} [settings.extraClass] Extra css class.
   * @param {object} [settings.placementOpt] Placement options.
   * @param {string} [settings.maxWidth] Toolip max width.
   * @param {boolean} [settings.initializeContent] Init the content in the tooltip.
   * @param {string} [settings.headerClass] If set this color will be used on the header (if a popover).
   * @param {string} [settings.delay] The delay before showing the tooltip
   * @param {string} [settings.attachToBody] The if true (default) the popup is added to the body. In some cases like popups with tab stops you may want to append the element next to the item.
   * @param {Array} [settings.attributes] allows user-defined attributes on generated Tooltip markup.
   */

  var TOOLTIP_DEFAULTS = {
    content: null,
    offset: {
      top: 10,
      left: 10
    },
    placement: 'top',
    trigger: TOOLTIP_TRIGGER_METHODS[0],
    showOnKeyboardFocus: true,
    title: null,
    beforeShow: null,
    popover: null,
    closebutton: null,
    isError: false,
    isErrorColor: false,
    tooltipElement: null,
    parentElement: null,
    keepOpen: false,
    extraClass: null,
    placementOpts: {},
    maxWidth: null,
    initializeContent: true,
    headerClass: null,
    delay: 500,
    onHidden: null,
    attachToBody: true,
    attributes: null
  };

  function Tooltip(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TOOLTIP_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  Tooltip.prototype = {
    /**
     * @returns {boolean} whether or not the tooltip/popover element is currently visible
     */
    get visible() {
      return this.tooltip.length && this.tooltip[0].classList.contains('hidden') === false && this.tooltip[0].classList.contains('is-hidden') === false;
    },

    /**
     * @returns {boolean} whether or not the tooltip/popover is able to be displayed,
     * which depends on its trigger element and all of its parent elements being visible.
     */
    get canBeShown() {
      return !this.reopenDelay && !DOM.hasClass(this.element[0], 'hidden') && !DOM.hasClass(this.element[0], 'is-hidden') && this.element.parents('.hidden, .is-hidden').length < 1;
    },

    /**
     * @returns {Popupmenu|undefined} if a Popupmenu API exists on the trigger element
     */
    get popupmenuAPI() {
      return this.element.data('popupmenu');
    },

    /**
     * @returns {boolean} whether or not the contents of this tooltip/popover currently have focus
     */
    get isFocused() {
      var activeElem = document.activeElement;

      if (this.activeElement.is($(activeElem))) {
        return true;
      }

      if (this.tooltip && this.tooltip.length && this.tooltip[0].contains(activeElem)) {
        return true;
      }

      return false;
    },

    /**
     * Initializes the component
     * @private
     * @returns {void}
     */
    init: function init() {
      this.uniqueId = utils.uniqueId(this.element, 'tooltip');
      this.isTouch = Environment.features.touch;
      this.setup();
      this.appendTooltip(); // Initial Content Setting.
      // Don't do this if we're using an "immediate" trigger because _setContent()_ is handled at
      // display time in that case.

      var shouldRender = this.settings.trigger !== 'immediate';

      if (shouldRender) {
        this.setContent(this.settings.content, true);
      }

      this.handleEvents();
    },

    /**
     * Builds internal references
     * @private
     * @returns {void}
     */
    setup: function setup() {
      // "this.activeElement" is the target element that the Tooltip will display itself against
      this.activeElement = this.settings.parentElement instanceof $ && this.settings.parentElement.length ? this.settings.parentElement : this.element;
      this.descriptionId = $('.tooltip-description').length + 1;
      this.description = this.element.parent().find('.tooltip-description');

      if (!this.description.length && this.settings.isError) {
        this.description = $("<span id=\"tooltip-description-".concat(this.descriptionId, "\" class=\"tooltip-description audible\"></span>")).insertAfter(this.element);
      }

      if (this.element.is('.dropdown, .multiselect')) {
        this.activeElement = this.element.nextAll('.dropdown-wrapper:first').find('>.dropdown');
      }

      var titleAttr = this.element.attr('title');

      if (!this.settings.popover && titleAttr && titleAttr.length || !this.settings.popover && this.settings.title) {
        this.settings.content = this.settings.title ? this.settings.title : titleAttr;
        this.element.removeAttr('title');
      }

      if (this.settings.trigger === 'hover' && this.isTouch) {
        this.element.addClass('longpress-target');
      }

      this.isPopover = this.settings.content !== null && _typeof(this.settings.content) === 'object' || this.settings.popover === true;
      this.settings.closebutton = !!(this.settings.closebutton || this.element.data('closebutton'));

      if (this.element.data('extraClass') && this.element.data('extraClass').length) {
        this.settings.extraClass = this.element.data('extraClass');
      }

      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes(this.element, this, this.settings.attributes, 'trigger');
      }

      this.isRTL = Locale.isRTL();
      DOM.addClass(this.element[0], 'has-tooltip');
    },

    /**
     * Adds ARIA attributes on some elements for better accessiblity.
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      if (!this.content) {
        return;
      }

      this.description.text(this.content);
      this.content = this.addClassToLinks(this.content, 'links-clickable');

      if (!this.isPopover) {
        this.element.removeAttr('title').attr('aria-describedby', this.description.attr('id'));
      }

      if (this.isPopover && this.settings.trigger === 'click') {
        this.element.attr('aria-haspopup', true);
      }
    },

    /**
     * @param {jquery[]|string} content HTML or String-based content.
     * @param {string} [thisClass] optional, additional CSS class that gets appeneded to any anchor tags inside of the content.
     * @returns {string} the appended content
     */
    addClassToLinks: function addClassToLinks(content, thisClass) {
      var isjQuery = content instanceof $ && content.length > 0;

      if (isjQuery) {
        return content;
      }

      var d = $('<div/>').html(content);
      $('a', d).addClass(thisClass);
      return d.html();
    },

    /**
     * Gets a reference to the element being used for the tooltip and positions it in the correct spot on the page.
     * @private
     * @returns {void}
     */
    appendTooltip: function appendTooltip() {
      this.tooltip = this.settings.tooltipElement ? $(this.settings.tooltipElement) : $('#tooltip');

      if (!this.tooltip.length) {
        var name = this.settings.tooltipElement ? this.settings.tooltipElement.substring(1, this.settings.tooltipElement.length) : 'tooltip';
        this.tooltip = $("<div class=\"".concat(this.isPopover ? 'popover' : 'tooltip', " bottom is-hidden\" role=\"tooltip\" id=\"").concat(name, "\"><div class=\"arrow\"></div><div class=\"tooltip-content\"></div></div>"));
      }

      this.tooltip.place({
        container: this.scrollparent,
        parent: this.activeElement,
        placement: this.settings.placement,
        strategy: 'flip'
      }); // Attach a reference to this tooltip API to the actual tooltip/popover element

      $.data(this.tooltip[0], 'tooltip', this);
      this.setTargetContainer();
    },

    /**
     * Sets up all event listeners for this component
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var delay = self.settings.delay;
      var renderLoopDelay = delay / 10;

      function clearTimer() {
        if (self.timer && self.timer.destroy) {
          self.timer.destroy(true);
        }
      }

      function showOnTimer() {
        clearTimer();
        self.timer = new RenderLoopItem({
          duration: renderLoopDelay,
          timeoutCallback: function timeoutCallback() {
            self.show();
          }
        });
        renderLoop.register(self.timer);
      }

      function showImmediately() {
        clearTimer();
        self.show();
      }

      function hideImmediately() {
        clearTimer();
        self.hide();
      }

      if (this.settings.trigger === 'hover' && !this.settings.isError) {
        (this.element.is('.dropdown, .multiselect, span.longpress-target') ? this.activeElement : this.element).on("mouseenter.".concat(COMPONENT_NAME$5), function () {
          if (self.isTouch) {
            return;
          }

          showOnTimer();
        }).on("mouseleave.".concat(COMPONENT_NAME$5), function () {
          if (self.visible) {
            hideImmediately();
          } else {
            clearTimer();
          }
        }).on("click.".concat(COMPONENT_NAME$5), function () {
          if (self.isTouch) {
            return;
          }

          hideImmediately();
        }).on("longpress.".concat(COMPONENT_NAME$5), function () {
          showImmediately();
        }).on("updated.".concat(COMPONENT_NAME$5), function () {
          self.updated();
        });

        if (this.settings.showOnKeyboardFocus) {
          (this.element.is('.dropdown, .multiselect, span.longpress-target') ? this.activeElement : this.element).on("focus.".concat(COMPONENT_NAME$5), function () {
            if (self.isTouch && !keyboard.pressedKeys.get('Tab')) {
              return;
            }

            showOnTimer();
          }).on("blur.".concat(COMPONENT_NAME$5), function () {
            if (!self.settings.keepOpen) {
              hideImmediately();
            }
          });
        }
      }

      function toggleTooltipDisplay() {
        if (!self.visible) {
          showImmediately();
        } else {
          hideImmediately();
        }
      }

      if (this.settings.trigger === 'click') {
        this.element.on("click.".concat(COMPONENT_NAME$5), function () {
          toggleTooltipDisplay();
        });
      }

      if (this.settings.trigger === 'immediate') {
        setTimeout(function () {
          toggleTooltipDisplay();
        }, 1);
      }

      var isFocusable = this.settings.trigger === 'focus';

      if (isFocusable) {
        this.element.on("focus.".concat(COMPONENT_NAME$5), function () {
          showImmediately();
        }).on("blur.".concat(COMPONENT_NAME$5), function () {
          if (!self.settings.keepOpen) {
            hideImmediately();
          }
        });
      } // Close the popup/tooltip on orientation changes (but not when keyboard is open)


      $(window).on("orientationchange.".concat(COMPONENT_NAME$5), function () {
        if (!self.visible) {
          return;
        }

        hideImmediately();
      }, false);
    },

    /**
     * Sets the content used inside the Tooltip element.
     * @private
     * @param {jquery[]|string|function} content incoming content to be set
     * @param {boolean} dontRender causes the tooltip to prevent a visual refresh
      after changing its content, meaning it will keep the previous content visible until this tooltip is closed or manually re-drawn.
     * @returns {boolean} whether or not the render was successful
     */
    setContent: function setContent(content, dontRender) {
      var self = this;
      var settingsContent = this.settings.content;
      var noIncomingContent = content === undefined || content === null;
      var noSettingsContent = settingsContent === undefined || settingsContent === null;

      function doRender() {
        if (dontRender === true) {
          return;
        }

        self.addAria();
        self.render();
      } // If all sources of content are undefined, just return false and don't show anything.


      if (noIncomingContent && noSettingsContent) {
        return false;
      } // If the settingsContent type is a function, we need to re-run that function
      // to update the content.
      // NOTE: If you need to use a function to generate content, understand that the
      //  tooltip/popover will not cache your content for future reuse.  It will ALWAYS
      //  override incoming content.


      if (typeof settingsContent === 'function') {
        content = settingsContent;
      } // Use the pre-set content if we have no incoming content


      if (noIncomingContent) {
        content = settingsContent;
      } // If the incoming/preset content is exactly the same as the stored content,
      // don't continue with this step. Deep object comparison for jQuery objects
      // is done further down the chain.


      if (content === this.content) {
        doRender();
        return true;
      } // jQuery-wrapped elements don't get manipulated.
      // Simply store the reference, render, and return.


      if (content instanceof $ && content.length) {
        this.content = content.addClass('hidden');
        doRender();
        return true;
      } // Handle setting of content based on its Object type.
      // If type isn't handled, the tooltip will not display.


      if (typeof content === 'string') {
        if (!content.length) {
          return false;
        } // Could be a translation definition


        content = Locale.translate(content, {
          showAsUndefined: true
        }) || content; // Could be an ID attribute.
        // If it matches an element already on the page, grab that element's content
        // and store the reference only.
        // Adding a condition if it's really uses the ID attribute.

        var idAttr = this.element[0].id;

        if (content.indexOf('#') === 0 && (this.settings.popover ? true : idAttr === content.split('#').pop())) {
          var contentCheck = $("".concat(content));

          if (contentCheck.length) {
            this.content = contentCheck;
            doRender();
            return true;
          }

          return false;
        } // functions

      } else if (typeof content === 'function') {
        var callbackResult = content.call(this.element);

        if (!callbackResult || typeof callbackResult !== 'string' || !callbackResult.length) {
          return false;
        }

        content = callbackResult; // if type isn't handled, return false
      } else {
        return false;
      } // Store an internal copy of the processed content


      this.content = xssUtils.sanitizeHTML(content); // Wrap tooltip content in <p> tags if there isn't already one present.
      // Only happens for non-jQuery markup.

      this.content = "<p>".concat(this.content, "</p>");
      doRender();
      return true;
    },

    /**
     * Renders internal content either as a Tooltip or Popover.
     * @private
     * @returns {void}
     */
    render: function render() {
      if (this.isPopover) {
        return this.renderPopover();
      }

      return this.renderTooltip();
    },

    /**
     * Renders internal content as a Tooltip.
     * @private
     * @returns {void}
     */
    renderTooltip: function renderTooltip() {
      var titleArea = this.tooltip[0].querySelectorAll('.tooltip-title')[0];
      var contentArea = this.tooltip[0].querySelectorAll('.tooltip-content')[0];
      var extraClass = this.settings.extraClass;
      var content = this.content;
      var tooltip = this.tooltip[0];
      var classes = 'tooltip is-hidden';

      if (extraClass) {
        classes += " ".concat(extraClass);
      }

      tooltip.setAttribute('class', classes);

      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes(this.tooltip, this, this.settings.attributes);
      }

      if (titleArea) {
        titleArea.style.display = 'none';
      }

      if (contentArea && contentArea.previousElementSibling && !contentArea.previousElementSibling.classList.contains('arrow')) {
        contentArea.insertAdjacentHTML('beforebegin', '<div class="arrow"></div>');
      }

      var tooltipHTML = typeof this.content === 'string' ? content : content[0].innerHTML;
      DOM.html(contentArea, tooltipHTML, '<div><p><span><ul><li><a><abbr><b><i><kbd><small><strong><sub><svg><use><br>');
    },

    /**
     * Renders internal content as a Tooltip.
     * @private
     * @returns {void}
     */
    renderPopover: function renderPopover() {
      var self = this;
      var extraClass = this.settings.extraClass;
      var contentArea = this.tooltip.find('.tooltip-content');
      var title = this.tooltip[0].querySelector('.tooltip-title');
      var content = this.content;
      var classes = 'popover is-hidden';

      if (extraClass) {
        classes += " ".concat(extraClass);
      }

      this.tooltip[0].setAttribute('class', classes);

      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes(this.tooltip, this, this.settings.attributes);
      }

      var useHtml = Environment.browser.name === 'ie' && Environment.browser.isIE11() && content instanceof $ && content.length && this.settings.trigger === 'hover';

      if (typeof content === 'string') {
        content = $(content);
        contentArea.html(content);
        contentArea.find('.hidden').removeClass('hidden');
      } else if (useHtml) {
        var clone = content[0].cloneNode(true);
        var id = clone.id;

        if (id) {
          clone.id = "".concat(id, "-").concat(this.uniqueId);
        }

        contentArea.html(clone.outerHTML);
      } else {
        contentArea.html(content);
      }

      var popoverWidth = contentArea.width();

      if (!this.settings.placementOpts) {
        this.settings.placementOpts = {};
      }

      if (!this.settings.placementOpts.parent) {
        this.settings.placementOpts.parent = this.element;
      }

      if (!useHtml) {
        content[0].classList.remove('hidden');
      }

      contentArea[0].firstElementChild.classList.remove('hidden');
      var parentWidth = this.settings.placementOpts.parent.width();

      if (Locale.isRTL()) {
        this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'left' : 'right';
      } else {
        this.settings.placementOpts.parentXAlignment = parentWidth > popoverWidth ? 'right' : 'left';
      }

      if (this.settings.title !== null) {
        if (!title) {
          var titleFrag = document.createDocumentFragment();
          title = document.createElement('div');
          DOM.html(title, this.settings.title, '*');
          title.classList.add('tooltip-title');

          if (this.settings.headerClass) {
            DOM.addClass(title, this.settings.headerClass, 'filled');
          }

          titleFrag.appendChild(title);
          this.tooltip[0].insertBefore(titleFrag, this.tooltip[0].firstChild);
        } else {
          title.style.display = '';
          title.childNodes[0].nodeValue = this.settings.title;
        }
      } else if (title) {
        title.style.display = 'none';
      }

      if (this.settings.closebutton && title && !title.firstElementChild) {
        var closeBtnX = $("<button type=\"button\" class=\"btn-icon l-pull-right btn-close\">".concat($.createIcon({
          classes: ['icon-close'],
          icon: 'close'
        }), "<span>Close</span>") + '</button>').on('click', function () {
          self.hide(true);
        });
        title.appendChild(closeBtnX[0]);

        if (Array.isArray(this.settings.attributes)) {
          utils.addAttributes(closeBtnX, this, this.settings.attributes, 'close-btn');
        }
      }

      if (this.settings.initializeContent) {
        content.initialize();
      }
    },

    /**
     * Alias for _show()_.
     * @private
     * @returns {void}
     */
    open: function open() {
      return this.show();
    },

    /**
     * Causes the tooltip to become shown
     * @param {object} newSettings an object containing changed settings that will be
     *  applied to the Tooltip/Popover before it's displayed.
     * @param {boolean} ajaxReturn causes an AJAX-powered Tooltip/Popover not to refresh.
     */
    show: function show(newSettings, ajaxReturn) {
      var self = this; // Don't open if this is an Actions Button with an open popupmenu

      if (this.popupmenuAPI && this.popupmenuAPI.isOpen) {
        return;
      } // Don't open if this tooltip's trigger element is currently hidden.


      if (!this.canBeShown) {
        return;
      }

      this.isInPopup = false;

      if (newSettings) {
        this.settings = utils.mergeSettings(this.element[0], newSettings, this.settings);
      }

      if (this.settings.beforeShow && !ajaxReturn) {
        var response = function response(content) {
          if (typeof content === 'boolean' && !content) {
            return;
          }

          self.content = content;
          self.show({
            content: content
          }, true);
        };

        if (typeof this.settings.beforeShow === 'string') {
          window[this.settings.beforeShow](response, this.element);
          return;
        }

        this.settings.beforeShow(response, this.element);
        return;
      }

      var okToShow = true;
      okToShow = this.setContent(this.content);

      if (okToShow === false) {
        return;
      }
      /**
       * Fires before show the tooltip.
       *
       * @event beforeshow
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */


      okToShow = this.element.triggerHandler('beforeshow', [this.tooltip]);

      if (okToShow === false) {
        return;
      }

      this.tooltip[0].removeAttribute('style');
      this.tooltip[0].classList.add(this.settings.placement);
      this.tooltip[0].classList.add('is-open');
      DOM.addClass(this.element[0], 'has-open-tooltip');

      if (this.settings.isError || this.settings.isErrorColor) {
        this.tooltip[0].classList.add('is-error');
      }

      this.position();
      utils.fixSVGIcons(this.tooltip);
      /**
       * Fires on show the tooltip.
       *
       * @event show
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */

      this.element.trigger('show', [this.tooltip]);
      var mouseUpEventName = this.isTouch ? 'touchend' : 'mouseup'; // Personalizable the tooltip

      if (!self.settings.popover) {
        var isPersonalizable = self.element.closest('.is-personalizable').length > 0;
        self.tooltip[0].classList[isPersonalizable ? 'add' : 'remove']('is-personalizable');
      }

      setTimeout(function () {
        $(document).on("".concat(mouseUpEventName, ".").concat(COMPONENT_NAME$5, "-").concat(self.uniqueId), function (e) {
          var target = $(e.target);

          if (self.settings.isError || self.settings.trigger === 'focus') {
            return;
          }

          if (target.is(self.element) && target.is('svg.icon')) {
            return;
          }

          if ($('#editor-popup').length && $('#colorpicker-menu').length) {
            return;
          }

          if ($('#editor-popup').length === 1 && target.closest('.popupmenu').length === 1) {
            return;
          }

          if (target.closest('.popover').length === 0 && target.closest('.dropdown-list').length === 0) {
            self.hide();
          } // Closes patepicker dialog closes when clicking on a parent popover


          if (target.closest('.popover').length === 1 && target.closest('.popover').not('.monthview-popup').length && self.element.prev().is('.datepicker')) {
            self.hide();
          }
        }).on("keydown.".concat(COMPONENT_NAME$5, "-").concat(self.uniqueId), function (e) {
          if (e.which === 27 || self.settings.isError) {
            self.hide();
          }
        });

        if (self.settings.isError && !self.element.is(':visible, .dropdown') && self.element.is('[aria-describedby]')) {
          self.hide();
        }

        if (window.orientation === undefined) {
          $('body').on("resize.".concat(COMPONENT_NAME$5), function () {
            self.hide();
          });
        } // Hide on Page scroll


        $('body').on("scroll.".concat(COMPONENT_NAME$5), function () {
          self.hide();
        });
        self.element.closest('.modal-body-wrapper').on('scroll.tooltip', function () {
          self.hide();
        });
        self.element.closest('.scrollable').on('scroll.tooltip', function () {
          self.hide();
        });
        self.element.closest('.datagrid-wrapper').on('scroll.tooltip', function () {
          self.hide();
        }); // Click to close

        if (self.settings.isError) {
          self.tooltip.on("click.".concat(COMPONENT_NAME$5), function () {
            self.hide();
          });
        }
        /**
         * Fires after show the tooltip.
         *
         * @event aftershow
         * @memberof Tooltip
         * @property {object} event - The jquery event object
         * @property {object} tooltip - instance
         */


        self.element.trigger('aftershow', [self.tooltip]);
      }, self.settings.delay);
    },

    /**
     * Places the tooltip element itself in the correct DOM element.
     * If the current element is inside a scrollable container, the tooltip element
     * goes as high as possible in the DOM structure.
     * @private
     * @returns {void}
     */
    setTargetContainer: function setTargetContainer() {
      var targetContainer = $('body');
      var attachAfterTriggerElem = false; // adjust the tooltip if the element is being scrolled inside a scrollable DIV

      this.scrollparent = this.element.closest('.page-container.scrollable');

      if (this.scrollparent.length) {
        targetContainer = this.scrollparent;
      } // If the tooltip/popover is located inside a Modal, contain it within the modal, but
      // place its markup directly after its target element.


      var modalParent = this.element.closest('.modal');

      if (!this.settings.attachToBody) {
        attachAfterTriggerElem = true;
        targetContainer = modalParent;
      } // If a specific parent element is defined, use that


      if (this.settings.parentElement) {
        targetContainer = this.settings.parentElement;
      }

      if (attachAfterTriggerElem) {
        this.tooltip.insertAfter(this.element);
      } else {
        targetContainer[0].appendChild(this.tooltip[0]);
      }
    },

    /**
     * Placement behavior's "afterplace" handler.
     * DO NOT USE FOR ADDITIONAL POSITIONING.
     * @private
     * @param {jquery.event} e custom `afterPlace` event
     * @param {placementobject} placementObj object containing placement settings
     * @returns {void}
     */
    handleAfterPlace: function handleAfterPlace(e, placementObj) {
      var _this = this;

      this.tooltip.data('place').setArrowPosition(e, placementObj, this.tooltip);
      setTimeout(function () {
        _this.tooltip.triggerHandler('tooltipafterplace', [placementObj]);
      });
    },

    /**
     * Resets the current position of the tooltip.
     * @returns {this} component instance
     */
    position: function position() {
      this.setTargetContainer();
      this.tooltip[0].classList.remove('is-hidden');
      var self = this;
      var distance = this.isPopover ? 20 : 10;
      var tooltipPlacementOpts = this.settings.placementOpts || {};
      var windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      var windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var rect = this.tooltip[0].getBoundingClientRect();
      var opts = $.extend({}, {
        x: 0,
        y: distance,
        container: this.scrollparent,
        containerOffsetX: tooltipPlacementOpts.containerOffsetX || this.settings.offset.left,
        containerOffsetY: tooltipPlacementOpts.containerOffsetY || this.settings.offset.top,
        parent: tooltipPlacementOpts.parent || this.activeElement,
        placement: tooltipPlacementOpts.placement || this.settings.placement,
        strategies: ['flip', 'nudge']
      }, tooltipPlacementOpts);

      if (opts.placement === 'left' || opts.placement === 'right') {
        opts.x = distance;
        opts.y = 0;
      }

      if (rect.width >= windowW && /left|right/g.test(opts.placement)) {
        this.tooltip[0].classList.add('no-arrow');
      } else if (rect.height >= windowH && /top|bottom/g.test(opts.placement)) {
        this.tooltip[0].classList.add('no-arrow');
      } else {
        this.tooltip[0].classList.remove('no-arrow');
      }

      this.tooltip.one('afterplace.tooltip', function (e, placementObj) {
        self.handleAfterPlace(e, placementObj);
      }); // Tool tip may be cleaned up on a modal or CAP

      if (this.tooltip.data('place')) {
        this.tooltip.data('place').place(opts);
      } else {
        this.tooltip.place(opts);
        this.tooltip.data('place').place(opts);
      }

      return this;
    },

    /**
     * Alias for _hide()_ that works with the global _closeChildren()_ method.
     * @private
     * @returns {void}
     */
    close: function close() {
      return this.hide();
    },

    /**
     * Hides the Tooltip/Popover
     * @param {boolean} [force=false] Force the tooltip to hide no matter the settings.
     * @returns {void}
     */
    hide: function hide(force) {
      if (this.settings.keepOpen && !force || !this.visible) {
        return;
      }

      if (this.isInPopup) {
        this.settings.content.addClass('hidden');
        return;
      }

      DOM.removeClass(this.element[0], 'has-open-tooltip');
      this.tooltip[0].classList.remove('is-personalizable');
      this.tooltip[0].classList.remove('is-open');
      this.tooltip[0].classList.add('is-hidden');
      this.tooltip[0].style.left = '';
      this.tooltip[0].style.top = '';
      this.tooltip.find('.arrow').removeAttr('style');
      this.detachOpenEvents();

      if ($('.popover').not('.is-hidden').length === 0) {
        $(document).off('mouseup.tooltip keydown.tooltip');
        $('body').off('resize.tooltip');
      }
      /**
       * Fires when hide the tooltip.
       *
       * @event hide
       * @memberof Tooltip
       * @property {object} event - The jquery event object
       * @property {object} tooltip - instance
       */


      this.element.triggerHandler('hide', [this.tooltip]);

      if (this.settings.onHidden) {
        this.settings.onHidden({
          api: this,
          elem: this.tooltip
        });
      }
    },

    /**
     * Causes the tooltip to store updated settings and re-render itself.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      var self = this;

      if (self.settings.trigger === 'immediate') {
        setTimeout(function () {
          self.show();
        }, 100);
      } else {
        self.setContent();
      }

      return this;
    },

    /**
     * Removes any events which would cause the tooltip/popover to re-open.
     * @private
     * @returns {void}
     */
    detachOpenEvents: function detachOpenEvents() {
      this.tooltip.off("click.".concat(COMPONENT_NAME$5));
      $(document).off(["keydown.".concat(COMPONENT_NAME$5, "-").concat(self.uniqueId), "mouseup.".concat(COMPONENT_NAME$5, "-").concat(self.uniqueId), "touchend.".concat(COMPONENT_NAME$5, "-").concat(self.uniqueId)].join(' '));
      $('body').off(["resize.".concat(COMPONENT_NAME$5), "scroll.".concat(COMPONENT_NAME$5)].join(' '));
      this.element.closest('.modal-body-wrapper').off("scroll.".concat(COMPONENT_NAME$5));
      this.element.closest('.scrollable').off("scroll.".concat(COMPONENT_NAME$5));
      this.element.closest('.datagrid-body').off("scroll.".concat(COMPONENT_NAME$5));
    },

    /**
     * Tears down this component instance, removing all internal flags and unbinding events.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      if (this.timer && this.timer.destroy) {
        this.timer.destroy(true);
      }

      this.description.remove();
      this.descriptionId = undefined;
      this.activeElement = undefined;
      this.element.removeAttr('aria-describedby').removeAttr('aria-haspopup');

      if (!this.tooltip.hasClass('is-hidden')) {
        this.hide();
      }

      if (this.reopenDelay) {
        delete this.reopenDelay;
      }

      if (this.tooltip && this.tooltip.length) {
        if (this.tooltip.data('place')) {
          this.tooltip.data('place').destroy();
        } // Remove a link back to this API, if one was generated


        if (this.tooltip.data('tooltip')) {
          $.removeData(this.tooltip[0], 'tooltip');
        }
      }

      this.element.off(["mouseenter.".concat(COMPONENT_NAME$5), "mouseleave.".concat(COMPONENT_NAME$5), "longpress.".concat(COMPONENT_NAME$5), "click.".concat(COMPONENT_NAME$5), "updated.".concat(COMPONENT_NAME$5), "focus.".concat(COMPONENT_NAME$5), "blur.".concat(COMPONENT_NAME$5)].join(' '));
      DOM.removeClass(this.element[0], 'has-tooltip');
      this.detachOpenEvents();
      $(window).off("orientationchange.".concat(COMPONENT_NAME$5));
      return this;
    },

    /**
     * Destroys this component instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$5);
    }
  };

  /**
   * jQuery Component Wrapper for Tooltip/Popover
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.tooltip = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$5);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$5, new Tooltip(this, settings));
      }
    });
  };

  var COMPONENT_NAME$6 = 'button'; // Styles of Buttons

  var buttonStyles = ['default', 'btn', 'btn-primary', 'btn-secondary', 'btn-tertiary', 'btn-destructive']; // Types of Buttons

  var buttonTypes = ['default', 'btn-icon', 'btn-menu', 'btn-actions', 'btn-toggle', 'icon-favorite', 'btn-editor', 'input']; // Pressable Button Types (has on/off state)

  var pressableTypes = ['icon-favorite', 'btn-toggle'];
  /**
   * IDS Button Component
   * @class Button
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {string} [settings.toggleOnIcon=null]  The icon to use for on state on toggle buttons
   * @param {string} [settings.toggleOffIcon=null]  The icon to use for off state on toggle buttons
   * @param {string} [settings.replaceText=false]  If true the selection will be used to replace the content
   */

  var BUTTON_DEFAULTS = {
    style: buttonStyles[0],
    type: buttonTypes[0],
    toggleOnIcon: null,
    toggleOffIcon: null,
    hideMenuArrow: null,
    replaceText: false,
    ripple: true,
    validate: false,
    attributes: null
  };

  function Button(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, BUTTON_DEFAULTS);
    this.init();
  } // Plugin Methods


  Button.prototype = {
    /**
     * @returns {Tooltip} component instance, if applicable
     */
    get tooltipAPI() {
      return this.element.data('tooltip');
    },

    /**
     * @returns {HTMLElement} a reference to this button's icon element
     */
    get icon() {
      return this.element[0].querySelector('svg:not(.ripple-effect):not(.icon-dropdown)');
    },

    /**
     * @returns {boolean} whether or not this component is currently disabled
     */
    get disabled() {
      if (this.element.parent().is('.spinbox-wrapper')) {
        return this.isDisabled(this.element.parent().find('input'));
      }

      return this.isDisabled(this.element);
    },

    /**
     * @param {boolean} val the value
     * @returns {void}
     */
    set disabled(val) {
      var isTrue = val === true;
      this.element[0].disabled = isTrue;
    },

    /**
     * Initializes the Button Component
     * @returns {void}
     */
    init: function init() {
      if (this.settings.buttonsetAPI !== undefined && typeof this.settings.buttonsetAPI.render === 'function') {
        this.buttonsetAPI = this.settings.buttonsetAPI;
        delete this.settings.buttonsetAPI;
      }

      this.getSettingsFromElement();
      this.render();
    },

    /**
     * Animates the button's ripple effects directly with Javascript,
     * for browsers that don't support CSS-based animation.
     * @private
     * @param {jQuery[]} el the ripple-effect element
     * @returns {void}
     */
    animateWithJS: function animateWithJS(el) {
      var scale = 200;
      var elStyle = el[0].style;
      var xPos = "".concat(parseFloat(elStyle.left) - scale / 2, "px");
      var yPos = "".concat(parseFloat(elStyle.top) - scale / 2, "px");
      el[0].style.opacity = '0.4';
      el.animate({
        opacity: 0,
        left: xPos,
        top: yPos,
        width: scale,
        height: scale
      }, 1000);
    },

    /**
     * @param {jQuery.Event} [e] incoming event object used for positioning.  If not provided,
     * the coordinates for the placement of the ripple will be at the center of the element.
     * @returns {void}
     */
    createRipple: function createRipple(e) {
      if (this.disabled) {
        return;
      }

      if (e) {
        // (!env.features.touch && e && e.which && e.which !== 1)
        // (env.features.touch && e.type !== 'touchstart')
        if (e.which !== undefined && e.which !== 1 || ['click', 'touchstart'].indexOf(e.type) === -1) {
          return;
        }
      } // Remove any previously-added ripple animations


      $('svg.ripple-effect', this.element).remove();
      var btnOffset = this.element.offset();
      var xPos;
      var yPos; // Derive X/Y coordinates from input events

      if (e) {
        if (!Environment.features.touch) {
          // Standard Mouse Click
          xPos = e.pageX - btnOffset.left;
          yPos = e.pageY - btnOffset.top;
        } else {
          // Use the `touchstart` event. Make sure the user is using only one finger and then get the touch position relative
          // to the ripple wrapper
          e = e.originalEvent;

          if (e && e.touches && e.touches.length === 1) {
            xPos = e.touches[0].pageX - btnOffset.left;
            yPos = e.touches[0].pageY - btnOffset.top;
          }
        }
      } // If values have not been defined, simply set them to the center of the element.


      xPos = xPos < 0 ? this.element.outerWidth() / 2 : xPos;
      yPos = yPos < 0 ? this.element.outerHeight() / 2 : yPos; // Create/place the ripple effect

      var ripple = $("<svg class=\"ripple-effect\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n      <circle r=\"0\" class=\"ripple-circle\"></circle>\n    </svg>");
      ripple[0].style.left = "".concat(xPos, "px");
      ripple[0].style.top = "".concat(yPos, "px");
      this.element.prepend(ripple); // Start the JS Animation Loop if IE9
      // Or Safari/Firefox has bug with combination like: animation, overflow, position,
      // border-radius etc.)

      if (!$.fn.cssPropSupport('animation') || Environment.browser.isSafari && !Environment.features.touch || Environment.browser.name === 'firefox') {
        ripple.removeClass('is-animation');
        this.animateWithJS(ripple);
      } else {
        var elem = $('svg.ripple-effect', this.element);
        elem.addClass('is-animation');
      }

      setTimeout(function () {
        ripple.remove();
      }, 1000);
    },

    /**
     * Renders the contents of the button
     * @returns {void}
     */
    render: function render() {
      var _this = this;

      this.renderAttributes();
      var elemClasses = this.element[0].classList; // Style = "primary/secondary/tertiary" hierarchy/context

      if (buttonStyles.indexOf(this.settings.style) > 0) {
        elemClasses.add(this.settings.style);
      } // Type = "function"


      if (buttonTypes.indexOf(this.settings.type) > 0) {
        elemClasses.add(this.settings.type);
      } // If this is a modal button, normalize CSS classes that are specific
      // to modal buttons.


      var buttonsetAPI = this.buttonsetAPI;
      var switchModalClasses = false;

      if (buttonsetAPI) {
        if (buttonsetAPI.settings.style === 'modal') {
          switchModalClasses = true;
        } // btn


        var btnClasses = ['default', 'btn', 'btn-modal'];

        if (btnClasses.indexOf(this.settings.style) > -1) {
          elemClasses[!switchModalClasses ? 'add' : 'remove']('btn');
          elemClasses[switchModalClasses ? 'add' : 'remove']('btn-modal');
        } // btn-primary


        var btnPrimaryClasses = ['btn-primary', 'btn-modal-primary'];

        if (btnPrimaryClasses.indexOf(this.settings.style) > -1) {
          elemClasses[!switchModalClasses ? 'add' : 'remove']('btn-primary');
          elemClasses[switchModalClasses ? 'add' : 'remove']('btn-modal-primary');
        } // btn-secondary


        var btnSecondaryClasses = ['btn-secondary', 'btn-modal-secondary'];

        if (btnSecondaryClasses.indexOf(this.settings.style) > -1) {
          elemClasses[!switchModalClasses ? 'add' : 'remove']('btn-secondary');
          elemClasses[switchModalClasses ? 'add' : 'remove']('btn-modal-secondary');
        }
      } // Backwards-compatibility with a legacy Modal setting.
      // `isDefault` is equivalent to setting a `btn-modal-primary` class.


      if (this.settings.isDefault) {
        this.settings.style = 'btn-primary';
        elemClasses.remove('btn-primary');
        elemClasses.add('btn-modal-primary');
        delete this.settings.isDefault;
      } // Add extra, user-defined CSS classes, if applicable


      if (typeof this.settings.cssClass === 'string') {
        this.element[0].className += xssUtils.stripHTML(this.settings.cssClass);
      } // Handle a one-time `disabled` setting, if defined.


      if (this.settings.disabled) {
        this.disabled = this.settings.disabled === true;
        delete this.settings.disabled;
      }

      var audibleTextBtnTypes = ['btn-icon', 'btn-actions']; // Handle the rendering of the text span.
      // Some buttons are "simpler" and directly inline the text inside the button tag.
      // Others wrap the text in a span, usually when there are multiple elements inside the button.

      if (this.settings.text) {
        var textSpan = this.element[0].querySelector('span');
        var hasPrexistingSpan = textSpan instanceof HTMLElement;

        if (!hasPrexistingSpan) {
          textSpan = this.element;
        }

        var currentTextContent = this.settings.text || $(textSpan).text().trim();
        currentTextContent = xssUtils.stripHTML(currentTextContent);

        if (!hasPrexistingSpan) {
          this.element[0].innerText = '';
          textSpan = document.createElement('span');
          this.element.append($(textSpan));

          if (this.settings.audible || audibleTextBtnTypes.indexOf(this.settings.type) > -1) {
            textSpan.classList.add('audible');
          }
        }

        textSpan.innerText = currentTextContent;
      } // Setup Icons, if applicable


      var iconElem = this.icon;
      var targetIcon;

      if (this.settings.icon) {
        targetIcon = this.settings.icon;
      } else if (this.settings.type === 'btn-toggle') {
        if (this.pressed) {
          targetIcon = this.settings.toggleOnIcon;
        } else {
          targetIcon = this.settings.toggleOffIcon;
        }
      } else if (this.settings.type === 'icon-favorite') {
        if (this.pressed) {
          targetIcon = 'icon-star-filled';
        } else {
          targetIcon = 'icon-star-outlined';
        }
      } else if (this.settings.type === 'btn-actions') {
        targetIcon = 'icon-more';
      } // if (targetIcon && ['btn-toggle', 'icon-favorite'].indexOf(this.settings.type) > -1) {


      if (targetIcon) {
        targetIcon = xssUtils.stripHTML(targetIcon);

        if (!(iconElem instanceof SVGElement) && !(iconElem instanceof HTMLElement)) {
          iconElem = $.createIconElement({
            icon: targetIcon.replace('icon-', '')
          });
          this.element.prepend($(iconElem));
        } else {
          iconElem.querySelector('use').setAttribute('href', "#".concat(targetIcon));
        }
      } // Add the Dropdown Arrow Icon to the button for Menu Buttons,
      // excluding icon menu buttons and action buttons


      if (this.element.hasClass('btn-menu') && !this.element.hasClass('btn-icon') && !this.element.hasClass('btn-actions')) {
        var ddIcon = this.element.children('svg.icon');
        var use = ddIcon.find('use');
        var hasIcon = false;

        if (ddIcon.length > 0 && use.length >= 1) {
          var hrefValue = use.last().attr('href');

          if (!hrefValue && use.last().attr('xlink:href')) {
            hrefValue = use.last().attr('xlink:href');
          }

          hasIcon = hrefValue.indexOf('#icon-dropdown') > -1;
        }

        if (!hasIcon) {
          ddIcon = $.createIconElement({
            icon: 'dropdown',
            classes: ['icon-dropdown']
          });
          this.element.append(ddIcon);
        }

        if (!ddIcon.hasClass('icon-dropdown')) {
          ddIcon.addClass('icon-dropdown');
        }

        if (this.settings.replaceText) {
          this.element.on('selected.content', function (e, a) {
            $(this).find('span').text(a.text());
          });
        }

        if (this.settings.hideMenuArrow) {
          ddIcon.remove();
        }
      } // Sets up click-to-toggle events on pressable button types (favorite, toggle)


      if (pressableTypes.indexOf(this.settings.type) > -1) {
        this.element.on('click.favorite', function () {
          _this.toggle();
        }); // Casuses the `set pressed()` property to rerender the button state
        // eslint-disable-next-line

        this.pressed = this.pressed;
      } // Standalone action buttons need a "More Actions" tooltip.
      // This is handled internally on most components that implement an action button.


      if (this.element.hasClass('btn-actions')) {
        if (!this.element.parents('.field').length && !this.element.parents('.toolbar').length) {
          if (!this.tooltipAPI) {
            if (!this.element.attr('title')) {
              var moreText = Locale.translate('More');
              this.element.attr('title', moreText).tooltip({
                content: moreText
              });
              return;
            }

            if (!this.settings.title || this.element.attr('title') === '') {
              this.tooltipAPI.destroy();
            }
          }
        }
      } // Hide/Show Ripple Effect


      elemClasses[this.settings.ripple ? 'remove' : 'add']('no-ripple');

      if (this.settings.ripple) {
        this.element.on('touchstart.button click.button', function (e) {
          _this.createRipple(e);
        });
      } // Hide Focus API


      if (!this.element.data('hidefocus')) {
        this.element.hideFocus();
      }
    },

    /**
     * Handle attributes from settings, if applicable
     * @returns {void}
     */
    renderAttributes: function renderAttributes() {
      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes(this.element, this, this.settings.attributes);
      }
    },

    /**
     * Backwards compatability method for buttons that were previously defined by markup.
     * This will take an existing DOM element representing a button, and rectify internal settings
     * to match the element's state.
     * NOTE: When actually storing settings, the lifecycle of the Button component is specifically designed
     * for this method to run ONE time, at the beginning of its creation.  It should not run every time `updated()` occurs.
     * To detect current settings without overwriting them, use a true `dontStoreSettings` argument.
     * @param {boolean} [dontStoreSettings=false] if true, will not store the current settings internally while running.
     * @returns {object} containing a JSON-friendly representation of this element's current state
     */
    getSettingsFromElement: function getSettingsFromElement() {
      var _this2 = this;

      var dontStoreSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var elementSettings = {}; // Setup link between this button instance and a parent buttonset component, if applicable.
      // NOTE this is not done with a getter because of the need to access it during the render step.

      var container = this.element.parents('.buttonset, .modal-buttonset');
      var buttonsetAPI;

      if (container.length) {
        buttonsetAPI = container.data('buttonset');

        if (buttonsetAPI) {
          this.buttonsetAPI = buttonsetAPI;
        }
      } // Button Style


      var elemClasses = this.element[0].classList || '';
      buttonStyles.forEach(function (style) {
        if (style !== 'default' && elemClasses.contains(style)) {
          elementSettings.style = style;
        }
      }); // In the case of Modal buttons, account for differences in naming convention on buttons

      if (this.buttonsetAPI && this.buttonsetAPI.settings.style === 'modal') {
        var modalBtnMappings = {
          'btn-modal': 'btn',
          'btn-modal-primary': 'btn-primary',
          'btn-modal-secondary': 'btn-secondary'
        };
        Object.keys(modalBtnMappings).forEach(function (modalBtnStyle) {
          if (elemClasses.contains(modalBtnStyle)) {
            elementSettings.style = modalBtnMappings[modalBtnStyle];
          }
        });
      } // Button Type


      buttonTypes.forEach(function (type) {
        if (type !== 'default' && elemClasses.contains(type)) {
          // ignore the `default` type classname
          elementSettings.type = type;
        }
      }); // Disabled State (only if it hasn't been pre-set via JS settings)

      if (!this.settings.disabled) {
        elementSettings.disabled = this.disabled;
      } // If the button type is pressable, get current state and the icons


      var ariaPressedAttr = this.element[0].getAttribute('aria-pressed');

      if (ariaPressedAttr !== undefined) {
        elementSettings.pressed = ariaPressedAttr === true;

        if (elementSettings.type === 'icon-favorite') {
          elementSettings.toggleOnIcon = 'icon-star-filled';
          elementSettings.toggleOffIcon = 'icon-star-outlined';
        }
      } // ID Attribute


      var idAttr = this.element[0].id;

      if (typeof idAttr === 'string' && idAttr.length) {
        elementSettings.id = idAttr;
      } // Title Attribute


      var titleAttr = this.element[0].title;

      if (typeof titleAttr === 'string' && titleAttr.length) {
        elementSettings.title = titleAttr;
      } // Ripple Effect


      if (elemClasses.contains('no-ripple')) {
        elementSettings.ripple = false;
      } // Audible Text Content


      var audibleTextElem = this.element[0].querySelector('span.audible');

      if (audibleTextElem) {
        elementSettings.audible = true;
      } // Pass all settings onto the `settings` object


      if (!dontStoreSettings) {
        Object.keys(elementSettings).forEach(function (setting) {
          _this2.settings[setting] = elementSettings[setting];
        });
      }

      return elementSettings;
    },

    /**
     * Provides a JSON-compatible data representation of this button component for use with
     * higher-level components.
     * @param {boolean} addContextElement if true, adds a reference to this button element to the return data (NOT JSON-compatible).
     * @returns {object} JSON-compatible representation of this button's configuration.
     */
    toData: function toData(addContextElement) {
      var _this3 = this;

      var ret = {};
      Object.keys(this.settings).forEach(function (setting) {
        ret[setting] = _this3.settings[setting];
      });
      ret.pressed = this.pressed;

      if (addContextElement) {
        ret.element = this.element[0];
      }

      return ret;
    },

    /**
     * @returns {boolean} whether or not this is a valid toggle button in a pressed state.
     */
    get pressed() {
      if (pressableTypes.indexOf(this.settings.type) === -1) {
        return false;
      }

      return this.element[0].getAttribute('aria-pressed') === 'true';
    },

    /**
     * On a Toggle or Favorite button, sets the current pressed state.
     * @param {boolean} val whether or not to set a "pressed" state on this valid toggle button.
     * @returns {void}
     */
    set pressed(val) {
      var trueVal = val === true;
      var hasPressedIcons = this.settings.toggleOffIcon && this.settings.toggleOnIcon;
      var iconElem = $(this.icon);
      this.element[0].setAttributeNS(null, 'aria-pressed', 'x');
      this.element[0].setAttributeNS(null, 'aria-pressed', trueVal);
      this.element[0].classList[trueVal ? 'add' : 'remove']('is-pressed'); // Change the icon

      var icon;

      switch (this.settings.type) {
        case 'icon-favorite':
          icon = trueVal ? 'icon-star-filled' : 'icon-star-outlined';
          break;

        case 'btn-toggle':
          if (hasPressedIcons) {
            icon = trueVal ? this.settings.toggleOnIcon : this.settings.toggleOffIcon;
          }

          break;
      }

      if (iconElem.length === 0 || typeof icon !== 'string') {
        return;
      }

      iconElem.changeIcon(icon);
      utils.fixSVGIcons(iconElem);
    },

    /**
     * Toggles the current state of an icon button.
     * @returns {void}
     */
    toggle: function toggle() {
      this.pressed = !this.pressed;
    },

    /**
     * Check if given element is disabled or not.
     * https://stackoverflow.com/a/41736179
     * $('elem')[0].disabled will only work on 'form elements' and will
     * return undefined for all others elements, so use $('elem').is('[disabled]') instead.
     * @private
     * @param {jQuery[]|HTMLElement} el element to check
     * @returns {boolean} True if disabled.
     */
    isDisabled: function isDisabled(el) {
      el = el instanceof jQuery ? el : $(el);
      return el.is('[disabled]') && !el.is('[disabled="false"]');
    },

    /**
     * Removes bound events and generated markup from this component
     * @private
     * @returns {Button} This component's API.
     */
    teardown: function teardown() {
      this.element.off(["click.".concat(COMPONENT_NAME$6), "touchstart.".concat(COMPONENT_NAME$6)].join(' '));
      var tooltipApi = this.tooltipAPI;

      if (this.element.hasClass('btn-actions') && tooltipApi) {
        tooltipApi.destroy();
      }

      var hidefocusApi = this.element.data('hidefocus');

      if (hidefocusApi) {
        hidefocusApi.destroy();
      }

      return this;
    },

    /**
     * Update the component with new settings.
     * @param {object} settings The settings you would like to modify.
     * @returns {Button} This component's API.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.teardown();
      this.render();
      return this;
    },

    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown(); // Delete the link to a parent buttonset

      var buttonsetAPI = this.buttonsetAPI;

      if (buttonsetAPI) {
        delete this.buttonsetAPI;
      }

      $.removeData(this.element[0], COMPONENT_NAME$6);
    }
    /**
    *  Fires when the button is clicked (if enabled).
    *
    * @event click
    * @memberof Button
    * @param {object} event - The jquery event object
    */

    /**
    * Fires when the button is focused.
    *
    * @event focus
    * @memberof Button
    * @param {object} event - The jquery event object
    */

  };

  /**
   * jQuery Component Wrapper for the Soho Button Element
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.button = function jQueryButton(settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$6);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$6, new Button(this, settings));
      }
    });
  };

  var COMPONENT_NAME$7 = 'buttonset'; // Styles of Buttonset

  var BUTTONSET_STYLES = ['default', 'modal']; // Default Buttonset Styles

  var BUTTONSET_DEFAULTS = {
    buttons: [],
    detectHTMLButtons: false,
    style: BUTTONSET_STYLES[0]
  };

  function ButtonSet(element, settings) {
    if (!(element instanceof HTMLElement)) {
      throw new Error('ButtonSet component needs an HTMLElement as a base element.');
    }

    this.element = element;
    this.settings = utils.mergeSettings(element, settings, BUTTONSET_DEFAULTS);
    this.init();
  }

  ButtonSet.prototype = {
    /**
     * @param {boolean} val whether or not the Buttonset is disabled.
     * @returns {void}
     */
    set disabled(val) {
      val = val === true;
      this.element.classList[val ? 'add' : 'remove']('is-disabled');

      if (this.buttons) {
        this.buttons.forEach(function (buttonAPI) {
          buttonAPI.disabled = val;
        });
      }
    },

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.build();
      this.render();
    },

    /**
     * @param {boolean} [doAdd=false] if true, does not reset the buttonset and simply adds the incoming buttons.
     * @returns {void}
     */
    build: function build(doAdd) {
      var _this = this;

      if (!this.buttons || !doAdd) {
        this.reset();
      } // If no/empty array is provided, try to detect pre-defined HTML buttons before rendering.


      if (!Array.isArray(this.settings.buttons) || !this.settings.buttons.length) {
        this.detectHTMLButtons();
        return;
      }

      this.settings.buttons.forEach(function (buttonJSON) {
        _this.add(buttonJSON);
      });
    },

    /**
     * Draws the entire buttonset.
     * @param {boolean} [ignoreChildren=false] if true, only renders the top-level Buttonset and leaves.
     * the child buttons alone (assuming the `render` step on buttons is manually called later).
     * @returns {void}
     */
    render: function render() {
      var _this2 = this;

      var ignoreChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var elemClasses = this.element.classList;
      var cssClassMap = {
        default: 'buttonset',
        modal: 'modal-buttonset'
      }; // Remove all classes except for the correct one.

      Object.keys(cssClassMap).forEach(function (style) {
        var cssClass = cssClassMap[style];

        if (_this2.settings.style !== style) {
          elemClasses.remove(cssClass);
        }
      });
      elemClasses.add(cssClassMap[this.settings.style]); // Render all established buttons

      if (!ignoreChildren) {
        this.buttons.forEach(function (buttonAPI) {
          buttonAPI.render();
        });
      }
    },

    /**
     * Adds button(s) to the Buttonset.
     * @param {object} settings containing
     * @param {boolean} [doAddDOM=false] if true, appends the new element to the Buttonset container after creation/update.
     */
    add: function add(settings) {
      var doAddDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!settings || _typeof(settings) !== 'object') {
        throw new Error('Settings object is required to add a new button to the ButtonSet');
      }

      var buttonElem = settings.element;
      var didExist = buttonElem instanceof HTMLElement;

      if (!didExist) {
        buttonElem = document.createElement('button');
      }

      var buttonId = xssUtils.stripHTML(settings.id);

      if (typeof buttonId === 'string' && buttonId.length > 0) {
        buttonElem.id = buttonId;
      } // Add the new button to the page


      var $buttonElem = $(buttonElem);

      if (doAddDOM || !didExist) {
        $(this.element).append($buttonElem);
      } // Invoke


      settings.buttonsetAPI = this;
      $buttonElem.button(settings);
      var buttonAPI = $buttonElem.data('button'); // Add the new API to the button store

      this.buttons.push(buttonAPI);
    },

    /**
     * @param {Button|HTMLElement|string} buttonAPI a Button Component instance, a Button HTML Element with an IDS component instance attached, or a string representing its ID
     * @param {boolean} [doRemoveDOM=false] if true, removes the button's HTML from the page.
     * @returns {void}
     */
    remove: function remove() {
      var buttonAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var doRemoveDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!buttonAPI) {
        throw new Error('No Button API, HTMLElement, or ID string provided');
      }

      var elem;
      var $elem; // Detect the type we're working with

      if (!(buttonAPI !== undefined && typeof buttonAPI.destroy === 'function')) {
        if (buttonAPI instanceof HTMLElement) {
          // Assume it's an Element
          elem = buttonAPI;
        } else if (typeof buttonAPI === 'string') {
          // Assume it's an ID String
          elem = $(this.element).find("#".concat(buttonAPI.replace('#', '')));
        }

        $elem = $(elem);
        buttonAPI = $(elem).data('button');

        if (!(buttonAPI !== undefined && typeof buttonAPI.destroy === 'function')) {
          throw new Error('The provided Button API did not match a button existing in this ButtonSet.');
        }
      } else {
        $elem = buttonAPI.element;
      }

      buttonAPI.destroy();

      if (doRemoveDOM) {
        $elem.remove();
      } // Remove the API from the buttons array


      this.buttons = this.buttons.filter(function (item) {
        return item !== buttonAPI;
      });
    },

    /**
     * Removes ALL buttons from the buttonset
     * @param {boolean} [doRemoveDOM=false] if true, removes the button's HTML from the page.
     * @returns {void}
     */
    removeAll: function removeAll() {
      var _this3 = this;

      var doRemoveDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.buttons.forEach(function (buttonAPI) {
        _this3.remove(buttonAPI, doRemoveDOM);
      });
    },

    /**
     * Resets the button array
     * @returns {void}
     */
    reset: function reset() {
      this.buttons = [];
    },

    /**
     * Returns a ButtonSet API in a specified place in the buttons array.
     * @param {number} idx index to target
     * @returns {Button|undefined} Button API at this particular buttonset index
     */
    at: function at() {
      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      return this.buttons[idx];
    },

    /**
     * Populates the `settings.buttons` array with the current set of rendered buttons
     * @private
     * @returns {void}
     */
    detectHTMLButtons: function detectHTMLButtons() {
      var _this4 = this;

      if (!this.settings.detectHTMLButtons) {
        return;
      }

      this.reset(); // HTML Buttons

      var htmlButtons = utils.getArrayFromList(this.element.querySelectorAll('button')) || [];
      htmlButtons.forEach(function (button) {
        var api = $(button).data('button');

        if (!api) {
          $(button).button();
          api = $(button).data('button');
        }

        var data = api.getSettingsFromElement(true);
        data.element = button;

        _this4.add(data);
      });
    },

    /**
     * Gets a data representation of the currently available buttons.
     * @returns {object} containing a list of object-representations of the available buttons.
     */
    toData: function toData() {
      var data = utils.extend({}, this.settings);
      this.buttons.forEach(function (buttonAPI) {
        data.buttons.push(buttonAPI.toData());
      });
      return data;
    },

    /**
     * Removes bound events and generated markup from this component
     * @private
     * @param {boolean} [doRemoveDOM=false] if true, removes the button HTML
     * @returns {ButtonSet} This component's API.
     */
    teardown: function teardown(doRemoveDOM) {
      this.removeAll(doRemoveDOM);
      this.reset();
      return this;
    },

    /**
     * Update the component with new settings.
     * @param {object} settings The settings you would like to modify.
     * @returns {ButtonSet} This component's API.
     */
    updated: function updated(settings) {
      var prevButtons = this.settings.buttons;

      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      } // Only teardown/re-init the buttons if the incoming buttons array is defined,
      // and different than the ones that have already been defined.  Otherwise,
      // simply re-render what's there.


      if (Array.isArray(settings.buttons) && prevButtons !== settings.buttons) {
        this.settings.buttons = settings.buttons;
        this.teardown(true);
        this.init();
      } else {
        this.render(true);
        this.buttons.forEach(function (buttonAPI) {
          buttonAPI.updated();
        });
      }

      return this;
    },

    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown(true);
      $.removeData(this.element, COMPONENT_NAME$7);
    }
  };

  /**
   * jQuery Component Wrapper for the Soho Button Element
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.buttonset = function jQueryButton(settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$7);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$7, new ButtonSet(this, settings));
      }
    });
  };

  var COMPONENT_NAME$8 = 'hyperlink';
  /**
   * Soho component wrapper for Hyperlinks.
   * @class Hyperlink
   *
   * @param {HTMLElement} element the base Hyperlink element
   * @param {object} [settings] incoming settings
   * @returns {this} component instance
   */

  var HYPERLINK_DEFAULTS = {};

  function Hyperlink(element, settings) {
    return this.init(element, settings);
  }

  Hyperlink.prototype = {
    init: function init(element, settings) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = element;
      }

      if (_typeof(settings) === 'object') {
        var previousSettings = this.settings || HYPERLINK_DEFAULTS;
        this.settings = utils.mergeSettings(this.element, settings, previousSettings);
      }

      this.element.classList.add('hyperlink');

      if (!this.focusBehavior) {
        this.focusBehavior = new HideFocus(this.element);
      }

      return this;
    },

    /**
     * Attach Events used by the Hyperlinks
     * @private
     * @returns {this} The component api for chaining.
     */
    handleEvents: function handleEvents() {
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },

    /**
     * Removes the events and pseudo-markup created by the hyperlinks
     * @returns {this} component instance
     */
    teardown: function teardown() {
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Hyperlink
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.hyperlink = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$8);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$8, new Hyperlink(this, settings));

        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$8);
        };
      }
    });
  };

  /**
   * Contains various Mask-related utilities, settings, masking functions, etc.
   * Available globally under `Soho.masks`.
   * @property {string} EMPTY_STRING just an empty string
   * @property {string} PLACEHOLDER_CHAR the default placeholder used in guides
   * @property {string} CARET_TRAP the string of characters representing a caret trap in mask arrays
   * @property {regexp} NON_DIGITS_REGEX regular expression that matches non-digit characters
   * @property {regexp} DIGITS_REGEX regular expression that matches digit characters
   * @property {regexp} ALPHAS_REGEX regular expression that matches alphabetic, non-special characters
   * @property {regexp} ANY_REGEX regular expression that matches any non-special characters
   * @property {object} LEGACY_DEFS mask definitions used by the old Soho Mask component.
   *  Will be translated to RegExp when a string-based pattern is convered to an array in the new Mask.
   * @property {object} DEFAULT_API_OPTIONS base options passed to a Mask API.
   * @property {object} DEFAULT_CONFORM_OPTIONS default set of options that get passed to `maskAPI.conformToMask()`
   */

  var masks = {
    EMPTY_STRING: '',
    PLACEHOLDER_CHAR: '_',
    CARET_TRAP: '[]',
    NON_DIGITS_REGEX: /[^\u0660-\u06690-9\u0966-\u096F\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD]/g,
    DIGITS_REGEX: /[\u0660-\u06690-9\u0966-\u096F\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD]/,
    ALPHAS_REGEX: /[\u00C0-\u017Fa-zA-Z]/,
    ANY_REGEX: /[\u00C0-\u017Fa-zA-Z0-9]/,
    DEFAULT_API_OPTIONS: {
      locale: 'en-US',
      pattern: undefined,
      pipe: undefined
    }
  }; // Legacy Mask pattern definitions.
  // The New Mask works based on an array of RegExps and Strings.

  masks.LEGACY_DEFS = {
    '#': masks.DIGITS_REGEX,
    0: masks.DIGITS_REGEX,
    x: masks.ALPHAS_REGEX,
    '*': masks.ANY_REGEX,
    '?': /./,
    '~': /[-0-9]/,
    a: /[APap]/,
    m: /[Mm]/
  }; // Default options that get passed for the _conformToMask()_ method.

  masks.DEFAULT_CONFORM_OPTIONS = {
    caretTrapIndexes: [],
    guide: true,
    previousMaskResult: masks.EMPTY_STRING,
    placeholderChar: masks.PLACEHOLDER_CHAR,
    placeholder: masks.EMPTY_STRING,
    selection: {
      start: 0
    },
    keepCharacterPositions: true
  }; // Default Number Mask Options

  var DEFAULT_NUMBER_MASK_OPTIONS = {
    prefix: masks.EMPTY_STRING,
    suffix: masks.EMPTY_STRING,
    allowThousandsSeparator: true,
    symbols: {
      currency: '$',
      decimal: '.',
      negative: '-',
      thousands: ','
    },
    allowDecimal: true,
    decimalLimit: 2,
    locale: '',
    requireDecimal: false,
    allowNegative: false,
    allowLeadingZeros: false,
    integerLimit: null
  }; // Gets the number of leading zeros in a string representing a formatted number.
  // @param {string} formattedStr the string to be checked
  // @returns {number} containing the number of leading zeros.

  function getLeadingZeros(formattedStr) {
    return "".concat(formattedStr).match(/^0*/)[0].length;
  } // Converts a string representing a formatted number into a Number Mask.
  // @param {string} strNumber incoming string
  // @returns {array} contains strings representing character literals and regex patterns.


  function convertToMask(strNumber) {
    return strNumber.split(masks.EMPTY_STRING).map(function (char) {
      return masks.DIGITS_REGEX.test(char) ? masks.DIGITS_REGEX : char;
    });
  } // Adds thousands separators to the correct spot in a formatted number string.
  // @param {string} n - the string
  // @param {string} thousands - the thousands separator.
  // @param {object} [options] - number mask function options.
  // @param {object} [localeStringOpts] - settings for `toLocaleString`.
  // @returns {string} the incoming string formatted with a thousands separator.
  // http://stackoverflow.com/a/10899795/604296


  function addThousandsSeparator(n, thousands, options, localeStringOpts) {
    if (n === '' || isNaN(n)) {
      return n;
    }

    var formatted = Locale.toLocaleString(Number(n), options.locale, localeStringOpts, thousands); // `Number.toLocaleString` does not account for leading zeroes, so we have to put them
    // back if we've configured this Mask to use them.

    if (options && options.allowLeadingZeros && n.indexOf('0') === 0) {
      var zeros = getLeadingZeros(n);

      if (formatted.indexOf('0') === 0) {
        formatted = formatted.substring(1);
      }

      while (zeros > 0) {
        zeros -= 1;
        formatted = "0".concat(formatted);
      }
    }

    return formatted;
  } // Gets an array of Regex objects matching the number of digits present in a source string
  // @param {string} part string representing the mark part.
  // @param {string} type 'any', 'digits', or 'alphas'
  // @returns {array} regex representing the part that was passed in.


  function getRegexForPart(part, type) {
    var types = {
      any: masks.ANY_REGEX,
      digits: masks.DIGITS_REGEX,
      alphas: masks.ALPHAS_REGEX
    };

    if (!types[type]) {
      type = 'any';
    }

    var size = part.toString().length;
    var arr = [];

    while (size > 0) {
      arr.push(types[type]);
      size -= 1;
    }

    return arr;
  }
  /**
   * Soho Number Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted number.
   */


  masks.numberMask = function sohoNumberMask(rawValue, options) {
    options = utils.mergeSettings(undefined, options, DEFAULT_NUMBER_MASK_OPTIONS);

    if (!options.locale || !options.locale.length) {
      options.locale = Locale.currentLocale.name;
    } // Deprecated in v4.25.1


    if (options.allowLeadingZeroes) {
      warnAboutDeprecation('allowLeadingZeros', 'allowLeadingZeroes', 'Number Mask');
      options.allowLeadingZeros = options.allowLeadingZeroes;
      options.allowLeadingZeroes = undefined;
    }

    var PREFIX = options.prefix;
    var SUFFIX = options.suffix;
    var DECIMAL = options.symbols.decimal;
    var THOUSANDS = options.symbols.thousands;
    var prefixLength = PREFIX && PREFIX.length || 0;
    var suffixLength = SUFFIX && SUFFIX.length || 0;
    var thousandsSeparatorSymbolLength = THOUSANDS && THOUSANDS.length || 0;

    function numberMask(thisRawValue) {
      if (typeof thisRawValue !== 'string') {
        thisRawValue = masks.EMPTY_STRING;
      }

      var rawValueLength = thisRawValue.length;

      if (thisRawValue === masks.EMPTY_STRING || thisRawValue[0] === PREFIX[0] && rawValueLength === 1) {
        return PREFIX.split(masks.EMPTY_STRING).concat([masks.DIGITS_REGEX]).concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      if (thisRawValue === DECIMAL && options.allowDecimal) {
        return PREFIX.split(masks.EMPTY_STRING).concat(['0', DECIMAL, masks.DIGITS_REGEX]).concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      var indexOfLastDecimal = thisRawValue.lastIndexOf(DECIMAL);
      var hasDecimal = indexOfLastDecimal !== -1;
      var isNegative = thisRawValue[0] === options.symbols.negative && options.allowNegative;
      var integer;
      var fraction;
      var mask; // remove the suffix

      if (thisRawValue.slice(suffixLength * -1) === SUFFIX) {
        thisRawValue = thisRawValue.slice(0, suffixLength * -1);
      }

      if (hasDecimal) {
        integer = thisRawValue.slice(thisRawValue.slice(0, prefixLength) === PREFIX ? prefixLength : 0, indexOfLastDecimal);
        fraction = thisRawValue.slice(indexOfLastDecimal + 1, rawValueLength);
        fraction = convertToMask(fraction.replace(masks.NON_DIGITS_REGEX, masks.EMPTY_STRING));
      } else if (thisRawValue.slice(0, prefixLength) === PREFIX) {
        integer = thisRawValue.slice(prefixLength);
      } else {
        integer = thisRawValue;
      }

      if (options.integerLimit && typeof options.integerLimit === 'number') {
        var thousandsSeparatorRegex = THOUSANDS === '.' ? '[.]' : "".concat(THOUSANDS);
        var numberOfThousandSeparators = (integer.match(new RegExp(thousandsSeparatorRegex, 'g')) || []).length;
        integer = integer.slice(0, options.integerLimit + (isNegative ? 1 : 0) + numberOfThousandSeparators * thousandsSeparatorSymbolLength);
      }

      integer = integer.replace(masks.NON_DIGITS_REGEX, masks.EMPTY_STRING);

      if (!options.allowLeadingZeros) {
        integer = integer.replace(/^0+(0$|[^0])/, '$1');
      }

      var localeOptions = {
        maximumFractionDigits: options.decimalLimit,
        style: 'decimal',
        useGrouping: true
      };
      integer = options.allowThousandsSeparator ? addThousandsSeparator(integer, THOUSANDS, options, localeOptions) : integer;
      mask = convertToMask(integer);

      if (hasDecimal && options.allowDecimal || options.requireDecimal === true) {
        if (thisRawValue[indexOfLastDecimal - 1] !== DECIMAL) {
          mask.push(masks.CARET_TRAP);
        }

        mask.push(DECIMAL, masks.CARET_TRAP);

        if (fraction) {
          if (typeof options.decimalLimit === 'number') {
            fraction = fraction.slice(0, options.decimalLimit);
          }

          mask = mask.concat(fraction);
        }

        if (options.requireDecimal === true && thisRawValue[indexOfLastDecimal - 1] === DECIMAL) {
          mask.push(masks.DIGITS_REGEX);
        }
      }

      if (prefixLength > 0) {
        mask = PREFIX.split(masks.EMPTY_STRING).concat(mask);
      }

      if (isNegative) {
        // If user is entering a negative number, add a mask placeholder spot to
        // attract the caret to it.
        // TODO: Allow the negative symbol as the suffix as well (SOHO-3259)
        if (mask.length === prefixLength) {
          mask.push(masks.DIGITS_REGEX);
        }

        mask = [/-/].concat(mask);
      }

      if (SUFFIX.length > 0) {
        mask = mask.concat(SUFFIX.split(masks.EMPTY_STRING));
      }

      return {
        mask: mask
      };
    }

    numberMask.instanceOf = 'createNumberMask';
    return numberMask(rawValue);
  };
  /**
   * Soho Range Number Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted Number.
   */


  masks.rangeNumberMask = function (rawValue, options) {
    options = options || {};
    options.delimeter = options.delimeter || '-';
    var minusSign = Locale.currentLocale.data.numbers.minusSign;

    var regex = function regex(s) {
      return new RegExp("".concat(s), 'g');
    };

    var isValid = function isValid(x) {
      return /^\u0028.+\u0029$/g.test(x);
    };

    var getLen = function getLen(partValue, x) {
      return (partValue.match(x) || []).length;
    };

    var parts = rawValue.split(")".concat(options.delimeter, "("));

    var getPatterns = function getPatterns(partValue) {
      var thisChar = partValue.substr(-1);
      var partLen = {
        start: getLen(partValue, /[\u0028]/g),
        end: getLen(partValue, /[\u0029]/g)
      };
      var r = [];

      if (partLen.start === 1) {
        var isMinus = options.allowNegative && partValue.substr(1, 1) === minusSign;
        r = masks.numberMask(isMinus ? partValue.substr(1) : partValue, options);
        r.splice(0, 0, /[\u0028]/g);

        if (thisChar === ")") {
          r.push(/[\u0029]/g);
        } else if (thisChar === options.delimeter) {
          r.push(/[\u0029]/g);
          r.push(regex("[".concat(options.delimeter, "]")));
        }
      }

      return r;
    };

    if (typeof options.integerLimit === 'number') {
      options.integerLimit *= 2;
      options.integerLimit += options.delimeter.length + 4;
    }

    var r1 = [];
    var r2 = [];

    if (rawValue.substr(0, 1) === "(" && parts.length) {
      if (getLen(rawValue, /[\u0028]/g) === 2 && getLen(rawValue, /[\u0029]/g) === 2 && getLen(rawValue, regex("\\u0029".concat(options.delimeter, "\\u0028"))) === 1 && parts[1].indexOf(")") !== parts[1].length - 1) {
        var str1 = parts[1].substr(0, parts[1].indexOf(")") + 1);
        r1 = getPatterns("".concat(parts[0], ")"));
        r2 = [regex("[".concat(options.delimeter, "]"))].concat(_toConsumableArray(getPatterns("(".concat(str1))));
      } else {
        r1 = getPatterns(parts.length === 2 ? "".concat(parts[0], ")") : parts[0]);

        if (r1.length && parts.length === 2 && isValid("".concat(parts[0], ")"))) {
          r2 = [regex("[".concat(options.delimeter, "]"))].concat(_toConsumableArray(getPatterns("(".concat(parts[1]))));
        }
      }
    }

    return {
      mask: [].concat(_toConsumableArray(r1), _toConsumableArray(r2))
    };
  };
  /**
   * Adjust range number value and options
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} opts masking options
   * @param {string} inputApi mask input ele api
   * @returns {object} adjusted range number and options.
   */


  masks.adjustRangeNumber = function (rawValue, opts, inputApi) {
    if (inputApi.settings.process === 'rangeNumber') {
      var _inputApi$settings, _inputApi$settings$pa, _opts$previousMaskRes, _opts$selection, _opts$selection2, _opts$selection3, _opts$selection4;

      var delimeter = inputApi && (_inputApi$settings = inputApi.settings) !== null && _inputApi$settings !== void 0 && (_inputApi$settings$pa = _inputApi$settings == null ? void 0 : _inputApi$settings.patternOptions) !== null && _inputApi$settings$pa !== void 0 && (_inputApi$settings$pa == null ? void 0 : _inputApi$settings$pa.delimeter) ? inputApi.settings.patternOptions.delimeter : '-';
      var isLastcharDelimeter = opts && ((_opts$previousMaskRes = opts.previousMaskResult) === null || _opts$previousMaskRes === void 0 ? void 0 : _opts$previousMaskRes == null ? void 0 : _opts$previousMaskRes.substr(-1)) === delimeter;

      if (opts && ((_opts$selection = opts.selection) === null || _opts$selection === void 0 ? void 0 : _opts$selection == null ? void 0 : _opts$selection.start) === 1 && ((_opts$selection2 = opts.selection) === null || _opts$selection2 === void 0 ? void 0 : _opts$selection2 == null ? void 0 : _opts$selection2.end) === 1 && rawValue !== "(") {
        rawValue = "(".concat(rawValue);
        opts.selection.start++;
        opts.selection.end++;
      } else if (opts && ((_opts$selection3 = opts.selection) === null || _opts$selection3 === void 0 ? void 0 : _opts$selection3 == null ? void 0 : _opts$selection3.start) !== 1 && ((_opts$selection4 = opts.selection) === null || _opts$selection4 === void 0 ? void 0 : _opts$selection4 == null ? void 0 : _opts$selection4.end) !== 1 && rawValue.substr(-1) === ")" && (rawValue.match(/\u0028/g) || []).length === 1 && !isLastcharDelimeter) {
        rawValue = "".concat(rawValue).concat(delimeter, "(");
        opts.selection.start += 2;
        opts.selection.end += 2;
      }
    }

    return {
      rawValue: rawValue,
      opts: opts
    };
  }; // Default Date Mask Options


  var DEFAULT_DATETIME_MASK_OPTIONS = {
    format: 'M/d/yyyy',
    symbols: {
      timeSeparator: ':',
      dayPeriodSeparator: ' ',
      dateSeparator: '/'
    }
  }; // Maximum Values for various section maps of date strings.

  var DATE_MAX_VALUES = {
    dd: 31,
    d: 31,
    MMM: undefined,
    MM: 12,
    M: 12,
    yy: 99,
    yyyy: 9999,
    h: 12,
    hh: 12,
    H: 24,
    HH: 24,
    mm: 60,
    ss: 60,
    a: undefined
  }; // Converts a string containing character literals acting as separators for date sections
  // Into a regular expression that can be used to detect those characters (used later in the masking process)

  function getSplitterRegex(splitterStr) {
    var arr = splitterStr.split('');
    var fixedArr = arr.map(function (c) {
      if (c === ' ') {
        // convert space characters into white space matcher
        c = '\\s';
      }

      if (c === '-') {
        // escape dashes that might be part of date formats
        c = '\\-';
      }

      return c;
    });
    return new RegExp("[(".concat(fixedArr.join('|'), ")]+"));
  }
  /**
   * Soho Date Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted date.
   */


  masks.dateMask = function dateMask(rawValue, options) {
    options = utils.mergeSettings(undefined, options, DEFAULT_DATETIME_MASK_OPTIONS);
    var mask = [];
    var digitRegex = masks.DIGITS_REGEX;
    var format = options.format;
    var splitterStr = stringUtils.removeDuplicates(format.replace(/[dMyHhmsa]+/g, ''));
    var splitterRegex = getSplitterRegex(splitterStr);
    var formatArray = format.match(/(d{1,2}|M{1,4}|y{1,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|a{1}|z{1, 4}|E{1, 4})/g);
    var rawValueArray = rawValue.split(splitterRegex);
    var maxValue = DATE_MAX_VALUES;
    formatArray.forEach(function (part, i) {
      var value = maxValue[part];
      var size;

      if (part === 'a' || part === 'ah') {
        var am = 'AM';
        var pm = 'PM'; // Match the day period

        if (Locale.calendar()) {
          am = Locale.calendar().dayPeriods[0];
          pm = Locale.calendar().dayPeriods[1];
          var apRegex = [];

          for (var j = 0; j < am.length; j++) {
            if (am[j] && pm[j] && am[j].toLowerCase() === pm[j].toLowerCase()) {
              apRegex.push(am[j].toLowerCase());
            } else {
              apRegex.push(am[j].toLowerCase() + (pm[j] ? pm[j].toLowerCase() : ''));
            }
          }

          for (var k = 0; k < apRegex.length; k++) {
            mask.push(new RegExp("[".concat(apRegex[k], "]"), 'i'));
          }
        } else {
          mask.push(/[aApP]/, /[Mm]/);
        }

        if (part === 'ah') {
          var hourValue = rawValueArray[i].replace(am, '').replace(pm, '');
          mask = mask.concat(getRegexForPart(hourValue, 'digits'));
        }
      } else if (!value) {
        mask = mask.concat(getRegexForPart(part, 'alphas'));
      } else if (rawValueArray[i]) {
        // Detect based on the size of a pre-existing formatted value, if possible.
        var rawValueStr = rawValueArray[i].toString();
        var rawValueFirstDigit = parseInt(rawValueStr.substr(0, 1), 10);
        var maxFirstDigit = parseInt(maxValue[part].toString().substr(0, 1), 10);

        if (part.length === 1 && rawValueFirstDigit > maxFirstDigit) {
          mask.push(digitRegex);
        } else if (rawValueStr !== '0' && rawValueStr.length === 1 && rawValueFirstDigit <= maxFirstDigit && rawValueArray[i + 1] !== undefined && part.toUpperCase() !== 'HH') {
          mask.push(digitRegex);
        } else {
          mask = mask.concat(getRegexForPart(value, 'digits'));
        }
      } else {
        // If NOT possible, pass back the maximum digit length that can be entered here
        size = value.toString().length;

        while (size > 0) {
          mask.push(digitRegex);
          size -= 1;
        }
      } // If this is not the last part, add whatever literals come after this part,
      // but before the next part.


      var nextPart = formatArray[i + 1];

      if (nextPart !== undefined) {
        var thisPartSize = part.toString().length;
        var start = format.indexOf(part) + thisPartSize;
        var end = format.indexOf(nextPart);
        var literals = format.substring(start, end).split(masks.EMPTY_STRING); // Insert caret traps (create logical sections)

        var literalsWithCarets = [masks.CARET_TRAP].concat(literals.concat(masks.CARET_TRAP));
        mask = mask.concat(literalsWithCarets);
      }
    });
    return {
      mask: mask,
      literals: splitterStr.split(''),
      literalRegex: splitterRegex
    };
  };
  /**
   * Soho Range Date Mask Function
   * @param {string} rawValue the un-formatted value that will eventually be masked.
   * @param {object} options masking options
   * @returns {array} representing a mask that will match a formatted date.
   */


  masks.rangeDateMask = function (rawValue, options) {
    var parts = rawValue.split(options.delimeter);
    var delimiterArr = options.delimeter.split('');
    var firstDate = masks.dateMask(parts[0], options);
    var secondDate = [];

    if (parts[1]) {
      secondDate = masks.dateMask(parts[1], options);
    }

    return {
      mask: firstDate.mask.concat(delimiterArr.concat(secondDate.mask)),
      literals: delimiterArr,
      literalRegex: secondDate.literalRegex
    };
  };
  /**
   * Generates a pipe function that can be applied to a Mask API that will correct
   * shorthand numeric dates.
   * NOTE: DOES NOT WORK FOR DATES WITH ALPHABETIC CONTENT. Do not use this if your
   * dates contain "MMM" or the full month name.
   * @param {object} processResult the results object of a mask process
   * @param {object} options settings for the date pipe function
   * @returns {object} the result of the piping function's changes
   */


  masks.autocorrectedDatePipe = function autoCorrectedDatePipe(processResult, options) {
    if (!options.dateFormat) {
      options.dateFormat = Locale.calendar().dateFormat.short;
    }

    var indexesOfPipedChars = [];
    var dateFormatArray = options.dateFormat.split(/[^dMy]+/);
    var maxValue = {
      d: 31,
      M: 12,
      yy: 99,
      yyyy: 9999
    };
    var minValue = {
      d: 1,
      M: 1,
      yy: 0,
      yyyy: 1
    };
    var conformedValueArr = processResult.conformedValue.split(''); // Check first digit

    dateFormatArray.forEach(function (format) {
      var position = options.dateFormat.indexOf(format);
      var maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);

      if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
        conformedValueArr[position + 1] = conformedValueArr[position];
        conformedValueArr[position] = 0;
        indexesOfPipedChars.push(position);
      }
    });
    var placeholderRegex = new RegExp("[^".concat(processResult.placeholderChar, "]"));
    var maskPieces = processResult.placeholder.split(placeholderRegex);
    var conformedPieces = processResult.conformedValue.split(/\D/g); // Check for invalid date

    var isInvalid = dateFormatArray.some(function (format, i) {
      var length = maskPieces[i].length > format.length ? maskPieces[i].length : format.length;
      var textValue = conformedPieces[i] || '';
      var value = parseInt(textValue, 10);
      return value > maxValue[format] || textValue.length === length && value < minValue[format];
    });

    if (isInvalid) {
      return false;
    }

    return {
      value: conformedValueArr.join(''),
      characterIndexes: indexesOfPipedChars
    };
  };

  /* eslint-disable no-continue, no-underscore-dangle, no-restricted-syntax, no-labels */
  /**
   * @class MaskAPI
   * @constructor
   * @param {object} [settings] incoming settings
   */

  function MaskAPI(settings) {
    this.configure(settings);
    return this;
  }

  MaskAPI.prototype = {
    /**
     * Configure the API for an incoming mask request.
     * Set up patterns, change locale, basically 'pre-render'
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    configure: function configure(settings) {
      if (!this.settings) {
        this.settings = {};
      }

      if (!settings) {
        return this;
      }

      if (settings.locale) {
        // TODO: store references to thousands sep, decimal, currency symbols,
        // etc for the specified locale.
        this.locale = settings.locale;
      } // Pre-define a stored Mask pattern.
      // In cases where the mask is a string (Legacy Soho Mask), the string is automatically converted
      // to an array containing regex patterns.
      // In cases where the mask is a function, the function call is stored and called when the mask
      // needs to be processed.


      if (settings.pattern) {
        if (Array.isArray(settings.pattern) || typeof settings.pattern === 'function') {
          this.pattern = settings.pattern;
        } else if (typeof settings.pattern === 'string') {
          var defs = utils.mergeSettings(undefined, settings.definitions || {}, masks.LEGACY_DEFS);
          this.pattern = this._convertPatternFromString(settings.pattern, defs);
        } else ;
      }

      if (settings.patternOptions) {
        this.patternOptions = settings.patternOptions;
      }

      return this;
    },

    /**
     * Process a string against the masking algorithm
     * @param {string} rawValue the original, unmasked value
     * @param {object} [opts] process options
     * @returns {object} containing the processed mask along with some meta-data
     */
    process: function process(rawValue, opts) {
      if (typeof rawValue !== 'string') {
        throw new Error('No string provided');
      }

      var maskObj = {};
      var processResult = {
        originalValue: rawValue,
        caretPos: opts.selection.start,
        maskResult: false
      }; // Setup the pattern if it's a function.

      if (typeof this.pattern === 'function') {
        if (!opts.patternOptions) {
          opts.patternOptions = {};
        } // Merge incoming settings


        var maskOpts = utils.extend({}, this.patternOptions, opts.patternOptions, {
          caretPos: opts.selection.start,
          previousMaskResult: opts.previousMaskResult
        }); // Get a processed mask pattern from the function.
        // See #4079 for an explanation of the change from just an array to an object with meta-data.

        maskObj = this.pattern(rawValue, maskOpts);

        if (Array.isArray(maskObj)) {
          maskObj = {
            mask: maskObj
          };
        } // mask functions can setup caret traps to have some control over how the caret
        // moves. We need to process the mask for any caret traps. `processCaretTraps`
        // will remove the caret traps from the mask and return the indexes of the caret traps.


        var caretTrapInfo = this._processCaretTraps(maskObj.mask); // The processed mask is what we're interested in


        maskObj.mask = caretTrapInfo.maskWithoutCaretTraps;
        maskObj.caretTrapIndexes = caretTrapInfo.indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`

        opts.caretTrapIndexes = caretTrapInfo.indexes;
      } else {
        // Use a provided array
        maskObj = {
          mask: this.pattern
        };
      } // As a convenience, setting the mask to false will cause it to return without processing.


      if (maskObj.mask === false) {
        return processResult;
      }

      try {
        processResult = this._conformToMask(rawValue, maskObj, opts);
      } catch (e) {
        // console.error('Couldn\'t complete masking process: "'+ e.message +'"');
        return processResult;
      }

      if (opts.patternOptions && opts.patternOptions.delimeter && processResult.conformedValue && processResult.conformedValue !== rawValue) {
        processResult.caretPos = processResult.conformedValue.length;
      } // Handle the optional "pipe" cleanup method, if applicable.


      if (typeof opts.pipe === 'function') {
        var pipeResult = {}; // `pipe` receives the entire `processResult` object and the configurations with which
        // `conformToMask` was called.

        try {
          pipeResult = opts.pipe(processResult, opts);
        } catch (e) {
          // console.error('Couldn\'t complete mask\'s pipe function: "'+ e.message +'"');
          pipeResult = false;
        } // `pipeResults` should be an object. But as a convenience, we allow the pipe
        // author to just return `false` to indicate rejection. Or return just a string when there
        // are no piped characters.
        // If the `pipe` returns `false` or a string, the block below turns it into an
        // object that the rest of the code can work with.


        if (pipeResult === false) {
          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,
          // and set `rejected` to `true`.
          processResult.pipeResult = false;
          processResult.pipedValue = opts.previousMaskResult;
        } else if (utils.isString(pipeResult)) {
          processResult.pipeResult = true;
          processResult.pipedValue = pipeResult;
          processResult.pipedCharIndexes = [];
        } else {
          processResult = utils.extend({}, processResult, {
            pipeResult: pipeResult.result,
            pipedValue: pipeResult.value,
            pipedCharIndexes: pipeResult.characterIndexes
          });
        }
      }

      return processResult;
    },

    /**
     * Processes a raw string value against a masking algorithm and removes unfavorable chracters.
     * @private
     * @param {string} rawValue incoming full text string to process.
     * @param {object} maskObj containing the mask to be used for modifying the raw value, along with some meta-data calculated about the mask.
     * @param {object} [settings] incoming settings for mask parsing.
     * @returns {object} containing the conformation result and some meta-data
     */
    _conformToMask: function _conformToMask(rawValue, maskObj, settings) {
      // Set default settings
      settings = utils.mergeSettings(undefined, settings, masks.DEFAULT_CONFORM_OPTIONS); // Setup the placeholder version of the mask

      settings.placeholder = this._convertMaskToPlaceholder(maskObj.mask, settings.placeholderChar); // Setup booleans and numbers for various settings (speed)

      var charactersRejected = false;
      var suppressGuide = settings.guide === false && settings.previousMaskResult !== undefined;
      var rawValueLength = rawValue.length;
      var prevMaskResultLength = settings.previousMaskResult.length;
      var maskLength = this.pattern.length;
      var placeholderLength = settings.placeholder.length || 0;
      var placeholderChar = settings.placeholderChar;
      var caretPos = settings.selection.start;
      var resultStr = masks.EMPTY_STRING;
      var editDistance = rawValueLength - prevMaskResultLength;
      var isAddition = editDistance > 0;
      var indexOfFirstChange = caretPos + (isAddition ? -editDistance : 0);
      var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `_conformToMask()` is configured to keep character positions, that is,
      // for mask 111, previous value _2_ and raw value 3_2_, the new conformed value
      // should be 32_, not 3_2 (default behavior). That's in the case of addition.
      // And in the case of deletion, previous value _23, raw value _3, the new conformed
      // string should be __3, not _3_ (default behavior)
      //
      // The next block of logic handles keeping character positions for the case
      // of deletion. (Keeping character positions for the case of addition is further
      // down since it is handled differently.)
      // To do this, we want to compensate for all characters that were deleted

      if (settings.keepCharacterPositions === true && !isAddition) {
        // We will be storing the new placeholder characters in this variable.
        var compensatingPlaceholderChars = masks.EMPTY_STRING; // For every character that was deleted from a placeholder position, we add a placeholder char

        for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {
          if (settings.placeholder[i] === placeholderChar) {
            compensatingPlaceholderChars += placeholderChar;
          }
        } // Now we trick our algorithm by modifying the raw value to make it contain
        // additional placeholder characters. That way when the we start laying the
        // characters again on the mask, it will keep the non-deleted characters
        // in their positions.


        rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);
      } // Convert `rawValue` string to an array, and mark characters based on whether
      // they are newly added or have existed in the previous conformed value. Identifying new
      // and old characters is needed for `_conformToMask()` to work if it is configured
      // to keep character positions.


      function markAddedChars(char, j) {
        return {
          char: char,
          isNew: j >= indexOfFirstChange && j < indexOfLastChange
        };
      }

      var rawValueArr = rawValue.split(masks.EMPTY_STRING).map(markAddedChars); // The loop below removes masking characters from user input. For example, for mask
      // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below
      // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm
      // then would lay `234` on top of the available placeholder positions in the mask.

      for (var k = rawValueLength - 1; k >= 0; k--) {
        var char = rawValueArr[k];

        if (char !== settings.placeholderChar) {
          var shouldOffset = k >= indexOfFirstChange && prevMaskResultLength === maskLength;

          if (char === settings.placeholder[shouldOffset ? k - editDistance : k]) {
            rawValueArr.splice(k, 1);
          }
        }
      } // Loop through the placeholder string to find characters that need to be filled.


      placeholderLoop: for (var l = 0; l < placeholderLength; l++) {
        var charInPlaceholder = settings.placeholder[l]; // We see one. Let's find out what we can put in it.

        if (charInPlaceholder === placeholderChar) {
          // But before that, do we actually have any user characters that need a place?
          if (rawValueArr.length > 0) {
            // We will keep chipping away at user input until either we run out of characters
            // or we find at least one character that we can map.
            while (rawValueArr.length > 0) {
              // Let's retrieve the first user character in the queue of characters we have left
              var rawValueChar = rawValueArr.shift();
              var nextChar = rawValue.slice(l, l + 1); // If the character we got from the user input is a placeholder character (which happens
              // regularly because user input could be something like (540) 90_-____, which includes
              // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,
              // then we map this placeholder character to the current spot in the placeholder

              if (rawValueChar.char === placeholderChar && suppressGuide !== true) {
                resultStr += placeholderChar; // And we go to find the next placeholder character that needs filling

                continue placeholderLoop; // Else if, the character we got from the user input is a known literal member of the
                // mask (not necessarily user-input, and forms part of the formatting), add that and speed the mask
                // up to the next section.
              } else if (maskObj.literalRegex && maskObj.literalRegex.test(rawValueChar.char) && nextChar && (nextChar === rawValueChar.char || nextChar === placeholderChar)) {
                if (isAddition && maskObj.literals.indexOf(rawValue[l - 1]) > -1) {
                  caretPos++;
                  continue placeholderLoop;
                } // Analyze the number of this particular literal in the value,
                // and only add it if we haven't passed the maximum


                var thisLiteralRegex = new RegExp("(".concat(rawValueChar.char, ")"), 'g');
                var numberLiteralsPlaceholder = settings.placeholder.match(thisLiteralRegex).length;
                var numberLiteralsRawValue = rawValue.match(thisLiteralRegex).length;

                if (numberLiteralsRawValue <= numberLiteralsPlaceholder) {
                  resultStr += rawValueChar.char;
                } // Fast forward the loop to the after the next instance of this literal.


                var literalIndex = settings.placeholder.slice(l).indexOf(rawValueChar.char);

                while (literalIndex > 0) {
                  l++;
                  literalIndex--;
                }

                continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see
                // if the current position in the mask can accept it.
              } else if (maskObj.mask[l].test(rawValueChar.char)) {
                // we map the character differently based on whether we are keeping character
                // positions or not. If any of the conditions below are met, we simply map the
                // raw value character to the placeholder position.
                if (settings.keepCharacterPositions !== true || rawValueChar.isNew === false || settings.previousMaskResult === masks.EMPTY_STRING || settings.guide === false || !isAddition) {
                  resultStr += rawValueChar.char;
                } else {
                  // We enter this block of code if we are trying to keep character positions and
                  // none of the conditions above is met. In this case, we need to see if there's
                  // an available spot for the raw value character to be mapped to. If we couldn't
                  // find a spot, we will discard the character.
                  //
                  // For example, for mask `1111`, previous conformed value `_2__`, raw value
                  // `942_2__`. We can map the `9`, to the first available placeholder position,
                  // but then, there are no more spots available for the `4` and `2`. So, we
                  // discard them and end up with a conformed value of `92__`.
                  var rawValueArrLength = rawValueArr.length;
                  var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for
                  // either a suitable spot, ie, a placeholder character or a non-suitable spot,
                  // ie, a non-placeholder character that is not new. If we see a suitable spot
                  // first, we store its position and exit the loop. If we see a non-suitable spot
                  // first, we exit the loop and our `indexOfNextAvailablePlaceholderChar`
                  // will stay as `null`.

                  for (var x = 0; x < rawValueArrLength; x++) {
                    var charData = rawValueArr[x];

                    if (charData.char !== placeholderChar && charData.isNew === false) {
                      break;
                    }

                    if (charData.char === placeholderChar) {
                      indexOfNextAvailablePlaceholderChar = x;
                      break;
                    }
                  } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the
                  // character is not blocked. We can map it. And to keep the character positions,
                  // we remove the placeholder character from the remaining characters


                  if (indexOfNextAvailablePlaceholderChar !== null) {
                    resultStr += rawValueChar.char;
                    rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the
                    // character is blocked. We have to discard it.
                  } else {
                    l--;
                  }
                } // Since we've mapped this placeholder position. We move on to the next one.


                continue placeholderLoop;
              } else {
                charactersRejected = true;
              }
            }
          } // We reach this point when we've mapped all the user input characters to placeholder
          // positions in the mask. In *guide* mode, we append the left over characters in the
          // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.
          //
          // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.


          if (suppressGuide === false) {
            resultStr += settings.placeholder.substr(l, placeholderLength);
          } // And we break


          break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it
          // with user input. So as long as it doesn't exist at the rawValue's current index,
          // we just map it to the final output.
        } else {
          resultStr += charInPlaceholder;
        }
      } // The following logic is needed to deal with the case of deletion in *no guide* mode.
      //
      // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder
      // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.
      // That's why the logic below finds the last filled placeholder character,
      // and removes everything from that point on.


      if (suppressGuide && isAddition === false) {
        var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there

        for (var m = 0; m < resultStr.length; m++) {
          if (settings.placeholder[m] === placeholderChar) {
            indexOfLastFilledPlaceholderChar = m;
          }
        }

        if (indexOfLastFilledPlaceholderChar !== null) {
          // We substring from the beginning until the position after the last filled
          // placeholder char.
          resultStr = resultStr.substr(0, indexOfLastFilledPlaceholderChar + 1);
        } else {
          // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted
          // the first character in the mask. So we return an empty string.
          resultStr = masks.EMPTY_STRING;
        }
      }

      return {
        caretPos: caretPos,
        caretTrapIndexes: settings.caretTrapIndexes,
        conformedValue: resultStr,
        charactersRejected: charactersRejected,
        placeholder: settings.placeholder,
        placeholderChar: placeholderChar,
        maskResult: true
      };
    },

    /**
     * Detects Caret Traps inside of a Mask Array and identifies them with a rich object
     * @private
     * @param {array} mask the mask being checked
     * @returns {object} containing a modified Mask array without caret traps, and an array of
     *  indices with locations of the caret traps.
     */
    _processCaretTraps: function _processCaretTraps(mask) {
      var indexes = [];
      var indexOfCaretTrap = mask.indexOf(masks.CARET_TRAP);

      while (indexOfCaretTrap !== -1) {
        indexes.push(indexOfCaretTrap);
        mask.splice(indexOfCaretTrap, 1);
        indexOfCaretTrap = mask.indexOf(masks.CARET_TRAP);
      }

      return {
        maskWithoutCaretTraps: mask,
        indexes: indexes
      };
    },

    /**
     * Converts an array-based mask into a placeholder string.
     * @private
     * @param {array} mask - contains string "literal" characters and Regex matchers.
     * @param {string} placeholderChar - a character that will be used as the placeholder.
     * @returns {string} representing the placeholder
     */
    _convertMaskToPlaceholder: function _convertMaskToPlaceholder(mask, placeholderChar) {
      if (!Array.isArray(mask)) {
        mask = [];
      }

      if (!placeholderChar) {
        placeholderChar = masks.PLACEHOLDER_CHAR;
      }

      if (mask.indexOf(placeholderChar) !== -1) {
        throw new Error("".concat('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\n\n' + 'The placeholder character that was received is:').concat(JSON.stringify(placeholderChar), "\n\n") + "The mask that was received is: ".concat(JSON.stringify(mask)));
      }

      var ret = mask.map(function (char) {
        return char instanceof RegExp ? placeholderChar : char;
      }).join(masks.EMPTY_STRING);
      return ret;
    },

    /**
     * Takes an index representing a caret and changes it based on mask modifications
     * @private
     * @param {object} opts information about the caret placement.
     * @returns {number} the index of the text caret.
     */
    adjustCaretPosition: function adjustCaretPosition(opts) {
      //eslint-disable-line
      if (opts.caretPos === 0) {
        return 0;
      }

      function nonPlaceholderFilter(char) {
        return char !== nonPlaceholderFilter;
      } // Store lengths for faster performance?


      var rawValueLength = opts.rawValue.length;
      var previousConformedValueLength = opts.previousMaskResult.length;
      var placeholderLength = opts.placeholder ? opts.placeholder.length : 0;
      var conformedValueLength = opts.conformedValue ? opts.conformedValue.length : 0; // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,
      // we know the user in this instance pasted two characters

      var editLength = rawValueLength - previousConformedValueLength; // If the edit length is positive, that means the user is adding characters, not deleting.

      var isAddition = editLength > 0; // This is the first raw value the user entered that needs to be conformed to mask

      var isFirstRawValue = previousConformedValueLength === 0; // A partial multi-character edit happens when the user makes a partial selection in their
      // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by
      // selecting the first 3 digits and pressing backspace.
      //
      // Such cases can also happen when the user presses the backspace while holding down the ALT
      // key.

      var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue; // This algorithm doesn't support all cases of multi-character edits, so we just return
      // the current caret position.
      //
      // This works fine for most cases.

      if (isPartialMultiCharEdit) {
        return opts.caretPos;
      } // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter
      // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the
      // same as the original `previousConformedValue`. We handle this case differently for caret
      // positioning.


      var possiblyHasRejectedChar = isAddition && (opts.previousMaskResult === opts.conformedValue || opts.conformedValue === opts.placeholder);
      var startingSearchIndex = 0;
      var trackRightCharacter;
      var targetChar;

      if (possiblyHasRejectedChar) {
        startingSearchIndex = opts.caretPos - editLength;
      } else {
        // At this point in the algorithm, we want to know where the caret is right
        // before the raw input has been conformed, and then see if we can find that
        // same spot in the conformed input.
        //
        // We do that by seeing what character lies immediately before the caret,
        // and then look for that same character in the conformed input and place
        // the caret there.
        //
        // First, we need to normalize the inputs so that letter capitalization between raw input and
        // conformed input wouldn't matter.
        var normalizedConformedValue = opts.conformedValue.toLowerCase();
        var normalizedRawValue = opts.rawValue.toLowerCase(); // Then we take all characters that come before where the caret currently is.

        var leftHalfChars = normalizedRawValue.substr(0, opts.caretPos).split(masks.EMPTY_STRING); // Now we find all the characters in the left half that exist in the conformed
        // input. This step ensures that we don't look for a character that was filtered
        // out or rejected by `conformToMask`.

        var intersection = leftHalfChars.filter(function (char) {
          return normalizedConformedValue.indexOf(char) !== -1;
        }); //eslint-disable-line
        // The last character in the intersection is the character we want to
        // look for in the conformed value and the one we want to adjust the caret close to

        targetChar = intersection[intersection.length - 1]; // Calculate the number of mask characters in the previous placeholder
        // from the start of the string up to the place where the caret is

        var previousLeftMaskChars = opts.previousPlaceholder.substr(0, intersection.length).split(masks.EMPTY_STRING).filter(nonPlaceholderFilter).length; // Calculate the number of mask characters in the current placeholder
        // from the start of the string up to the place where the caret is

        var leftMaskChars = opts.placeholder.substr(0, intersection.length).split(masks.EMPTY_STRING).filter(nonPlaceholderFilter).length; // Has the number of mask characters up to the caret changed?

        var masklengthChanged = leftMaskChars !== previousLeftMaskChars; // Detect if `targetChar` is a mask character and has moved to the left

        var targetIsMaskMovingLeft = opts.previousPlaceholder[intersection.length - 1] !== undefined && opts.placeholder[intersection.length - 2] !== undefined && opts.previousPlaceholder[intersection.length - 1] !== opts.placeholderChar && opts.previousPlaceholder[intersection.length - 1] !== opts.placeholder[intersection.length - 1] && //eslint-disable-line
        opts.previousPlaceholder[intersection.length - 1] === opts.placeholder[intersection.length - 2] //eslint-disable-line
        ; // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true
        // or the mask is moving to the left, we can't use the selected `targetChar` any longer
        // if we are not at the end of the string.
        // In this case, change tracking strategy and track the character to the right of the caret.

        if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && opts.placeholder.indexOf(targetChar) > -1 && opts.rawValue[opts.caretPos] !== undefined) {
          trackRightCharacter = true;
          targetChar = opts.rawValue[opts.caretPos];
        } // It is possible that `targetChar` will appear multiple times in the conformed value.
        // We need to know not to select a character that looks like our target character
        // from the placeholder or the piped characters, so we inspect the piped characters
        // and the placeholder to see if they contain characters that match our target character.
        // If the `conformedValue` got piped, we need to know which characters were piped in so
        // that when we look for our `targetChar`, we don't select a piped char by mistake.


        var pipedChars = [];

        if (opts.indexesOfPipedChars) {
          pipedChars = opts.indexesOfPipedChars.map(function (index) {
            return normalizedConformedValue[index];
          });
        } // We need to know how many times the `targetChar` occurs in the piped characters.


        var countTargetCharInPipedChars = pipedChars.filter(function (char) {
          return char === targetChar;
        }).length; // We need to know how many times it occurs in the intersection

        var countTargetCharInIntersection = intersection.filter(function (char) {
          return char === targetChar;
        }).length; // We need to know if the placeholder contains characters that look like
        // our `targetChar`, so we don't select one of those by mistake.

        var countTargetCharInPlaceholder = opts.placeholder.substr(0, opts.placeholder.indexOf(opts.placeholderChar)).split(masks.EMPTY_STRING) // Check if `char` is the same as our `targetChar`, so we account for it
        // but also make sure that both the `rawValue` and placeholder don't have the same
        // character at the same index because if they are equal, that means we are already
        // counting those characters in `countTargetCharInIntersection`
        .filter(function (char, index) {
          return char === targetChar && opts.rawValue[index] !== char;
        }).length; // The number of times we need to see occurrences of the `targetChar` before we
        // know it is the one we're looking for is:

        var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + ( // The character to the right of the caret isn't included in `intersection`
        // so add one if we are tracking the character to the right
        trackRightCharacter ? 1 : 0); // Now we start looking for the location of the `targetChar`.
        // We keep looping forward and store the index in every iteration. Once we have encountered
        // enough occurrences of the target character, we break out of the loop
        // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.

        var numberOfEncounteredMatches = 0;

        for (var i = 0; i < conformedValueLength; i++) {
          var conformedValueChar = normalizedConformedValue[i];
          startingSearchIndex = i + 1;

          if (conformedValueChar === targetChar) {
            numberOfEncounteredMatches++;
          }

          if (numberOfEncounteredMatches >= requiredNumberOfMatches) {
            break;
          }
        }
      } // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,
      // most cases would be handled. However, we want to fast forward or rewind the caret to the
      // closest placeholder character if it happens to be in a non-editable spot.
      // That's what the next logic is for.
      //
      // In case of addition, we fast forward.


      if (isAddition) {
        // We want to remember the last placeholder character encountered so that if the mask
        // contains more characters after the last placeholder character, we don't forward the caret
        // that far to the right. Instead, we stop it at the last encountered placeholder character.
        var lastPlaceholderChar = startingSearchIndex;

        for (var j = startingSearchIndex; j <= placeholderLength; j++) {
          if (!opts.placeholder) {
            return lastPlaceholderChar;
          }

          if (opts.placeholder[j] === opts.placeholderChar) {
            lastPlaceholderChar = j;
          }

          if ( // If we're adding, we can position the caret at the next placeholder character.
          opts.placeholder[j] === opts.placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.
          opts.caretTrapIndexes.indexOf(j) !== -1 || // This is the end of the placeholder. We cannot move any further.
          // Let's put the caret there.
          j === placeholderLength) {
            return lastPlaceholderChar;
          }
        }
      } else {
        // In case of deletion, we rewind.
        if (trackRightCharacter) {
          //eslint-disable-line
          // Searching for the character that was to the right of the caret
          // We start at `startingSearchIndex` - 1 because it includes one character
          // extra to the right
          for (var k = startingSearchIndex - 1; k >= 0; k--) {
            // If tracking the character to the right of the cursor, we move to the left until
            // we found the character and then place the caret right before it
            if ( // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just
            // to the right of the caret
            opts.conformedValue[k] === targetChar || // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(k) !== -1 || // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            k === 0) {
              return k;
            }
          }
        } else {
          // Searching for the first placeholder or caret trap to the left
          for (var l = startingSearchIndex; l >= 0; l--) {
            // If we're deleting, we stop the caret right before the placeholder character.
            // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user
            // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret
            // right after the first `6`
            if ( // If we're deleting, we can position the caret right before the placeholder character
            opts.placeholder[l - 1] === opts.placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.
            opts.caretTrapIndexes.indexOf(l) !== -1 || // This is the beginning of the placeholder. We cannot move any further.
            // Let's put the caret there.
            l === 0) {
              return l;
            }
          }
        }
      }
    },

    /**
     * Converts the legacy Soho Mask pattern format from a string into an array.
     * If character is a defined pattern matcher, the corresponding item at the
     * array index is converted to its regex form.
     * @private
     * @param {string} pattern a legacy Soho Mask Pattern
     * @param {object} [defs] mask conversion definitions
     * @returns {array} contains string "literal" characters and Regex matchers
     */
    _convertPatternFromString: function _convertPatternFromString(pattern, defs) {
      var arr = [];
      var legacyKeys = Object.keys(defs);

      function getRegex(char) {
        var idx = legacyKeys.indexOf(char);

        if (idx > -1) {
          char = defs[legacyKeys[idx]];
        }

        return char;
      }

      for (var i = 0; i < pattern.length; i++) {
        arr.push(getRegex(pattern[i]));
      } // TODO: Attach an object here that contains an analysis of the original mask
      // that can be used to configure the new API accordingly.


      return arr;
    }
  };

  /* eslint-disable no-underscore-dangle, new-cap */

  var COMPONENT_NAME$9 = 'mask';
  /**
   * Component Wrapper for input elements that gives them the ability to become "masked".
   * @class MaskInput
   * @constructor
   * @param {HTMLInputElement} element regular HTML Input Element (not wrapped with jQuery)
   * @param {MaskInputOptions} [settings] incoming settings
   *
   * @param {object} [settings.definitions=false] if defined, passes additional string-based pattern match "types".
   * @param {boolean} [settings.guide=false] if true, causes a guide to show inside the input field, represented by the placeholder,
   *  that demonstrates how the mask can be filled in.
   * @param {boolean} [settings.keepCharacterPositions=false] if defined alongside of `settings.guide`, will allow indiviual characters
   *  to be removed from the mask without moving the positions of other characters that have been written into the field.
   *  Works well with things like credit card or phone numbers, which have sections that are separate from each other.
   * @param {array|function|string} [settings.pattern] the pattern that is used by the mask for determining input to keep or throw out.
   *  Arrays of strings representing individual characters, and regex matching individual characters, is the perferred way of supplying a pattern.
   *  For some `settings.process` types (date/time/number), a function that dynamically generates a mask is automatically used.
   *  It's also possible to define a custom mask function and supply it here. The legacy string style is also supported.
   * @param {object} [settings.patternOptions={}] If using a function to define `settings.pattern`, any options that must be passed
   *  to the masking function can be supplied in this object.
   * @param {string} [settings.patternOptions.format] [date/time masks only] contains a basic date format string that will be used to properly display a date mask.
   * @param {string} [settings.patternOptions.prefix] [number masks only] will be automatically prepended to the beginning of the masked value, but will not be counted as part of the masked value.
   * @param {string} [settings.patternOptions.suffix] [number masks only] will be automatically appended to the end of the masked value, but will not be counted as part of the masked value.
   * @param {boolean} [settings.patternOptions.allowThousandsSeparator] [number masks only] If true, displays a localized thousands separator in the masked value
   * @param {string} [settings.patternOptions.locale] [number/date/time masks] will cause formatting to occur against a particular Locale culture.
   * @param {object} [settings.patternOptions.symbols] [number masks only] contains default, localized special characters used in numbers
   * @param {string} [settings.patternOptions.symbols.currency] [number masks only]
   * @param {string} [settings.patternOptions.symbols.decimal] [number masks only]
   * @param {string} [settings.patternOptions.symbols.negative] [number masks only]
   * @param {string} [settings.patternOptions.symbols.thousands] [number masks only]
   * @param {boolean} [settings.patternOptions.allowDecimal] [number masks only] allows the entry of a decimal point into a number mask with a decimal limit defined (negated when using `requireDecimal` to force its placement)
   * @param {boolean} [settings.patternOptions.requireDecimal] [number masks only] forces the placement of a decimal point in a number mask with a decimal limit defined.
   * @param {number} [settings.patternOptions.decimalLimit] [number masks only] defines the number of characters allowed after the decimal point.
   * @param {number} [settings.patternOptions.integerLimit] [number masks only] defines the number of characters allowed before the decimal point.
   * @param {boolean} [settings.patternOptions.allowNegative] [number masks only] allows a number to be negative (adds/retains a "minus" symbol at the beginning of the value)
   * @param {boolean} [settings.patternOptions.allowLeadingZeros] [number masks only] allows a zero be placed before a decimal or other numbers.
   * @param {string} [settings.placeholderChar='_'] If using the `settings.guide`, will be used as the placeholder
   *  for characters that are not yet typed.
   * @param {function} [settings.pipe] provides a way of adjusting the masked content, caret position,
   *  etc after the input field has been processed by the mask API.
   * @param {string} [settings.process=undefined] can be defined as a quick way to create certain complex masks.  Defaults to the regular pattern mask,
   *  but can automatically configure the field for "date", "time", and "number"
   * @param {boolean} [settings.processOnBlur=true] if defined, causes the mask API to process this input field whenever it becomes blurred.
   * @param {boolean} [settings.processOnInitialize=true] if defined, causes the mask API to process this input field when the component is initialized.
   * @returns {MaskInput} component instance
   */

  var DEFAULT_MASK_INPUT_OPTIONS = {
    definitions: undefined,
    guide: false,
    keepCharacterPositions: false,
    maskAPI: MaskAPI,
    locale: null,
    pattern: undefined,
    patternOptions: {},
    placeholderChar: '_',
    pipe: undefined,
    process: undefined,
    processOnBlur: true,
    processOnInitialize: true
  };

  function MaskInput(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, DEFAULT_MASK_INPUT_OPTIONS);
    return this.init();
  }

  MaskInput.prototype = {
    /**
     * @returns {string} representing the Masked HTMLInputElement's type
     */
    get type() {
      return this.element.type;
    },

    /**
     * Initialization/things that need to be called on `updated()` in addition to initialization
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setLocale();
    },
    build: function build() {
      // TODO: Deprecate legacy settings in v4.4.0, remove in v4.5.0
      this._replaceLegacySettings();

      var styleClasses = ['is-number-mask']; // If the 'process' setting is defined, connect a pre-defined Soho Mask/Pattern

      if (typeof this.settings.process === 'string') {
        if (!this.settings.patternOptions.locale) {
          this.settings.patternOptions.locale = this.settings.locale;
        }

        switch (this.settings.process) {
          case 'number':
            {
              this.settings.pattern = masks.numberMask;
              this.element.classList.add('is-number-mask');
              break;
            }

          case 'rangeNumber':
            {
              this.settings.pattern = masks.rangeNumberMask;
              this.element.classList.add('is-range-number-mask');
              break;
            }

          case 'date':
            {
              // Check for an instance of a Datepicker/Timepicker Component, and grab the date format
              var datepicker = $(this.element).data('datepicker');

              if ($.fn.datepicker && $(this.element).data('datepicker')) {
                if (!this.settings.patternOptions && !this.settings.patternOptions.format) {
                  this.settings.patternOptions.format = datepicker.settings.dateFormat;
                }
              }

              this.settings.pattern = masks.dateMask;
              break;
            }

          case 'rangeDate':
            {
              var _datepicker = $(this.element).data('datepicker');

              if ($.fn.datepicker && $(this.element).data('datepicker')) {
                this.settings.patternOptions.format = _datepicker.settings.dateFormat;
              }

              this.settings.pattern = masks.rangeDateMask;
              break;
            }

          default:
            {
              this.element.classList.remove(styleClasses.join(' '));
              break;
            }
        }
      }

      this.mask = new this.settings.maskAPI(this.settings);
      this.state = {
        previousMaskResult: ''
      };
      this.handleEvents();

      if (this.settings.processOnInitialize) {
        this.process();
      }

      return this;
    },

    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      this.locale = Locale.currentLocale;

      if (this.settings.locale) {
        Locale.getLocale(this.settings.locale).done(function (locale) {
          _this.locale = Locale.cultures[locale];

          _this.build();
        });
      } else {
        this.build();
      }
    },

    /**
     * Sets up events
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this; // On change event

      this.changeEventHandler = function () {
        self.hasTriggeredChangeEvent = true;
      };

      this.element.addEventListener('change', this.changeEventHandler); // Store an initial value on focus

      this.focusEventHandler = function () {
        self.state.previousMaskResult = self.element.value;
        self.state.initialValue = self.element.value;
      };

      this.element.addEventListener('focus', this.focusEventHandler); // Handle all masking on the `input` event

      this.inputEventHandler = function (e) {
        self.hasTriggeredChangeEvent = false;
        return self.process(e);
      };

      this.element.addEventListener('input', this.inputEventHandler); // Remove an initial value from the state object on blur

      this.blurEventHandler = function (e) {
        if (this.processingJustHappenedOnInput === true) {
          e.preventDefault();
          return false;
        } // Handle mask processing on blur, if settings allow.  Otherwise, return out.


        if (self.settings.processOnBlur) {
          if (self.element.readOnly) {
            e.preventDefault();
            return false;
          } // in IE11 or Edge, change event doesn't fire for some unknown reason.
          // Added this for backwards compatility with this OS/Browser combo.
          // See http://jira.infor.com/browse/SOHO-6895


          if (self._hasChangedValue() && (self._isEdgeIE() || !self.hasTriggeredChangeEvent)) {
            $(self.element).trigger('change');
            self.hasTriggeredChangeEvent = true;
          }
        }

        delete self.state.initialValue;
        return self.process(e);
      };

      this.element.addEventListener('blur', this.blurEventHandler);
      return this;
    },

    /**
     * Main Process for conforming a mask against the API.
     * @param {jQuery.Event} e the input/blur event
     * @returns {boolean} whether or not the mask process was successful
     */
    process: function process(e) {
      // If no pattern's defined, act as if no mask component is present.
      if (!this.settings.pattern) {
        return true;
      } // Get a reference to the desired Mask API (by default, the one setup
      // during Soho initialization).


      var api = this.mask;
      var patternOptions = this.settings.patternOptions || {};
      var definedDecimal = '.';

      if (this.locale && this.locale.data && this.locale.data.numbers && this.locale.data.numbers.decimal) {
        definedDecimal = this.locale.data.numbers.decimal;
      }

      if (patternOptions.symbols && patternOptions.symbols.decimal) {
        definedDecimal = patternOptions.symbols.decimal;
      }

      if (!api.pattern) {
        api.configure({
          pattern: this.settings.pattern,
          patternOptions: patternOptions
        });
      } // Get all necessary bits of data from the input field.


      var rawValue = this.element.value;
      var numberInputCorrections = false;

      if (e && e.type === 'input') {
        // Number input fields operate differently than text-based input fields.
        // If we're using a number input and the rawValue detected is empty, but the field contents are not,
        // it's possible that a double decimal has been entered and not properly detected
        // at the time the input event occurred.
        if (e.inputType === 'insertText') {
          if (rawValue === '') {
            rawValue = this.state.previousMaskResult;
            numberInputCorrections = true;
          } else if (e.data === definedDecimal && rawValue.indexOf(definedDecimal) > -1) {
            numberInputCorrections = true;
          }
        }
      }

      if (rawValue === this.state.previousMaskResult) {
        if (numberInputCorrections) {
          this.element.value = '';
          this.element.value = "".concat(rawValue);
        }

        return false;
      }

      var posBegin = this.element.selectionStart || 0;
      var posEnd = this.element.selectionEnd || 0; // On Android, the first character inserted into a field is automatically
      // selected when it shouldn't be. This snippet fixes that problem.

      if (this._isAndroid() && this.state.previousMaskResult === '' && posBegin !== posEnd) {
        utils.safeSetSelection(rawValue.length, rawValue.length);
        posBegin = rawValue.length;
        posEnd = rawValue.length;
      } // Attempt to make the raw value safe to use.  If it's not in a viable format
      // this will throw an error.


      rawValue = this._getSafeRawValue(rawValue);
      var opts = {
        guide: this.settings.guide,
        keepCharacterPositions: this.settings.keepCharacterPositions,
        patternOptions: this.settings.patternOptions,
        placeholderChar: this.settings.placeholderChar,
        previousMaskResult: this.state.previousMaskResult,
        selection: {
          start: posBegin,
          end: posEnd
        }
      };

      if (posBegin !== posEnd) {
        opts.selection.contents = rawValue.substring(posBegin, posEnd);
      }

      if (typeof this.settings.pipe === 'function') {
        opts.pipe = this.settings.pipe;
      } // Adjust range number value and options for rangeNumberMask.


      var adjustedRangeNumber = masks.adjustRangeNumber(rawValue, opts, this);
      rawValue = adjustedRangeNumber.rawValue;
      opts = adjustedRangeNumber.opts; // Perform the mask processing.

      var processed = api.process(rawValue, opts);

      if (!processed.maskResult) {
        // Error during masking.  Simply return out and don't mask this field.
        return processed.maskResult;
      } // Use the piped value, if applicable.


      var finalValue = processed.pipedValue ? processed.pipedValue : processed.conformedValue;

      if (finalValue !== '' && patternOptions && patternOptions.suffix && finalValue.indexOf(patternOptions.suffix) < 0) {
        finalValue += this.settings.patternOptions.suffix;
      }

      if (opts.patternOptions && opts.patternOptions.delimeter && finalValue && finalValue !== rawValue) {
        rawValue = finalValue;
      } // Setup values for getting corrected caret position
      // TODO: Improve this by eliminating the need for an extra settings object.


      var adjustCaretOpts = {
        previousMaskResult: this.state.previousMaskResult || '',
        previousPlaceholder: this.state.previousPlaceholder || '',
        conformedValue: finalValue,
        placeholder: processed.placeholder,
        rawValue: rawValue,
        caretPos: processed.caretPos,
        placeholderChar: this.settings.placeholderChar
      };

      if (processed.pipedCharIndexes) {
        adjustCaretOpts.indexesOfPipedChars = processed.pipedCharIndexes;
      }

      if (processed.caretTrapIndexes) {
        adjustCaretOpts.caretTrapIndexes = processed.caretTrapIndexes;
      } // Get a corrected caret position.


      processed.caretPos = api.adjustCaretPosition(adjustCaretOpts);
      var previousValue = this.state.previousMaskResult; // Set the internal component state

      this.state.previousMaskResult = finalValue;
      this.state.previousPlaceholder = processed.placeholder; // Set state of the input field

      if (Environment.browser.name === 'firefox') {
        if (this.element.value !== finalValue) {
          this.element.value = finalValue;
        }
      } else {
        this.element.value = finalValue;
      }

      utils.safeSetSelection(this.element, processed.caretPos); // Return out if there was no visible change in the conformed result
      // (causes state not to change, events not to fire)

      if (previousValue === finalValue) {
        return false;
      }
      /**
       * Fire the 'write' event
       * @event write
       * @memberof MaskInput
       * @param {jQuery.Event} e the event object
       * @param {string} finalValue the final, masked value
       */


      $(this.element).trigger('write.mask', [finalValue]); // return event handler true/false

      return processed.maskResult;
    },

    /**
     * Obfuscates the operating system/browser check from Soho.env into internal methods
     * NOTE: Helps compartmentalize us from using calls to global "Soho" object until we can
     * properly setup import/export for unit tests.
     * TODO: deprecate eventually (v4.4.0?)
     * @private
     * @returns {boolean} whether or not the current device is running the Android OS.
     */
    _isAndroid: function _isAndroid() {
      var os = Environment && Environment.os && Environment.os.name ? Environment.os.name : '';
      return os === 'android';
    },

    /**
     * Determine if browser is IE11 or Edge
     * @private
     * @returns {boolean} whether or not the current device is running Windows 7
     *  using the IE11 browser.
     */
    _isEdgeIE: function _isEdgeIE() {
      var browser = Environment && Environment.browser && Environment.browser.name ? Environment.browser.name : '';
      return browser === 'ie' || browser === 'edge';
    },

    /**
     * Checks the current value of this masked input against it's stored "previousMaskResult"
     *  state to see if the value changed.
     * @private
     * @returns {boolean} whether or not the previous mask state matches the current one.
     */
    _hasChangedValue: function _hasChangedValue() {
      if ((!this.state || !this.state.previousMaskResult) && this.state.previousMaskResult !== '') {
        return true;
      }

      return this.state.previousMaskResult !== this.state.initialValue;
    },

    /**
     * Gets the safe raw value of an input field
     * @private
     * @param {?} inputValue the original value that came from an input field or other source
     * @returns {string} the string-ified version of the original value
     */
    _getSafeRawValue: function getSafeRawValue(inputValue) {
      if (utils.isString(inputValue)) {
        return inputValue;
      }

      if (utils.isNumber(inputValue)) {
        return String(inputValue);
      }

      if (inputValue === undefined || inputValue === null) {
        return '';
      }

      throw new Error("".concat('The "value" provided to the Masked Input needs to be a string or a number. The value ' + 'received was:\n\n').concat(JSON.stringify(inputValue)));
    },

    /**
     * Changes a bunch of "legacy" setting definitions into more apt names.  Additionally handles
     * the old data-attribute system that is still occasionally used.
     * @private
     * @deprecated as of v4.4.0.
     * @returns {void}
     */
    _replaceLegacySettings: function _replaceLegacySettings() {
      var modes = ['group', 'number', 'date', 'time']; // pre-set a bunch of objects if they don't already exist

      this.settings.patternOptions = this.settings.patternOptions || {};
      this.settings.patternOptions.symbols = this.settings.patternOptions.symbols || {}; //= =====================================
      // Deprecated as of v4.3.2
      //= =====================================
      // Order of operations when choosing pattern strings:
      // HTML5 'data-mask' attribute > Generic pattern string based on "type" attribute > nothing.
      //
      // if no pattern is provided in settings, use a pre-determined pattern based
      // on element type, or grab the pattern from the element itself.

      var html5DataMask = this.element.getAttribute('data-mask') || false;

      if (typeof html5DataMask === 'string' && html5DataMask.length) {
        this.settings.pattern = html5DataMask;
      } // If a "mode" is defined, special formatting rules may apply to this mask.
      // Otherwise, the standard single-character pattern match will take place.


      var html5DataMaskMode = this.element.getAttribute('data-mask-mode') || false;

      if (html5DataMaskMode && modes.indexOf(html5DataMaskMode) > -1) {
        this.settings.mode = html5DataMaskMode;
      } // map deprecated "mode" setting to "process".  Triggers additional settings in
      // some cases.


      if (this.settings.mode) {
        if (modes.indexOf(this.settings.mode) === -1) {
          delete this.settings.mode;
        }

        if (this.settings.mode === 'group') {
          this.settings.process = undefined;
        } else if (this.settings.mode === 'date') {
          this.settings.process = 'date';
        } else {
          this.settings.process = this.settings.mode;
        }

        delete this.settings.mode;
      }

      if (this.settings.process === 'number') {
        // map deprecated "thousandsSeparator" to "patternOptions.allowThousandsSeparator"
        if (this.settings.thousandsSeparator) {
          this.settings.patternOptions.allowThousandsSeparator = this.settings.thousandsSeparator;
          delete this.settings.thousandsSeparator;
        } // If "thousands" is defined, the thousands separator for numbers (comma or decimal, based on
        // localization) will be inserted wherever necessary during typing. Will automatically set to
        // "true" if the localized thousands separator is detected inside the mask.


        var html5DataThousands = this.element.getAttribute('data-thousands') || false;

        if (html5DataThousands) {
          this.settings.patternOptions.allowThousandsSeparator = html5DataThousands === 'true';
        }

        if (typeof this.settings.pattern === 'string') {
          // If "negative" is defined, you can type the negative symbol in front of the number.
          // Will automatically set to "true" if a negative symbol is detected inside the mask.
          var allowNegative = this.settings.pattern.indexOf('-') !== -1;

          if (allowNegative) {
            this.settings.patternOptions.allowNegative = allowNegative;
            this.settings.patternOptions.symbols.negative = '-';
          } // Detect the thousands separator and see if we use it.


          var group = Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',';
          var thousandsSep = this.settings.patternOptions && this.settings.patternOptions.symbols && this.settings.patternOptions.symbols.thousands ? this.settings.patternOptions.symbols.thousands : group;
          var hasThousandsInPattern = this.settings.pattern.indexOf(thousandsSep) !== -1;
          this.settings.patternOptions.allowThousandsSeparator = hasThousandsInPattern;

          if (hasThousandsInPattern) {
            this.settings.patternOptions.symbols.thousands = thousandsSep;
          } // The new masking algorithm requires an "integerLimit" defined to function.
          // This grabs the number of items currently inside this part of the mask, and sets it.


          var decimal = typeof this.settings.patternOptions.symbols.decimal === 'string' ? this.settings.patternOptions.symbols.decimal : '.';
          var decimalParts = this.settings.pattern.split(decimal);
          var decimalOpt = this.settings.patternOptions.symbols.decimal;

          if (decimalOpt === undefined) {
            this.settings.patternOptions.symbols.decimal = Locale.currentLocale.data.numbers.decimal;
          }

          this.settings.patternOptions.integerLimit = decimalParts[0].replace(/[^#0]/g, '').length;

          if (decimalParts[1]) {
            this.settings.patternOptions.allowDecimal = true;
            this.settings.patternOptions.decimalLimit = decimalParts[1].toString().replace(/[^#0]/g, '').length;

            if (!this.settings.patternOptions.symbols.decimal) {
              this.settings.patternOptions.symbols.decimal = decimal;
            }
          }
        }
      } // If 'mustComplete' is defined, you MUST complete the full mask, or the mask
      // will revert to empty once the field is blurred.


      var html5DataMustComplete = this.element.getAttribute('data-must-complete') || false;

      if (html5DataMustComplete) {
        this.settings.mustComplete = html5DataMustComplete;
      } // Backwards compat with the old "data-show-currency"


      var html5DataCurrency = this.element.getAttribute('data-show-currency');

      if (html5DataCurrency) {
        this.settings.showSymbol = 'currency';
      } // Handle the currency/percent symbols automatically


      var symbolSetting = this.settings.showSymbol;
      var symbolTypes = ['currency', 'percent'];
      var symbol;

      if (symbolTypes.indexOf(symbolSetting) > -1) {
        symbol = function (s) {
          if (s === 'currency') {
            return {
              char: Locale.currentLocale.data.currencySign,
              format: Locale.currentLocale.data.currencyFormat
            };
          }

          if (s === 'percent') {
            return {
              char: Locale.currentLocale.data.numbers.percentSign,
              format: Locale.currentLocale.data.numbers.percentFormat
            };
          }

          return {};
        }(this.settings.showSymbol); // derive the location of the symbol


        var detectableSymbol = symbolSetting === 'currency' ? '' : symbol.char;
        var symbolRegex = new RegExp(detectableSymbol, 'g');
        var match = symbolRegex.exec(symbol.format);
        var replacementRegex;
        var symbolWithWhitespace;
        var index = -1;
        var placementType;

        if (match && match.length) {
          index = symbol.format.indexOf(match[0]);

          if (index === 0) {
            placementType = 'prefix';
            replacementRegex = new RegExp("[^".concat(detectableSymbol, "]\\S"), 'g');
            symbolWithWhitespace = symbol.format.replace(replacementRegex, '');
          } else if (index > 0) {
            placementType = 'suffix';
            replacementRegex = new RegExp("\\S[^".concat(detectableSymbol, "]"), 'g');

            while (/\s/.test(symbol.format.charAt(index - 1))) {
              --index;
            }

            symbolWithWhitespace = symbol.format.substr(index).replace(replacementRegex, '');
          }

          if (symbolSetting === 'currency') {
            symbolWithWhitespace = symbolWithWhitespace.replace('', symbol.char);
          }

          this.settings.patternOptions[placementType] = symbolWithWhitespace;
        }
      }
    },

    /**
     * Updates the component instance with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      return this.teardown().init();
    },

    /**
     * Tears down the current component instance
     * @returns {this} component instance
     */
    teardown: function teardown() {
      if (this.settings.process === 'number') {
        this.element.classList.remove('is-number-mask');
      }

      if (this.settings.process === 'rangeNumber') {
        this.element.classList.remove('is-range-number-mask');
      }

      this.element.removeEventListener('focus', this.focusEventHandler);
      delete this.focusEventHandler;
      this.element.removeEventListener('input', this.inputEventHandler);
      delete this.inputEventHandler;

      if (this.blurEventHandler) {
        this.element.removeEventListener('blur', this.blurEventHandler);
        delete this.blurEventHandler;
      }

      if (this.changeEventHandler) {
        this.element.removeEventListener('change', this.changeEventHandler);
        delete this.changeEventHandler;
      }

      return this;
    }
  };

  /**
   * Wrap Mask as a jQuery component, and attach the factory function to $.fn
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements to be acted on.
   */

  $.fn.maskinput = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$9);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$9, new MaskInput(this, settings));

        instance.destroy = function () {
          this.teardown();
          $.removeData(this.element, COMPONENT_NAME$9);
        };
      }
    });
  };
  /**
   * Backwards Compatibility with the old Mask
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements to be acted on.
   */


  $.fn.maskedinput = $.fn.maskinput;
  $.fn.mask = $.fn.maskinput;

  var COMPONENT_NAME$a = 'popupmenu'; // Popupmenu Trigger Types

  var triggerTypes = ['click', 'rightClick', 'immediate', 'manual'];
  /**
   * Responsive Popup Menu Control aka Context Menu when doing a right click action.
   * @class PopupMenu
   * @param {jquery[]|htmlelement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.menu]  Menu's ID Selector, or a jQuery object representing a menu.
   * @param {string} [settings.trigger='click']  Action on which to trigger a menu can be: click, rightClick, immediate ect.
   * @param {boolean} [settings.autoFocus=true]  If false the focus will not focus the first list element. (At the cost of accessibility).
   * @param {boolean} [settings.mouseFocus=true]  If false the focus will not highlight the first list element. (At the cost of accessibility).
   * @param {boolean} [settings.attachToBody=true]  If true the menu will be moved out to the body. If false, the menu HTML will remain adjacent to its trigger button. To be used in certin overflow situations.
   * @param {function} [settings.beforeOpen]  Callback that can be used for populating the contents of the menu.
   * @param {string} [settings.ariaListbox=false]   Switches aria to use listbox construct instead of menu construct (internal).
   * @param {string} [settings.eventObj]  Can pass in the event object so you can do a right click with immediate.
   * @param {string} [settings.triggerSelect]  If false select event will not be triggered.
   * @param {string} [settings.removeOnDestroy] Dispose of the menu from the DOM on destroy
   * @param {string} [settings.showArrow]  If true you can explicitly set an arrow on the menu.
   * @param {string} [settings.stretchToWidestMenuItem] Find the widest menu element and stretch the width to that element.
   * @param {boolean|function} [settings.returnFocus]  If set to false, focus will not be
    returned to the calling element. Can also be defined as a callback that can determine how
    to return focus.  It usually should be for accessibility purposes.
   * @param {object} [settings.placementOpts=new PlacementObject({
     containerOffsetX: 10,
     containerOffsetY: 10,
     strategies: ['flip', 'shrink']
  })] Gets passed to this control's Place behavior.
   * @param {object} [settings.offset={x: 0, y: 0}] Can tweak the menu position in the x and y direction. Takes an object of form: `{x: 0, y: 0}`.
   * @param {jQuery[]} [settings.predefined=$()] containing references to menu items that should be passed to the "predefined" hash.
   */

  var POPUPMENU_DEFAULTS = {
    menu: null,
    trigger: triggerTypes[0],
    autoFocus: true,
    mouseFocus: true,
    attachToBody: true,
    removeOnDestroy: false,
    beforeOpen: null,
    ariaListbox: false,
    eventObj: undefined,
    returnFocus: true,
    showArrow: null,
    triggerSelect: true,
    placementOpts: new PlacementObject({
      containerOffsetX: 10,
      containerOffsetY: Environment.os.name === 'ios' ? 25 : 15,
      strategies: ['flip', 'shrink']
    }),
    offset: {
      x: 0,
      y: 0
    },
    predefined: $(),
    duplicateMenu: null,
    stretchToWidestMenuItem: false,
    attributes: null
  };

  function PopupMenu(element, settings) {
    this.settings = utils.mergeSettings(element, settings, POPUPMENU_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  PopupMenu.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.isFirefox = Environment.browser.name === 'firefox';
      this.setup();
      this.addMarkup();
      this.handleEvents();
      this.iconFilteringSetup(); // Allow for an external click event to be passed in from outside this code.
      // This event can be used to pass clientX/clientY coordinates for mouse cursor positioning.

      if (this.settings.trigger === 'immediate') {
        this.open(this.settings.eventObj);
      } // Use some css rules on submenu parents


      if (this.menu.find('.submenu').length) {
        this.menu.addClass('has-submenu');
      }
    },

    /**
     * Checks whether or not Right-To-Left reading mode is active.
     * @private
     * @returns {boolean} whether or not the reading/writing direction is RTL
     */
    isRTL: function isRTL() {
      return Environment.rtl;
    },

    /**
     * @returns {boolean} whether or not the popupmenu is currently open
     */
    get isOpen() {
      return DOM.hasClass(this.element[0], 'is-open');
    },

    /**
     * @returns {boolean} whether or not the popupmenu trigger, or an item within the
     * popupmenu, currently has focus.
     */
    get isFocused() {
      var active = document.activeElement;
      var triggerIsActive = this.element.is(active);
      var menuIsActive = this.menu && this.menu.length && this.menu[0].contains(active);

      if (triggerIsActive || menuIsActive) {
        return true;
      }

      return false;
    },

    /**
     * @private
     * @returns {void}
     */
    setup: function setup() {
      if (this.element.attr('data-popupmenu') && !this.settings.menu) {
        this.settings.menu = this.element.attr('data-popupmenu').replace(/#/g, '');
      } // Backwards compatibility for "menuId" menu options coming from other controls
      // that utilize the Popupmenu.


      if (this.settings.menuId) {
        this.settings.menu = this.settings.menuId;
        this.settings.menuId = undefined;
      } // keep track of how many popupmenus there are with an ID.
      // Used for managing events that are bound to $(document)


      if (!this.id) {
        this.id = (parseInt($('.popupmenu-wrapper').length, 10) + 1).toString();
      } // Set a reference collection for containing "pre-defined" menu items that should never
      // be replaced during an AJAX call.


      this.predefinedItems = $().add(this.settings.predefined);
    },

    /**
     * Set original dom position containment for given menu in case need to move
     * @private
     * @param {jQuery[]} menu the menu object
     * @returns {void}
     */
    setMenuOrgContainment: function setMenuOrgContainment(menu) {
      if (!menu || !menu.length) {
        return;
      }

      var parent = menu.parent();

      if (!parent.is('body')) {
        this.menuOrgContainment = {
          parent: parent,
          index: parent.children().index(menu)
        };
      }
    },

    /**
     * Insert the given element to arbitrarily based on containment with parent and index
     * @private
     * @param {jQuery[]} elem the element to insert
     * @param {object} containment the original dom position containment
     * @returns {void}
     */
    insertAtContainment: function insertAtContainment(elem, containment) {
      var isEl = function isEl(el) {
        return el && el.length;
      };

      containment = containment || this.menuOrgContainment || {};

      if (isEl(elem) && isEl(containment.parent)) {
        var index = containment.index;
        var parent = containment.parent;
        var lastIndex = parent.children().length;

        if (index < 0) {
          index = Math.max(0, lastIndex + 1 + index);
        }

        if (index < lastIndex) {
          parent.children().eq(index).before(elem);
        } else {
          parent.append(elem);
        }
      }
    },

    /**
     * Add markip including Aria
     * @private
     * @returns {void}
     */
    addMarkup: function addMarkup() {
      var id;
      var duplicateMenu;
      var triggerId;

      if (!this.menu || !this.menu.length) {
        switch (_typeof(this.settings.menu)) {
          case 'string':
            // ID Selector
            id = this.settings.menu;
            this.menu = $("#".concat(this.settings.menu)); // duplicate menu if shared by multiple triggers

            if (this.settings.duplicateMenu && this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
              this.menu.data('trigger', this.element);
              triggerId = this.menu.data('trigger')[0].id;
              duplicateMenu = this.menu.clone();
              this.setMenuOrgContainment(duplicateMenu);
              duplicateMenu.detach().appendTo('body'); // add data-id attr to menus

              duplicateMenu.attr('data-trigger', triggerId);
              this.menu.attr('data-trigger', triggerId);
            }

            break;

          case 'object':
            // jQuery Object
            if (this.settings.menu === null) {
              this.menu = this.element.next('.popupmenu, .popupmenu-wrapper');
            } else {
              this.menu = $(this.settings.menu);
            }

            id = this.menu.attr('id');

            if (!id || id === '') {
              this.menu.attr('id', "popupmenu-".concat(this.id));
              id = this.menu.attr('id');
            }

            triggerId = this.element.attr('id');
            break;
        }
      } // If markup already exists for the wrapper, use that instead of rebuilding.


      if (this.menu.is('.popupmenu-wrapper')) {
        this.preExistingWrapper = true;
        this.wrapper = this.menu;
        this.menu = this.wrapper.children('.popupmenu').first();
      } // Similar check as above, assuming the menu wasn't a popupmenu wrapper.


      if (this.menu.parent().is('.popupmenu-wrapper')) {
        this.preExistingWrapper = true;
        this.wrapper = this.menu.parent();
      } // If we still don't have a menu reference at this point, fail gracefully by returning out
      // and simply acting like a button.


      if (this.menu.length === 0) {
        return;
      } // Add attributes to both the trigger element and the menu `<ul>`


      if (this.settings.attributes) {
        utils.addAttributes(this.element, this, this.settings.attributes, 'trigger');
        utils.addAttributes(this.menu, this, this.settings.attributes, 'menu');
      } // if the menu is deeply rooted inside the markup, detach it and append it to the <body> tag
      // to prevent containment issues. (Now a Preference)


      if (this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
        this.originalParent = this.menu.prev();
        this.setMenuOrgContainment(this.menu);
        this.menu.detach().appendTo('body');

        if (this.settings.duplicateMenu) {
          this.menu.attr('id', "".concat(this.settings.menu, "-original"));
        }
      }

      if (!this.menu.is('.popupmenu')) {
        this.menu.addClass('popupmenu').attr('role', this.settings.ariaListbox ? 'listbox' : 'menu').attr('aria-labelledby', triggerId);
      } // Always store a reference to the trigger element under jQuery data.


      this.menu.data('trigger', this.element);
      this.wrapper = this.menu.parent('.popupmenu-wrapper');

      if (!this.wrapper.length) {
        this.menu.wrap('<div class="popupmenu-wrapper"></div>');
        this.wrapper = this.menu.parent('.popupmenu-wrapper');
      } // Invoke all icons as icons


      this.wrapper.find('svg').each(function () {
        if (!$(this).data('icon')) {
          $(this).icon();
        }
      }); // Use "absolute" positioning on the menu insead of "fixed", only when the
      // menu lives <body> tag and we have a <body> element that is tall enough to
      // scroll and is allowed to scroll.

      function scrollableFilter() {
        var c = this ? this.style.overflow : null;
        return c !== 'auto' && c !== 'visible' && c !== 'scroll';
      }

      if (this.wrapper.parents().filter(scrollableFilter).length === 0) {
        this.wrapper[0].style.position = 'absolute';
      } // Wrap submenu ULs in a 'wrapper' to help break it out of overflow.


      this.menu.find('.popupmenu').each(function (i, elem) {
        var popup = $(elem);

        if (!popup.parent().hasClass('wrapper')) {
          popup.wrap('<div class="wrapper"></div>');
        }
      }); // Some popupmenu components will contain an arrow that points to their
      // triggering element, or a child of that element.

      var doSetArrow = false;
      var containerClass = this.element.parent().attr('class'); // `true` setting takes precedent over all else

      if (this.settings.showArrow === true) {
        doSetArrow = false;
      } else if (this.settings.showArrow === null) {
        var closestToolbar = this.element.closest('.toolbar');
        var closestMasthead = this.element.closest('.masthead');

        if (this.element.hasClass('btn-menu') || this.element.hasClass('btn-actions') || this.element.hasClass('btn-icon') && this.element.find('use').attr('href') === '#icon-more' || closestToolbar.length > 0 && !closestToolbar.is('.formatter-toolbar') || closestMasthead.length > 0 || this.settings.menu === 'colorpicker-menu' || this.element.is('.searchfield-category-button') || containerClass && containerClass.indexOf('more') >= 0 || containerClass && containerClass.indexOf('btn-group') >= 0) {
          doSetArrow = true;
        }
      }

      if (doSetArrow) {
        var arrow = $('<div class="arrow"></div>');
        var wrapper = this.menu.parent('.popupmenu-wrapper');

        if (wrapper.find('.arrow').length === 0) {
          wrapper.addClass('bottom').append(arrow);
        }
      } // If inside of a ".field-short" container, make smaller


      var addFieldShort = this.element.closest('.field-short').length > 0;
      this.menu[addFieldShort ? 'addClass' : 'removeClass']('popupmenu-short'); // If button is part of a header/masthead or a container using the "alternate"
      // UI color, add the "alternate" class.

      if (containerClass !== undefined && this.element.closest('.masthead').not('.search-results .masthead').length > 0) {
        this.menu.parent('.popupmenu-wrapper').addClass('inverse');
      }

      this.element.attr('aria-haspopup', true);
      this.element.attr('aria-controls', id);
      this.markupItems(); // Unhide the menu markup, if hidden

      if (this.menu.is('.hidden')) {
        this.menu.removeClass('hidden');
      } // If `settings.stretchToWidestMenuItem` is true, the trigger element will be sized
      // to match the size of the menu's largest item.


      if (this.settings.stretchToWidestMenuItem) {
        this.element.width(parseInt(this.getMaxMenuWidth(), 10));
      }
    },

    /**
     * Renders a menu item in the UI.
     * @private
     * @param {object|object[]} settings JSON-friendly object that represents a popupmenu item, or array of items.
     * @param {string} [settings.id] adds an ID to the item's anchor tag
     * @param {boolean} [settings.separator=false] causes this menu item to be a separator (overrides everything else)
     * @param {string} [settings.heading=""] Produces a heading element after a separator with text content.
     * @param {string} [settings.nextSectionSelect] can be null, "single", or "multiple"
     * @param {string} settings.text contains the text that will be displayed.
     * @param {string|null} [settings.icon=null] applies an icon to the menu item
     * @param {string|null} [settings.selectable] can be null, "single", or "multiple"
     * @param {boolean} [settings.disabled=false] causes the item to be disabled.
     * @param {object[]} [settings.submenu] array of settings object contstructed just like this one, that represent submenu items.
     * @param {boolean} [settings.noMenuWrap=false] if true, causes multiple top-level menu items not to be wrapped by a `<ul class="popupmenu"></ul>`
     * @returns {string} HTML representing a Popupmenu item with the settings passed.
     */
    renderItem: function renderItem(settings) {
      if (settings === undefined) {
        return '';
      }

      var self = this;

      function wrapMenuItems(settingsArr) {
        var items = '';
        settingsArr.forEach(function (menuObj) {
          items += self.renderItem(menuObj);
        });
        return items;
      } // Top-level arrays run this method on each sub-item.


      if (Array.isArray(settings)) {
        var items = wrapMenuItems(settings);
        var template = "<ul class=\"popupmenu\">".concat(items, "</ul>");
        return stringUtils.stripWhitespace(template);
      }

      var headingText = '';
      var sectionSelectClass = ''; // separators get rendered out first

      if (settings.separator !== undefined) {
        if (settings.heading) {
          headingText += "<li class=\"heading\">".concat(settings.heading, "</li>");
        }

        if (settings.nextSectionSelect === 'single') {
          sectionSelectClass = ' single-selectable-section';
        } else if (settings.nextSectionSelect === 'multiple') {
          sectionSelectClass = ' multi-selectable-section';
        }

        return stringUtils.stripWhitespace("\n        <li class=\"separator".concat(sectionSelectClass, "\"></li>\n        ").concat(headingText, "\n      "));
      } // Top-level Menus can have settings.
      // Handle an object-based settings with a `menu` definition here


      if (settings.menu) {
        var menuId = '';

        if (settings.menuId) {
          menuId = " id=\"".concat(settings.menuId, "\"");
        }

        var iconsClass = '';

        if (settings.hasIcons) {
          iconsClass += ' has-icons';
        }

        var _items = '';

        if (Array.isArray(settings.menu)) {
          _items = wrapMenuItems(settings.menu);
        }

        if (settings.noMenuWrap) {
          return _items;
        }

        return stringUtils.stripWhitespace("\n        <ul".concat(menuId, " class=\"popupmenu").concat(iconsClass, "\">\n          ").concat(_items, "\n        </ul>\n      "));
      }

      var disabledClass = '';
      var hiddenClass = '';
      var icon = '';
      var id = '';
      var selectableClass = '';
      var submenuClass = '';
      var submenu = '';
      var ddicon = '';

      if (settings.disabled) {
        disabledClass += ' is-disabled';
      }

      if (settings.visible === false) {
        hiddenClass += ' hidden';
      }

      if (settings.id) {
        id = " id=\"".concat(settings.id, "\"");
      }

      if (settings.selectable === 'single') {
        selectableClass += ' is-selectable';
      }

      if (settings.selectable === 'multiple') {
        selectableClass += ' is-multiselectable';
      }

      if (settings.icon) {
        icon = "<svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n        <use href=\"#icon-".concat(settings.icon, "\"></use>\n      </svg>");
      }

      if (Array.isArray(settings.submenu)) {
        submenuClass += ' submenu';
        submenu += this.renderItem(settings.submenu);
        ddicon += "<svg class=\"arrow icon-dropdown icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n        <use href=\"#icon-dropdown\"></use>\n      </svg>";
      }

      return stringUtils.stripWhitespace("<li class=\"popupmenu-item".concat(disabledClass).concat(hiddenClass).concat(selectableClass).concat(submenuClass, "\">\n      <a").concat(id, " href=\"#\">").concat(icon, "<span>").concat(settings.text, "</span>\n        ").concat(ddicon, "\n      </a>\n      ").concat(submenu, "\n    </li>"));
    },

    /**
     * Converts the contents of a popupmenu or submenu to a JSON-friendly object structure.
     * @private
     * @param {object} [settings={}] incoming conversion settings
     * @param {jQuery[]|HTMLElement} [settings.contextElement] the top-most element that will
     *  be modified (defaults to the top-level menu).
     * @param {boolean} [settings.noMenuWrap] if true, will pass an array as the top-level data instead
     *  of an object with a `menu` property.
     * @returns {object|object[]} an object representation of this popupmenu's current state.
     */
    toData: function toData(settings) {
      var data = {};
      var menu = [];
      var self = this;
      settings = settings || {}; // Figure out Context Element

      if (!settings.contextElement) {
        settings.contextElement = this.menu;
      }

      if (settings.contextElement instanceof HTMLElement) {
        settings.contextElement = $(settings.contextElement);
      }

      if (settings.contextElement.is('.popupmenu-wrapper')) {
        settings.contextElement = settings.contextElement.children('ul');
      }

      var idAttr = settings.contextElement.attr('id');

      if (idAttr && idAttr.length) {
        data.menuId = "".concat(idAttr);
      }

      var hasIcons = settings.contextElement.hasClass('has-icons');
      data.hasIcons = hasIcons;
      var singleSelectable;
      var multiSelectable;

      function decodeListItem(item) {
        var li = $(item);
        var liData = {}; // Ignore headings, which are included as part of separators inside data

        if (li.hasClass('heading')) {
          return undefined;
        } // separators include different metadata


        if (li.hasClass('separator')) {
          liData.separator = true;

          if (li.hasClass('single-selectable-section')) {
            singleSelectable = true;
            liData.nextSectionSelect = 'single';
          }

          if (li.hasClass('multi-selectable-section')) {
            multiSelectable = true;
            liData.nextSectionSelect = 'multiple';
          }

          var next = li.next();

          if (next.hasClass('heading')) {
            liData.heading = next.text().trim();
          }

          return liData;
        }

        var a = li.children('a');
        var icon = a.children('.icon:not(.close):not(.icon-dropdown):not(.image-user-status .icon)');
        var id = a.attr('id');
        liData.text = a.text().trim();
        liData.disabled = li.hasClass('is-disabled');
        liData.visible = !li.hasClass('hidden');

        if (typeof id === 'string' && id.length) {
          liData.id = id;
        }

        if (icon.length && icon[0] instanceof SVGElement) {
          liData.icon = icon[0].querySelector('use').getAttribute('href').replace('#icon-', '');
        }

        var notGloballySelectable = !singleSelectable && !multiSelectable;
        var noSelectableSections = !self.hasSelectableSeparator(li);
        /*
        // Determine single/multi-select
        if (li.hasClass('is-selectable') || li.hasClass('is-checked')) {
          liData.selectable = 'single';
        } else if (li.hasClass('is-multiselectable')) {
          liData.selectable = 'multiple';
        }
        */
        // If selection isn't contained to a header, set it for the entire menu

        if (liData.selectable && notGloballySelectable && noSelectableSections) {
          if (liData.selectable === 'single') {
            singleSelectable = true;
          } else if (liData.selectable === 'multiple') {
            multiSelectable = true;
          }

          data.selectable = liData.selectable;
        }

        var submenu = li.find('.popupmenu');

        if (submenu.length) {
          liData.submenu = [];
          submenu.first().children().each(function (i, submenuItem) {
            var submenuLiData = decodeListItem(submenuItem);

            if (!submenuLiData) {
              return;
            }

            liData.submenu.push(submenuLiData);
          });
        }

        return liData;
      }

      var lis = settings.contextElement.children('li');
      lis.each(function (i, item) {
        var liData = decodeListItem(item);

        if (!liData) {
          return;
        }

        menu.push(liData);
      });

      if (settings.noMenuWrap) {
        data = menu;
      } else {
        data.menu = menu;
      }

      return data;
    },

    /**
     * Marks up menu items in the UI
     * @private
     * @param {jQuery[]|HTMLElement} [contextElement] the top-most element that will
     *  be modified (defaults to the top-level menu).
     * @returns {void}
     */
    markupItems: function markupItems(contextElement) {
      var self = this;

      if (!contextElement) {
        contextElement = this.menu;
      } else if (contextElement instanceof HTMLElement) {
        contextElement = $(contextElement);
      }

      var lis = contextElement.find('li:not(.heading):not(.separator)');
      var hasIcons = false;
      contextElement[0].setAttribute('role', 'menu');
      contextElement[0].setAttribute('aria-labelledby', this.element.attr('id')); // Calculates a nested index

      function getTreeIndex(li) {
        var $li = $(li);
        var parentLis = $li.parents('li');
        var indexes = [];
        $li.add(parentLis).each(function (i, thisLi) {
          indexes.push($(thisLi).parent().children('li:not(.heading):not(.separator)').index(thisLi));
        });
        return indexes.join('-');
      }

      lis.each(function (i, li) {
        var a = $(li).children('a')[0]; // TODO: do this better when we have the infrastructure

        var $a = $(a);
        var $li = $(li);
        var span = $a.children('span')[0];
        var submenu = $li.children('ul')[0];
        var icon = $li.find('.icon:not(.close):not(.icon-dropdown):not(.image-user-status .icon)');
        var submenuWrapper = $li.children('.wrapper')[0];
        li.setAttribute('role', 'none');

        if (a) {
          a.setAttribute('role', self.settings.ariaListbox ? 'option' : 'menuitem');
          a.setAttribute('tabindex', '-1'); // Add user-defined attributes to the anchor

          if (self.settings.attributes) {
            utils.addAttributes($a, self, self.settings.attributes, "option-".concat(getTreeIndex(li)));
          } // disabled menu items, by prop and by className


          if ($li.hasClass('is-disabled') || a.getAttribute('disabled') === 'true' || a.getAttribute('disabled') === 'disabled') {
            $li.addClass('is-disabled');
            a.setAttribute('aria-disabled', 'true');
            a.setAttribute('disabled', true);
          } else {
            $li.removeClass('is-disabled');
            $a.removeAttr('aria-disabled');
            a.removeAttribute('disabled');
          } // Checks for existing menus, and if present, apply a `popupmenu` class automatically.


          if (submenu instanceof HTMLElement) {
            submenu.classList.add('popupmenu');
          }

          if (submenuWrapper instanceof HTMLElement) {
            li.className += "".concat(DOM.hasAnyClass(li) ? ' ' : '', "submenu");
            submenu = $(submenuWrapper).children('ul')[0];

            if (submenu instanceof HTMLElement) {
              submenu.classList.add('popupmenu');
            }
          } // Adds the SVG arrow, etc to submenu items.


          if (DOM.hasClass(li, 'submenu')) {
            // Add a span
            if (!span) {
              a.innerHTML = "<span>".concat(a.innerHTML, "</span>");
              span = $a.children('span')[0];
            }

            if ($a.find('svg.arrow').length === 0) {
              $a.append($.createIconElement({
                classes: ['arrow', 'icon-dropdown'],
                icon: 'dropdown'
              }));
            }

            a.setAttribute('aria-haspopup', 'true');
          } // is-checked


          if (DOM.hasClass(li, 'is-checked')) {
            a.setAttribute('role', 'menuitemcheckbox');
            a.setAttribute('aria-checked', true); // Make all adjacent items selectable.

            if (!self.hasSelectableSeparator(li)) {
              var selectableClassName = 'is-selectable';

              if (self.menu.is('.is-multiselectable')) {
                selectableClassName = 'is-multiselectable';
              }

              self.getAdjacentSelectables(li).addClass(selectableClassName);
            }
          } // is-not-checked


          if (DOM.hasClass(li, 'is-not-checked')) {
            li.className = li.className.replace('is-not-checked', '');
            a.setAttribute('role', 'menuitemcheckbox');
            a.removeAttribute('aria-checked');
          }
        }

        if (icon && icon.length > 0) {
          hasIcons = true;
        }
      });

      if (hasIcons) {
        contextElement.addClass('has-icons');
      } else {
        contextElement.removeClass('has-icons');
      }
    },

    /**
     * Takes a pre-existing menu item and refreshes its state.
     * @private
     * @param {HTMLElement} item the menu item to be refreshed
     * @param {object} data representing a Popupmenu data structure, containing updated state information
     * @param {function} [callback] runs on completion of the item refresh.  Can be used for adding additional
     *  important flags/properties to the Menu Item for a specific implementation.
     * @returns {void}
     */
    refreshMenuItem: function refreshMenuItem(item, data, callback) {
      if (!item || !(item instanceof HTMLElement) || !data) {
        return;
      } // Don't refresh the menu item if it doesn't belong to this menu


      if (!$(this.menu)[0].contains(item)) {
        return;
      }

      var itemA = item.querySelector('a');
      var itemIcon = item.querySelector('.icon:not(.close):not(.icon-dropdown)');
      var itemIconUse;

      if (data.text) {
        if (itemA.innerText.trim() !== data.text) {
          itemA.innerText = "".concat(data.text);
        }
      }

      if (data.disabled === true) {
        if (item.className.indexOf('hidden') === -1) {
          item.classList.add('is-disabled');
        }
      } else if (item.className.indexOf('is-disabled') > -1) {
        item.classList.remove('is-disabled');
      }

      if (data.visible === true) {
        if (item.className.indexOf('hidden') > -1) {
          item.classList.remove('hidden');
        }
      } else if (item.className.indexOf('hidden') === -1) {
        item.classList.add('visible');
      }

      if (data.icon) {
        // TODO: fragile?
        if (itemIcon) {
          itemIconUse = itemIcon.querySelector('use');

          if (itemIconUse && itemIconUse.getAttribute('href').replace('#icon-', '') !== data.icon) {
            itemIcon.remove();
          }

          itemIconUse.setAttribute('href', "#icon-".concat(data.icon));
        }
      } else if (itemIcon) {
        itemIcon.remove();
      } // Refresh a menu item's submenu, if applicable.


      if (data.submenu) {
        item.classList.add('submenu');
        var submenuContainer = item.querySelector('.popupmenu');

        if (submenuContainer) {
          // Simply update the menu item's children
          var submenuItems = submenuContainer.children;

          for (var j = 0; j < data.submenu.length; j++) {
            data.submenu[j].isSubmenuItem = true;
            this.refreshMenuItem(submenuItems.item(j), data.submenu[j], callback);
          }
        }
      } // Run callback to apply additional refresh changes, if applicable.


      if (typeof callback === 'function') {
        callback.apply(this, [item, data]);
      }
    },

    /**
     * Sets up the event listener structure for the popupmenu
     * @private
     * @listens dragstart
     * @listens contextmenu
     * @listens keydown
     * @listens updated
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      var leftClick = this.settings.trigger !== 'rightClick';
      var immediate = this.settings.trigger === 'immediate';

      function disableBrowserContextMenu(e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      function doOpen(e) {
        if (self.element.hasClass('is-disabled')) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        var rightClick = self.settings.trigger === 'rightClick';
        e.stopPropagation();
        e.preventDefault();

        if (rightClick && self.menu.hasClass('is-open')) {
          self.close();
          self.open(e);
          return;
        }

        if (self.menu.add(self.element).hasClass('is-open')) {
          self.close();
        } else {
          self.open(e);
        }
      }

      function contextMenuHandler(e, isLeftClick) {
        if (self.keydownThenClick) {
          delete self.keydownThenClick;
          return;
        }

        var btn = isLeftClick === true ? 0 : 2;

        if (e.button > btn || self.element.is(':disabled')) {
          return;
        }

        var allowedOS = ['android', 'ios'];

        if (allowedOS.indexOf(Environment.os.name) > -1) {
          self.holdingDownClick = true;
        }

        doOpen(e);
      }

      if (!immediate) {
        // Left-Click activation
        if (leftClick) {
          this.element.on('click.popupmenu', function (e) {
            contextMenuHandler(e, true);
          });
        } // Right-Click activation


        if (!leftClick) {
          this.menu.parent().on('contextmenu.popupmenu', disableBrowserContextMenu);
          var disallowedOS = ['android', 'ios'];

          if (disallowedOS.indexOf(Environment.os.name) === -1) {
            // Normal desktop operation
            this.element.on('contextmenu.popupmenu', function (e) {
              disableBrowserContextMenu(e);
              contextMenuHandler(e);
            });
          } else {
            // Touch-based operation on a mobile device
            this.element.on('touchstart.popupmenu', function (e) {
              // iOS needs this prevented to prevent its own longpress feature in Safari
              // NOTE: this should not interfere with normal text input on form fields.
              if (Environment.os.name === 'ios' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
              }

              $(e.target).addClass('longpress-target');
            }).on('touchend.popupmenu', function (e) {
              $(e.target).removeClass('longpress-target');
            }).on('longpress.popupmenu', function (e, originalE) {
              self.openedWithTouch = true;
              contextMenuHandler(originalE);
            });
          }
        }
      } // Disable dragging text to a new browser tab


      this.menu.off('dragstart.popupmenu').on('dragstart.popupmenu', 'a', function () {
        return false;
      }); // Setup these next events no matter what trigger type is

      this.element.not('.autocomplete, ul').on('keydown.popupmenu', function (e) {
        switch (e.which) {
          case 13:
          case 32:
            if (self.settings.trigger === 'click') {
              self.keydownThenClick = true;
              self.open(e);
            }

            break;

          case 121:
            if (e.shiftKey) {
              // Shift F10
              self.open(e);
            }

            break;
        }
      }).on('updated.popupmenu', function (e, settings) {
        e.stopPropagation();
        self.updated(settings);
      });
    },
    handleKeys: function handleKeys() {
      var self = this; // http://access.aol.com/dhtml-style-guide-working-group/#popupmenu
      // Handle Events in Anchors

      this.menu.on('click.popupmenu', 'li', function (e) {
        var a = $(this).find('a');
        self.handleItemClick(e, a);
      });
      var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled):not(.is-placeholder)'; // Select on Focus

      if (this.settings.mouseFocus) {
        this.menu.on('mouseenter.popupmenu', 'li', function () {
          self.highlight($(this).children('a'));
        });
      }

      setTimeout(function () {
        $(document).off("keydown.popupmenu.".concat(this.id)).on("keydown.popupmenu.".concat(this.id), function (e) {
          var key = e.which; // Close on escape

          if (key === 27) {
            e.stopPropagation();
            e.stopImmediatePropagation();
            self.close(true);
            return false;
          } // Close on tab


          if (key === 9) {
            e.stopPropagation();
            self.close(true);
          } // Select Checkboxes


          if (key === 32) {
            e.stopPropagation();
            var target = $(e.target);
            var checkbox = target.find('input:checkbox');

            if (checkbox.length) {
              checkbox.trigger('click');
              return true;
            }

            var a = $(); // Return here and let Tabs control handle the spacebar

            if (target.is('.tab') || target.parent().is('.tab') || target.is('.tab-more')) {
              // Spacebar acts like Enter if there aren't any checkboxes (trigger links, etc)
              e.preventDefault();
              return true;
            }

            if (target.is('li')) {
              a = target.children('a');
            }

            if (target.is('a')) {
              a = target;
            }

            if (a.length) {
              a.trigger('click');
              return true;
            }
          }

          var focus = self.menu.find(':focus'); // Sets focus for functional testing

          if (!focus[0]) {
            focus = $(self.menu[0].querySelector('.is-focused a'));
          }

          var isPicker = self.settings.menu === 'colorpicker-menu';
          var isAutocomplete = self.element.is('.autocomplete'); // Close Submenu

          if (key === 37 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.closest('.popupmenu')[0] !== self.menu[0] && focus.closest('.popupmenu').length > 0) {
              focus.closest('.popupmenu').removeClass('is-open').parent().parent().removeClass('is-submenu-open');
              self.highlight(focus.closest('.popupmenu').parent().prev('a'));
            }
          }

          var getPrev;
          var getNext;
          var getLast;
          var getFirst;

          getPrev = function getPrev(a) {
            //eslint-disable-line
            var prevs = a.parent().prevAll(excludes);
            var prev;
            prevs.each(function () {
              if (prev) {
                return;
              }

              var li = $(this);
              var targetA = li.children('a');

              if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                return;
              }

              prev = targetA;
            });

            if (!prev) {
              return getFirst(a);
            }

            return prev;
          };

          getFirst = function getFirst(a) {
            //eslint-disable-line
            var first = a.parent().prevAll(excludes).last();
            var targetA = first.children('a');

            if (first.is('.is-disabled') || targetA.prop('disabled') === true) {
              return getNext(targetA);
            }

            return targetA;
          };

          getNext = function getNext(a) {
            //eslint-disable-line
            var nexts = a.parent().nextAll(excludes);
            var next;
            nexts.each(function () {
              if (next) {
                return;
              }

              var li = $(this);
              var targetA = li.children('a');

              if (li.is('.is-disabled') || targetA.prop('disabled') === true) {
                return;
              }

              next = targetA;
            });

            if (!next) {
              return getFirst(a);
            }

            return next;
          };

          getLast = function getLast(a) {
            //eslint-disable-line
            var last = a.parent().nextAll(excludes).last();
            var targetA = last.children('a');

            if (last.is('.is-disabled') || targetA.prop('disabled') === true) {
              return getPrev(targetA);
            }

            return targetA;
          }; // Count number of rows in picker


          var rowCount = 0;
          var colors = self.menu.children(excludes);
          var colorsLength = colors.length;
          var currentOffsetTop = 0;

          for (var i = 0; i < colorsLength; i++) {
            var colorItem = colors[i];

            if (currentOffsetTop === 0) {
              currentOffsetTop = colorItem.offsetTop;
            }

            if (colorItem.offsetTop === currentOffsetTop) {
              rowCount++;
            } else {
              break;
            }
          } // Up on Up


          if (!isPicker && key === 38 || isPicker && key === (Locale.isRTL() ? 39 : 37)) {
            e.stopPropagation();
            e.preventDefault(); // Go back to Top on the last one

            if (focus.parent().prevAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).last().find('a'));
              } else {
                self.highlight(getLast(focus));
              }

              return undefined;
            }

            self.highlight(getPrev(focus));
          } // Up a square


          if (isPicker && key === 38) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().prevAll(excludes).length > 0) {
              self.highlight($(focus.parent().prevAll(excludes)[rowCount - 1]).find('a'));
            }
          } // Right Open Submenu


          if (key === 39 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().hasClass('submenu')) {
              self.openSubmenu(focus.parent());
              self.highlight(focus.parent().find('.popupmenu a:first'));
            }
          } // Down


          if (!isPicker && key === 40 || isPicker && key === (Locale.isRTL() ? 37 : 39) && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault(); // Go back to Top on the last one

            if (focus.parent().nextAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).first().find('a'));
              } else {
                self.highlight(getFirst(focus));
              }

              return undefined;
            }

            self.highlight(getNext(focus));
          } // Down a square


          if (isPicker && key === 40) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().nextAll(excludes).length > 0) {
              self.highlight($(focus.parent().nextAll(excludes)[rowCount - 1]).find('a'));
            }
          } // Fix - not sure why, but firefox have to manualy trigger


          if (self.isFirefox && isAutocomplete && !/37|39|38|40/.test(key)) {
            self.element.triggerHandler(e);
            self.element[0].focus();
            var val = self.element[0].value;
            self.element[0].value = '';
            self.element[0].value = val;
          }

          return undefined;
        });
      }, 1);
    },

    /**
     * Handles the action of clicking items in the popupmenu.
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @param {jQuery[]} anchor the anchor tag element that was clicked
     * @returns {boolean} whether or not the click handler successfully passed.
     */
    handleItemClick: function handleItemClick(e, anchor) {
      var href = anchor.attr('href');
      var selectionResult = [anchor];

      if (!e && !anchor || !anchor.length) {
        return false;
      }

      if (anchor.parent().is('.submenu, .hidden, .is-disabled') || anchor[0].disabled) {
        // Do not close parent items of submenus on click
        e.preventDefault();
        return false;
      }

      if (anchor.find('input[checkbox]').length > 0) {
        return false;
      }

      if (this.element.hasClass('btn-filter')) {
        this.iconFilteringUpdate(anchor);
        e.preventDefault();
      }

      if (this.isSelectable(anchor.parent())) {
        selectionResult = this.select(anchor);
      } // Single toggle on off of checkbox class


      if (anchor.parent().hasClass('is-toggleable')) {
        anchor.parent().toggleClass('is-checked');
      } // Trigger a selected event containing the anchor that was selected
      // If an event object is not passed to `handleItemClick()`, assume it was due to this
      // event being triggered already, making it not necessary to re-trigger it.


      if (e && this.settings.triggerSelect) {
        if (selectionResult.length === 1) {
          selectionResult.push(undefined);
        }

        selectionResult.push(true);
        /**
         * Fires on selected.
         *
         * @event selected
         * @memberof PopupMenu
         * @property {object} event - The jquery event object
         * @property {object} selected anchor
         */

        this.element.triggerHandler('selected', selectionResult);
      } // MultiSelect Lists should act like other "multiselect" items and not
      // close the menu when options are chosen.


      if (this.menu.hasClass('is-multiselectable') || this.isInMultiselectSection(anchor)) {
        return true;
      }

      this.close();

      if (this.element.is('.autocomplete')) {
        return true;
      }

      if (href && href.charAt(0) !== '#') {
        if (anchor.attr('target') === '_blank') {
          window.open(href, '_blank');
        } else {
          window.location.href = href;
        }

        return true;
      }

      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      return true;
    },

    /**
     * Filtering icon initial setup
     * @private
     * @param {jQuery[]} [alink] menu item to be targeted
     * @returns {void}
     */
    iconFilteringSetup: function iconFilteringSetup(alink) {
      if (this.element.hasClass('btn-filter')) {
        var svg = this.element.find('svg.icon-dropdown');
        var link = alink || $('li.is-checked a', this.menu) || $('li:first a', this.menu);
        var audibleText = link.find('span').text();

        if (svg.length === 1) {
          this.element.append($.createIconElement({
            classes: 'icon-dropdown',
            icon: 'dropdown'
          }));
        }

        svg.first().changeIcon(link.find('svg').getIconName());
        this.element.find('.audible').text(audibleText);
      }
    },

    /**
     * Filtering icon update
     * @private
     * @param {jQuery[]} [alink] menu item to be targeted
     * @returns {void}
     */
    iconFilteringUpdate: function iconFilteringUpdate(alink) {
      if (this.element.hasClass('btn-filter')) {
        var link = alink || $('li.is-checked a', this.menu) || $('li:first a', this.menu);
        var audibleText = link.find('span').text();
        this.element.find('.audible').text(audibleText);
        this.element.find('svg:not(.ripple-effect):first').changeIcon(link.find('svg').getIconName());
      }
    },

    /**
     * Get the event position, handling browser cases (IE,FF) as well as SVG
     * @private
     * @param {jQuery.Event} e the mouse event to be checked for pageX/pageY
     * @returns {object} containing x/y coordinates
     */
    getPositionFromEvent: function getPositionFromEvent(e) {
      var x = 0;
      var y = 0;

      if (!e) {
        e = window.event;
      }

      if (!e) {
        return {};
      }

      if (e.changedTouches) {
        var touch = e.changedTouches[0];
        x = touch.pageX;
        y = touch.pageY;
      } else if (e.pageX || e.pageY) {
        x = e.pageX;
        y = e.pageY;
      } else if (e.clientX || e.clientY) {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      return {
        x: x,
        y: y
      };
    },

    /**
     * Sets the position of the context menu.
     * @private
     * @param {jQuery.Event} e jQuery Event that caused the menu to open (can be several types)
     * @returns {void}
     */
    position: function position(e) {
      var self = this;
      var target = this.element;
      var isRTL = this.isRTL();
      var wrapper = this.menu.parent('.popupmenu-wrapper');
      var mouse = this.getPositionFromEvent(e);
      var menuDimensions = {
        width: this.menu[0].offsetWidth,
        height: this.menu[0].offsetHeight
      };

      if (!wrapper.length) {
        return;
      } // Make the field the same size


      var elemWidth = this.element[0].offsetWidth;

      if (this.settings.trigger === 'click' && elemWidth > menuDimensions.width) {
        this.menu.width(elemWidth);
      }

      if (target.is('svg, .icon') && target.closest('.tab').length) {
        target = target.closest('.tab');
      }

      function getCoordinates(thisE, axis) {
        axis = axis === 'x' || axis === 'y' ? axis : 'x';
        return mouse[axis]; // use mouseX/mouseY if this doesn't work
      } // Reset the arrow


      wrapper.find('.arrow').removeAttr('style');
      var opts = $.extend({}, this.settings.placementOpts);
      var strategies = ['flip'];
      strategies.push('shrink-y');
      opts.strategies = strategies; // If right-click or immediate (with an incoming event object), use coordinates from the event

      if (this.settings.trigger === 'immediate' && this.settings.eventObj || this.settings.trigger === 'rightClick') {
        opts.x = getCoordinates(e, 'x') - (isRTL ? menuDimensions.width : 0) + (isRTL ? -1 : 1) * this.settings.offset.x;
        opts.y = getCoordinates(e, 'y') + this.settings.offset.y;

        if (opts.x === 0 && opts.y === 0) {
          opts.x = this.settings.offset.x || 0;
          opts.y = this.settings.offset.y || 0;
          opts.parent = this.element;
          opts.placement = 'bottom';
          opts.parentXAlignment = isRTL ? 'right' : 'left';
        }
      } else {
        opts.x = this.settings.offset.x || 0;
        opts.y = this.settings.offset.y || 0;
        opts.parent = this.element;
        opts.placement = 'bottom';
        opts.strategies.push('nudge');
      } //= ======================================================
      // BEGIN Temporary stuff until we sort out passing these settings
      // from the controls that utilize them
      //= ======================================================


      var toolbarParent = target.parents('.toolbar');
      var insideToolbar = toolbarParent.length > 0;
      var insideToolbarTitle = target.parents('.title').length > 0;
      var isNotFullToolbar = insideToolbar && toolbarParent.children('.buttonset, .title').length > 1;
      var isPagerMenu = target.parents('.pager-pagesize').length > 0;

      function alignLeft() {
        opts.parentXAlignment = isRTL ? 'right' : 'left';
      }

      function alignRight() {
        opts.parentXAlignment = isRTL ? 'left' : 'right';
      }

      function shiftDown() {
        opts.y += 15;
      } // Change the alignment of the popupmenu based on certain conditions


      (function doAlignment() {
        if (target.is('.btn-menu')) {
          if (isPagerMenu) {
            return alignRight();
          }

          if (insideToolbar) {
            if (!isNotFullToolbar) {
              return alignLeft();
            }

            if (insideToolbarTitle) {
              return alignLeft();
            }

            return alignRight();
          }

          return alignLeft();
        }

        if (target.is('.btn-actions')) {
          return alignRight();
        }

        if (target.is('.tab-more')) {
          return alignRight();
        }

        if (target.is('.btn-split-menu, .tab, .searchfield-category-button') && !target.parent('.pager-pagesize').length) {
          return alignLeft();
        }

        return undefined;
      })();

      if (target.parents('.masthead').length > 0) {
        shiftDown();
      } // If inside a "page-container" element, constrain the popupmenu to that element
      // (fixes SOHO-6223)


      var container = this.element.parents('.page-container:not(.tab-container)');

      if (container.length) {
        opts.container = container.first();
      } //= ======================================================
      // END Temporary stuff until we sort out passing these settings
      // from the controls that utilize them
      //= ======================================================


      wrapper.one('afterplace.popupmenu', function (thisE, positionObj) {
        self.handleAfterPlace(thisE, positionObj);
      });
      this.wrapperPlace = new Place(wrapper, opts);
      this.wrapperPlace.place(opts);
    },
    handleAfterPlace: function handleAfterPlace(e, placementObj) {
      var wrapper = this.menu.parent('.popupmenu-wrapper');
      this.wrapperPlace.setArrowPosition(e, placementObj, wrapper); // Check if colorpicker has scrollbar
      // Use CSS class to modify width of popupmenu.

      if (placementObj.height < this.menu[0].offsetHeight) {
        if (this.menu[0].classList.contains('colorpicker')) {
          this.menu[0].classList.add('has-scrollbar');
        }
      }

      if (placementObj.height) {
        wrapper[0].style.height = '';
        this.menu[0].style.height = placementObj.height + (/(px|%)/i.test("".concat(placementObj.height)) ? '' : 'px');
      }

      if (placementObj.width) {
        wrapper[0].style.width = '';
        this.menu[0].style.width = placementObj.width + (/(px|%)/i.test("".concat(placementObj.width)) ? '' : 'px');
      }

      wrapper.triggerHandler('popupmenuafterplace', [placementObj]);
      return placementObj;
    },

    /**
     * Calls an external source.
     * @private
     * @param {jQuery.Event} [e] an event that triggered the Popupmenu to open
     *  (could be several types)
     * @param {boolean} [doOpen] causes the menu to re-open once the data has been reloaded.
     * @param {jQuery[]|HTMLElement} [contextElement] if passed, represents a submenu
     *  as the actionable, replaceable menu element instead of the main menu.
     * @param {boolean} [isSubmenu] Note that the request is a submenu for the callback.
    */
    callSource: function callSource(e, doOpen, contextElement, isSubmenu) {
      if (typeof this.settings.beforeOpen !== 'function') {
        return;
      }

      var self = this;
      var targetMenu = this.menu; // Use a different menu, if applicable

      if (DOM.isElement(contextElement) && $(contextElement).is('.popupmenu, .submenu')) {
        targetMenu = $(contextElement); // Skip calling external source if submenu is already open

        if (contextElement.hasClass('is-open')) {
          return;
        }
      }

      var response = function response(content) {
        var existingMenuItems = targetMenu.children();
        existingMenuItems.filter(function (i, item) {
          return self.predefinedItems.index(item) === -1;
        }).off().remove();

        if (content === false) {
          return false;
        }

        var newContent = $(content);
        targetMenu.append(newContent);
        var wrapper = targetMenu.parent('.wrapper, .popupmenu-wrapper');

        if (!wrapper.length) {
          wrapper = targetMenu.wrap('<div class="wrapper">').parent();
        }

        wrapper.removeAttr('style');
        self.markupItems(targetMenu);

        if (doOpen) {
          if (!targetMenu.is(self.menu)) {
            self.openSubmenu(wrapper.parent('li'), true);
          } else {
            self.open(e, true);
          }
        }

        return true;
      };

      var callbackOpts = {};

      if (!targetMenu.is(this.menu)) {
        callbackOpts.contextElement = targetMenu;
      }

      callbackOpts.element = this.element;
      callbackOpts.isSubmenu = isSubmenu;

      if (typeof this.settings.beforeOpen === 'string') {
        window[this.settings.beforeOpen](response, callbackOpts);
        return;
      }

      this.settings.beforeOpen(response, callbackOpts);
    },

    /**
     * Gets the width of the menu
     * @returns {number} representing the width of the largest menu item.
     */
    getMaxMenuWidth: function getMaxMenuWidth() {
      if (!(this.menu instanceof $)) {
        return 0;
      }

      var wasOriginallyClosed = !this.isOpen;

      if (wasOriginallyClosed) {
        this.wrapper.css({
          left: '-999999px'
        });
        this.menu.addClass('is-open');
      }

      var width = this.menu.width();

      if (wasOriginallyClosed) {
        this.wrapper.css({
          left: ''
        });
        this.menu.removeClass('is-open');
      }

      return width;
    },

    /**
     * Opens the popupmenu, including repopulating data and setting up visual delays, if necessary.
     * @param {jQuery.Event} e the event that caused the menu to open
     * @param {boolean} ajaxReturn set to true if the open routine should not include a source call
     * @param {boolean} useDelay set to true if the menu should open on a delay (used in mobile environments where a software keybord is present)
     * @returns {void}
     */
    open: function open(e, ajaxReturn, useDelay) {
      var self = this; // If no top-level menu is present, don't open at all and act like a button.

      if (!this.menu || !this.menu.length) {
        return;
      }
      /**
       * Fires before open.
       *
       * @event beforeopen
       * @memberof PopupMenu
       * @property {object} event - The jquery event object
       * @property {object} this menu instance
       */


      var canOpen = true;

      if (!this.element.hasClass('autocomplete')) {
        canOpen = this.element.triggerHandler('beforeopen', [this.menu]);

        if (canOpen === false) {
          return;
        }
      } // Check external AJAX source, if applicable


      if (!ajaxReturn) {
        canOpen = this.callSource(e, true);

        if (this.settings.beforeOpen) {
          return;
        }
      } // If there's no explicit run of this method without this flag, setup a delay and re-run the open method


      if (!useDelay) {
        if (Environment.os.name === 'ios') {
          setTimeout(function () {
            self.open(e, ajaxReturn, true);
          }, 400);
          return;
        }
      }

      var otherMenus = $('.popupmenu.is-open').filter(function () {
        return $(this).parents('.popupmenu').length === 0;
      }).not(this.menu); // close others.

      otherMenus.each(function () {
        var trigger = $(this).data('trigger');

        if (!trigger || !trigger.length) {
          return;
        }

        var api = $(this).data('trigger').data('popupmenu');

        if (api && typeof api.close === 'function') {
          api.close();
        }
      }); // Close open tooltips associated with this menu's trigger element

      var tooltipAPI = this.element.data('tooltip');

      if (tooltipAPI && tooltipAPI.visible) {
        tooltipAPI.hide();
      } // Close open dropdowns


      var openDropdown = $('.dropdown.is-open');

      if (openDropdown.length > 0) {
        var dropDownApi = openDropdown.parent().prev().data('dropdown');

        if (dropDownApi) {
          dropDownApi.closeList('cancel');
        }
      } // Close Application Menu, if applicable


      var openAppMenu = document.querySelector('.application-menu.is-open');

      if (openAppMenu instanceof HTMLElement && !openAppMenu.contains(this.element[0]) && !openAppMenu.contains(this.menu[0])) {
        $(document).triggerHandler('dismiss-applicationmenu');
      }

      this.element.addClass('is-open');
      this.menu.addClass('is-open').attr('aria-hidden', 'false');

      if (this.element.hasClass('inverse')) {
        this.menu.parent('.popupmenu-wrapper').addClass('inverse');
      }

      this.position(e);
      utils.fixSVGIcons(this.menu);

      if (this.element.closest('.header').length > 0) {
        this.menu.parent()[0].style.zIndex = '9001';
      } // Check every anchor tag to see if it should be disabled.
      // Use the CSS class on its parent to determine whether or not to disable.


      this.menu.find('a').each(function () {
        var a = $(this);
        var li = a.parent();

        if (li.hasClass('is-disabled')) {
          li.addClass('is-disabled');
          a.attr('aria-disabled', 'true');
          a.attr('disabled', 'disabled');
        } else {
          li.removeClass('is-disabled');
          a.removeAttr('aria-disabled');
          a.removeAttr('disabled');
        }
      }); // Close on Document Click etc..

      setTimeout(function () {
        $(document).on("touchend.popupmenu.".concat(self.id, " click.popupmenu.").concat(self.id), function (thisE) {
          var isPicker = self.settings.menu === 'colorpicker-menu';

          if (thisE.button === 2) {
            return;
          }

          if (self.holdingDownClick) {
            delete self.holdingDownClick;
            return;
          } // Click functionality will toggle the menu - otherwise it closes and opens


          if ($(thisE.target).is(self.element) && !isPicker && !(self.settings.trigger === 'rightClick')) {
            return;
          }

          if ($(thisE.target).closest('.popupmenu').length === 0) {
            self.close(true, self.settings.trigger === 'rightClick');
          }

          if ($(thisE.target).hasClass('swatch')) {
            setTimeout(function () {
              self.close();
            }, 150);
          }
        }); // in desktop environments, close the list on viewport resize

        if (window.orientation === undefined) {
          $('body').on('resize.popupmenu', function () {
            self.handleCloseEvent();
          });
        }

        $(window).on('scroll.popupmenu', function () {
          setTimeout(function () {
            self.close();
          }, 150);
        });
        $('.datagrid-wrapper').on('scroll.popupmenu', function () {
          setTimeout(function () {
            self.close();
          }, 150);
        });
        $('.scrollable, .modal.is-visible .modal-body-wrapper').on('scroll.popupmenu', function () {
          setTimeout(function () {
            self.close();
          }, 150);
        });
        /**
         * Fires on open.
         *
         * @event open
         * @memberof PopupMenu
         * @property {object} event - The jquery event object
         * @property {object} this menu instance
         */

        self.element.triggerHandler('open', [self.menu]);
      }, 300); // Hide on iFrame Clicks - only works if on same domain

      $('iframe').each(function () {
        var frame = $(this);
        frame.ready(function () {
          try {
            frame.contents().find('body').on('click.popupmenu', function () {
              self.close();
            });
          } catch (thisE) {// Ignore security errors on out of iframe
          }
        });
      });
      this.handleKeys(); // hide and decorate submenus - we use a variation on

      var tracker = 0;
      var startY;
      var menuToClose;
      self.menu.find('.popupmenu').removeClass('is-open');
      self.menu.on('mouseenter.popupmenu touchend.popupmenu', '.submenu:not(.is-disabled)', function (thisE) {
        if (!$(thisE.target).hasClass('popupmenu')) {
          var menuitem = $(this);
          startY = thisE.pageX;
          clearTimeout(self.submenuOpenTimeout);
          self.submenuOpenTimeout = setTimeout(function () {
            self.openSubmenu(menuitem);
          }, 300);
          $(document).on("mousemove.popupmenu.".concat(this.id), function (documentE) {
            tracker = documentE.pageX;
          });
        }
      }).on('mouseleave.popupmenu', '.submenu', function () {
        $(document).off("mousemove.popupmenu.".concat(this.id));
        menuToClose = $(this).find('ul');
        var hasWrapper = menuToClose.parent('.wrapper').length > 0;
        var isLeft = (hasWrapper ? parseInt(menuToClose.parent('.wrapper')[0].style.left, 10) : 0) < 0;
        var canClose = tracker - startY < 3.5;

        if (isLeft) {
          canClose = tracker - startY >= 0;
        }

        if (canClose) {
          // We are moving slopie to the menu
          menuToClose.removeClass('is-open').removeAttr('style');
          menuToClose.parent('.wrapper').removeAttr('style');
          menuToClose.parent().parent().removeClass('is-submenu-open');
          menuToClose = null;
        }

        clearTimeout(self.submenuOpenTimeout);
      });

      if (self.settings.autoFocus) {
        setTimeout(function () {
          var excludes = ':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';
          var selection = self.menu.children(excludes).find('.is-selected').children('a');

          if (!selection.length) {
            selection = self.menu.children(excludes).first().children('a');
          }

          self.highlight(selection);
          /**
           * Fires after open.
           *
           * @event afteropen
           * @memberof PopupMenu
           * @property {object} event - The jquery event object
           * @property {object} this menu instance
           */

          self.element.triggerHandler('afteropen', [self.menu]);
        }, 1);
      }
    },

    /**
     * Only allows a menu to close if a key is no longer being pressed
     * @private
     * @returns {void}
     */
    handleCloseEvent: function handleCloseEvent() {
      if (this.holdingDownClick) {
        return;
      }

      this.close();
    },

    /**
     * Opens a top-level menu item's submenu, if applicable
     * @private
     * @param {jQuery[]} li the list item that needs to be opened.
     * @param {boolean} [ajaxReturn] if defined, prevents an external source from
     *  re-populating the menu before it opens.
     * @returns {void}
     */
    openSubmenu: function openSubmenu(li, ajaxReturn) {
      if (DOM.hasClass(li, 'is-disabled') || li[0].disabled) {
        return;
      }

      var submenu = li.children('.wrapper, .popupmenu');

      if (submenu.length && submenu.is('.wrapper')) {
        submenu = submenu.children('.popupmenu');
      }

      var canOpen = this.element.triggerHandler('beforeopen', [submenu]);

      if (canOpen === false) {
        return;
      } // Check external AJAX source, if applicable


      if (!ajaxReturn) {
        canOpen = this.callSource(null, true, submenu, true);

        if (this.settings.beforeOpen) {
          return;
        }
      }

      this.showSubmenu(li);
    },

    /**
     * Opens a top-level menu item's submenu, if applicable
     * @private
     * @param {jQuery[]} li the list item that needs to be opened.
     * @returns {void}
     */
    showSubmenu: function showSubmenu(li) {
      // Trigger an event so other components can listen to this element as a popupmenu trigger.
      this.element.triggerHandler('show-submenu', [li]);
      var wrapper = li.children('.wrapper').filter(':first');
      var isRTL = this.isRTL();
      var rtlPadding = 30; // Wrap if not wrapped (dynamic menu situation)

      if (wrapper.length === 0) {
        var ul = li.children('ul').filter(':first');
        ul.wrap('<div class="wrapper"></div>');
        wrapper = ul.parent();
      }

      var menu = wrapper.children('.popupmenu');
      var wrapperLeft = li.position().left + li.outerWidth();
      var wrapperWidth = 0;
      li.parent().find('.popupmenu').removeClass('is-open').removeAttr('style');
      wrapper.children('.popupmenu').addClass('is-open');
      wrapperWidth = wrapper.outerWidth();

      if (isRTL) {
        wrapperLeft = li.position().left - wrapperWidth;
      }

      wrapper[0].style.left = "".concat(wrapperLeft, "px");
      wrapper[0].style.top = "".concat(parseInt(li.position().top, 10) - 5, "px"); // Handle Case where the menu is off to the right

      var menuWidth = menu.outerWidth();

      if (wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft() || isRTL && wrapper.offset().left < 0) {
        wrapper[0].style.left = '-9999px';
        menuWidth = menu.outerWidth();
        wrapperLeft = li.position().left - menuWidth;

        if (isRTL) {
          var parentMenuWidth = wrapper.closest('.popupmenu').outerWidth();
          wrapperLeft = parentMenuWidth - 4; // Move back across the parent menu
        }

        wrapper[0].style.left = "".concat(wrapperLeft, "px"); // Did it fit?

        if (wrapper.offset().left < 0 || isRTL && wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft()) {
          // No. Push the menu's left offset onto the screen.
          wrapperLeft = li.position().left - menuWidth + Math.abs(wrapper.offset().left) + 40;

          if (isRTL) {
            wrapperLeft = li.position().left - menuWidth - rtlPadding;
          }

          wrapper[0].style.left = "".concat(wrapperLeft, "px");
          menuWidth = menu.outerWidth();
        } // Do one more check to see if the right edge bleeds off the screen.
        // If it does, shrink the menu's X size.


        if (wrapper.offset().left + menuWidth > $(window).width() + $(document).scrollLeft() || isRTL && wrapper.offset().left < 0) {
          var differenceY = wrapper.offset().left + menuWidth - ($(window).width() + $(document).scrollLeft());
          menuWidth -= differenceY;
          menu[0].style.width = "".concat(menuWidth, "px");
        }
      } // Handle Case where menu is off bottom


      var menuHeight = menu.outerHeight();
      var bottomBuffer = this.settings.placementOpts.containerOffsetY;

      if (wrapper.offset().top + menuHeight > window.innerHeight - bottomBuffer + $(document).scrollTop()) {
        // First try bumping up the menu to sit just above the bottom edge of the window.
        var bottomEdgeCoord = wrapper.offset().top + menuHeight;
        var differenceFromBottomY = bottomEdgeCoord - (window.innerHeight + $(document).scrollTop());
        wrapper[0].style.top = "".concat(wrapper.position().top - differenceFromBottomY - bottomBuffer, "px"); // Does it fit?

        if (wrapper.offset().top + menuHeight > window.innerHeight + $(document).scrollTop()) {
          // No. Bump the menu up higher based on the menu's height and the extra
          // space from the main wrapper.
          var mainWrapperOffset = li.parents('.popupmenu-wrapper:first').offset().top;
          wrapper[0].style.top = "".concat(window.innerHeight + $(document).scrollTop() - menuHeight - mainWrapperOffset, "px");
        } // Does it fit now?


        if (wrapper.offset().top - $(document).scrollTop() < 0) {
          // No. Push the menu down onto the screen from the top of the window edge.
          wrapper[0].style.top = 0;
          wrapper[0].style.top = "".concat(wrapper.offset().top * -1, "px");
          menuHeight = menu.outerHeight();
        } // Do one more check to see if the bottom edge bleeds off the screen.
        // If it does, shrink the menu's Y size and make it scrollable.


        if (wrapper.offset().top + menuHeight > window.innerHeight + $(document).scrollTop()) {
          var differenceX = wrapper.offset().top + menuHeight - (window.innerHeight + $(document).scrollTop());
          menuHeight = menuHeight - differenceX - 32;
          menu[0].style.height = "".concat(menuHeight, "px");
        }
      }

      li.parent().find('.is-submenu-open').removeClass('is-submenu-open');
      li.addClass('is-submenu-open');
    },

    /**
     * Places a highlighted visual state on an item inside the menu
     * @private
     * @param {jQuery[]} anchor the anchor tag representing the menu item.
     * @returns {void}
     */
    highlight: function highlight(anchor) {
      if (!anchor || !anchor.length) {
        return;
      }

      var li = anchor.parent();
      li.parent().children('li').removeClass('is-focused');
      li.addClass('is-focused'); // Prevent chrome from scrolling - toolbar

      if (anchor) {
        anchor.focus();
      }

      li.closest('.header').scrollTop(0);
    },

    /**
     * Adds/removes checkmarks that are in selectable groups inside the Popupmenu
     * @param {jQuery[]} anchor the anchor tag representing the menu item.
     * @returns {array} updated references to the anchor and its state.
     */
    select: function select(anchor) {
      var singleMenu = this.menu.is('.is-selectable');
      var multipleMenu = this.menu.is('.is-multiselectable');
      var singleSection = this.isInSingleSelectSection(anchor);
      var multipleSection = this.isInMultiselectSection(anchor);
      var parent = anchor.parent();
      var returnObj = [anchor]; // If the entire menu is "selectable", place the checkmark where it's supposed to go.

      if (parent.hasClass('is-selectable') && !anchor.find('.icon').length || singleMenu || singleSection) {
        parent.prevUntil('.heading, .separator').add(parent.nextUntil('.heading, .separator')).removeClass('is-checked');
        parent.addClass('is-checked');
        returnObj.push('selected');
        return returnObj;
      }

      if (parent.hasClass('is-multiselectable') || multipleMenu || multipleSection) {
        if (parent.hasClass('is-checked')) {
          parent.removeClass('is-checked');
          returnObj.push('deselected');
          return returnObj;
        }

        parent.addClass('is-checked');
        returnObj.push('selected');
        return returnObj;
      }

      return returnObj;
    },

    /**
     * Gets references to top-level menu items that are currently selected.
     * @returns {jQuery[]} elements inside the top-level menu that are selected.
     */
    getSelected: function getSelected() {
      if (!this.menu.is('.is-selectable, .is-multiselectable')) {
        return $();
      }

      return this.menu.children('.is-checked').children('a');
    },

    /**
     * Checks if a list item is selectable, single or multi.
     * @param {HTMLElement} li an HTML List Item to check
     * @returns {boolean} whether or not the element is selectable
     */
    isSelectable: function isSelectable(li) {
      return $(li).is('.is-selectable, .is-multiselectable') || this.hasSelectableSeparator(li) || this.menu.hasClass('is-selectable') || this.menu.hasClass('is-multiselectable');
    },

    /**
     * @private
     * @param {HTMLElement} li an HTML List Item to check
     * @returns {jQuery[]} element representing a menu item's adjacent selectable header, if applicable.
     */
    getSelectableSeparator: function getSelectableSeparator(li) {
      return $(li).prevAll('.separator.single-selectable-section, .separator.multi-selectable-section').first();
    },

    /**
     * @private
     * @param {HTMLElement} li an HTML List Item to check
     * @returns {boolean} whether or not a menu item has an adjacent selectable header.
     */
    hasSelectableSeparator: function hasSelectableSeparator(li) {
      var sep = this.getSelectableSeparator(li);
      return sep && sep.length;
    },

    /**
     * Gets references to the adjacent menu items in a selectable section
     * If there are no selectable sections defined, consider the entire menu
     * as selectable (not including submenu items)
     * @param {HTMLElement} li the list item being checked.
     * @returns {jQuery[]} elements inside the selectable section.
     */
    getAdjacentSelectables: function getAdjacentSelectables(li) {
      var sep = this.getSelectableSeparator(li);
      var exclusions = ':not(.heading):not(.separator):not(.submenu)';

      if (!sep || !sep.length) {
        return $(li).parent().children("li".concat(exclusions));
      }

      return $(sep).nextUntil('.separator').filter(exclusions);
    },

    /**
     * Determines whether or not an anchor resides inside of a selectable Popupmenu section.
     * @private
     * @deprecated as of v4.24.x. Use `hasSelectableSeparator()` instead.
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected.
     */
    isInSelectableSection: function isInSelectableSection(anchor) {
      warnAboutDeprecation('hasSelectableSeparator()', 'isInSelectableSection()');
      var separator = anchor.parent().prevAll().filter('.separator').first();
      return separator.hasClass('multi-selectable-section') || separator.hasClass('single-selectable-section');
    },

    /**
     * Determines whether or not an anchor resides inside of a single-selectable Popupmenu section.
     * @private
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected
     *  within a single-selectable section.
     */
    isInSingleSelectSection: function isInSingleSelectSection(anchor) {
      return anchor.parent().prevAll().filter('.separator').first().hasClass('single-selectable-section');
    },

    /**
     * Determines whether or not an anchor resides inside of a multi-selectable Popupmenu section.
     * @private
     * @param {jQuery[]} anchor the anchor tag being checked.
     * @returns {jQuery[]} elements inside the top-level menu that are selected
     *  within a multi-selectable section.
     */
    isInMultiselectSection: function isInMultiselectSection(anchor) {
      return anchor.parent().prevAll().filter('.separator').first().hasClass('multi-selectable-section');
    },

    /**
     * Removes event listeners from all popupmenu elements.
     * @private
     * @returns {void}
     */
    detach: function detach() {
      $(document).off("touchend.popupmenu.".concat(this.id, " click.popupmenu.").concat(this.id, " keydown.popupmenu"));
      $(window).off('scroll.popupmenu orientationchange.popupmenu');
      $('.datagrid-wrapper').off('scroll.popupmenu');
      $('body').off('resize.popupmenu');
      $('.scrollable').off('scroll.popupmenu');

      if (this.menu && this.menu.length) {
        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
      }

      $('iframe').each(function () {
        var frame = $(this);

        try {
          frame.contents().find('body').off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
        } catch (e) {// Ignore security errors on out of iframe
        }
      });
    },

    /**
     * Close the open menu
     * @param {boolean} isCancelled Internally set option used if the operation is a cancel.
     *  Wont matter for manual api call.
     * @param {boolean} [noFocus] Do not return focus to the calling element (fx a button)
     */
    close: function close(isCancelled, noFocus) {
      if (!isCancelled || isCancelled === undefined) {
        isCancelled = false;
      }

      if (!this.menu || !this.menu.add(this.element).hasClass('is-open')) {
        return;
      }

      var wrapper = this.menu.parent('.popupmenu-wrapper');
      var menu = this.menu.find('.popupmenu');
      this.menu.removeClass('is-open').attr('aria-hidden', 'true');

      if (this.menu[0]) {
        this.menu[0].style.height = '';
        this.menu[0].style.width = '';
      }

      if (wrapper[0]) {
        wrapper[0].style.left = '-999px';
        wrapper[0].style.height = '';
        wrapper[0].style.width = '';
      }

      this.menu.find('.submenu').off(['mouseenter.popupmenu', 'mouseleave.popupmenu'].join(' '));
      this.menu.find('.is-submenu-open').removeClass('is-submenu-open');

      if (this.submenuOpenTimeout) {
        clearTimeout(this.submenuOpenTimeout);
        delete this.submenuOpenTimeout;
      }

      if (menu[0]) {
        menu[0].style.left = '';
        menu[0].style.top = '';
        menu[0].style.height = '';
        menu[0].style.width = '';
      }

      this.menu.find('.is-focused').removeClass('is-focused'); // Close all events

      $(document).off(["keydown.popupmenu.".concat(this.id), "click.popupmenu.".concat(this.id), "mousemove.popupmenu.".concat(this.id), "touchend.popupmenu.".concat(self.id)].join(' '));
      this.menu.off(['click.popupmenu', 'touchend.popupmenu', 'touchcancel.popupmenu', 'mouseenter.popupmenu', 'mouseleave.popupmenu'].join(' ')); // Get rid of internal flags that check for how the menu was opened

      delete this.keydownThenClick;
      delete this.holdingDownClick; // If `this.element` comes as `ul` element

      if (this.element.is('ul.popupmenu')) {
        this.element.closest('.popupmenu-wrapper').prev('button').removeClass('is-open');
      }

      this.menu.find('.popupmenu.is-open').removeClass('is-open');
      /**
       * Fires when close.
       *
       * @event close
       * @memberof PopupMenu
       * @property {object} event - The jquery event object
       * @property {object} close by cancelled
       */

      this.element.removeClass('is-open').triggerHandler('close', [isCancelled]);
      this.detach();

      if (this.settings.trigger === 'immediate') {
        this.destroy();
      } // On text input targets, don't refocus the input if the opening event was called by a touch


      if (this.element[0].tagName === 'INPUT' && this.openedWithTouch) {
        this.element.removeClass('longpress-target');
        delete this.openedWithTouch;
        return;
      }

      delete this.openedWithTouch; // Editor colorpicker

      var cpEditorNotVisible = false;

      if (this.element.is('.colorpicker-editor-button')) {
        var toolbarItem = this.element.data('toolbaritem') || this.element.data('toolbarflexitem');
        var toolbarAPI = toolbarItem ? toolbarItem.toolbarAPI : null;

        if (toolbarAPI) {
          toolbarAPI.overflowedItems.forEach(function (thisItem) {
            if (thisItem.type === 'colorpicker') {
              cpEditorNotVisible = true;
            }
          });
        }
      }

      if (noFocus || !this.settings.returnFocus || Environment.features.touch || cpEditorNotVisible) {
        return;
      }

      if (typeof this.settings.returnFocus === 'function') {
        this.settings.returnFocus(this, {
          triggerElement: this.element[0],
          menuElement: this.menu[0]
        });
        return;
      }

      if (document.activeElement && document.activeElement.tagName === 'INPUT') {
        return;
      }

      if (this.element) {
        this.element.focus();
      }
    },

    /**
     * Removes bound events and generated markup from this component
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      var self = this;

      if (!this.menu || !this.menu.parent) {
        return this;
      }

      var wrapper = this.menu.parent('.popupmenu-wrapper');

      function unwrapPopup(menu) {
        var thisWrapper = menu.parent();

        if (thisWrapper.is('.popupmenu-wrapper, .wrapper')) {
          menu.unwrap();
        }
      }

      if (this.ajaxContent) {
        this.ajaxContent.off().remove();
      }

      this.predefinedItems = $();
      var parentNode = this.menu.parent();
      parentNode.find('.arrow').remove();
      parentNode.off('contextmenu.popupmenu');

      if (this.element.hasClass('btn-actions')) {
        parentNode.removeClass('bottom');
      }

      this.menu.off('dragstart.popupmenu'); // Remove the wrapper, if applicable

      if (!this.preExistingWrapper && this.menu.parent().is('.popupmenu-wrapper')) {
        this.menu.unwrap();
      } // Place the menu back where it came from while cleaning up.
      // Get an accurate target to place the menu back where it came from


      var searchfield = this.element.parent().children('.searchfield');

      if (searchfield.length) {
        this.menu.insertAfter(searchfield.first());
      } else if (this.menuOrgContainment) {
        this.insertAtContainment(this.menu);
      } else {
        this.menu.insertAfter(this.element);
      } // Cleanup menu items


      this.menu.find('.submenu').children('a').each(function (i, item) {
        var spantext = $(item).find('span').text();
        var text = spantext || $(item).text();
        $(item).find('span, svg').remove();
        $(item).text(text);
      });
      this.menu.find('.submenu').removeClass('submenu'); // Unwrap submenus, if applicable

      this.menu.find('.popupmenu').each(function () {
        unwrapPopup($(this));
      }); // Finish cleaning up after the wrapper

      if (self.wrapperPlace) {
        self.wrapperPlace.destroy();
        delete self.wrapperPlace;
      }

      wrapper.off().remove();

      if (this.menu && this.menu.length && this.menu.data('trigger')) {
        $.removeData(this.menu[0], 'trigger');
      }

      this.detach();
      this.element.removeAttr('aria-controls').removeAttr('aria-haspopup').off('touchend.popupmenu touchcancel.popupmenu click.popupmenu keydown.popupmenu keypress.popupmenu contextmenu.popupmenu updated.popupmenu');
      return this;
    },

    /**
     * Updates this Popupmenu instance with new settings
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      return this.teardown().init();
    },

    /**
     * Teardown markup and detach all events.
     * @returns {void}
     */
    destroy: function destroy() {
      var _this$menu;

      if (!this.menu) {
        return;
      }

      this.close();
      this.teardown(); // In some cases, the menu needs to be completely removed on `destroy`.

      (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu == null ? void 0 : _this$menu.triggerHandler('destroy');

      if (this.settings.removeOnDestroy && this.menu && this.menu.length) {
        this.menu.off().remove();
        delete this.menu;
      }

      $.removeData(this.element[0], COMPONENT_NAME$a);
    }
  };

  /**
   * jQuery Component Wrapper for Popupmenu
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.popupmenu = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$a);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$a, new PopupMenu(this, settings));
      }
    });
  };

  var COMPONENT_NAME$b = 'about';
  /**
   * The About Dialog Component is displays information regarding the application.
   * @class About
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.appName='Infor Application Name'] The Main Application Name to display in the header.
   * @param {string} [settings.content] Additional text content to display at the top.
   * @param {string} [settings.copyrightYear=new Date().getFullYear()] The year displayed in the copyright, defaults to current year.
   * @param {boolean} [settings.deviceSpecs=true] Determines whether or not to display device information.
   * This information includes Browser, Platform, Locale and if Cookies are Enabled.
   * @param {string} [settings.productName] Additional product name information to display.
   * @param {boolean} [settings.useDefaultCopyright=true] Add the Legal Approved Infor Copyright Text.
   * @param {string} [settings.version] Semantic Version Number for example (4.0.0).
   * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var ABOUT_DEFAULTS = {
    appName: 'Infor Application Name',
    content: undefined,
    copyrightYear: new Date().getFullYear(),
    deviceSpecs: true,
    productName: undefined,
    useDefaultCopyright: true,
    version: undefined
  };

  function About(element, settings) {
    this.settings = utils.mergeSettings(element, settings, ABOUT_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  About.prototype = {
    init: function init() {
      return this.setup().build().handleEvents();
    },
    setup: function setup() {
      var appName = this.element.attr('data-appname');
      this.isBody = $(this.element).is('body');
      this.settings.appName = appName !== undefined ? appName.toString() : this.settings.appName;
      var content = this.element.attr('data-about-content');
      this.settings.content = content !== undefined ? content.toString() : this.settings.content;
      var copyrightYear = this.element.attr('data-copyright-year');
      this.settings.copyrightYear = copyrightYear !== undefined ? copyrightYear.toString() : this.settings.copyrightYear;
      var deviceSpecs = this.element.attr('data-device-specs');

      if (deviceSpecs) {
        this.settings.deviceSpecs = deviceSpecs === 'true';
      }

      var productName = this.element.attr('data-product-name');
      this.settings.productName = productName !== undefined ? productName.toString() : this.settings.productName;
      var useDefaultCopyright = this.element.attr('data-use-default');

      if (useDefaultCopyright !== undefined) {
        this.settings.useDefaultCopyright = useDefaultCopyright === 'true';
      }

      var version = this.element.attr('data-version');
      this.settings.version = version !== undefined ? version.toString() : this.settings.version; // Get the default copyright text and cut in the current year

      this.defaultCopyright = "".concat(Locale.translate('AboutText'), " <a class=\"hyperlink\" href=\"http://www.infor.com\" target=\"_blank\">www.infor.com</a>.");
      this.defaultCopyright = this.defaultCopyright.replace('{0}', this.settings.copyrightYear);
      return this;
    },
    build: function build() {
      this.modal = $('<div class="modal about" id="about-modal"></div>');
      $('<div class="modal-content"></div>').appendTo(this.modal);
      var header = $('<div class="modal-header"></div>').appendTo(this.modal.find('.modal-content'));
      $('<div class="close-container"></div>').append($('<button name="close" type="button" class="btn-icon btn-close hide-focus"></button>').append($.createIconElement({
        icon: 'close',
        classes: 'icon-close'
      })).append("<span>".concat(Locale.translate('Close'), "'</span>"))).appendTo(header);
      $.createIconElement({
        icon: 'logo-trademark',
        classes: ['icon', 'about-logo']
      }).attr({
        viewBox: '0 0 44 44'
      }).appendTo(header);
      this.title = $('<h1 class="title"></h1>').text(this.settings.appName).appendTo(this.modal.find('.modal-header'));
      var body = $('<div class="modal-body"></div>').appendTo(this.modal.find('.modal-content'));

      if (this.settings.version || this.settings.productName) {
        var productAndVersion = this.settings.productName ? "".concat(this.settings.productName, " ").concat(this.settings.version) : "".concat(this.settings.version);
        $('<p></p>').text(productAndVersion).appendTo(body);
      }

      if (this.settings.content) {
        $('<div class="additional-content"></div>').html(this.settings.content).appendTo(body);
      }

      if (this.settings.useDefaultCopyright || !this.settings.content) {
        $('<p></p>').html(this.defaultCopyright).appendTo(body);
      }

      if (this.settings.deviceSpecs) {
        var specs = this.getDeviceSpecs();
        var text = "<span class=\"ds\">".concat(Locale.translate('OperatingSystem'), " : ").concat(Environment.devicespecs.os.replace(Environment.devicespecs.currentOSVersion, ''), " ").concat(Environment.devicespecs.currentOSVersion, "</span><br>\n        <span class=\"platform\">").concat(Locale.translate('Platform'), " : ").concat(specs.os, "</span><br>\n        <span class=\"ds\">").concat(Locale.translate('Mobile'), " : ").concat(Environment.devicespecs.isMobile, "</span><br>\n        <span class=\"locale\">").concat(Locale.translate('Locale'), " : ").concat(Locale.currentLocale.name, "</span><br>\n        <span class=\"locale\">").concat(Locale.translate('Language'), " : ").concat(Locale.currentLanguage.name, "</span><br>\n        <span class=\"browser\">").concat(Locale.translate('Browser'), " :", " ".concat(Environment.devicespecs.browserVersionName), " ").concat(Environment.devicespecs.currentBrowser, " (").concat(Environment.devicespecs.browserVersion, ")</span><br>\n        <span class=\"locale\">").concat(Locale.translate('BrowserLanguage'), " : ").concat(specs.locale, "</span><br>\n        <span class=\"cookiesEnabled\">").concat(Locale.translate('CookiesEnabled'), " : ").concat(specs.cookiesEnabled, "</span><br>\n        <span class=\"version\">").concat(Locale.translate('Version'), " : ").concat($('html').attr('data-sohoxi-version'), "</span><br>");
        $("<p".concat(Locale.isRTL() ? ' dir="rtl"' : '', "></p>")).html(text).appendTo(body);
      }

      this.buttons = this.modal.find('button');
      this.modal.find('.hide-focus').one('blur', function () {
        $(this).removeClass('hide-focus');
      });
      this.element.attr('data-modal', 'about-modal');
      $('.modal-body', this.modal)[0].tabIndex = 0;
      this.modal.appendTo('body');
      this.modal.modal({
        trigger: this.isBody ? 'immediate' : 'click',
        attributes: this.settings.attributes
      }); // Link the About API to the Modal API

      var modalAPI = this.modal.data('modal');
      modalAPI.aboutAPI = this;
      return this;
    },

    /**
     * Return the browser specs. Currently returns browse, os, cookiesEnabled and locale
     * @returns {string} The specs of the browser.
     */
    getDeviceSpecs: function getDeviceSpecs() {
      var locale = navigator.appName === 'Microsoft Internet Explorer' ? navigator.userLanguage : navigator.language;

      var browser = function () {
        var ua = navigator.userAgent;
        var result = [];
        var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

        if (/trident/i.test(M[1])) {
          result = /\brv[ :]+(\d+)/g.exec(ua) || [];
          return "IE '".concat(result[1]);
        }

        if (M[1] === 'Chrome') {
          result = ua.match(/\b(OPR|Edge)\/(\d+)/);

          if (result != null) {
            return result.slice(1).join(' ').replace('OPR', 'Opera');
          }
        }

        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
        result = ua.match(/version\/(\d+)/i);

        if (result !== null) {
          M.splice(1, 1, result[1]);
        }

        return M.join(' ');
      }();

      return {
        browser: browser,
        os: navigator.platform,
        cookiesEnabled: navigator.cookieEnabled,
        locale: locale
      };
    },

    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },

    /**
     * Progamatically close the About dialog.
     * @returns {void}
     */
    close: function close() {
      /**
       * Fires after the dialog is done closing and removed.
       * @event afterclose
       * @memberof About
       * @property {object} event - The jquery event object
       * @property {object} ui - The dialog object
       */
      if (this.isBody) {
        this.destroy();
        return;
      }
      /**
       * Fires when the dialog is closing.
       * @event close
       * @memberof About
       * @property {object} event - The jquery event object
       * @property {object} ui - The dialog object
       */


      var modalApi = this.modal.data('modal');

      if (modalApi) {
        modalApi.close();
      }
    },

    /**
     * Teardown and remove any added markup and events.
     * @param {boolean} [noModalDestroy=false] if true, skips the routine for destroying the modal (presumably because this is called from another method that destroys the modal manually)
     * @returns {void}
     */
    destroy: function destroy(noModalDestroy) {
      this.buttons.off();
      this.element.off('open.about');

      if (noModalDestroy !== true) {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.element.off('beforeopen.about');
          modalApi.aboutAPI = null;
          modalApi.destroy();
        }
      }

      if (this.element.length > 0) {
        $.removeData(this.element[0], COMPONENT_NAME$b);
      }
    },

    /**
     * Add component event handlers.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on('open.about', function (e) {
        e.stopPropagation();

        _this.element.trigger('click');
      });
      this.buttons.filter('[name="done"], [name="close"]').on('click.about', function () {
        _this.close();
      });
      /**
      * Fires when the about dialog is opening, allowing you to veto by returning false.
      *
      * @event beforeopen
      * @memberof About
      * @property {object} event The jquery event object.
      * @property {object} ui The dialog object
      */

      this.modal.data('modal').element.on('beforeopen.about', function () {
        _this.modal.find('.modal-body').scrollTop(0);
      });
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for About.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} Elements being acted on.
   */

  $.fn.about = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$b);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$b, new About(this, settings));
      }
    });
  };

  // Adapted from: http://n12v.com/css-transition-to-from-auto/
  // Contains a handful of animation helper methods that attempt
  // to DRY up CSS-powered sliding animations.

  /**
   * animateOpen default settings
   * @namespace
   * @property {string} direction horizontal or vertical
   * @property {string|number} distance in pixels that the animation covers. defaults to 'auto',
   *  or can pixel value size.
   * @property {number} timing delay in Miliseconds
   * @property {string} transition settings for the CSS Transition Timing Function
   */

  var ANIMATE_OPEN_DEFAULTS = {
    direction: 'vertical',
    distance: 'auto',
    timing: 300,
    transition: 'cubic-bezier(.17, .04, .03, .94)'
  }; // Use CSS Transitions to animate from "0" to "auto" widths

  $.fn.animateOpen = function (settings) {
    var eventName = $.fn.transitionEndName();
    settings = utils.mergeSettings(undefined, settings, ANIMATE_OPEN_DEFAULTS); // Initialize the plugin (Once)

    return this.each(function () {
      var self = this;
      var $self = $(this);
      var dim = settings.direction === 'horizontal' ? 'width' : 'height';
      var cDim = dim.charAt(0).toUpperCase() + dim.slice(1);
      var distance = !isNaN(settings.distance) ? "".concat(parseInt(settings.distance, 10), "px") : 'auto';
      var timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off("".concat(eventName, ".animateopen"));
        self.style.transition = '';
        self.style[dim] = distance;
        $self.trigger('animateopencomplete');
      } // Clear any previous attempt at this animation when the animation starts new


      $self.one('animateopenstart.animation', function (e) {
        e.stopPropagation();
        $self.off("".concat(eventName, ".animateopen"));
      });
      $self.trigger('animateopenstart'); // Trigger the callback either by Timeout or by TransitionEnd

      if (eventName) {
        $self.one("".concat(eventName, ".animateopen"), transitionEndCallback);
      } // Animate


      $self.data('is-animating', true);
      var prevVal = this.style[dim];
      this.style[dim] = distance;
      var endVal = getComputedStyle(this)[dim];
      this.style[dim] = prevVal; // next line forces a repaint

      this["offset".concat(cDim)]; // eslint-disable-line

      this.style.transition = "".concat(dim, " ").concat(settings.timing, "ms ").concat(settings.transition);
      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = endVal; // Trigger immediately if this element is invisible or has the 'no-transition' class

      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };
  /**
   * Animate closed defaults
   * @namespace
   * @property {string} direction horizontal or vertical
   * @property {number} timing delay in Miliseconds
   * @property {string} transition settings for the CSS Transition Timing Function
   */


  var ANIMATE_CLOSED_DEFAULTS = {
    direction: 'vertical',
    timing: 300,
    transition: 'cubic-bezier(.17, .04, .03, .94)'
  }; // Use CSS Transitions to animate from "auto" to "0" widths

  $.fn.animateClosed = function (settings) {
    var eventName = $.fn.transitionEndName();
    settings = utils.mergeSettings(undefined, settings, ANIMATE_CLOSED_DEFAULTS); // Initialize the plugin (Once)

    return this.each(function () {
      var self = this;
      var $self = $(this);
      var dim = settings.direction === 'horizontal' ? 'width' : 'height';
      var cDim = dim.charAt(0).toUpperCase() + dim.slice(1);
      var timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off("".concat(eventName, ".animatedclosed"));
        self.style.transition = '';
        self.style[dim] = '0px';
        $self.trigger('animateclosedcomplete');
      } // Clear any previous attempt at this animation when the animation starts new


      $self.one('animateclosedstart', function (e) {
        e.stopPropagation();
        $self.off("".concat(eventName, ".animatedclosed"));
      });
      $self.trigger('animateclosedstart'); // Trigger the callback either by Timeout or by TransitionEnd

      if (eventName) {
        $self.one("".concat(eventName, ".animatedclosed"), transitionEndCallback);
      } // Animate


      $self.data('is-animating', true);
      this.style[dim] = getComputedStyle(this)[dim]; // next line forces a repaint

      this["offset".concat(cDim)]; // eslint-disable-line

      this.style.transition = "".concat(dim, " ").concat(settings.timing, "ms ").concat(settings.transition);
      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = '0px'; // Trigger immediately if this element is invisible or has the 'no-transition' class

      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  }; // Chainable jQuery plugin that checks if an element is in the process of animating


  $.fn.isAnimating = function () {
    return this.each(function () {
      return $(this).data('is-animating') === true;
    });
  };

  var COMPONENT_NAME$c = 'accordion'; // Expander Button Display Modes
  // In some cases, expander buttons can be all "plus-minus" icons, or all "chevron" icons.
  // "Classic" is the original mode, with Chevrons at the top level, and Plus-minus style on all subheaders.
  // "Plus-minus" mode is the replacement setting for the deprecated setting `displayChevron`

  var expanderDisplayModes = ['classic', 'plus-minus', 'chevron'];
  /**
   * The Accordion is a grouped set of collapsible panels used to navigate sections of
   * related content. Each panel consists of two levels: the top level identifies the
   * category or section header, and the second level provides the associated options.
   *
   * @class Accordion
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.allowOnePane=true] If set to true, allows only one pane of the Accordion to be open at a
   * time. If an Accordion pane is open, and that pane contains sub-headers only one of the pane's sub-headers can be open at a time. (default true)
   * @param {boolean} [settings.displayChevron=true] (deprecated in v4.23.0) Displays a "Chevron" icon that sits off to the right-most
   * side of a top-level accordion header. Used in place of an Expander (+/-) if enabled.  Use `settings.expanderDisplay` instead.
   * @param {boolean} [settings.enableTooltips=true] If false, does not run logic to apply tooltips to elements with truncated text.
   * @param {string} [settings.expanderDisplay='classic'] Changes the iconography used in accordion header expander buttons. By default, top level expanders will be chevrons, and sub-header expanders will be "plus-minus" style.  This setting can also be "plus-minus" or "chevron" to force the same icons throughout the accordion.
   * @param {string} [settings.rerouteOnLinkClick=true]  Can be set to false if routing is externally handled
   * @param {boolean} [settings.source=null]  A callback function that when implemented provided a call back for "ajax loading" of tab contents on open.
   */

  var ACCORDION_DEFAULTS = {
    allowOnePane: true,
    expanderDisplay: expanderDisplayModes[0],
    enableTooltips: true,
    rerouteOnLinkClick: true,
    source: null
  }; // Handles the conversion of deprecated settings to current settings

  function handleDeprecatedSettings(settings) {
    if (settings.displayChevron !== undefined) {
      warnAboutDeprecation('expanderDisplay setting', 'displayChevron setting');

      if (settings.displayChevron === false) {
        settings.expanderDisplay = expanderDisplayModes[1]; // plus-minus
      } else {
        settings.expanderDisplay = expanderDisplayModes[0]; // classic
      }

      delete settings.displayChevron;
    }

    return settings;
  }

  function Accordion(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, ACCORDION_DEFAULTS);
    this.settings = handleDeprecatedSettings(this.settings);
    this.init();
  } // Plugin Methods


  Accordion.prototype = {
    /**
    * Initialization kickoff point
    * @private
    * @param {jQuery[]} [headers] - if provided, only attempts to build the specified headers and
    * their related anchors/panes
    */
    init: function init(headers) {
      this.build(headers).handleEvents(headers).setupTooltips();
    },

    /**
     * Takes a barebones Accordion markup definition and fleshes out any missing parts,
     * as well as storing references to headers, anchors, and panes.
     * @private
     * @param {jQuery[]} [headers] if provided, only attempts to build the specified headers and
     *  their related anchors/panes
     * @param {boolean} [noFilterReset] if provided, will not reset the contents of the
     * `currentlyFiltered` property.
     * @returns {object} The component api for chaining.
     */
    build: function build(headers, noFilterReset) {
      var _this = this;

      var anchors;
      var panes;
      var contentAreas;
      var self = this;
      var isGlobalBuild = true;

      if (!headers || !(headers instanceof jQuery)) {
        this.headers = this.element.find('.accordion-header');
        headers = this.element.find('.accordion-header');
        this.anchors = headers.children('a');
        anchors = this.anchors;
        this.panes = headers.next('.accordion-pane');
        panes = this.panes;
        this.contentAreas = panes.children('.accordion-content');
        contentAreas = this.contentAreas;
      } else {
        anchors = headers.children('a');
        panes = headers.next('.accordion-pane');
        contentAreas = panes.children('.accordion-content');
        isGlobalBuild = false; // update internal refs

        this.headers = this.headers.add(headers);
        this.anchors = this.anchors.add(anchors);
        this.panes = this.panes.add(panes);
        this.contentAreas = this.contentAreas.add(contentAreas);
      }

      var headersHaveIcons = false; // Accordion Headers that have an expandable pane need to have an
      // expando-button added inside of them

      headers.each(function addExpander() {
        var header = $(this);
        var hasIcons = false;
        var containerPane = header.parent();
        var isTopLevel = containerPane.is('.accordion');

        function checkIfIcons() {
          if (isTopLevel) {
            return;
          }

          if (!hasIcons) {
            header.addClass('no-icon');
            return;
          }

          containerPane.addClass('has-icons');
        }

        header.hideFocus(); // For backwards compatibility:  If an icon is found inside an anchor, bring it up to the
        // level of the header.

        header.children('a').find('svg').detach().insertBefore(header.children('a'));
        var outerIcon = header.children('.icon, svg');
        outerIcon.addClass('icon').attr({
          role: 'presentation',
          'aria-hidden': 'true',
          focusable: 'false'
        });

        if (isTopLevel && outerIcon.length) {
          headersHaveIcons = true;
        }

        if (header.is('.list-item') || !isTopLevel && header.find('button').length || !isTopLevel && header.find('svg').length) {
          hasIcons = true;
        } // Enable/Disable


        if (header.hasClass('is-disabled')) {
          header.children('a, button').attr('tabindex', '-1');
        } // Don't continue if there's no pane


        if (!header.next('.accordion-pane').length) {
          checkIfIcons();
          return;
        }

        hasIcons = true;
        var expander = header.children('.btn');

        if (!expander.length) {
          expander = $('<button class="btn" type="button"></button>');
          var method = 'insertBefore';

          if (self.settings.expanderDisplay !== 'plus-minus' && isTopLevel) {
            header.addClass('has-chevron');
            method = 'insertAfter';
          }

          expander[method](header.children('a'));
          header.data('addedExpander', expander);
        } // Hide Focus functionality


        expander.hideFocus(); // If Chevrons are turned off and an icon is present, it becomes the expander

        if (outerIcon.length && self.settings.expanderDisplay === 'plus-minus') {
          outerIcon.appendTo(expander);
        }

        var expanderIcon = expander.children('.icon, .svg, .plus-minus');

        if (!expanderIcon.length) {
          if (self.settings.expanderDisplay === 'classic' && isTopLevel || self.settings.expanderDisplay === 'chevron') {
            expanderIcon = $.createIconElement({
              icon: 'caret-down',
              classes: ['chevron']
            });
          } else {
            var isActive = self.isExpanded(header) ? ' active' : '';
            expanderIcon = $("<span class=\"icon plus-minus".concat(isActive, "\" aria-hidden=\"true\" role=\"presentation\"></span>"));
          }

          expanderIcon.appendTo(expander);
        }

        var expanderIconOpts = {
          role: 'presentation',
          'aria-hidden': 'true'
        };

        if (!expanderIcon.is('span')) {
          expanderIconOpts.focusable = 'false';
        }

        expanderIcon.attr(expanderIconOpts); // Move around the Expander depending on whether or not it's a chevron
        // ONLY do this if the chevron is top-level.

        if (expanderIcon.is('.chevron') && isTopLevel) {
          header.addClass('has-chevron');
          expander.insertAfter(header.children('a'));
        } else {
          header.removeClass('has-chevron');
          expander.insertBefore(header.children('a'));
        } // Double check to see if we have left-aligned expanders or icons present,
        // so we can add classes that do alignment


        if (self.settings.expanderDisplay === 'plus-minus' && isTopLevel) {
          headersHaveIcons = true;
        }

        checkIfIcons();
      });

      if (headersHaveIcons) {
        this.element.addClass('has-icons');
      } // Expand to the current accordion header if we find one that's selected


      if (isGlobalBuild && !this.element.data('updating')) {
        var targetsToExpand = headers.filter('.is-selected, .is-expanded');
        targetsToExpand.next('.accordion-pane').addClass('no-transition');

        if (this.settings.allowOnePane) {
          targetsToExpand = targetsToExpand.first();
          this.expand(targetsToExpand);
        } else {
          targetsToExpand.each(function (idx) {
            _this.expand($(targetsToExpand[idx]));
          });
        }

        this.select(targetsToExpand.last());
        targetsToExpand.next('.accordion-pane').removeClass('no-transition');
      }

      panes.each(function addPaneARIA() {
        var pane = $(this);
        var header = pane.prev('.accordion-header'); // Setup correct ARIA for accordion panes

        header.children('a').attr({
          'aria-haspopup': 'true',
          role: 'button'
        }); // double-check the contents of the pane. If all children are filtered out,
        // label this at the top level

        var children = pane.children();
        var allChildrenFiltered = true;
        children.each(function (i, child) {
          if ($(child).is('.accordion-header, .accordion-content') && !$(child).hasClass('filtered')) {
            allChildrenFiltered = false;
          }
        });
        pane[allChildrenFiltered ? 'addClass' : 'removeClass']('all-children-filtered');

        if (allChildrenFiltered) {
          pane.data('ignore-animation-once', true);
          self.collapse(header, false);
        } // Preset the "expand/collase" on initial render, if applicable


        if (!noFilterReset) {
          var heightAttr = '0px';

          if (self.isExpanded(header)) {
            heightAttr = 'auto';
          }

          pane.attr('style', "height: ".concat(heightAttr));
        }
      }); // Retain an internal storage of available filtered accordion headers.

      if (!noFilterReset) {
        this.currentlyFiltered = $();
      }

      return this;
    },

    /**
     * Header Click Handler
     * @private
     * @param {jQuery.Event} e The click event object
     * @param {jQuery[]} header The header query object
     * @returns {boolean} Returns false is the event should be ignored.
     */
    handleHeaderClick: function handleHeaderClick(e, header) {
      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        e.preventDefault();
        return;
      } // Check that we aren't clicking the expando button.  If we click that, this listener dies


      if ($(e.target).is('[class^="btn"]')) {
        e.preventDefault();
        return;
      }

      var anchor = header.children('a');
      return this.handleAnchorClick(e, anchor);
    },

    /**
     * Anchor Click Handler
     * @private
     * @param {object} e The click event object.
     * @param {object} anchor The anchor jQuery object.
     * @returns {boolean} Returns false is the event should be ignored.
     */
    handleAnchorClick: function handleAnchorClick(e, anchor) {
      var self = this;
      var header = anchor.parent('.accordion-header');
      var pane = header.next('.accordion-pane');
      var ngLink = anchor.attr('ng-reflect-href');

      if (e && !ngLink) {
        e.preventDefault();
      }

      if (!header.length || this.isDisabled(header) || this.isFiltered(header)) {
        return false;
      }

      var canSelect = this.element.triggerHandler('beforeselect', [anchor]);

      if (canSelect === false) {
        return;
      } // Set the original element for DOM traversal by keyboard


      this.originalSelection = anchor;
      this.select(anchor);

      function followLink() {
        var href = anchor.attr('href');

        if (href && href !== '' && href !== '#') {
          if (!self.settings.rerouteOnLinkClick) {
            return true;
          }

          window.location.href = href;
          return true;
        }

        return false;
      }

      this.closePopups(e);
      /**
       * If the anchor is a real link, follow the link and die here.
       * This indicates the link has been followed.
       *
       * @event followlink
       * @memberof Accordion
       * @param {array} anchor - The anchor in an array
       */

      if (followLink()) {
        this.element.trigger('followlink', [anchor]);
        return true;
      } // If it's not a real link, try and toggle an expansion pane.


      if (pane.length) {
        self.toggle(header);
        self.focusOriginalType(header);
        return true;
      } // This flag is set by the List/Detail Pattern Wrapper.
      // If this component is controlling a detail area, the anchor shouldn't focus,
      // and it should trigger an event that will bubble to the pattern to give
      // context to the detail area.


      if (this.isControllingDetails) {
        if (!pane.length) {
          self.element.trigger('drilldown', [header[0]]);
        }
      } else {
        self.orignalSelection = anchor;
        self.focusOriginalType(header);
      }
      /**
      * Fires when an accordion header is truly selected.
      *
      * @event selected
      * @memberof Accordion
      * @param {object} event - The jquery event object
      * @param {object} header - The header object
      */


      this.element.trigger('selected', header);
      return true;
    },

    /**
    * Close any open popup menus.
    * @private
    * @param {object} e The click event object.
    */
    closePopups: function closePopups(e) {
      var openPopup = $('.popupmenu.is-open');

      if (openPopup.length) {
        var headers = this.element.find('.accordion-header[aria-haspopup="true"]');
        headers.each(function () {
          var api = $(this).data('popupmenu');
          api.close();

          if (e !== undefined) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }

          return false;
        });
      }
    },

    /**
    * Expander-Button Click Handler
    * @private
    * @param {object} e The click event object.
    * @param {object} expander The jquery expander DOM element.
    * @returns {boolean} Returns false in some cases if the event should stop propagating.
    */
    handleExpanderClick: function handleExpanderClick(e, expander) {
      var header = expander.parent('.accordion-header');

      if (!header.length || this.isDisabled(header) || this.isFiltered(header) || header.data('is-animating')) {
        return;
      } // Set the original element for DOM traversal by keyboard


      this.originalSelection = expander; // Don't propagate when clicking the expander.  Propagating can cause the link to be clicked in
      // cases where it shouldn't be clicked.

      if (e) {
        e.stopPropagation();
      }

      this.closePopups();
      var pane = header.next('.accordion-pane');

      if (pane.length) {
        this.toggle(header);
        this.select(header);
        this.focusOriginalType(header);
        return;
      } // If there's no accordion pane, attempt to simply follow the link.


      return this.handleAnchorClick(e, header.children('a'));
    },

    /**
    * Keypress Event Handler for expanders and anchors
    * @private
    * @param {jQuery.Event} e The click event object.
    * @returns {boolean} Returns false in some cases if the event should stop propagating.
    */
    handleKeys: function handleKeys(e) {
      var self = this;
      var key = e.which; // will be either an anchor or expando button.  Should NEVER be the header itself.

      var target = $(e.target);
      var header = target.parent();
      var expander = header.children('[class^="btn"]').first();
      var anchor = header.children('a');
      var headerPanes = document.querySelectorAll('.accordion-pane');

      function setInitialOriginalSelection(selection) {
        if (!selection) {
          selection = target;
        }

        if (!self.originalSelection) {
          self.originalSelection = selection;
        }
      }

      if (key === 9) {
        // Tab (also triggered by Shift + Tab)
        this.headers.removeClass('is-selected');

        var collapsedPanes = _toConsumableArray(headerPanes).filter(function (pane) {
          return !pane.classList.contains('is-expanded');
        });

        var expandedPanes = _toConsumableArray(headerPanes).filter(function (pane) {
          return pane.classList.contains('is-expanded');
        }); // If accordion pane is expanded enable normal tabbing behavior.


        expandedPanes.forEach(function (pane) {
          _toConsumableArray(pane.children).forEach(function (el) {
            if (!$(el).hasClass('is-disabled')) {
              $(el).find('a').removeAttr('tabindex');
              $(el).find('button').removeAttr('tabindex');
            }
          });
        }); // If accordion pane is collapsed skip over the child elements.

        collapsedPanes.forEach(function (pane) {
          _toConsumableArray(pane.children).forEach(function (el) {
            $(el).find('a').attr('tabindex', '-1');
            $(el).find('button').attr('tabindex', '-1');
          });
        });

        if (target.is('a') && expander.length) {
          setInitialOriginalSelection(expander);
        } else {
          setInitialOriginalSelection(anchor);
        }
      }

      if (key === 32) {
        // Spacebar
        e.preventDefault(); // Don't let this propagate and run against the header element, if it's a button

        if (target.is('[class^="btn"]')) {
          e.stopPropagation();
          e.stopImmediatePropagation(); // Firefox will attempt to run this twice, despite the fact that we're stopping propagation.
          // Just cancel the whole thing if Firefox is running this method.

          if ($('html').hasClass('is-firefox')) {
            return;
          }
        }

        if (expander.length) {
          setInitialOriginalSelection(expander);
          return this.handleExpanderClick(null, target);
        }

        setInitialOriginalSelection(anchor);
        return this.handleAnchorClick(null, target);
      }

      if (key === 37 || key === 38) {
        // Left Arrow/Up Arrow
        e.preventDefault();
        setInitialOriginalSelection();

        if (e.shiftKey) {
          return this.ascend(header);
        }

        return this.prevHeader(header);
      }

      if (key === 39 || key === 40) {
        // Right Arrow/Down Arrow
        e.preventDefault();
        setInitialOriginalSelection();

        if (e.shiftKey) {
          return this.descend(header);
        }

        return this.nextHeader(header);
      }
    },

    /**
     * Translates all existing markup inside the accordion to a JSON-compatible object structure.
     * @param {boolean} flatten If true, places all accordion headers in the root array.
     * @param {boolean} addElementReference - if true, includes a reference to the original
     * header element inside the structure (NOT valid JSON).
     * @returns {object} The data the represents the accodion structure
     */
    toData: function toData(flatten, addElementReference) {
      var data = [];
      var topHeaders = this.element.children('.accordion-header');

      function buildElementJSON(el, index, parentNesting, parentArr) {
        var $el = $(el);
        var pane = $(el).next('.accordion-pane');
        var isContentArea = el.classList.contains('accordion-content');
        var elemData = {
          index: "".concat(parentNesting !== undefined ? "".concat(parentNesting, ".") : '').concat(index),
          type: isContentArea ? 'content' : 'header'
        };

        if (addElementReference) {
          elemData.element = el;
        }

        if (el.getAttribute('id')) {
          elemData.id = el.getAttribute('id');
        }

        if (isContentArea) {
          elemData.content = "".concat($el.html());
          elemData.contentText = "".concat($el.text().trim().replace(/\n|\s{2,}/g, ' '));
        } else {
          elemData.text = $el.children('a, span').text().trim();
        }

        var icon = $el.children('.icon');

        if (icon.length) {
          elemData.icon = icon[0].tagName.toLowerCase() === 'svg' ? icon[0].getElementsByTagName('use')[0].getAttribute('href') : '';
        }

        if ($el.hasClass('is-disabled')) {
          elemData.disabled = true;
        }

        if (pane.length) {
          var subElems = pane.children('.accordion-header, .accordion-content');
          var subElementData = [];

          if (subElems.length) {
            // Normally this will nest.
            // If "flatten" is true, don't nest and add straight to the parent array.
            var targetArray = subElementData;

            if (flatten) {
              targetArray = parentArr;
            }

            subElems.each(function (j, subitem) {
              buildElementJSON(subitem, j, elemData.index, targetArray);
            });
            elemData.children = subElementData;
          }
        }

        parentArr.push(elemData);
      } // Start traversing the accordion


      topHeaders.each(function (i, item) {
        buildElementJSON(item, i, undefined, data);
      });
      return data;
    },

    /**
    * Makes a header "selected" if its expander button or anchor tag is focused.
    * @param {object} element - a jQuery object containing either an expander button or an anchor tag.
    * @returns {void}
    */
    select: function select(element) {
      if (!element || !element.length) {
        return;
      } // Make sure we select the anchor


      var anchor = element;
      var header = anchor.parent();

      if (element.is('.accordion-header')) {
        header = element;
        anchor = header.children('a');
      }

      if (anchor.is('[class^="btn"]')) {
        anchor = element.next('a');
      }

      if (this.isDisabled(header) || this.isFiltered(header)) {
        return;
      }

      this.headers.removeClass('child-selected').removeClass('is-selected');
      header.addClass('is-selected');
      var items = header.parentsUntil(this.element, '.accordion-pane').prev('.accordion-header');
      items.addClass('child-selected');
    },

    /**
     * Gets the currently-selected Accordion Header, if applicable.
     * @returns {jQuery[]} the currently selected Accordion Header, or an empty jQuery selector
     *  if there are currently no headers selected.
     */
    getSelected: function getSelected() {
      return this.element.find('.is-selected');
    },

    /**
    * Checks if a particular header is disabled, or if the entire accordion is disabled..
    * @param {object} header The jquery header element
    * @returns {boolean} Whether or not the element is enabled.
    */
    isDisabled: function isDisabled(header) {
      if (this.element.hasClass('is-disabled')) {
        return true;
      }

      if (!header) {
        return false;
      }

      return header.hasClass('is-disabled');
    },

    /**
     * Checks if the header is filtered out or not
     * @param {object} header  The jquery header element
     * @returns {boolean} Whether or not the element is filtered.
     */
    isFiltered: function isFiltered(header) {
      if (!header || !header.length) {
        return false;
      }

      var cl = header[0].classList;
      return cl.contains('filtered') && !cl.contains('has-filtered-children');
    },

    /**
    * Checks if an Accordion Section is currently expanded.
    * @param {object} header The jquery header element
    * @returns {boolean} Whether or not the element is expanded.
    */
    isExpanded: function isExpanded(header) {
      if (header && header instanceof Element) {
        header = $(header);
      }

      if (!header || !header.length) {
        return;
      }

      return header.children('a').attr('aria-expanded') === 'true' || header.hasClass('is-expanded');
    },

    /**
    * Toggle the given Panel on the Accordion between expanded and collapsed.
    * @param {object} header The jquery header element.
    * @returns {void}
    */
    toggle: function toggle(header) {
      var _this2 = this;

      if (!header || !header.length || this.isDisabled(header) || this.isFiltered(header) || this.isAnimating) {
        return;
      }

      this.isAnimating = true;
      setTimeout(function () {
        _this2.isAnimating = false;
      }, 500);

      if (this.isExpanded(header)) {
        this.collapse(header);
        return;
      }

      this.expand(header);
    },

    /**
    * Expand the given Panel on the Accordion.
    * @param {object|string} header The jquery header element or the id of a header DOM element
    * @param {boolean} dontCollapseHeaders if defined, will not collapse any open accordion headers
    *  (generally used while filtering)
    * @returns {$.Deferred} resolved on the completion of an Accordion pane's
    *  collapse animation (or immediately, if animation is disabled).
    */
    expand: function expand(header, dontCollapseHeaders) {
      if (typeof header === 'string') {
        header = this.element.find("#".concat(header)).first();
      }

      if (!header || !header.length) {
        return;
      }

      var self = this;
      var pane = header.next('.accordion-pane');
      var a = header.children('a');
      var dfd = $.Deferred();
      var canExpand = this.element.triggerHandler('beforeexpand', [a]);

      if (canExpand === false) {
        return dfd.reject();
      }

      function continueExpand() {
        // Don't try to expand any further if this header has no associated accordion pane.
        // NOTE: We re-check for the pane's existence here because it may have been loaded via AJAX.
        pane = header.next('.accordion-pane');

        if (!pane || !pane.length) {
          return dfd.reject();
        } // Change the expander button into "collapse" mode


        var expander = header.children('.btn');

        if (expander.length) {
          expander.children('.plus-minus, .chevron').addClass('active');
          expander.children('.audible').text(Locale.translate('Collapse'));
        }

        var headerParents = header.parentsUntil(self.element).filter('.accordion-pane').prev('.accordion-header').add(header); // If we have the correct settings defined, close other accordion
        // headers that are not parents of this one.

        var collapseDfds = [];

        if (self.settings.allowOnePane && !dontCollapseHeaders && self.headers) {
          self.headers.not(headerParents).each(function () {
            var h = $(this);

            if (self.isExpanded(h)) {
              collapseDfds.push(self.collapse(h));
            }
          });
        } // Expand all headers that are parents of this one, if applicable


        var expandDfds = [];

        if (headerParents) {
          headerParents.not(header).each(function () {
            var h = $(this);

            if (!self.isExpanded(h)) {
              expandDfds.push(self.expand(h));
            }
          });
        }

        header.add(pane).addClass('is-expanded');
        header.children('a').attr('aria-expanded', 'true');
        /**
        * Fires when expanding a pane is initiated.
        *
        * @event expand
        * @memberof Accordion
        * @param {object} event - The jquery event object
        * @param {array} anchor - The anchor tag in an array.
        */

        self.element.trigger('expand', [a]);
        /**
         * Fires after a pane is expanded.
         *
         * @event afterexpand
         * @memberof Accordion
         * @param {jQuery.Event} [e] - The jquery event object
         * @param {array} anchor - The anchor tag in an array.
         */

        function handleAfterExpand(e) {
          var _$;

          if (e) {
            e.stopPropagation();
          }

          pane.triggerHandler('afterexpand', [a]);
          self.element.trigger('afterexpand', [a]);

          (_$ = $).when.apply(_$, expandDfds.concat(collapseDfds)).done(function () {
            dfd.resolve();
          });
        }

        if (pane.hasClass('no-transition')) {
          handleAfterExpand();
        } else {
          pane.one('animateopencomplete', handleAfterExpand).animateOpen();
        }
      } // Load from an external source, if applicable


      if (!this.callSource(a, continueExpand)) {
        continueExpand.apply(this);
      }

      return dfd;
    },

    /**
     * Expands all accordion headers, if possible.
     * @returns {$.Deferred} resolved when all the accordion panes being expanded
     *  complete their animations.
     */
    expandAll: function expandAll() {
      var _$2;

      if (this.settings.allowOnePane === true) {
        return;
      }

      var self = this;
      var dfd = $.Deferred();
      var dfds = [];
      this.headers.each(function () {
        var h = $(this);

        if (!self.isExpanded(h)) {
          dfds.push(self.expand(h));
        }
      });

      (_$2 = $).when.apply(_$2, dfds).always(function () {
        dfd.resolve();
      });

      return dfd;
    },

    /**
    * Collapse the given Panel on the Accordion.
    * @param {object|string} header The jquery header element or the id of a header DOM element
    * @param {boolean} closeChildren If true closeChildren elements that may be on the page. Skip for performance.
    * @returns {$.Deferred} resolved on the completion of an Accordion pane's
    *  collapse animation (or immediately, if animation is disabled).
    */
    collapse: function collapse(header) {
      var closeChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (typeof header === 'string') {
        header = this.element.find("#".concat(header)).first();
      }

      if (!header || !header.length) {
        return;
      }

      var self = this;
      var pane = header.next('.accordion-pane');
      var a = header.children('a');
      var dfd = $.Deferred();
      var canExpand = this.element.triggerHandler('beforecollapse', [a]);

      if (canExpand === false) {
        return dfd.reject();
      } // Change the expander button into "expand" mode


      var expander = header.children('.btn');

      if (expander.length) {
        expander.children('.plus-minus, .chevron').removeClass('active');
        expander.children('.audible').text(Locale.translate('Expand'));
      }

      if (closeChildren) {
        pane.closeChildren();
      }
      /**
      *  Fires when collapsed a pane is initiated.
      *
      * @event collapse
      * @memberof Accordion
      * @param {jQuery.Event} event - The jquery event object
      * @param {array} anchor - The anchor tag in an array.
      */


      self.element.trigger('collapse', [a]);
      /**
       * Fires after a pane is collapsed.
       *
       * @event aftercollapse
       * @memberof Accordion
       * @param {jQuery.Event} [e] - The jquery event object
       */

      function handleAfterCollapse(e) {
        if (e) {
          e.stopPropagation();
        }

        pane.triggerHandler('aftercollapse', [a]);
        self.element.trigger('aftercollapse', [a]);
        header.add(pane).removeClass('is-expanded');
        a.attr('aria-expanded', 'false');
        dfd.resolve();
      }

      if (pane.hasClass('no-transition')) {
        handleAfterCollapse();
      } else {
        pane.one('animateclosedcomplete', handleAfterCollapse).animateClosed();
      }

      return dfd;
    },

    /**
    * Collapses all accordion headers.
    * @returns {void}
    * @returns {$.Deferred} resolved when all the accordion panes being collapsed
    *  complete their animations.
    */
    collapseAll: function collapseAll() {
      var _$3;

      var self = this;
      var dfd = $.Deferred();
      var dfds = [];
      this.headers.each(function () {
        var h = $(this);

        if (self.isExpanded(h)) {
          dfds.push(self.collapse(h));
        }
      });

      (_$3 = $).when.apply(_$3, dfds).always(function () {
        dfd.resolve();
      });

      return dfd;
    },

    /**
     * Uses a function (this.settings.source()) to call out to an external API to fill the
     * inside of an accordion pane.
     * @param {jQuery[]} anchor The anchor element
     * @param {Function} animationCallback The call back function
     * @returns {Function} The call back function
     */
    callSource: function callSource(anchor, animationCallback) {
      if (!this.settings.source || typeof this.settings.source !== 'function') {
        return false;
      }

      var self = this;
      var header = anchor.parent();
      var pane = header.next('.accordion-pane');
      var ui = {
        anchor: anchor,
        header: header,
        pane: pane
      };

      function response(skipUpdated, headers) {
        if (skipUpdated !== true) {
          self.updated(headers);
        }

        setTimeout(function () {
          animationCallback.apply(self);
        }, 1);
      } // Trigger the external method and wait for a response.


      return this.settings.source(ui, response);
    },

    /**
    * Prepares a handful of references for dealing with a specific accordion header
    * @param {object} eventTarget The event we are working with.
    * @returns {object} An object with the accordion dom elements in it.
    */
    getElements: function getElements(eventTarget) {
      var target = $(eventTarget);
      var header;
      var anchor;
      var expander;
      var pane = null;

      if (target.is('.accordion-header')) {
        header = target;
        expander = target.children('[class^="btn"]');
        anchor = target.children('a');
      }

      if (target.is('.btn')) {
        expander = target;
        header = expander.parent();
        anchor = header.children('a');
      }

      if (target.is('a')) {
        anchor = target;
        header = anchor.parent();
        expander = header.children('.btn');
      }

      pane = header.next('.accordion-pane');
      return {
        header: header,
        expander: expander,
        anchor: anchor,
        pane: pane
      };
    },

    /**
    * Selects an adjacent Accordion Header that sits directly before the currently selected
    * Accordion Header.
    * @param {object} element - a jQuery object containing either an expander button or an anchor tag.
    * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent
    * against descending.
    * @returns {void}
    */
    prevHeader: function prevHeader(element, noDescend) {
      var elem = this.getElements(element);
      var adjacentHeaders = elem.header.parent().children();
      var currentIndex = adjacentHeaders.index(elem.header);
      var target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) - 1));

      if (!adjacentHeaders.length || currentIndex === 0) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header);
        }

        target = adjacentHeaders.last();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':first-child')) {
          return this.ascend(elem.header);
        }

        target = target.prev();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');

        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');

          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader, -1);
          }
        }

        target = prevHeader; // if no target's available here, we've hit the end and need to wrap around

        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header);
          }

          target = adjacentHeaders.last();

          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.prev();
          }
        }
      }

      this.focusOriginalType(target);
    },

    /**
    * Selects an adjacent Accordion Header that sits directly after the currently selected
    * Accordion Header.
    * @param {jQuery[]} element - a jQuery object containing either an expander button
    * or an anchor tag.
    * @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion,
    * prevent against descending.
    * @returns {void}
    */
    nextHeader: function nextHeader(element, noDescend) {
      var elem = this.getElements(element);
      var adjacentHeaders = elem.header.parent().children();
      var currentIndex = adjacentHeaders.index(elem.header);
      var target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) + 1));

      if (!adjacentHeaders.length || currentIndex === adjacentHeaders.length - 1) {
        if (elem.header.parent('.accordion-pane').length) {
          return this.ascend(elem.header, -1);
        }

        target = adjacentHeaders.first();
      }

      while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
        if (target.is(':only-child') || target.is(':last-child')) {
          return this.ascend(elem.header);
        }

        target = target.next();
      }

      if (target.is('.accordion-pane')) {
        var prevHeader = target.prev('.accordion-header');

        if (this.isExpanded(prevHeader)) {
          var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');

          if (descendantChildren.length && !noDescend) {
            return this.descend(prevHeader);
          }
        }

        target = $(adjacentHeaders.get(xssUtils.ensureAlphaNumeric(currentIndex) + 2)); // if no target's available here, we've hit the end and need to wrap around

        if (!target.length) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header, -1);
          }

          target = adjacentHeaders.first();

          while (target.is('.accordion-content') || this.isDisabled(target) || this.isFiltered(target)) {
            target = target.next();
          }
        }
      }

      this.focusOriginalType(target);
    },

    /**
    * Selects the first Accordion Header in the parent container of the current Accordion Pane.
    * If we're at the top level, jump out of the accordion to the last focusable element.
    * @param {object} header A jQuery object containing an Accordion header.
    * @param {number} direction If -1, sets the position to be at the end of this set of
    * headers instead of at the beginning.
    * @returns {void}
    */
    ascend: function ascend(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.parent('.accordion-pane');
      var target = pane.prev();

      if (direction === -1) {
        target = pane.next('.accordion-header');

        if (!target.length) {
          if (pane.parent('.accordion').length) {
            return this.nextHeader(pane.prev().children('a'), true);
          }

          return this.ascend(pane.prev(), -1);
        }
      }

      this.focusOriginalType(target);
    },

    /**
    * Selects the first Accordion Header in the child container of the current Accordion Header.
    * @param {jQuery[]} header - a jQuery object containing an Accordion header.
    * @param {integer} direction - if -1, sets the position to be at the end of this set of
    * headers instead of at the beginning.
    * @returns {void}
    */
    descend: function descend(header, direction) {
      if (!direction) {
        direction = 0;
      }

      var pane = header.next('.accordion-pane');
      var target = pane.children('.accordion-header').first();

      if (direction === -1) {
        target = pane.children('.accordion-header').last();
      } // No headers may be present.  In which case, it may be necessary to simply focus
      // the header for the current pane.


      if (!target.length) {
        return this.focusOriginalType(header);
      }

      if (this.isExpanded(target)) {
        return this.descend(target, -1);
      }

      this.focusOriginalType(target);
    },

    /**
    * Focuses an accordion header by either its anchor, or its optional expander button.
    * Governed by the property "this.originalSelection".
    * @param {object} header - a jQuery object containing an Accordion header.
    * @returns {void}
    */
    focusOriginalType: function focusOriginalType(header) {
      var btns = header.children('[class*="btn"]');
      this.headers.not(header).removeClass('is-focused');

      if (this.originalSelection.is('[class*="btn"]') && btns.length) {
        btns.first()[0].focus();
      } else {
        header.children('a')[0].focus();
        header.addClass('is-focused').removeClass('hide-focus');
      }
    },

    /**
     * @param {jQuery[]} targets element references representing accordion headers.
     */
    filter: function filter(targets) {
      var _this3 = this;

      if (!targets) {
        return;
      }

      var self = this; // Reset all the things

      this.headers.removeClass('filtered has-filtered-children hide-focus');
      this.panes.removeClass('all-children-filtered no-transition');
      this.contentAreas.removeClass('filtered');
      this.currentlyFiltered = $(); // If headers are included in the currentlyFiltered storage, removes the ones that
      // have previously been filtered

      var toFilter = targets.not(this.currentlyFiltered); // Store a list of all modified parent headers

      var allParentHeaders = $();
      var allContentAreas = $(); // Perform filtering

      this.headers.add(this.contentAreas).not(toFilter).addClass('filtered');
      toFilter.each(function (i, target) {
        var isContentArea = $(target).is('.accordion-content');
        var allParentPanes = $(target).parents('.accordion-pane'); // Handle Content Areas

        if (isContentArea) {
          allContentAreas.push($(target));
          var thisParentPane = $(allParentPanes[0]);
          var thisParentHeader = thisParentPane.prev('.accordion-header').filter(function (j, item) {
            return allParentHeaders.index(item) === -1;
          });

          if (thisParentHeader.length) {
            allParentHeaders = allParentHeaders.add(thisParentHeader);
          }
        } // Handle Labeling of Parent Headers


        if (allParentPanes.length) {
          var parentHeaders = allParentPanes.prev('.accordion-header').filter(function (j, item) {
            return allParentPanes.index(item) === -1;
          });
          allParentHeaders = allParentHeaders.add(parentHeaders);
        }
      });
      allParentHeaders.addClass('has-filtered-children');
      var expandPromise = this.expand(allParentHeaders, true);
      $.when(expandPromise).done(function () {
        _this3.currentlyFiltered = toFilter;
        self.build(undefined, true);
      });
    },

    /**
     * @param {jQuery[]} [headers] element references representing accordion headers.
     *  If provided, will cause only specific items to become unfiltered.  If not
     *  provided, removes all filtering from the accordion.
     */
    unfilter: function unfilter(headers) {
      var _this4 = this;

      if (!this.currentlyFiltered.length) {
        return;
      }

      if (!headers || !headers.length) {
        headers = this.currentlyFiltered;
      } // Store a list of all modified parent headers


      var allParentHeaders = $(); // Reset all the things

      this.headers.removeClass('filtered has-filtered-children hide-focus');
      this.panes.removeClass('all-children-filtered no-transition');
      this.contentAreas.removeClass('filtered');
      headers.each(function (i, header) {
        var parentPanes = $(header).parents('.accordion-pane');

        if (parentPanes.length) {
          var parentHeaders = parentPanes.prev('.accordion-header').filter(function (j, item) {
            return allParentHeaders.index(item) === -1;
          });
          allParentHeaders = allParentHeaders.add(parentHeaders);
        }
      });
      allParentHeaders.removeClass('has-filtered-children');
      var collapseDfds = [this.collapse(headers), this.collapse(allParentHeaders)];
      $.when(collapseDfds).done(function () {
        _this4.currentlyFiltered = _this4.currentlyFiltered.not(headers);
      });
    },

    /**
    * Disable an accordion from events
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled');
      this.anchors.add(this.headers.children('[class^="btn"]')).attr('tabindex', '-1');
    },

    /**
    * Enable a disabled accordion.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
      this.anchors.add(this.headers.children('[class^="btn"]')).removeAttr('tabindex');
    },

    /**
       * Updates an entire accordion, or specific portion(s).
       * @param {jQuery[]} [headers] Optional jQuery object containing accordion headers whose
       * contents need to be torndown/rebound
       * @param {object} settings The current settings.
       * @returns {this} The api object
       */
    updated: function updated(headers, settings) {
      this.element.data('updating', true);

      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
        this.settings = handleDeprecatedSettings(this.settings);
      }

      var currentFocus = $(document.activeElement);

      if (!$.contains(this.element[0], currentFocus[0])) {
        currentFocus = undefined;
      } // If accordion headers are passed in, simply teardown/rebind events only for those sections.
      // Otherwise, re-init the entire accordion.


      if (headers && headers instanceof jQuery) {
        this.teardown(headers).init(headers);
      } else {
        this.teardown().init();
      }

      if (currentFocus && currentFocus.length) {
        currentFocus.focus();
      }

      $.removeData(this.element[0], 'updating');
      return this;
    },

    /**
    * Teardown process for accordion elements
    * @param {jQuery} [headers] The header elements to tear down (optional).
    * @returns {void}
    */
    teardown: function teardown(headers) {
      var globalTeardown = false;
      var headerElems = headers;

      if (this.currentlyFiltered) {
        this.unfilter(this.currentlyFiltered);
      }

      if (!headers || !(headers instanceof jQuery)) {
        headerElems = this.headers;
        globalTeardown = true;
      }

      if (headerElems && headerElems.length) {
        headerElems.off('touchend.accordion click.accordion focusin.accordion focusout.accordion keydown.accordion mousedown.accordion mouseup.accordion').each(function () {
          var header = $(this);
          var icon = header.children('.icon');
          var hideFocus = header.data('hidefocus');

          if (hideFocus) {
            hideFocus.destroy();
          }

          if (icon.length) {
            var iconAPI = icon.data('icon');

            if (iconAPI) {
              iconAPI.destroy();
            }
          }

          var expander = header.data('addedExpander');

          if (expander) {
            expander.remove();
            $.removeData(this, 'addedExpander');
          }
        });
        var anchors = headerElems.not('.accordion-content').find('a');
        anchors.off('touchend.accordion keydown.accordion click.accordion');
        headerElems.children('[class^="btn"]').off('touchend.accordion click.accordion keydown.accordion');
      }

      if (globalTeardown) {
        this.element.off('updated.accordion selected.accordion');
        delete this.anchors;
        delete this.headers;
        delete this.panes;
        delete this.contentAreas;
      }

      return this;
    },

    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], 'accordion');
    },

    /**
     * Teardown and remove any events.
     * @private
     * @param  {object} headers The headers to destroy
     * @returns {void}
     */
    handleEvents: function handleEvents(headers) {
      var self = this;
      var headerWhereMouseDown = null;
      var headerElems = headers;
      var globalEventSetup = false; // If no header elements are passed in, simply default to ALL headers.

      if (!headers || !(headers instanceof jQuery)) {
        headerElems = this.headers;
        globalEventSetup = true;
      } // Returns "Header", "Anchor", or "Expander" based on the element's tag


      function getElementType(element) {
        var elementType = 'Header';

        if (element.is('a')) {
          elementType = 'Anchor';
        }

        if (element.is('button')) {
          elementType = 'Expander';
        }

        return elementType;
      } // Intercepts a 'click' event in order to either prevent a link from being followed,
      // or allows it to continue.


      function clickInterceptor(e, element) {
        var type = getElementType(element); // Trigger a document click since we stop propgation, to close any open menus/popups.

        $('body').children().not('.application-menu, .modal-page-container, .page-container').closeChildren();
        return self["handle".concat(type, "Click")](e, element);
      }

      headerElems.on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      }).on('focusin.accordion', function (e) {
        var target = $(e.target);

        if (!self.originalSelection) {
          self.originalSelection = target;
        }

        headerElems.not($(this)).removeClass('is-focused');

        if (target.is(':not(.btn)')) {
          $(this).addClass('is-focused').removeClass('hide-focus');
        }
      }).on('focusout.accordion', function () {
        if (!$.contains(this, headerWhereMouseDown) || $(this).is($(headerWhereMouseDown))) {
          $(this).removeClass('is-focused');
        }
      }).on('keydown.accordion', function (e) {
        self.handleKeys(e);
      }).on('mousedown.accordion', function (e) {
        $(this).addClass('is-focused').removeClass('hide-focus');
        headerWhereMouseDown = e.target;
      }).on('mouseup.accordion', function () {
        headerWhereMouseDown = null;
      });
      headerElems.children('[class^="btn"]').on('click.accordion', function (e) {
        return clickInterceptor(e, $(this));
      }).on('keydown.accordion', function (e) {
        self.handleKeys(e);
      });

      if (globalEventSetup) {
        this.element.on('selected.accordion', function (e) {
          // Don't propagate this event above the accordion element
          e.stopPropagation();
        }).on('updated.accordion', function (e, settings) {
          // Don't propagate just in case this is contained by an Application Menu
          e.stopPropagation();
          self.updated(settings);
        });
      }

      return this;
    },

    /**
     * Hide the visible tooltip.
     * @private
     * @returns {void}
     */
    hideTooltip: function hideTooltip() {
      var _this5 = this;

      var self = window;

      if (self.tooltip) {
        this.removeTooltipData(self.tooltip); // Remove flag as spantooltip

        self.tooltip.classList.add('is-hidden');
        self.tooltip.classList.remove('content-tooltip');
      } // Remove scroll events


      $('body, .scrollable').off('scroll.spantooltip', function () {
        _this5.hideTooltip();
      });
    },

    /**
     * Remove the tooltip data from given node
     * @private
     * @param {object} elem The DOM element to remove data
     * @returns {void}
     */
    removeTooltipData: function removeTooltipData(elem) {
      elem = elem instanceof jQuery ? elem : $(elem);

      if (elem.data('spantooltip')) {
        $.removeData(elem[0], 'spantooltip');
      }
    },

    /**
     * Setup tooltips on truncated text elements.
     * @private
     * @returns {void}
     */
    setupTooltips: function setupTooltips() {
      if (!this.settings.enableTooltips) {
        return;
      }

      var self = this;
      var selector = '.accordion-header a span';
      var delay = 400;
      var tooltipTimer; // Handle tooltip to show

      var handleShow = function handleShow(elem) {
        elem.style.width = 'auto';

        if (elem.offsetWidth > elem.parentElement.offsetWidth - parseInt($(elem).parent().css('padding-left'), 10)) {
          elem.style.width = '';
          tooltipTimer = setTimeout(function () {
            $(elem).tooltip({
              trigger: 'immediate',
              content: "".concat(elem.innerText),
              extraClass: 'tooltip-accordion-style'
            });
          }, delay);
        }
      }; // Handle tooltip to hide


      var handleHide = function handleHide(elem) {
        elem.style.width = 'auto';

        if (elem.offsetWidth > elem.parentElement.offsetWidth - parseInt($(elem).parent().css('padding-left'), 10)) {
          elem.style.width = '';
          self.hideTooltip();
          clearTimeout(tooltipTimer);
        }
      }; // Bind events


      this.element.off('mouseenter.spantooltip', selector).on('mouseenter.spantooltip', selector, function () {
        handleShow(this);
      }).off('mouseleave.spantooltip click.spantooltip', selector).on('mouseleave.spantooltip click.spantooltip', selector, function () {
        handleHide(this);
      });
    }
  };
  /* eslint-enable no-multi-assign */

  /**
   * jQuery component wrapper for the Accordion
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.accordion = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$c);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$c, new Accordion(this, settings));
      }
    });
  };

  // Lifecycle Methods for jQuery Controls
  // Recursive methods that "globally" call certain methods on large groups of controls
  // =============================================================================
  // Used by several of these plugins to detect whether or not the "data" property in question
  // is a valid IDS Enterprise Control.
  function canAccessAPI(prop) {
    return prop && !(prop instanceof jQuery);
  } // Can access a property/method on an API.


  function canAccessProp(prop, method) {
    var api = canAccessAPI(prop);

    if (!api) {
      return false;
    }

    return prop[method] !== undefined && prop[method] !== null;
  } // Used by several of these plugins to detect whether or not there is a method on a "data" api
  // that can be called.


  function canCall(prop, method) {
    return canAccessProp(prop, method) && typeof prop[method] === 'function';
  } // Actually triggers the method on the control if it's possible


  function triggerAPIMethod(prop, method) {
    if (canCall(prop, method)) {
      prop[method]();
      return true;
    }

    return false;
  }
  /**
   * Tracks each element that attempts to trigger an API method.
   * If a trigger is successful, it stores it in an array that's used later.
   * @param {jQuery[]} elems containing elements to search.
   * @param {array|string} methods the method/prop to search for.
   * @param {array} [componentNames=[]] if defined, only sifts for specific component names instead of doing a blanket search/check
   * @param {boolean} [doTrigger=false] if true, causes the method being searched to be called, if possible.
   * @returns {array} containing IDS components that have the method/prop being searched.
   */


  function findComponentsOnElements(elems, methods) {
    var componentNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var doTrigger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var foundComponents = [];

    if (typeof methods === 'string') {
      methods = [methods];
    }

    $.each(elems, function (index, elem) {
      $.each($(elem).data(), function (i, dataEntry) {
        if (componentNames.length && componentNames.indexOf(i) === -1) {
          return;
        }

        methods.forEach(function (method) {
          if (doTrigger && triggerAPIMethod(dataEntry, method)) {
            foundComponents.push({
              elem: $(elem),
              control: dataEntry
            });
          } else if (canAccessProp(dataEntry, method)) {
            foundComponents.push({
              elem: $(elem),
              control: dataEntry
            });
          }
        });
      });
    });
    return foundComponents;
  }
  /**
   * Sifts through all elements within a root element and attempts to call a method
   * on the elements' attached IDS Components, if those components are present.
   * @private
   * @param {jQuery[]|HTMLElement} rootElem the top-level element to search
   * @param {string} method the method name to search for
   * @param {array} [filteredOutElements=[]] if provided, filters out some component selectors.
   * @returns {jQuery[]} wrapped root element
   */


  function siftFor(rootElem, method) {
    var filteredOutElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    if (!rootElem || !method) {
      return undefined;
    }

    rootElem = $(rootElem);
    var DOMelements = rootElem.find('*').add(rootElem).not(filteredOutElements.join(', '));
    var siftedControls = findComponentsOnElements(DOMelements, method, undefined, true);
    rootElem.trigger("sift-".concat(method, "-complete"), [siftedControls]);
    return rootElem;
  }

  var EXCLUDED_FROM_CLOSE_CHILDREN = ['.expandable-area', '.accordion', '[soho-busyindicator]', '.busy-indicator-container'];
  var EXCLUDED_FROM_HANDLE_RESIZE = [];
  /**
   * Searches this element for all IDS Components internally that can be destroyed.
   * Any components matched will automatically be destroyed.
   * @returns {jQuery[]} the root element
   */

  $.fn.destroy = function () {
    return siftFor($(this), 'destroy');
  };
  /**
   * Searches this element for all IDS Components internally that have menus or popups that can be closed.
   * Any components matched will automatically have these items closed.
   * @returns {jQuery[]} the root element
   */


  $.fn.closeChildren = function () {
    return siftFor($(this), 'close', EXCLUDED_FROM_CLOSE_CHILDREN);
  };
  /**
   * Searches this element for all IDS Components internally that contain a `handleResize` method.
   * Any components matched will automatically run this method.
   * @returns {jQuery[]} the root element
   */


  $.fn.handleResize = function () {
    return siftFor($(this), 'handleResize', EXCLUDED_FROM_HANDLE_RESIZE);
  };

  var COMPONENT_NAME$d = 'expandablearea';
  /**
  * An expandable pane / area.
  * @class ExpandableArea
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.trigger = null]  Id of some other button to use as a trigger
  * @param {string} [settings.bottomBorder = false] Change the border to bottom vs top (for some cases)
  * @param {number} [settings.animationSpeed = 300] Change the animation speed in ms
  * @param {string} [settings.attributes=null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var EXPANDABLEAREA_DEFAULTS = {
    trigger: null,
    bottomBorder: false,
    animationSpeed: 300,
    attributes: null
  };

  function ExpandableArea(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EXPANDABLEAREA_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Expandable Area API


  ExpandableArea.prototype = {
    /**
    * Initialize the Expandable area
    * @private
    */
    init: function init() {
      this.setup().build().handleEvents();
    },

    /**
    * Setup internal variables.
    * @private
    * @returns {object} The Api for chaining.
    */
    setup: function setup() {
      this.id = this.element.attr('id');

      if (!this.id || this.id === undefined) {
        this.id = "expandable-area-".concat($('body').find('.expandable-area').index(this.element));
      } // Detect a button preceeding the expandable area that acts as its trigger element.


      if (this.element.prev('.expandable-area-trigger').length > 0) {
        this.expander = this.element.prev('.expandable-area-trigger');
        this.settings.trigger = this.expander.attr('id') || "expandable-area-trigger-".concat($('body').find('.expandable-area').index(this.element));
      }

      this.header = this.settings.trigger ? this.element : this.element.children('.expandable-header');
      this.footer = this.element.children('.expandable-footer');
      this.content = this.element.children('.expandable-pane');
      this.isCard = this.element.is('.card, .widget');
      return this;
    },

    /**
    * Add markup to build up the component.
    * @private
    * @returns {object} The Api for chaining.
    */
    build: function build() {
      var _this = this;

      var expanded = this.element.hasClass('is-expanded');
      var target = this.expander || this.header;
      target.attr({
        'aria-expanded': "".concat(expanded),
        'aria-controls': "".concat(this.id, "-content")
      });
      this.header.attr({
        id: "".concat(this.id, "-header")
      });
      this.content.attr({
        id: "".concat(this.id, "-content"),
        role: 'region',
        'aria-labelledby': "".concat(this.id, "-header")
      }); // Add the link and footer if not there already.
      // If we're using an expandable card,

      if (!this.isCard && !this.footer.length && !this.settings.trigger) {
        this.footer = $('<div class="expandable-footer"></div>').appendTo(this.element);
      }

      function getExpander(instance, useHeaderExpander) {
        var expander;

        if (useHeaderExpander === true) {
          // Use icon-based expander in the header
          expander = instance.header.find('expandable-expander');

          if (!expander.length) {
            expander = $("".concat('<a href="#" target="_self" role="button" class="btn-expander">' + '<svg class="chevron icon" focusable="false" aria-hidden="true" role="presenation">' + '<use href="#icon-caret-down"></use>' + '</svg>' + '<span class="audible">').concat(Locale.translate('ShowMore'), "</span>") + '</a>').appendTo(instance.header);
          }

          return expander;
        } // Use the text-based expander button in the footer


        expander = instance.footer.find('.expandable-expander');

        if (!expander.length) {
          expander = $("".concat('<a href="#" target="_self" role="button" class="expandable-expander hyperlink">' + '<span data-translated="true">').concat(Locale.translate('ShowMore'), "</span>") + '</a>').prependTo(instance.footer);
        }

        return expander;
      }

      this.expander = getExpander(this, this.isCard);
      this.expander.attr('href', '#').hideFocus();
      this.expander.attr('role', 'button');

      if (this.expander.length === 0) {
        this.expander = $("#".concat(this.settings.trigger));
      } // Change the borer to the bottom vs top


      if (this.settings.bottomBorder) {
        this.element.addClass('has-bottom-border');
      } // Initialized in expanded mode.


      if (expanded) {
        this.content.addClass('no-transition');
        this.element.one('afterexpand.expandable-area', function () {
          _this.content.removeClass('no-transition');
        });
        this.open();
      }

      if (!expanded) {
        this.content.addClass('no-transition');
        this.element.one('aftercollapse.expandable-area', function () {
          _this.content.removeClass('no-transition');
        });
        this.close();
      }

      this.resize();
      utils.addAttributes(this.element, this, this.settings.attributes, '', true);
      utils.addAttributes(this.header, this, this.settings.attributes, 'header', true);
      utils.addAttributes(this.content, this, this.settings.attributes, 'content', true);
      utils.addAttributes(this.expander, this, this.settings.attributes, 'expander', true);
      utils.addAttributes(this.footer, this, this.settings.attributes, 'footer', true);
      return this;
    },

    /**
    * Return if the expandable area is current disable or not.
    * @returns {boolean} True or False depending on the disabled status.
    */
    isDisabled: function isDisabled() {
      return this.element.hasClass('is-disabled');
    },

    /**
    * Returns expanded status about the current expandable area
    * @returns {boolean} True of alse depending on current expanded status.
    */
    isExpanded: function isExpanded() {
      return this.element.is('.is-expanded');
    },

    /**
    * Toggle current expansion state.
    */
    toggleExpanded: function toggleExpanded() {
      // if (this.header.attr('aria-expanded') === 'true') {
      if (this.isExpanded()) {
        this.close();
      } else {
        this.open();
      }
    },

    /**
    * Open the pane if closed.
    */
    open: function open() {
      var _this2 = this;

      /**
       * Fires after a row is added via the api.
      * @event beforeexpand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      var canExpand = this.element.triggerHandler('beforeexpand', [this.element]);

      if (canExpand === false) {
        return;
      }

      this.element.addClass('is-expanded');
      (this.expander || this.header).attr('aria-expanded', 'true');
      this.expander.addClass('active');
      /**
       * Fires after a row is added via the api.
      * @event expand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */

      this.element.triggerHandler('expand', [this.element]);
      this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowLess') ? Locale.translate('ShowLess') : 'Show Less');

      if (this.isCard) {
        this.expander.find('.icon').addClass('active');
      }

      if (this.content[0]) {
        this.content[0].style.display = 'block';
      }
      /**
       * Fires after a row is added via the api.
      * @event afterexpand
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */


      this.content.one('animateopencomplete', function () {
        _this2.element.triggerHandler('afterexpand', [_this2.element]);
      }).animateOpen({
        timing: this.settings.animationSpeed
      });
      this.applyIE11Fix();
    },

    /**
    * Close the pane if open.
    */
    close: function close() {
      var _this3 = this;

      /**
      * Fires after a row is added via the api.
      * @event beforecollapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */
      var canCollapse = this.element.triggerHandler('beforecollapse', [this.element]);

      if (canCollapse === false) {
        return;
      }

      this.expander.removeClass('active');
      /**
      * Fires after a row is added via the api.
      * @event collapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */

      this.element.triggerHandler('collapse', [this.element]);
      this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowMore') ? Locale.translate('ShowMore') : 'Show More');

      if (this.isCard) {
        this.expander.find('.icon').removeClass('active');
      }
      /**
      * Fires after a row is added via the api.
      * @event aftercollapse
      * @memberof ExpandableArea
      * @property {object} event The jquery event object
      * @property {HTMLElement} args.row The Html Element.
      */


      this.content.one('animateclosedcomplete', function () {
        _this3.element.removeClass('is-expanded');

        (_this3.expander || _this3.header).attr('aria-expanded', 'false');

        _this3.element.triggerHandler('aftercollapse', [_this3.element]);

        _this3.content[0].style.display = 'none';
      }).animateClosed({
        timing: this.settings.animationSpeed
      });
      this.applyIE11Fix();
    },

    /**
    * Determines if the browser is IE11 and applies a min-height fix for the overflow.
    * @private
    * @returns {void}
    */
    applyIE11Fix: function applyIE11Fix() {
      var self = this;
      var isIE11 = $('html').hasClass('ie11');
      setTimeout(function () {
        if (isIE11 && self.element.hasClass('is-expanded')) {
          self.element.css('min-height', self.element.children('.expandable-pane').outerHeight(true) + self.element.children('.expandable-footer').outerHeight(true));
        } else if (isIE11 && !self.element.hasClass('is-expanded')) {
          self.element.css('min-height', 'auto');
        }
      }, 300); // equal to transition time
    },

    /**
    * Determines if the the body has resized and fires the applyIE11Fix.
    * @private
    * @returns {void}
    */
    resize: function resize() {
      var self = this;
      $('body').on('resize.expandablearea', function () {
        self.applyIE11Fix();
      });
    },

    /**
    * Disable the expandable area from being closable.
    * @returns {void}
    */
    disable: function disable() {
      this.element.addClass('is-disabled');
    },

    /**
    * Enable the expandable area to allow close.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
    },

    /**
    * Destroy by removing markup and canceling events.
    * @returns {void}
    */
    destroy: function destroy() {
      var expandTarget = this.expander || this.header;
      expandTarget.removeAttr('aria-controls').removeAttr('aria-expanded');
      this.header.children('a').off();
      this.header.off();
      this.header.removeAttr('id');
      this.content.removeAttr('id').removeClass('no-transition');
      $.removeData(this.element[0], COMPONENT_NAME$d);
    },

    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this;
    },

    /**
    * Attach event handlers.
    * @private
    * @returns {object} The Api for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this;
      this.expander.on('click.expandablearea', function (e) {
        if (!self.isDisabled()) {
          e.preventDefault();
          self.toggleExpanded();
        }
      });
      return this;
    }
  };

  $.fn.expandablearea = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$d);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$d, new ExpandableArea(this, settings));
      }
    });
  };

  /**
   * @this {Promise}
   */
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(
      function(value) {
        // @ts-ignore
        return constructor.resolve(callback()).then(function() {
          return value;
        });
      },
      function(reason) {
        // @ts-ignore
        return constructor.resolve(callback()).then(function() {
          // @ts-ignore
          return constructor.reject(reason);
        });
      }
    );
  }

  function allSettled(arr) {
    var P = this;
    return new P(function(resolve, reject) {
      if (!(arr && typeof arr.length !== 'undefined')) {
        return reject(
          new TypeError(
            typeof arr +
              ' ' +
              arr +
              ' is not iterable(cannot read property Symbol(Symbol.iterator))'
          )
        );
      }
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              function(e) {
                args[i] = { status: 'rejected', reason: e };
                if (--remaining === 0) {
                  resolve(args);
                }
              }
            );
            return;
          }
        }
        args[i] = { status: 'fulfilled', value: val };
        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  }

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function isArray(x) {
    return Boolean(x && typeof x.length !== 'undefined');
  }

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function() {
      fn.apply(thisArg, arguments);
    };
  }

  /**
   * @constructor
   * @param {Function} fn
   */
  function Promise(fn) {
    if (!(this instanceof Promise))
      throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */
    this._state = 0;
    /** @type {!boolean} */
    this._handled = false;
    /** @type {Promise|undefined} */
    this._value = undefined;
    /** @type {!Array<!Function>} */
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function() {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self)
        throw new TypeError('A promise cannot be resolved with itself.');
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  /**
   * @constructor
   */
  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(
        function(value) {
          if (done) return;
          done = true;
          resolve(self, value);
        },
        function(reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        }
      );
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function(onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function(onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.prototype['finally'] = finallyConstructor;

  Promise.all = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.all accepts an array'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(
                val,
                function(val) {
                  res(i, val);
                },
                reject
              );
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.allSettled = allSettled;

  Promise.resolve = function(value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function(resolve) {
      resolve(value);
    });
  };

  Promise.reject = function(value) {
    return new Promise(function(resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function(arr) {
    return new Promise(function(resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.race accepts an array'));
      }

      for (var i = 0, len = arr.length; i < len; i++) {
        Promise.resolve(arr[i]).then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn =
    // @ts-ignore
    (typeof setImmediate === 'function' &&
      function(fn) {
        // @ts-ignore
        setImmediate(fn);
      }) ||
    function(fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  var filterModes = ['startsWith', 'contains', 'keyword', 'wordStartsWith', 'phraseStartsWith'];
  /**
   * Matches the provided term against the beginning of all words in a text string.
   * @param {string} text searchable text.
   * @param {string} term the term for which to search in the text string.
   * @returns {boolean} true if the term is present.
   */

  function wordStartsWithFilter(text, term) {
    var parts = text.split(' '); // Check all words for a match

    for (var a = 0; a < parts.length; a++) {
      if (parts[a].indexOf(term) === 0) {
        return true;
      }
    } // Direct Match


    if (text.indexOf(term) === 0) {
      return true;
    } // Partial dual word match


    if (term.indexOf(' ') > 0 && text.indexOf(term) > 0) {
      return true;
    }

    return false;
  }
  /**
   * Abstracted search/filter for use in other controls
   * @class ListFilter
   * @constructor
   *
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.caseSensitive=false]  Set to true if searches ARE case sensitive
   * @param {string} [settings.filterMode='startsWith']  Type of search can current be either 'startsWith' or 'contains'
   * @param {function} [settings.searchableTextCallback] If defined, will take each
    filterable item passed and return user-defined, searchable text content
   */


  var LISTFILTER_DEFAULTS = {
    caseSensitive: false,
    filterMode: filterModes[3],
    searchableTextCallback: undefined
  };

  function ListFilter(settings) {
    this.settings = utils.mergeSettings(undefined, settings, LISTFILTER_DEFAULTS);
    this.init();
  }

  ListFilter.prototype = {
    /**
     * Sanitize Incoming Options
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      function setReasonableDefaults(setting, limits, preset) {
        if ($.inArray(setting, limits) === -1) {
          setting = preset;
        }
      }

      var checks = [{
        setting: this.settings.filterMode,
        limits: filterModes,
        preset: LISTFILTER_DEFAULTS.filterMode
      }];

      for (var i = 0; i < checks.length; i++) {
        setReasonableDefaults(checks[i].setting, checks[i].limits, checks[i].preset);
      } // Warn about deprecated `startsWith` filter mode


      if (this.settings.filterMode === filterModes[0]) {
        warnAboutDeprecation('wordStartsWith (filter)', 'startsWith (filter)');
      }

      return this;
    },

    /**
     * Run the filter on the list for the given search term.
     * @param {array} list The array to search.
     * @param {string} term The term to look for.
     * @returns {boolean|array|jquery[]} false if filtering failed,
     *  or an array/jQuery of items that matched the filter.
     */
    filter: function filter(list, term) {
      if (!list) {
        return false;
      } // Check incoming list type


      if (!$.isArray(list) && !(list instanceof jQuery)) {
        return false;
      } // Search term must exist and must not be nothing


      if (!term || typeof term !== 'string' || !term.length) {
        return false;
      }

      var self = this;
      var items = [];
      var isJQuery = false; // make search term lowercase if the search is not case-senstive

      if (!this.settings.caseSensitive) {
        term = term.toLowerCase();
      } // If it's not an array, build an array of the incoming object(s) for iterating through


      if (!$.isArray(list)) {
        if (list instanceof jQuery || _typeof(list) === 'object') {
          list = $.makeArray(list);
          isJQuery = true;
        }
      } // Gets the properties of an object and splices them into text


      function getObjectPropsAsText(thisItem) {
        var text = '';
        var props = Object.keys(thisItem);
        props.forEach(function (prop) {
          var pad = text.length ? ' ' : '';
          text += "".concat(pad).concat(thisItem[prop]);
        });
        return text;
      } // If a custom callback for getting searchable content is defined, return a
      // string result from that callback. Otherwise, perform the standard method
      // of grabbing text content.


      function getSearchableContent(item) {
        var santitize = true;

        if (typeof self.settings.searchableTextCallback === 'function') {
          return self.settings.searchableTextCallback(item);
        }

        var targetContent;

        if (typeof item === 'string') {
          targetContent = item;
        } else if (item instanceof $) {
          targetContent = $(item).text();
        } else if (item instanceof HTMLElement) {
          santitize = false; // safe from innerText and we wan encoding.

          targetContent = item.innerText;
        } else {
          // Object
          targetContent = getObjectPropsAsText(item);
        }

        var ret = targetContent;

        if (santitize) {
          ret = xssUtils.sanitizeHTML(targetContent);
        }

        return ret;
      } // Iterates through each list item and attempts to find the provided search term.


      function searchItemIterator(item) {
        var text = getSearchableContent(item);

        if (!self.settings.caseSensitive) {
          text = text.toLowerCase().trim();
        }

        var match = false; // `startsWith` filter is deprecated as of v4.20.x.
        // For checking if any word in the string begins with the term, use `wordStartsWith`.
        // For checking if a string begins with the term, use `phraseStartsWith`.

        var wordStartsWithFilters = ['startsWith', 'wordStartsWith'];

        if (wordStartsWithFilters.indexOf(self.settings.filterMode) > -1) {
          match = wordStartsWithFilter(text, term);
        }

        if (self.settings.filterMode === 'phraseStartsWith') {
          if (text.indexOf(term) === 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'contains') {
          if (text.indexOf(term) >= 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'keyword') {
          var keywords = term.split(' ');

          for (var i = 0; i < keywords.length; i++) {
            var keyword = keywords[i];

            if (text.indexOf(keyword) >= 0) {
              match = true;
              break;
            }
          }
        } // assume filtered server side


        if (self.settings.filterMode === null) {
          match = true;
        }

        if (match) {
          items.push(item);
        }
      } // Run the iterator


      list.forEach(searchItemIterator); // If we originally took in a jQuery selector, rebuild that jQuery selector
      // with the relevant results.

      if (isJQuery) {
        items = $(items);
      } // If we're not dealing with jQuery, an empty array shouldn't be returned.


      if (!isJQuery && !items.length) {
        return false;
      }

      return items;
    },

    /**
     * Updates the ListFilter with new settings
     * @param {object} [settings] incoming settings
     * @returns {object} component instance
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(undefined, settings, this.settings);
      return this.teardown().init();
    },

    /**
     * @private
     * @returns {object} component instance
     */
    teardown: function teardown() {
      return this;
    },

    /**
     * @returns {object} component instance
     */
    destroy: function destroy() {
      return this.teardown();
    }
  };

  var Tmpl = {};
  /**
   * Recursive compile function for minimal mustache templates.
   * @param  {string} template The template string.
   * @param  {object} self The data / datacontext
   * @param  {object} parent When running recursively this is the parents data when nested.
   * @param  {boolean} invert An inverted expression.
   * @returns {string} The markup
   */

  Tmpl.compile = function compile(template, self, parent, invert) {
    var render = compile;
    var output = '';
    var i;

    function get(ctx, path) {
      path = path.pop ? path : path.split('.');
      ctx = ctx[path.shift()] || '';
      return 0 in path ? get(ctx, path) : ctx;
    }

    self = Array.isArray(self) ? self : self ? [self] : []; // eslint-disable-line

    self = invert ? 0 in self ? [] : [1] : self; // eslint-disable-line

    var _loop = function _loop() {
      var childCode = '';
      var depth = 0;
      var inverted = void 0;
      var ctx = _typeof(self[i]) === 'object' ? self[i] : {};
      ctx = utils.extend({}, parent, ctx); // Same as Object.assign({}, parent, ctx); but safe on IE

      ctx[''] = {
        '': self[i]
      };
      template.replace(/([\s\S]*?)({{((\/)|(\^)|#)(.*?)}}|$)/g, function (match, code, y, z, close, invert, name) {
        //eslint-disable-line
        if (!depth) {
          output += code.replace(/{{{(.*?)}}}|{{(!?)(&?)(>?)(.*?)}}/g, function (match, raw, comment, isRaw, partial, name) {
            return raw ? get(ctx, raw) //eslint-disable-line
            : isRaw ? get(ctx, name) //eslint-disable-line
            : partial ? render(get(ctx, name), ctx) : //eslint-disable-line
            !comment ? new Option(get(ctx, name)).innerHTML : '';
          });
          inverted = invert;
        } else {
          childCode += depth && !close || depth > 1 ? match : code;
        }

        if (close) {
          if (! --depth) {
            name = get(ctx, name);

            if (/^f/.test(_typeof(name))) {
              output += name.call(ctx, childCode, function (template) {
                return render(template, ctx);
              }); //eslint-disable-line
            } else {
              output += render(childCode, name, ctx, inverted);
            }

            childCode = '';
          }
        } else {
          ++depth;
        }
      });
    };

    for (i = 0; i < self.length; i++) {
      _loop();
    }

    return output;
  };

  var COMPONENT_NAME$e = 'autocomplete';
  /*
   * Default Autocomplete Result Item Template.  This can be modified to add data points that
   * will be populated by adding properties to the object created
   * in `DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK`.
   */

  var DEFAULT_AUTOCOMPLETE_TEMPLATE = "<li id=\"{{listItemId}}\" data-index=\"{{index}}\" {{#hasValue}}data-value=\"{{value}}\"{{/hasValue}} role=\"listitem\">\n <a href=\"#\" tabindex=\"-1\">\n   <span>{{{label}}}</span>\n </a>\n</li>";
  /*
  * Autocomplete's method for obtaining the string that will be tested against a provided search
  * term for a match. This is configurable in the event that the component you attach this to
  * needs a specific part of it searched (instead of the whole thing).
  * @param {String|Object} item - text string, or an object containing a 'label'.
  * @returns {string} The item or item label.
  */

  var DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK = function DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK(item) {
    var isString = typeof item === 'string';
    return isString ? item : item.label;
  };
  /*
  * Autocomplete provides a method that will be run on every result that is passed back from the
  * filtering API. This method can be replaced, allowing developers to customize the output of the
  * returned dataset to add values that can also be displayed on each list item with a modified
  * `DEFAULT_AUTOCOMPLETE_TEMPLATE`.
  */


  var DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK = function resultIterator(item, index) {
    // For standard autocompletes with a popupmenu, build the dataset that
    // will be submitted to the template.
    var isString = typeof item === 'string';
    var dataset = {
      highlightTarget: 'label',
      index: index,
      listItemId: "ac-list-option".concat(index)
    };

    if (!isString) {
      dataset = utils.extend({}, dataset, item);
    } else {
      dataset.label = item;
    }

    dataset.hasValue = item.value !== undefined;

    if (dataset.hasValue) {
      dataset.value = item.value;
    }

    return dataset;
  };
  /*
   * Provides a method for highlighting or calling out the matching search term
   * within rendered filter results.  Note that this method will not be run by the
   * Autocomplete if the component is configured with an external `displayResultsCallback` method
   * for handling the display of filter results.
   */


  var DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK = function highlightMatch(item, options) {
    var targetProp = item;
    var hasAlias = false; // If this is an object and we need to replace text within a specific property,
    // look for an "alias" property to use instead of the item itself.

    if (typeof options.alias === 'string' && item[options.alias] !== undefined) {
      hasAlias = true;
      targetProp = item[options.alias];
    } // Easy match for 'contains'-style filterMode.


    if (options.filterMode === 'contains') {
      targetProp = targetProp.replace(new RegExp('(' + stringUtils.escapeRegExp(options.term) + ')', 'ig'), '<i>$1</i>');
    } else if (options.filterMode === 'keyword') {
      // Handle "keyword" filterMode
      var keywords = options.term.split(' ');

      for (var i = 0; i < keywords.length; i++) {
        var keyword = keywords[i];

        if (keyword) {
          targetProp = targetProp.replace(new RegExp('(' + stringUtils.escapeRegExp(keyword) + ')', 'ig'), '<i>$1</i>');
        }
      }
    } else {
      // Handle "startsWith" filterMode highlighting a bit differently.
      var originalItem = targetProp;
      var testContent = "".concat(originalItem);

      if (!options.caseSensitive) {
        testContent = Locale.toLowerCase(testContent);
      }

      var safeTerm = stringUtils.escapeRegExp(options.term);
      var pos = testContent.indexOf(safeTerm);

      if (pos > 0) {
        targetProp = originalItem.substr(0, pos) + '<i>' + originalItem.substr(pos, safeTerm.length) + '</i>' + originalItem.substr(safeTerm.length + pos);
      } else if (pos === 0) {
        targetProp = '<i>' + originalItem.substr(0, safeTerm.length) + '</i>' + originalItem.substr(safeTerm.length);
      }
    } // place result back


    if (hasAlias) {
      item[options.alias] = targetProp;
    } else {
      item = targetProp;
    }

    return item;
  };
  /**
  * The Autocomplete control provides an easier means of searching through a large amount of data by filtering
  * down the results based on keyboard input from the user.
  * @class Autocomplete
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.source=[]] Defines the data to use, must be specified.
  * @param {string} [settings.sourceArguments={}] If a source method is defined, this flexible object can be passed
  * into the source method, and augmented with parameters specific to the implementation.
  * @param {boolean} [settings.template If defined, use this to draw the contents of each search result instead of the default draw routine.
  * @param {boolean} [settings.caseSensitive=false] if true, causes filter results that don't match case to be thrown out
  * @param {string} [settings.filterMode='startsWith'] The matching algorithm, startsWith, keyword and contains are supported - false will not filter client side
  * @param {boolean} [settings.delay=300] The delay between key strokes on the keypad before it thinks you stopped typing
  * @param {string} [settings.width=null] Width of the open auto complete menu
  * @param {string} [settings.offset=null] For the open menu, the left or top offset
  * @param {string} [settings.autoSelectFirstItem=false] Whether or not to select he first item in the list to be selected
  * @param {boolean} [settings.highlightMatchedText=true] The highlightMatchText property.
  * @param {function} [settings.highlightCallback] The highlightCallback property.
  * @param {function} [settings.resultIteratorCallback] The resultIteratorCallback property.
  * @param {function} [settings.clearResultsCallback] the clearResultsCallback property.
  * @param {function} [settings.displayResultsCallback] The displayResultsCallback property.
  * @param {function} [settings.searchableTextCallback] The searchableTextCallback property.
  */


  var AUTOCOMPLETE_DEFAULTS = {
    source: [],
    sourceArguments: {},
    template: undefined,
    filterMode: 'wordStartsWith',
    caseSensitive: false,
    delay: 300,
    width: null,
    offset: null,
    autoSelectFirstItem: false,
    highlightMatchedText: true,
    highlightCallback: DEFAULT_AUTOCOMPLETE_HIGHLIGHT_CALLBACK,
    resultIteratorCallback: DEFAULT_AUTOCOMPLETE_RESULT_ITERATOR_CALLBACK,
    clearResultsCallback: undefined,
    displayResultsCallback: undefined,
    searchableTextCallback: DEFAULT_AUTOCOMPLETE_SEARCHABLE_TEXT_CALLBACK
  };

  function Autocomplete(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, AUTOCOMPLETE_DEFAULTS);
    this.init();
  } // Plugin Object


  Autocomplete.prototype = {
    init: function init() {
      // data-autocomplete can be a url, 'source' or an array
      var data = this.element.attr('data-autocomplete');

      if (data && data !== 'source') {
        this.settings.source = data;
        this.element.removeAttr('data-autocomplete');
      }

      var listFilterSettings = {
        filterMode: this.settings.filterMode,
        caseSensitive: this.settings.caseSensitive,
        highlightMatchedText: this.settings.highlightMatchedText,
        searchableTextCallback: this.settings.searchableTextCallback
      };

      if (!this.listFilter) {
        this.listFilter = new ListFilter(listFilterSettings);
      } else {
        this.listFilter.updated(listFilterSettings);
      }

      this.addMarkup();
      this.handleEvents();
    },

    /**
     * @returns {boolean} whether or not this component instance has an element that is focused.
     */
    get isFocused() {
      var active = document.activeElement;
      var input = this.element[0];
      var $list = this.list;

      if (input.isEqualNode(active) || $list && $list.length && $list[0].contains(active)) {
        return true;
      }

      return false;
    },

    addMarkup: function addMarkup() {
      this.element.addClass('autocomplete').attr({
        role: 'combobox',
        autocomplete: 'off'
      }); // Add test automation ids

      utils.addAttributes(this.element, this, this.settings.attributes);
    },
    isLoading: function isLoading() {
      return this.element.hasClass('is-loading') && this.element.hasClass('is-blocked');
    },
    openList: function openList(term, items) {
      var _this = this;

      if (this.element.is('[disabled], [readonly]') || this.isLoading()) {
        return;
      }

      if (!this.element.hasClass('searchfield')) {
        var canOpen = this.element.triggerHandler('beforeopen.autocomplete', {
          elem: this.element,
          value: this.element.val()
        });

        if (canOpen === false) {
          return;
        }
      }

      var self = this;

      if (!this.settings.caseSensitive) {
        term = Locale.toLowerCase(term);
      } // append the list


      this.list = $('#autocomplete-list');

      if (this.list.length === 0) {
        this.list = $('<ul id="autocomplete-list" aria-expanded="true"></ul>').appendTo('body');
      } // Add test automation ids


      utils.addAttributes(this.list, this, this.settings.attributes, 'list');

      if (self.settings.attributes) {
        setTimeout(function () {
          var options = _this.list.find('li a');

          options.each(function (i) {
            var opt = $(this);
            utils.addAttributes(opt, self, self.settings.attributes, "list-option".concat(i));
          });
        });
      }

      this.list[0].style.height = 'auto';
      this.list[0].style.width = "".concat(this.element.outerWidth(), "px");
      this.list.addClass('autocomplete');
      this.list.empty();

      if (this.settings.width) {
        this.list[0].style.width = this.settings.width + (/(px|%)/i.test("".concat(this.settings.width)) ? '' : 'px');
      } // Pre-compile template.
      // Try to get an element first, and use its contents.
      // If the string provided isn't a selector, attempt to use it as a string, or fall back
      // to the default template.


      var templateAttr = $(this.element.attr('data-tmpl'));
      this.tmpl = $(templateAttr).length ? $(templateAttr).text() : typeof templateAttr === 'string' ? templateAttr : $(this.settings.template).length ? $(this.settings.template).text() : typeof this.settings.template === 'string' ? this.settings.template : DEFAULT_AUTOCOMPLETE_TEMPLATE; // Send full item list to the ListFilter for filtering.

      var filterResult = this.listFilter.filter(items, term);
      var modifiedFilterResults = []; // Modify filtered results for a specific template with a `resultIteratorCallback`,
      // if applicable. Each of these results is deep-copied.

      if (filterResult !== false) {
        filterResult.forEach(function (val, index) {
          if (typeof val === 'string') {
            val = {
              label: val,
              value: val
            };
          }

          var result = utils.extend(true, {}, val);
          result = self.settings.resultIteratorCallback(result, index);

          if (self.settings.highlightMatchedText) {
            var filterOpts = {
              filterMode: self.settings.filterMode,
              caseSensitive: self.settings.caseSensitive,
              term: term
            };

            if (result.highlightTarget) {
              filterOpts.alias = result.highlightTarget;
            } // Only render highlight results if we don't do this manually
            // in another component's rendering method.


            if (!self.settings.displayResultsCallback) {
              result = self.settings.highlightCallback(result, filterOpts);
            }
          }

          modifiedFilterResults.push(result);
        });
      }

      this.currentDataSet = modifiedFilterResults; // If a "resultsCallback" method is defined, pipe the filtered items to that method and skip
      // building a popupmenu.

      if (typeof this.settings.displayResultsCallback === 'function') {
        this.settings.displayResultsCallback(modifiedFilterResults, function () {
          self.element.trigger('listopen', [modifiedFilterResults]);
        }, term);
        return;
      }

      this.handleListResults(term, items, modifiedFilterResults);
    },
    handleListResults: function handleListResults(term, items, filterResult) {
      var self = this;
      filterResult.forEach(function (dataset) {
        if (typeof Tmpl !== 'undefined') {
          var renderedTmpl = Tmpl.compile(self.tmpl, dataset);
          DOM.append(self.list, renderedTmpl, '*');
        }
      });
      /**
       * Fires before the menu DOM is populated with the filter results.
       *
       * @event beforepopulated
       * @memberof Autocomplete
       * @param {object} event - The jquery event object
       * @param {object} filterResult - The results of the filtering
       */

      this.element.trigger('beforepopulated', [filterResult]);

      var afterPlaceCallback = function afterPlaceCallback(placementObj) {
        if (placementObj.wasFlipped === true) {
          self.list.add(self.element).addClass('is-ontop');
          placementObj.y += 1;
        }

        return placementObj;
      };

      var popupOpts = {
        menuId: 'autocomplete-list',
        ariaListbox: true,
        mouseFocus: false,
        trigger: 'immediate',
        attachToBody: true,
        autoFocus: false,
        returnFocus: false,
        triggerSelect: false,
        placementOpts: {
          parent: this.element,
          callback: afterPlaceCallback
        }
      };

      if (!this.previouslyOpened) {
        this.element.addClass('is-open').popupmenu(popupOpts).one('close.autocomplete', function () {
          self.closeList(true);
        });
      } else {
        var popupmenuAPI = this.element.data('popupmenu');

        if (popupmenuAPI) {
          popupmenuAPI.position();
        }
      } // Adjust the widths of the LIs to the longest


      var lis = self.list.find('li');
      var width = $(lis[0]).find('span').outerWidth() + 20;

      if (width > parseInt(this.element.outerWidth(), 10)) {
        for (var i = 0; i < lis.length; i++) {
          lis.width(width + 'px');
        }

        this.maxWidth = width;
      } // Optionally select the first item in the list


      if (self.settings.autoSelectFirstItem) {
        self.list.children().filter(':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)').first().addClass('is-selected');
      }

      this.noSelect = true;
      /**
      * Fires after the menu is populated with its contents.
      *
      * @event populated
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      * @param {object} filterResult - The results of the filtering
      */

      this.element.trigger('populated', [filterResult]).focus();

      if (!this.previouslyOpened) {
        // Overrides the 'click' listener attached by the Popupmenu plugin
        self.list.on("touchend.".concat(COMPONENT_NAME$e, " click.").concat(COMPONENT_NAME$e), 'a', function (e) {
          self.select(e);
        }).on("focusout.".concat(COMPONENT_NAME$e), function () {
          self.checkActiveElement();
        }); // Highlight anchors on focus

        var all = self.list.find('a').on("focus.".concat(COMPONENT_NAME$e, " touchend.").concat(COMPONENT_NAME$e), function () {
          self.highlight($(this), all);
        });

        if (this.settings.offset) {
          var domListParent = this.list.parent()[0];

          if (this.settings.offset.left) {
            domListParent.style.left = "".concat(parseInt(domListParent.style.left, 10) + this.settings.offset.left, "px");
          }

          if (this.settings.offset.top) {
            domListParent.style.top = "".concat(parseInt(domListParent.style.top, 10) + this.settings.offset.top, "px");
          }
        }
      } // As chars are typed into the edit field, nothing was announced to indicate
      // that a value has been suggested, for the non-sighted user an offscreen span
      // added and will remove soon popup close that includes aria-live="polite"
      // which have the first suggested item automatically announced when it
      // appears without moving focus.


      var previousLiveMessages = utils.getArrayFromList(document.querySelectorAll('#ac-is-arialive'));

      if (previousLiveMessages) {
        previousLiveMessages.forEach(function (messageElem) {
          messageElem.parentNode.removeChild(messageElem);
        });
      }

      DOM.append(self.list.parent('.popupmenu-wrapper'), "<span id=\"ac-is-arialive\" aria-live=\"polite\" class=\"audible\">".concat($.trim(this.list.find('>li:first-child').text()), "</span>"), '<div><span><a><small><img><svg><i><b><use><br><strong><em>');
      this.noSelect = true;
      this.previouslyOpened = true;
      this.element.trigger('listopen', [filterResult]);
    },
    closeList: function closeList(dontClosePopup) {
      if (!this.list) {
        return;
      } // Remove events


      this.list.off(["click.".concat(COMPONENT_NAME$e), "keydown.".concat(COMPONENT_NAME$e), "touchend.".concat(COMPONENT_NAME$e), "focusout.".concat(COMPONENT_NAME$e)].join(' '));
      this.list.find('a').off("focus.".concat(COMPONENT_NAME$e, " touchend.").concat(COMPONENT_NAME$e));
      this.element.trigger('listclose');

      if (typeof this.settings.clearResultsCallback === 'function') {
        this.settings.clearResultsCallback();
        return;
      }

      var popup = this.element.data('popupmenu');

      if (!popup) {
        return;
      }

      if (!dontClosePopup) {
        popup.close();
      }

      $('#autocomplete-list').parent('.popupmenu-wrapper').remove();
      $('#autocomplete-list').remove();
      this.element.add(this.list).removeClass('is-open is-ontop');
      delete this.previouslyOpened;
    },
    listIsOpen: function listIsOpen() {
      return this.list instanceof $ && this.list.length && this.list.is(':visible');
    },
    // Handles the Autocomplete's "keydown" event
    handleAutocompleteKeydown: function handleAutocompleteKeydown(e) {
      var self = this;

      if (this.isLoading()) {
        e.preventDefault();
        return false;
      }

      if (!this.listIsOpen()) {
        return null;
      }

      function getHighlighted(items) {
        var highlightedItems = items.filter('.is-selected');

        if (highlightedItems.length === 0) {
          highlightedItems = items.filter('.is-focused');
        }

        return highlightedItems;
      }

      function unhighlight(item) {
        item.removeClass('is-selected is-focused');
      }

      function highlight(item) {
        item.addClass('is-selected').find('a').focus();
      }

      var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';
      var items = this.list.find(excludes);
      var highlighted = getHighlighted(items); // Down - select next

      if (e.keyCode === 40 && this.listIsOpen()) {
        if (highlighted.length) {
          self.noSelect = true;
          unhighlight(highlighted);
          highlight(items.eq(items.index(highlighted) + 1));
          e.preventDefault();
          e.stopPropagation();
        }
      } // Up select prev


      if (e.keyCode === 38 && this.listIsOpen()) {
        if (highlighted.length) {
          self.noSelect = true;
          unhighlight(highlighted);
          highlight(items.eq(items.index(highlighted) - 1));
          e.preventDefault();
          e.stopPropagation();
        }
      } // Enter/Tab - apply selected item


      if ((e.keyCode === 9 || e.keyCode === 13) && this.listIsOpen()) {
        // Apply selection if an item is selected, otherwise close list and
        // allow default tab/enter behavior to happen
        if (highlighted.length) {
          e.stopPropagation();
          e.preventDefault();
          self.noSelect = true;
          self.select(highlighted);
        } else {
          self.closeList();
        }
      }

      return null;
    },
    // Handles the Autocomplete's "input" event
    handleAutocompleteInput: function handleAutocompleteInput(e) {
      var self = this;

      if (self.isLoading()) {
        e.preventDefault();
        return false;
      } // Makes a new AJAX call every time a key is pressed.


      var waitForSource = this.getDataFromSource();
      waitForSource.done(function (term, response) {
        self.currentDataSet = response;
        self.openList(term, response);
      });
      return null;
    },

    /**
     * Check to see whether or not the currently-focused element resides within
     * the Autocomplete's field or list, and if not, fires a "safe-blur" event on the element.
     *
     * @private
     * @param {object} e The event object passed in from the jQuery `.on()` listener.
     * @returns {void}
     */
    checkActiveElement: function checkActiveElement() {
      var self = this;
      setTimeout(function () {
        var activeElem = document.activeElement;

        if (self.listIsOpen() && $.contains(self.list[0], activeElem) || self.element.is(activeElem)) {
          return;
        }
        /**
        *  Fires after the input (and menu) both loose focus
        *
        * @event safe-blur
        * @memberof Autocomplete
        * @param {object} event The input event object
        */


        self.element.trigger('safe-blur');
      }, 0);
    },
    getDataFromSource: function getDataFromSource() {
      var self = this; // Don't attempt to load if we're already loading.

      if (self.isLoading()) {
        return false;
      }

      var field = this.element;
      var dfd = $.Deferred();
      var buffer;
      clearTimeout(this.loadingTimeout);

      function done(searchTerm, response, deferredStatus) {
        if (self.lastTerm !== searchTerm) {
          return dfd.reject(searchTerm);
        }

        self.element.triggerHandler('complete'); // For Busy Indicator

        /**
        *  Fires when the ajax request (source option) is completed
        *
        * @event requestend
        * @memberof Autocomplete
        * @param {object} event The input event object
        * @param {array} An array containing the searchTerm and call back function
        */

        self.element.trigger('requestend', [searchTerm, response]);

        if (deferredStatus === false) {
          return dfd.reject(searchTerm);
        }

        return dfd.resolve(xssUtils.stripTags(searchTerm), response);
      }

      this.loadingTimeout = setTimeout(function () {
        if (self.isLoading() || !self.isFocused) {
          return;
        }

        buffer = field.val();

        if (buffer === '') {
          if (self.element.data('popupmenu')) {
            self.element.data('popupmenu').close();
          }

          return;
        }

        var sourceType = _typeof(self.settings.source);

        self.element.triggerHandler('start'); // For Busy Indicator

        /**
        * Fires when the ajax request (source option) is initiated
        *
        * @event requeststart
        * @memberof Autocomplete
        * @param {object} event The input event object
        * @param {array} event An array with the buffer in it
        */

        self.element.trigger('requeststart', [buffer]);
        self.lastTerm = buffer;

        if (sourceType === 'function') {
          // Call the 'source' setting as a function with the done callback.
          self.settings.source(buffer, done, self.settings.sourceArguments);
        } else if (sourceType === 'object') {
          // Use the 'source' setting as pre-existing data.
          // Sanitize accordingly.
          var sourceData = $.isArray(self.settings.source) ? self.settings.source : [self.settings.source];
          done(buffer, sourceData, true);
        } else if (!self.settings.source) {
          dfd.reject(buffer);
        } else if (self.settings.filterMode === 'keyword') {
          var keywordData = [];

          var mergeData = function mergeData(data) {
            if (keywordData.length === 0) {
              keywordData = data;
            } else {
              // Check for duplicate entries
              for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];
                var isExists = false;

                for (var ii = 0; ii < keywordData.length; ii++) {
                  var keywordItem = keywordData[ii];

                  for (var iii = 0; iii < Object.getOwnPropertyNames(keywordItem).length; iii++) {
                    var dataPropVal = dataItem[Object.getOwnPropertyNames(dataItem)[iii]];
                    var keywordPropVal = keywordItem[Object.getOwnPropertyNames(keywordItem)[iii]];

                    if (dataPropVal === keywordPropVal) {
                      isExists = true;
                      break;
                    }
                  }
                }

                if (!isExists) {
                  keywordData.push(dataItem);
                }
              }
            }
          };

          var doneData = function doneData(data) {
            mergeData(data);
            done(buffer, keywordData, true);
          };

          var keywords = buffer.split(' ');

          if (keywords[keywords.length - 1] === '') {
            keywords.splice(-1, 1);
          }

          for (var i = 0; i < keywords.length; i++) {
            var keyword = keywords[i];

            if (keyword.length > 0) {
              var sourceURL = self.settings.source.toString();
              var request = $.getJSON(sourceURL + keyword);

              if (i < keywords.length - 1) {
                request.done(mergeData).fail(mergeData);
              } else {
                request.done(doneData).fail(doneData);
              }
            }
          }
        } else {
          // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
          var _sourceURL = self.settings.source.toString();

          var _request = $.getJSON(_sourceURL + buffer);

          _request.done(function (data) {
            done(buffer, data, true);
          }).fail(function () {
            done(buffer, [], false);
          });
        }
      }, self.settings.delay);
      return dfd;
    },

    /**
    * Resets a filtered autocomplete back to its original state.
    * @returns {void}
    */
    resetFilters: function resetFilters() {
      this.openList('', this.currentDataSet);
    },
    // Handles the Autocomplete's "focus" event
    handleAutocompleteFocus: function handleAutocompleteFocus() {
      var self = this;

      if (this.noSelect) {
        this.noSelect = false;
        return;
      } // select all text (after a delay since works better across browsers), but only if element is
      // still focused to avoid flashing cursor focus trap (since select causes focus event to
      // fire if no longer focused)


      self.element.select();
    },

    /**
     * Highlights (and focuses) an Autocomplete list option
     * @param {jQuery} anchor the anchor to be highlighted
     * @param {jQuery[]} [allAnchors=null] optional list of anchors to deselect when the new one becomes selected.
     * @returns {void}
     */
    highlight: function highlight(anchor, allAnchors) {
      var val = this.element.val();
      var text = anchor.text().trim();

      if (anchor.find('.display-value').length > 0) {
        text = anchor.find('.display-value').text().trim();
      }

      if (allAnchors && allAnchors.length) {
        allAnchors.parent('li').removeClass('is-selected');
      }

      anchor.parent('li').addClass('is-selected');
      this.noSelect = true;
      this.element.val(text).focus();

      if (val !== text) {
        this.element.triggerHandler('change');
      }
    },

    /**
     * Selects an Autocomplete result.
     * @param {jQuery|jQuery.Event} anchorOrEvent either a reference to a jQuery-wrapped HTMLElement, or a jQuery Event object with a target.
     * @param {object[]} [items=this.currentDataSet] an array of objects representing autocomplete options.
     * @returns {object} contains information about the selected item.
     */
    select: function select(anchorOrEvent, items) {
      var a;
      var li;
      var ret = {};
      var isEvent = false; // Initial Values

      if (anchorOrEvent instanceof $.Event) {
        isEvent = true;
        a = $(anchorOrEvent.currentTarget);
      } else {
        a = anchorOrEvent;
      }

      if (a.is('li')) {
        li = a;
        a = a.children('a');
      }

      li = a.parent('li');
      var dataIndex = li.attr('data-index');
      var dataValue = li.attr('data-value');
      this.element.attr('aria-activedescendant', li.attr('id'));

      if (!items || !items.length) {
        items = this.currentDataSet;
      } // If the data-index attr is supplied, use it to get the item
      // (since two items could have same value)


      if (dataIndex) {
        ret = items[parseInt(dataIndex, 10)];
      } else if (dataValue) {
        // Otherwise use data-value to get the item (a custom template may not supply data-index)
        for (var i = 0, value; i < items.length; i++) {
          if (_typeof(items[i]) === 'object' && items[i].value !== undefined) {
            value = items[i].value.toString();
          } else {
            value = items[i].toString();
          }

          if (value === dataValue) {
            if (_typeof(items[i]) === 'object') {
              ret = items[i];
            }

            ret.value = value;
          }
        }
      } // Use the label as the value, if we're not working from a true dataset


      if (!ret.value || !ret.value.length === 0) {
        ret.value = a.text().trim();
      }

      this.highlight(a);
      this.noSelect = true; // Update the data for the event

      ret.label = xssUtils.stripHTML(ret.label); // Add these elements for key down vs click consistency

      if (!ret.highlightTarget) {
        ret.highlightTarget = 'label';
        ret.index = parseInt(dataIndex, 10);
        ret.listItemId = 'ac-list-option' + ret.index;
        ret.hasValue = true;
      }
      /**
      *  Fires when an element is selected from the list.
      *
      * @event selected
      * @memberof Autocomplete
      * @param {array} args An array containing the link and the return object.
      */


      this.element.trigger('selected', [a, ret]);

      if (isEvent) {
        anchorOrEvent.preventDefault();
      }

      this.closeList();
      this.element.focus();
      return ret;
    },

    /*
    * Handle after list open.
    */
    handleAfterListOpen: function handleAfterListOpen() {
      var _this2 = this;

      // Fix one pixel off list by element
      if (this.element.offset().left > this.list.offset().left) {
        this.list.width(this.list.width() + 1);
      } // Allow keyboard handling when focus is inside the Autocomplete list.
      // See https://github.com/infor-design/enterprise-ng/issues/901


      this.list.on("keydown.".concat(COMPONENT_NAME$e), function (e) {
        if (e.key === 'Enter') {
          _this2.handleAutocompleteKeydown(e);
        }
      });
      return this;
    },

    /**
     * Update the component with new settings.
     * @param {object} settings The new settings object to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (settings && settings.source) {
        this.settings.source = settings.source;
      }

      this.teardown().init();
      return this;
    },

    /**
    * Enable the input from readonly or disabled state.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
    },

    /**
    * Disable the input from editing
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);
    },
    teardown: function teardown() {
      var popup = this.element.data('popupmenu');

      if (popup) {
        popup.destroy();
      }

      this.element.off(["focus.".concat(COMPONENT_NAME$e), "focusout.".concat(COMPONENT_NAME$e), "input.".concat(COMPONENT_NAME$e), "keydown.".concat(COMPONENT_NAME$e), "listopen.".concat(COMPONENT_NAME$e), "requestend.".concat(COMPONENT_NAME$e), "resetfilter.".concat(COMPONENT_NAME$e), "updated.".concat(COMPONENT_NAME$e)].join(' '));
      return this;
    },

    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$e);
    },

    /**
    * Setup the event handlers.
    * @private
    * @returns {void}
    */
    handleEvents: function handleEvents() {
      // similar code as dropdown but close enough to be dry
      var self = this;
      this.element.on("updated.".concat(COMPONENT_NAME$e), function () {
        self.updated();
      }).on("keydown.".concat(COMPONENT_NAME$e), function (e) {
        self.handleAutocompleteKeydown(e);
      }).on("input.".concat(COMPONENT_NAME$e), function (e) {
        self.handleAutocompleteInput(e);
      }).on("focus.".concat(COMPONENT_NAME$e), function () {
        self.handleAutocompleteFocus();
      }).on("focusout.".concat(COMPONENT_NAME$e), function () {
        self.checkActiveElement();
      })
      /**
      * Fires when the menu is opened.
      * @event listopen
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      * @param {object} ui - The dialog object
      */
      .on("listopen.".concat(COMPONENT_NAME$e), function () {
        self.handleAfterListOpen();
      })
      /**
      * Comes from Searchfields wrapping an autocomplete - resets
      * a filtered autocomplete back to normal.
      * @event listopen
      * @memberof Autocomplete
      * @param {object} event - The jquery event object
      */
      .on("resetfilter.".concat(COMPONENT_NAME$e), function () {
        self.resetFilters();
      });
    }
  };
  /* eslint-enable no-nested-ternary */

  /**
   * jQuery Component Wrapper for Autocomplete
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.autocomplete = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$e); // NOTE: This is modified due to a conflict between a legacy Soho attribute, `data-autocomplete`,
      // having the same value as jQuery's `$.data('autocomplete')`.

      if (typeof instance === 'string') {
        var stringSource = "".concat(instance);
        var modifiedSettings = utils.extend({}, settings, {
          source: stringSource || settings.source
        });
        instance = $.data(this, COMPONENT_NAME$e, new Autocomplete(this, modifiedSettings));
      } else if (!instance) {
        instance = $.data(this, COMPONENT_NAME$e, new Autocomplete(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  var COMPONENT_NAME$f = 'searchfield'; // Types of collapse modes

  var SEARCHFIELD_COLLAPSE_MODES = [false, 'mobile', true]; // Search Field Defaults

  var SEARCHFIELD_DEFAULTS = {
    resultsCallback: undefined,
    allResultsCallback: undefined,
    showAllResults: true,
    showGoButton: false,
    goButtonCopy: undefined,
    goButtonAction: undefined,
    categories: undefined,
    categoryMultiselect: false,
    showCategoryText: false,
    source: undefined,
    template: undefined,
    clearable: false,
    collapsible: SEARCHFIELD_COLLAPSE_MODES[0],
    collapseSize: undefined
  }; // Used throughout:

  var TOOLBARSEARCHFIELD_EXPAND_SIZE = 280;
  var MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE = 450;
  /**
   * The search field component.
   * @class SearchField
   * @param {jQuery[]|HTMLElement} element the base searchfield element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.resultsCallback] Callback function for getting typahead results on search.
   * @param {function} [settings.allResultsCallback] Callback function for getting "all results".
   * @param {boolean} [settings.showAllResults = true] If true the show all results link is showin in the list.
   * @param {boolean} [settings.showGoButton = false] If true a go button is associated.
   * @param {string} [settings.goButtonCopy] The text to use on the go button.
   * @param {function} [settings.goButtonAction] If defined as a function, will fire this callback on the Go Button "click"
   * @param {array} [settings.categories] If defined as an array, displays a dropdown containing categories that can be used to filter results.
   * @param {boolean} [settings.categoryMultiselect = false]  If true, creates a multiselectable categories list.
   * @param {boolean} [settings.showCategoryText = false]  If true, will show any available categories that are selected
   * to the left of the Dropdown field.
   * @param {function} [settings.source] Callback function for getting type ahead results.
   * @param {string} [settings.template] The html template to use for the search list
   * @param {boolean} [settings.clearable = true] If "true", provides an "x" button on the right edge that clears the field
   * @param {boolean} [settings.collapsible = true] If "true", allows the field to expand/collapse on larger breakpoints when
   * focused/blurred respectively
   * @param {boolean} [settings.collapsibleOnMobile = true] If true, overrides `collapsible` only on mobile settings.
   * @param {number|function} [settings.collapseSize=undefined] If true, configures the size of a toolbar searchfield when it's in it's "button", unfocused mode.  If defined as a function, gets a reference to this API as its primary argument, and returns a number.
   */

  function SearchField(element, settings) {
    this.element = $(element); // Backwards compatibility for old toolbars that had `collapsible` and `clearable` as the defaults

    if (this.toolbarParent && !this.isContainedByFlexToolbar && settings !== undefined) {
      if (settings.clearable === undefined) {
        settings.clearable = true;
      }

      if (settings.collapsible === undefined) {
        settings.collapsible = true;
      }
    }

    this.settings = utils.mergeSettings(element, settings, SEARCHFIELD_DEFAULTS);
    this.init();
  }

  SearchField.prototype = {
    /**
     * @returns {HTMLElement} a toolbar parent element, or `undefined`
     */
    get toolbarParent() {
      var toolbarParents = this.element.parents('.toolbar');
      var toolbarFlexParents = this.element.parents('.flex-toolbar');

      if (toolbarParents.add(toolbarFlexParents).length < 1) {
        return undefined;
      }

      if (toolbarFlexParents.length > 0) {
        return toolbarFlexParents.first()[0];
      }

      return toolbarParents.first()[0];
    },

    /**
     * @returns {HTMLElement} a buttonset element, or `undefined`
     */
    get buttonsetElem() {
      if (!this.toolbarParent) {
        return undefined;
      }

      return this.toolbarParent.querySelector('.buttonset');
    },

    /**
     * @returns {HTMLElement} a toolbar `.title` area, if one is present.
     */
    get titleElem() {
      if (!this.toolbarParent) {
        return undefined;
      }

      return this.toolbarParent.querySelector('.title');
    },

    /**
     * @returns {HTMLElement} a toolbar parent element, or `undefined`
     */
    get containmentParent() {
      var moduleTabs = this.element.closest('.module-tabs');

      if (moduleTabs.length) {
        return moduleTabs.first()[0];
      }

      return this.toolbarParent;
    },

    /**
     * @returns {HTMLElement} a reference to the input field
     */
    get input() {
      return this.element[0];
    },

    /**
      @returns {HTMLElement} a reference to an optional button with an attached Category selection menu
     */
    get categoryButton() {
      return this.wrapper.find('.searchfield-category-button');
    },

    /**
     * @returns {boolean} whether or not the searchfield can ever be collapsible.
     */
    get isCollapsible() {
      return this.settings.collapsible !== false;
    },

    /**
     * @returns {boolean} whether or not the searchfield is currently able to be collapsed.
     */
    get isCurrentlyCollapsible() {
      return this.settings.collapsible === true || this.settings.collapsible === 'mobile' && this.shouldBeFullWidth();
    },

    /**
     * @private
     * @returns {boolean} whether or not the parent toolbar is a Flex Toolbar
     */
    get isContainedByFlexToolbar() {
      if (!this.containmentParent) {
        return false;
      }

      return this.containmentParent.className.indexOf('flex-toolbar') > -1;
    },

    /**
     * @private
     * @returns {ToolbarFlexItem|undefined} if inside a Flex Toolbar, returns a reference to the corresponding Toolbar Flex Item API
     */
    get toolbarFlexItem() {
      var item;

      if (this.isContainedByFlexToolbar) {
        item = $(this.element).data('toolbarflexitem');
      }

      return item;
    },

    /**
     * @private
     * @returns {Autocomplete|undefined} a reference to the Searchfield's optional Autocomplete API
     */
    get autocompleteAPI() {
      return $(this.element).data('autocomplete');
    },

    /**
     * @returns {boolean} whether or not this is a context searchfield.
     */
    get isContextSearch() {
      return this.wrapper[0].className.indexOf('context') > -1;
    },

    /**
     * Initialization Kickoff
     * @private
     * @returns {void}
     */
    init: function init() {
      this.coerceBooleanSettings();
      this.build();
      this.setupEvents();
    },

    /**
     * Builds the markup for this component.
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      // Used for managing events that are bound to $(document)
      if (!this.id) {
        this.id = utils.uniqueId(this.element, COMPONENT_NAME$f);
      }

      this.label = this.element.prev('label, .label');
      this.inlineLabel = this.element.closest('label');
      this.isInlineLabel = this.element.parent().is('.inline'); // Invoke Autocomplete and store references to that and the popupmenu created by autocomplete.
      // Autocomplete settings are fed the same settings as Searchfield
      // NOTE: The `source` setting can be modified due to a conflict between a legacy Soho attribute,
      // `data-autocomplete`, having the same value as jQuery's `$.data('autocomplete')`.

      var autocompleteDataAttr = this.element.attr('data-autocomplete');

      if (autocompleteDataAttr && autocompleteDataAttr !== 'source') {
        this.settings.source = autocompleteDataAttr;
        this.element.removeAttr('data-autocomplete');
        $.removeData(this.element, 'autocomplete');
      }

      if (this.settings.source) {
        this.autocomplete = this.element.data('autocomplete');

        if (!this.autocomplete) {
          this.element.autocomplete(this.settings);
          this.autocomplete = this.element.data('autocomplete');
        } else {
          this.autocomplete.updated(this.settings);
        }
      } // Prevent browser typahead


      this.element.attr('autocomplete', 'off'); // Setup ARIA

      var label = this.element.attr('placeholder') || this.element.prev('label, .label').text().trim();

      if (!label || label === '') {
        label = Locale.translate('Keyword');
      }

      this.element.attr({
        'aria-label': label
      }); // Build the wrapper

      this.wrapper = this.element.parent('.searchfield-wrapper');

      if (!this.wrapper || !this.wrapper.length) {
        if (this.isInlineLabel) {
          this.wrapper = this.inlineLabel.addClass('searchfield-wrapper');
        } else {
          this.wrapper = this.element.wrap('<span class="searchfield-wrapper"></span>').parent();
        }
      }

      this.checkContents(); // Add/remove custom collapse CSS identifier

      var collapseSizeMethod = 'remove';

      if (this.settings.collapsible && this.settings.collapseSize) {
        collapseSizeMethod = 'add';
      }

      this.wrapper[0].classList[collapseSizeMethod]('has-custom-collapse-size'); // Label for toolbar-inlined searchfields needs to be inside the
      // wrapper to help with positioning.

      if (this.toolbarParent) {
        this.label.prependTo(this.wrapper);
        this.setInitalWidth();
      }

      var customClasses = ['context', 'alternate'];
      var c;

      for (var i = 0; i < customClasses.length; i++) {
        if (this.element.hasClass(customClasses[i])) {
          c = customClasses[i];
          this.wrapper.addClass(c);
          this.element.removeClass(c);
        }
      } // Backwards compatibility with collapsibleOnMobile
      // TODO: Remove in v4.9.0


      if (this.settings.collapsibleOnMobile === true) {
        this.settings.collapsible = SEARCHFIELD_COLLAPSE_MODES[1];
      } // Add/remove the collapsible functionality


      this.wrapper[0].classList[!this.settings.collapsible === true ? 'add' : 'remove']('non-collapsible'); // Add/remove `toolbar-searchfield-wrapper` class based on existence of Toolbar Parent

      this.wrapper[0].classList[this.toolbarParent ? 'add' : 'remove']('toolbar-searchfield-wrapper'); // Add test automation ids

      utils.addAttributes(this.element, this, this.settings.attributes, '', true);
      utils.addAttributes(this.wrapper, this, this.settings.attributes, 'wrapper', true); // Initially disable animations on toolbar searchfields
      // An event listener on Toolbar's `rendered` event removes these at the correct time

      if (this.toolbarParent && !this.isContainedByFlexToolbar) {
        this.element.add(this.wrapper).addClass('no-transition no-animation');
      } // Add Icon


      var icon = this.wrapper.find('.icon:not(.icon-dropdown)');

      if (!icon || !icon.length) {
        icon = $.createIconElement('search');
      } // Swap icon position to in-front if we have "context/has-categories" CSS class.


      var insertIconInFront = this.wrapper.hasClass('context') || this.wrapper.hasClass('has-categories');
      icon[insertIconInFront ? 'insertBefore' : 'insertAfter'](this.element).icon(); // Change icon to a trigger button if we're dealing with categories

      if (this.hasCategories()) {
        this.wrapper.addClass('has-categories');

        if (!this.categoryButton.length) {
          $('<button type="button" class="btn searchfield-category-button"></button>').insertBefore(this.element);
        }

        icon.appendTo(this.categoryButton);
        icon = this.categoryButton;

        if (this.settings.showCategoryText) {
          this.wrapper.addClass('show-category');
        }

        var ddIcon = icon.find('.icon-dropdown');

        if (!ddIcon.length) {
          ddIcon = $.createIconElement({
            classes: 'icon-dropdown',
            icon: 'dropdown'
          }).icon();
        }

        ddIcon.appendTo(icon);
        var popupAPI = this.categoryButton.data('popupmenu');

        if (!popupAPI) {
          this.list = this.wrapper.find('ul.popupmenu');

          if (!this.list || !this.list.length) {
            this.list = $('<ul class="popupmenu"></ul>');
          } // Handle Single vs Multi-Selectable Lists


          var categoryListType = this.settings.categoryMultiselect ? 'is-multiselectable' : 'is-selectable';
          this.list.addClass(categoryListType);
          var removeListType = 'is-selectable';

          if (!this.settings.categoryMultiselect) {
            removeListType = 'is-multiselectable';
          }

          this.list.removeClass(removeListType);
          this.setCategories(this.settings.categories);
          this.list.insertAfter(this.element);

          var _self = this;

          this.categoryButton.popupmenu({
            menu: this.list,
            offset: {
              y: 10
            },
            returnFocus: function returnFocus() {
              if (_self.isFocused) {
                _self.element.focus();
              }
            }
          });
        } else {
          this.setCategories(this.settings.categories);
        }

        this.setCategoryButtonText();
      } // Flex Toolbar Searchfields contain an extra button for use as a closing trigger


      if (this.isContainedByFlexToolbar) {
        if (!this.collapseButton || !this.collapseButton.length) {
          this.collapseButton = $("\n          <button class=\"btn-secondary collapse-button\" type=\"button\">\n            <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n              <use href=\"#icon-exit-fullview\"></use>\n            </svg>\n            <span class=\"audible\">".concat(Locale.translate('Collapse'), "</span>\n          </button>\n        "));
        }

        this.wrapper[0].classList.add('has-collapse-button');
        this.element.after(this.collapseButton);
      } else {
        this.wrapper[0].classList.remove('has-collapse-button');
      } // Pull a Go Button from markup, if applicable.


      var goButton = this.wrapper.next('.go-button');

      if (!goButton.length) {
        goButton = this.wrapper.find('.go-button');
      }

      if (goButton.length) {
        this.settings.showGoButton = true;
        this.goButton = goButton;
        this.element.after(this.goButton);
      } // Add a "Go" Button from scratch if we enable the setting


      if (this.settings.showGoButton) {
        if (!this.goButton || !this.goButton.length) {
          this.goButton = $("\n          <button class=\"btn-secondary go-button\">\n            <span>".concat(this.settings.goButtonCopy || Locale.translate('Go', {
            showBrackets: false
          }), "</span>\n          </button>\n        "));
        }

        this.goButton[0].setAttribute('id', utils.uniqueId(this.goButton, 'searchfield-go-button-'));
        this.wrapper.addClass('has-go-button');
        this.element.after(this.goButton);
      } else {
        this.wrapper.removeClass('has-go-button');
      }

      if (this.settings.clearable) {
        this.makeClearable();
      } // Stagger a calculation for setting the size of the Searchfield element, if applicable


      var self = this;
      var resizeTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          self.calculateSearchfieldWidth();
        }
      });
      renderLoop.register(resizeTimer);

      if (this.settings.collapsible === false || this.settings.collapsible === 'mobile' && breakpoints.isAbove('phone-to-tablet')) {
        this.expand(true);
      }

      return this;
    },

    /**
     * Simpler version of `adjustOnBreakpoint` for non-collapsible Toolbar Flex searchfields
     */
    simpleAdjustOnBreakpoint: function simpleAdjustOnBreakpoint() {
      if (this.shouldBeFullWidth()) {
        if (!this.isFocused) {
          this.wrapper[0].classList.remove('is-open');
        }

        return;
      }

      this.wrapper[0].classList.add('is-open');
    },

    /**
     * Makes necessary adjustments to the DOM surrounding the Searchfield element to accommodate
     * breakpoint changes.
     * @private
     * @returns {void}
     */
    adjustOnBreakpoint: function adjustOnBreakpoint() {
      // On smaller form-factor (tablet/phone)
      if (this.shouldBeFullWidth()) {
        this.wrapper.removeAttr('style');
        this.input.removeAttribute('style');

        if (this.isFocused) {
          this.appendToParent();
          this.calculateOpenWidth();
          this.setOpenWidth();

          if (this.isExpanded) {
            return;
          }

          this.expand(true);
          return;
        }

        if (this.isCurrentlyCollapsible && this.isExpanded) {
          this.collapse();
        }

        if (this.isContainedByFlexToolbar) {
          this.wrapper[0].classList.remove('is-open');
        }

        this.setInitalWidth();
        return;
      } // On larger form-factor (desktop)


      this.appendToButtonset();

      if (this.isFocused || this.settings.collapsible === 'mobile') {
        if (!this.isExpanded) {
          this.expand(true);
        }

        return;
      }

      if (this.isExpanded) {
        this.collapse();
      }

      this.setInitalWidth();
    },

    /**
     * If focused, we need to store a reference to the element with focus
     * (for example: searchfield, internal buttons, etc) because once the element
     * becomes removed from the DOM, focus is lost.
     * @private
     * @returns {void}
     */
    saveFocus: function saveFocus() {
      if (!this.isFocused) {
        return;
      }

      this.focusElem = document.activeElement;
    },

    /**
     * Restores focus to an element reference that was previously focused.
     * @private
     * @returns {void}
     */
    restoreFocus: function restoreFocus() {
      if (!this.focusElem) {
        return;
      }

      var self = this;
      var focusTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          if (!self.focusElem) {
            return;
          }

          self.focusElem.focus();
          delete self.focusElem;
        }
      });
      renderLoop.register(focusTimer);
    },

    /**
     * Appends this searchfield to the `containmentParent` element
     * Used when the small-form-factor searchfield needs to be established.
     * @private
     * @returns {void}
     */
    appendToParent: function appendToParent() {
      if (!this.containmentParent || this.wrapper.parent().is($(this.containmentParent))) {
        return;
      }

      if (this.isContainedByFlexToolbar) {
        return;
      }

      this.saveFocus();
      this.elemBeforeWrapper = this.wrapper.prev();
      $(this.containmentParent).find('.buttonset').prepend(this.wrapper);
      utils.fixSVGIcons(this.wrapper);
      this.restoreFocus();
    },

    /**
     * Removes this searchfield from the `containmentParent` element,
     * and places it back into the buttonset. Used when the small-form-factor
     * searchfield needs to be established.
     * @private
     * @returns {void}
     */
    appendToButtonset: function appendToButtonset() {
      if (!this.containmentParent || !this.wrapper.parent().is($(this.containmentParent))) {
        return;
      }

      if (this.isContainedByFlexToolbar) {
        return;
      }

      this.saveFocus();

      if (!(this.elemBeforeWrapper instanceof $) || !this.elemBeforeWrapper.length) {
        this.wrapper.prependTo($(this.buttonsetElem));
      } else {
        this.wrapper.insertAfter(this.elemBeforeWrapper);
        this.elemBeforeWrapper = null;
      }

      $(this.toolbarParent).triggerHandler('scrollup');
      utils.fixSVGIcons(this.wrapper);
      this.restoreFocus();
    },

    /**
     * Determines whether or not, when the Searchfield is expanded, the Searchfield should be placed
     *  over top of its sibling Toolbar elements, and take up 100% of its container's space.
     * @private
     * @returns {boolean} whether or not the Toolbar should be full width.
     */
    shouldBeFullWidth: function shouldBeFullWidth() {
      var header = this.wrapper.closest('.header');
      var headerCondition = false;

      if (header.length) {
        headerCondition = header.width() < breakpoints.phone;
      }

      return headerCondition || breakpoints.isBelow('phone-to-tablet');
    },

    /**
     * Determines whether or not the Searchfields should expand on the Mobile breakpoint.
     * @private
     * @returns {boolean} whether or not the searchfield should expand on mobile.
     */
    shouldExpandOnMobile: function shouldExpandOnMobile() {
      if (this.settings.collapsible === true) {
        return false;
      }

      if (this.settings.collapsible === 'mobile') {
        return true;
      }

      return this.shouldBeFullWidth();
    },

    /**
     * Set boolean value if strings
     * @private
     * @returns {void}
     */
    coerceBooleanSettings: function coerceBooleanSettings() {
      var arr = ['showAllResults', 'categoryMultiselect', 'showCategoryText', 'clearable'];
      this.settings = utils.coerceSettingsToBoolean(this.settings, arr);
    },

    /**
     * Reveals whether or not categories are active on this searchfield.
     * @returns {boolean} whether or not categories are active on this searchfield.
     */
    hasCategories: function hasCategories() {
      return this.settings.categories && $.isArray(this.settings.categories) && this.settings.categories.length > 0;
    },

    /**
     * Detects the existence of a "Go" button added to the main searchfield API
     * @returns {boolean} whether or not a "Go" button is present
     */
    hasGoButton: function hasGoButton() {
      return this.settings.showGoButton && this.goButton && this.goButton.length;
    },

    /**
     * Sets up the event-listening structure for this component instance.
     * @private
     * @returns {this} component instance
     */
    setupEvents: function setupEvents() {
      var _this = this;

      var self = this;
      self.element.on("updated.".concat(this.id), function (e, settings) {
        self.updated(settings);
      }).on("focus.".concat(this.id), function (e) {
        self.handleFocus(e);
      }).on("blur.".concat(this.id), function (e) {
        if (self.isContainedByFlexToolbar) {
          self.handleSafeBlur(e);
        }
      }).on("click.".concat(this.id), function (e) {
        self.handleClick(e);
      }).on("keydown.".concat(this.id), function (e) {
        self.handleKeydown(e);
      }).on("beforeopen.".concat(this.id), function (e, menu) {
        // propagates from Autocomplete's Popupmenu
        self.handlePopupBeforeOpen(e, menu);
      }).on("safe-blur.".concat(this.id), function () {
        // Triggered by Autocomplete
        self.handleSafeBlur();
      }).on("listclose.".concat(this.id), function () {
        // Triggered by Autocomplete
        self.handleSafeBlur();
      }).on("input.".concat(this.id), function () {
        self.checkContents();
      });
      self.wrapper.on("mouseenter.".concat(this.id), function () {
        $(this).addClass('is-hovered');
      }).on("mouseleave.".concat(this.id), function () {
        $(this).removeClass('is-hovered');
      });

      if (this.hasCategories()) {
        this.categoryButton.on("selected.".concat(this.id), function (e, anchor) {
          self.handleCategorySelected(e, anchor);
        }).on("focus.".concat(this.id), function (e) {
          self.handleCategoryFocus(e);
        }).on("blur.".concat(this.id), function () {
          self.handleSafeBlur();
        }).on("close.".concat(this.id), function () {
          // Popupmenu Close
          self.handleSafeBlur();
        }).on("beforeopen.".concat(this.id), function (e, menu) {
          // Popupmenu beforeOpen
          self.handlePopupBeforeOpen(e, menu);
        });
      }

      if (self.hasGoButton()) {
        self.goButton.on("click.".concat(this.id), function (e) {
          return self.handleGoButtonClick(e);
        }).on("click.".concat(this.id), function (e) {
          return self.handleGoButtonFocus(e);
        }).on("blur.".concat(this.id), function () {
          return self.handleSafeBlur();
        });
      }

      if (this.isCollapsible) {
        this.wrapper.on("focusin.".concat(this.id), function (e) {
          self.handleFocus(e);
        }).on("focusout.".concat(this.id), function (e) {
          self.handleBlur(e);
        }).on("keydown.".concat(this.id), function (e) {
          self.handleKeydown(e);
        }).on("collapse.".concat(this.id), function () {
          self.collapse();
        });
        $('body').on("resize.".concat(this.id), function () {
          self.adjustOnBreakpoint();
        });
        self.adjustOnBreakpoint();
      } else {
        $('body').on("resize.".concat(this.id), function () {
          self.simpleAdjustOnBreakpoint();
        });
        self.simpleAdjustOnBreakpoint();
      }

      if (this.collapseButton && this.collapseButton.length) {
        this.collapseButton.on("keydown.".concat(this.id), function (e) {
          self.collapseResponsive(e);
        }).on("click.".concat(this.id), function (e) {
          self.collapseResponsive(e);
        }).on("blur.".concat(this.id), function () {
          return self.handleSafeBlur();
        });
      }

      if (this.toolbarParent) {
        $(this.toolbarParent).on("navigate.".concat(this.id), function () {
          if (self.isFocused || !self.isCurrentlyCollapsible) {
            return;
          }

          self.collapse();
        }).on("rendered.".concat(this.id), function () {
          self.element.removeClass('no-transition no-animation');
          self.wrapper.removeClass('no-transition no-animation');
        });
      } // Insert the "view more results" link on the Autocomplete control's "populated" event


      self.element.on("beforepopulated.".concat(this.id), function (e, items) {
        if (items.length > 0) {
          if (self.settings.showAllResults) {
            self.addMoreLink();
          }
        } else {
          self.addNoneLink();
        }
      }); // Setup a listener for the Clearable behavior, if applicable

      if (self.settings.clearable) {
        self.element.on("cleared.".concat(this.id), function () {
          if (self.autocomplete) {
            self.autocomplete.closeList();
          }
        });
        self.xButton.on("blur.".concat(this.id), function (e) {
          self.handleSafeBlur(e);
        });
      } // Override the 'click' listener created by Autocomplete (which overrides the
      // default Popupmenu method) to act differntly when the More Results link is activated.


      self.element.on("listopen.".concat(this.id), function () {
        var list = $('#autocomplete-list'); // Visual indicator class

        self.wrapper.addClass('popup-is-open'); // Trigger the `allResultsCallback` if one is defined

        self.element.on("selected.".concat(_this.id), function (thisE, a, ret) {
          var isMoreLink = a.hasClass('more-results');

          if (!isMoreLink) {
            return;
          }

          var callback = self.settings.allResultsCallback;

          if (callback && typeof callback === 'function') {
            callback(ret);
          }
        }); // Override the focus event created by the Autocomplete control to make the more link
        // and no-results link blank out the text inside the input.

        list.find('.more-results, .no-results').on("focus.".concat(_this.id), function () {
          var anchor = $(this);
          list.find('li').removeClass('is-selected');
          anchor.parent('li').addClass('is-selected');
          self.element.val('');
        });
      }).on("listclose.".concat(this.id), function () {
        var list = $('#autocomplete-list');
        self.element.off("selected.".concat(_this.id));
        list.off("focus.".concat(_this.id));
      });
      return this;
    },

    /**
     * Activates a toolbar-based searchfield and keeps it "open".  Instead of closing
     * it on blur, sets up an explicit, out-of-bounds click/tap that will serve to close
     * it when the user acts.
     * @private
     * @param {boolean} force ignore any attempt to return out first
     * @param {boolean} doFocus focus the searchfield element.
     * @returns {void}
     */
    setAsActive: function setAsActive(force, doFocus) {
      var _this2 = this;

      if (!force && this.wrapper.hasClass('active')) {
        return;
      }

      this.addDocumentDeactivationEvents();
      var wrapperClasses = ['has-focus', 'active'];

      if (this.isCurrentlyCollapsible || this.isContainedByFlexToolbar) {
        this.expand(true);

        if (this.isContainedByFlexToolbar) {
          wrapperClasses.push('is-open');
        }
      } // Activate


      wrapperClasses.forEach(function (cssClass) {
        // IE11 compatibility doesn't allow for multiple arguments for `classList.add()`
        _this2.wrapper[0].classList.add(cssClass);
      });

      if (this.toolbarParent) {
        this.toolbarParent.classList.add('searchfield-active');
      }

      if (this.isExpanded) {
        return;
      }

      if (doFocus === true) {
        this.element.focus();
      }
    },

    /**
     * @returns {boolean} whether or not one of elements inside the Searchfield wrapper has focus.
     */
    get isFocused() {
      var active = document.activeElement;
      var wrapperElem = this.wrapper[0]; // If another element inside the Searchfield Wrapper is focused, the entire component
      // is considered "focused".

      if (wrapperElem.contains(active)) {
        return true;
      } // Retain focus if the autocomplete menu is focused


      if (this.autocomplete) {
        var autocompleteListElem = this.autocomplete.list;

        if (autocompleteListElem && autocompleteListElem[0].contains(active)) {
          return true;
        }
      } // Retain focus if a category is being selected from a category menu


      if (this.categoryButton && this.categoryButton.length) {
        var menu = this.categoryButton.data('popupmenu').menu;

        if (menu.has(active).length) {
          return true;
        }
      } // Clearable button


      if (this.xButton && this.xButton.length) {
        if (this.xButton.has(active).length) {
          return true;
        }
      }

      return false;
    },

    /**
     * Detects whether or not the Searchfield has focus.
     * @deprecated in v4.8.0.  Please use the `isFocused` property instead.
     * @returns {boolean} whether or not the Searchfield has focus.
     */
    hasFocus: function hasFocus() {
      warnAboutDeprecation('isFocused', 'hasFocus');
      return this.isFocused;
    },

    /**
     * Focus event handler
     * @private
     * @returns {void}
     */
    handleFocus: function handleFocus() {
      this.setAsActive(true);
    },

    /**
     * Blur event handler
     * @private
     * @returns {void}
     */
    handleBlur: function handleBlur() {
      var self = this;
      self.handleSafeBlur();
    },

    /**
     * Custom event handler for Autocomplete's `safe-blur` and `listclose` events.
     * Fired on the base element when any Autocomplete-related focusable element loses focus to
     * something outside the Autocomplete's wrapper
     * @private
     * @returns {void}
     */
    handleSafeBlur: function handleSafeBlur() {
      var self = this;

      function safeBlurHandler() {
        // Do a check for searchfield-specific elements
        if (self.isFocused) {
          return;
        }

        var wrapperElem = self.wrapper[0];
        wrapperElem.classList.remove('has-focus', 'active');
        self.removeDocumentDeactivationEvents();
        self.clearResponsiveState();

        if (self.isCurrentlyCollapsible) {
          self.collapse();
        } else if (self.isContainedByFlexToolbar) {
          self.wrapper[0].classList.remove('is-open');
        }
      } // Stagger the check for the activeElement on a timeout in order to accurately detect focus.


      if (this.blurTimer) {
        this.blurTimer.destroy(true);
      }

      this.blurTimer = new RenderLoopItem({
        duration: 1,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: safeBlurHandler
      });
      renderLoop.register(this.blurTimer);
    },

    /**
     * @private
     * @returns {void}
     */
    clearResponsiveState: function clearResponsiveState() {
      if (!this.toolbarParent) {
        return;
      }

      this.toolbarParent.classList.remove('searchfield-active');
    },

    /**
     * Click event handler
     * @private
     * @returns {void}
     */
    handleClick: function handleClick() {
      this.setAsActive();
    },

    /**
     * Sets up event listeners that need to be handled at the global (document) level, since they deal
     * with general keystrokes.
     * @private
     * @returns {void}
     */
    addDocumentDeactivationEvents: function addDocumentDeactivationEvents() {
      if (this.hasDeactivationEvents === true) {
        return;
      }

      var self = this;
      $(document).on("click.".concat(this.id), function (e) {
        self.handleOutsideClick(e);
      }).on("keydown.".concat(this.id), function (e) {
        self.handleOutsideKeydown(e);
      });
      this.hasDeactivationEvents = true;
    },

    /**
     * Removes global (document) level event handlers.
     * @private
     * @returns {void}
     */
    removeDocumentDeactivationEvents: function removeDocumentDeactivationEvents() {
      $(document).off("click.".concat(this.id, " keydown.").concat(this.id));
      this.hasDeactivationEvents = false;
    },

    /**
     * Event Handler for dealing with global (document) level clicks.
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    handleOutsideClick: function handleOutsideClick(e) {
      var target = e.target;

      if (this.isSearchfieldElement(target)) {
        return;
      }

      this.handleSafeBlur();
    },

    /**
     * Keydown event handler
     * @private
     * @param {jQuery.Event} e jQuery `keydown`
     * @returns {void}
     */
    handleKeydown: function handleKeydown(e) {
      var key = e.which;
      var keyName = e.key;

      if (key === 27 && Environment.browser.isIE11()) {
        e.preventDefault();
      }

      if (e.ctrlKey && key === 8) {
        this.element.val('');
      }

      if (key === 9) {
        // Tab
        this.handleSafeBlur();
      }

      if (this.isContainedByFlexToolbar) {
        var yKeys = ['ArrowUp', 'Up', 'ArrowDown', 'Down'];

        if (yKeys.indexOf(keyName) > -1) {
          this.collapse();
        }
      }
    },

    /**
     * Handles global (document) level keydown events that are established to help
     * collapse/de-highlight searchfields on a timer.
     * @private
     * @param {jQuery.Event} e jQuery-wrapped Keydown event
     * @returns {void}
     */
    handleOutsideKeydown: function handleOutsideKeydown(e) {
      var key = e.which;
      var target = e.target;

      if (key === 9 && !this.isSearchfieldElement(target)) {
        this.handleSafeBlur();
      }
    },

    /**
     * Modifies the menu at $('#autocomplete-list') to propagate/remove style
     *  classes on the Searchfield element.
     * @private
     * @param {jQuery.Event} e custom jQuery `beforeopen` event from the Popupmenu Component.
     * @param {jQuery[]} menu element that represents the popupmenu that is being opened.
     * @returns {boolean} the ability to cancel the menu's opening.
     */
    handlePopupBeforeOpen: function handlePopupBeforeOpen(e, menu) {
      if (this.isCollapsible && (this.isExpanding || !this.isExpanded) || !menu) {
        return false;
      }

      var contextClassMethod = this.wrapper.hasClass('context') ? 'addClass' : 'removeClass';
      var altClassMethod = this.wrapper.hasClass('alternate') ? 'addClass' : 'removeClass';
      menu[contextClassMethod]('context');
      menu[altClassMethod]('alternate');

      if (!this.isExpanded) {
        this.categoryButton.focus();
        return false;
      }

      return true;
    },

    /**
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleGoButtonClick: function handleGoButtonClick(e) {
      var action = this.settings.goButtonAction;

      if (typeof action !== 'function') {
        return undefined;
      }

      var searchfieldValue = this.element.val();
      var categorySelection;

      if (this.hasCategories()) {
        categorySelection = this.getCategoryData();
      } // gives access to the current searchfield value, and category data if applicable.


      return action(e, searchfieldValue, categorySelection);
    },

    /**
     * @private
     * @returns {void}
     */
    handleGoButtonFocus: function handleGoButtonFocus() {
      this.setAsActive(true);
    },

    /**
     * Sets the text content on the category button.  Will either display a single category
     * name, or a translated "[x] Selected." string.
     * @param {string} [textContent] Optional incoming text that will be subtituted for the
     * selected element count.
     * @returns {undefined}
     */
    setCategoryButtonText: function setCategoryButtonText(textContent) {
      if (!this.settings.showCategoryText || !this.categoryButton.length) {
        return;
      }

      var text = '';
      var button = this.wrapper.find('.btn');
      var span = button.find('span');

      if (!span || !span.length) {
        span = $('<span class="category"></span>').insertAfter(button.find('.icon').first());
      }

      span.empty(); // incoming text takes precedent

      if (typeof textContent === 'string' && textContent.length) {
        span.text(textContent.trim());
        return;
      } // Otherwise, grab currently selected categories and set text
      // (or clear, if no options are selected).


      var item = this.getSelectedCategories();

      if (!item.length) {
        return;
      }

      if (item.length > 1) {
        text = "".concat(item.length, " ").concat(Locale.translate('Selected'));
      } else {
        text = item.text().trim();
      }

      span.text(text);
    },

    /**
     * Detects whether or not an element is part of this instance of the Searchfield component
     * @private
     * @param {HTMLElement} element the element being checked.
     * @returns {boolean} whether or not the element provided is part of this Searchfield component
     */
    isSearchfieldElement: function isSearchfieldElement(element) {
      if ($.contains(this.wrapper[0], element)) {
        return true;
      } // Don't close if a category is being selected from a category menu


      if (this.categoryButton && this.categoryButton.length) {
        var menu = this.categoryButton.data('popupmenu').menu;

        if (menu.has(element).length) {
          return true;
        }
      }

      return false;
    },

    /**
     * Retrieves the distance between a left and right boundary.
     * Used on controls like Lookup, Contextual Panel, etc. to fill the space remaining in a toolbar.
     * @private
     * @param {Number|jQuery[]} leftBoundary left boundary in pixels
     * @param {Number|jQuery[]} rightBoundary right boundary in pixels
     * @returns {number} the fill size area
     */
    getFillSize: function getFillSize(leftBoundary, rightBoundary) {
      var leftBoundaryNum = 0;
      var rightBoundaryNum = 0;

      function sanitize(boundary) {
        if (!boundary) {
          return 0;
        } // Return out if the boundary is just a number


        if (!isNaN(parseInt(boundary, 10))) {
          return parseInt(boundary, 10);
        }

        if (boundary instanceof jQuery) {
          if (!boundary.length) {
            return 0;
          }

          if (boundary.is('.title')) {
            boundary = boundary.next('.buttonset');
          }

          boundary = boundary[0];
        }

        return boundary;
      }

      function getEdgeFromBoundary(boundary, edge) {
        if (!isNaN(boundary)) {
          return boundary === null || boundary === undefined ? 0 : boundary;
        }

        if (!edge || typeof edge !== 'string') {
          edge = 'left';
        }

        var edges = ['left', 'right'];

        if ($.inArray(edge, edges) === -1) {
          edge = edges[0];
        }

        var rect;

        if (boundary instanceof HTMLElement || boundary instanceof SVGElement) {
          rect = boundary.getBoundingClientRect();
        }

        return rect[edge];
      }

      leftBoundary = sanitize(leftBoundary);
      rightBoundary = sanitize(rightBoundary);

      function whichEdge() {
        var e = 'left';

        if (leftBoundary === rightBoundary || $(rightBoundary).length && $(rightBoundary).is('.buttonset')) {
          e = 'right';
        }

        return e;
      }

      leftBoundaryNum = getEdgeFromBoundary(leftBoundary);
      rightBoundaryNum = getEdgeFromBoundary(rightBoundary, whichEdge());

      if (!leftBoundaryNum && !rightBoundaryNum) {
        return TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      var distance = rightBoundaryNum - leftBoundaryNum; // TODO: Remove this once we figure out how to definitively fix the searchfield sizing.
      // Toolbar Searchfield needs a way to demand that the parent toolbar increase
      // the size of its buttonset and decrease the size of its title under this condition
      // -- currently there is no way.

      if (distance <= TOOLBARSEARCHFIELD_EXPAND_SIZE) {
        return TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      if (distance >= MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE) {
        return MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE;
      }

      return distance;
    },

    /**
     * @deprecated as of v4.26.0
     * @private
     * @returns {void}
     */
    setClosedWidth: function setClosedWidth() {
      return this.setInitalWidth();
    },

    /**
     * @private
     * @returns {void}
     */
    setOpenWidth: function setOpenWidth() {
      var subtractWidth = 0;

      if (this.wrapper[0]) {
        this.wrapper[0].style.width = this.openWidth;
      } // If the searchfield category button exists, change the width of the
      // input field on the inside to provide space for the (variable) size of the currently-selected
      // category (or categories)


      if (this.hasCategories()) {
        var categoryButtonStyle = window.getComputedStyle(this.categoryButton[0]);
        var categoryButtonWidth = this.categoryButton.width();
        var categoryButtonPadding = parseInt(categoryButtonStyle.paddingLeft, 10) + parseInt(categoryButtonStyle.paddingRight, 10);
        var categoryButtonBorder = parseInt(categoryButtonStyle.borderLeftWidth, 10) * 2;
        subtractWidth += categoryButtonWidth + categoryButtonPadding + categoryButtonBorder;
      }

      if (this.hasGoButton()) {
        var goButtonStyle = window.getComputedStyle(this.goButton[0]);
        var goButtonWidth = this.goButton.width();
        var goButtonPadding = parseInt(goButtonStyle.paddingLeft, 10) + parseInt(goButtonStyle.paddingRight, 10);
        var goButtonBorder = parseInt(goButtonStyle.borderLeftWidth, 10) * 2;
        subtractWidth += goButtonWidth + goButtonPadding + goButtonBorder;
      }

      if (subtractWidth > 0) {
        this.input.style.width = "calc(100% - ".concat(subtractWidth, "px)");
      }

      delete this.openWidth;
    },

    /**
     * @private
     * @returns {void}
     */
    calculateOpenWidth: function calculateOpenWidth() {
      var buttonset = this.element.parents('.toolbar').children('.buttonset');
      var nextElem = this.wrapper.next();
      var width;

      if (!buttonset.length) {
        return;
      } // If small form factor, use the right edge


      if (nextElem.is('.title')) {
        nextElem = buttonset;
      }

      if (this.shouldBeFullWidth()) {
        width = '100%';

        if ($(this.toolbarParent).closest('.header').length) {
          width = 'calc(100% - 40px)';
        }

        if ($(this.toolbarParent).closest('.tab-container.module-tabs').length) {
          width = 'calc(100% - 1px)';
        }

        this.openWidth = width;
        return;
      } // Figure out boundaries
      // +10 on the left boundary reduces the likelyhood that the toolbar pushes other elements
      // into the spillover menu whenever the searchfield opens.


      var leftBoundary = buttonset.offset().left + 10;
      var rightBoundary = nextElem; // If the search input sits alone, just use the other side of the buttonset to measure

      if (!rightBoundary.length) {
        rightBoundary = buttonset.offset().left + 10 + buttonset.outerWidth(true);
      }

      width = this.getFillSize(leftBoundary, rightBoundary);
      this.openWidth = "".concat(width - 6, "px");
    },

    /**
     * Ensures that the size of the Searchfield Wrapper does not change whenever a category
     * is chosen from a category searchfield.
     * NOTE: this method must be run AFTER changes to DOM elements (text/size changes) have been made.
     * @private
     */
    calculateSearchfieldWidth: function calculateSearchfieldWidth() {
      var inlineStyleProp = this.element[0].getAttribute('style');
      var baseWidth = '100%';
      var subtractWidth = 0;
      var targetWidthProp;

      if (inlineStyleProp) {
        this.element[0].removeAttribute('style');
      }

      var computedStyle = window.getComputedStyle(this.element[0]);

      if (computedStyle.width && !this.isContextSearch) {
        baseWidth = computedStyle.width;
      } // Subtract width of extraneous buttons/elems


      if (this.hasCategories()) {
        subtractWidth += this.categoryButton.outerWidth(true);
      }

      if (this.hasGoButton()) {
        subtractWidth += this.goButton.outerWidth(true);
      } // NOTE: final width can only be 100% if no value is subtracted for other elements


      if (subtractWidth > 0) {
        targetWidthProp = "calc(".concat(baseWidth, " - ").concat(subtractWidth, "px)");
      }

      if (targetWidthProp) {
        this.element[0].style.width = targetWidthProp;
      }
    },

    /**
     * Category Selection event handler
     * @private
     * @param  {object} e The event.
     * @param  {object} anchor the link object
     */
    handleCategorySelected: function handleCategorySelected(e, anchor) {
      /**
       * Fires when the searchfield has become collapsed.
       * @event selected
       * @memberof SearchField
       * @type {object}
       * @property {object} event - The jquery event object
       */
      this.element.trigger('selected', [anchor]); // Only change the text and searchfield size if we can

      if (!this.settings.showCategoryText) {
        return;
      }

      this.setCategoryButtonText(e, anchor.text().trim());
      this.calculateSearchfieldWidth();

      if (!this.settings.categoryMultiselect) {
        this.setAsActive(true, true);
      }
    },

    /**
     * Category Button Focus event handler
     * @private
     * @returns {undefined}
     */
    handleCategoryFocus: function handleCategoryFocus() {
      this.saveFocus();
      this.setAsActive(true);
    },

    /**
     * Gets a complete list of categories in jQuery-collection form.
     * @returns {jQuery} categories
     */
    getCategories: function getCategories() {
      return this.list.children('li:not(.separator)');
    },

    /**
     * Gets the currently selected list of categories in jQuery-collection form.
     * @returns {jQuery} selectedCategories
     */
    getSelectedCategories: function getSelectedCategories() {
      return this.getCategories().filter('.is-checked');
    },

    /**
     * Gets the currently selected categories as data.
     * @param {boolean} [onlyReturnSelected=false] - If set to true, will only return
     *  checked list items.
     * @returns {Object[]} data -
     * @returns {string} name - Category name
     * @returns {string|number} id - Category element's ID (if applicable)
     * @returns {string|number} value - Category element's value (if applicable)
     * @returns {boolean} [checked=true] - Category's selection status
     */
    getCategoryData: function getCategoryData(onlyReturnSelected) {
      var categories = this.getCategories();
      var data = [];
      categories.each(function () {
        var classList = this.classList;
        var checked = classList.contains('is-checked');

        if (onlyReturnSelected === true && checked === false) {
          return;
        }

        var category = {
          name: this.innerText,
          checked: checked
        };

        if (this.id) {
          category.id = this.id;
        }

        var value = this.getAttribute('data-value');

        if (value !== undefined) {
          category.value = value;
        }

        data.push(category);
      });
      return data;
    },

    /**
     * Updates just the categories setting and rerenders the category list.
     * @param {Object[]} categories - Array of category object definitions.
     * @param {string} categories[].name - Category name.
     * @param {string|number} [id] - Category element's ID (if applicable).
     * @param {string|number} [value] - Category element's value (if applicable).
     * @param {boolean} [checked=true] - Category's selection status
     * @returns {undefined}
     */
    updateCategories: function updateCategories(categories) {
      this.settings.categories = categories;
      this.setCategories(this.settings.categories);
    },

    /**
     * Creates a new set of categories on the Searchfield and rerenders it.
     * @param {Object[]} categories - Array of category object definitions.
     * @param {string} categories[].name - Category name.
     * @param {string|number} [id] - Category element's ID (if applicable).
     * @param {string|number} [value] - Category element's value (if applicable).
     * @param {boolean} [checked=true] - Category's selection status
     * @returns {undefined}
     */
    setCategories: function setCategories(categories) {
      this.list.empty();
      var self = this;
      var valueTypes = ['string', 'number'];
      var previouslySelected = false;
      categories.forEach(function (val) {
        // if passed a string, typecast to an object.
        if (typeof val === 'string') {
          val = {
            name: val
          };
        } // Object types get a bit more customization.
        // Don't continue if there's no name present.


        if (!val.name) {
          return;
        }

        var id = '';

        if (typeof val.id === 'string' && val.id.length) {
          id = " id=\"".concat(val.id, "\"");
        }

        var value = '';

        if (valueTypes.indexOf(_typeof(val.value)) > -1) {
          value = " data-value=\"".concat(val.value, "\"");
        }

        var selected = '';

        if (val.checked === true && previouslySelected !== true) {
          selected = ' class="is-checked"';

          if (!self.settings.categoryMultiselect) {
            previouslySelected = true;
          }
        }

        self.list.append("<li".concat(selected).concat(id).concat(value, "><a href=\"#\">").concat(val.name, "</a></li>"));
      });
      var api = this.categoryButton.data('popupmenu');

      if (api && typeof api.updated === 'function') {
        api.updated();
      }
    },

    /**
     * Expands the Searchfield
     * @param {boolean} [noFocus] If defined, causes the searchfield component not to become focused
     *  at the end of the expand method. Its default functionality is that it will become focused.
     * @returns {Promise} resolved when the expansion completes
     */
    expand: function expand(noFocus) {
      var _this3 = this;

      var self = this;
      var expandPromise = new Promise(function (resolve) {
        if (self.isExpanded || self.isExpanding || self.isCollapsing) {
          resolve();
          return;
        }

        var notFullWidth = !self.shouldBeFullWidth();
        self.isExpanding = true; // Places the input wrapper into the toolbar on smaller breakpoints

        if (!notFullWidth) {
          self.appendToParent();
        }

        self.wrapper.removeAttr('style');
        self.input.removeAttribute('style'); // Re-adjust the size of the buttonset element if the expanded searchfield would be
        // too large to fit.

        var buttonsetWidth = 0;

        if (self.buttonsetElem) {
          buttonsetWidth = parseInt(window.getComputedStyle(self.buttonsetElem).width, 10);
        }

        var buttonsetElemWidth = buttonsetWidth + TOOLBARSEARCHFIELD_EXPAND_SIZE;
        var containerSizeSetters = {
          buttonset: buttonsetElemWidth
        };

        if (!_this3.isContainedByFlexToolbar || breakpoints.isAbove('phone-to-tablet')) {
          _this3.wrapper[0].classList.add('is-open');
        }

        _this3.calculateOpenWidth();

        _this3.setOpenWidth(); // Some situations require adjusting the focused element


        if (!noFocus || Environment.os.name === 'ios' || self.isFocused && document.activeElement !== self.input) {
          if (self.focusElem) {
            self.focusElem = self.input;
          }

          self.input.focus();
        } // Recalculate the Toolbar Buttonset/Title sizes.


        var eventArgs = [];

        if (containerSizeSetters) {
          eventArgs.push(containerSizeSetters);
        }
        /**
         * Fires before the searchfield is expanded.
         * @event beforeexpand
         * @memberof SearchField
         * @type {object}
         * @property {object} event - The jquery event object
         */


        self.element.trigger('beforeexpand');
        $(self.toolbarParent).triggerHandler('recalculate-buttons', eventArgs);
        var expandTimer = new RenderLoopItem({
          duration: 10,
          updateCallback: function updateCallback() {},
          // TODO: make this work without an empty function
          timeoutCallback: function timeoutCallback() {
            $(self.toolbarParent).triggerHandler('recalculate-buttons', eventArgs);
            /**
             * Fires when the searchfield has become expanded.
             * @event expanded
             * @memberof SearchField
             * @type {object}
             * @property {object} event - The jquery event object
             */

            self.element.trigger('expanded');
            delete self.isExpanding;
            self.isExpanded = true;

            if (self.isCurrentlyCollapsible && !self.isFocused && !self.focusElem) {
              self.handleSafeBlur();
            }
          }
        });
        renderLoop.register(expandTimer);
      });
      return expandPromise;
    },

    /**
     * Collapses the Searchfield
     * @returns {Promise} resolved once the collapse completes
     */
    collapse: function collapse() {
      var _this4 = this;

      var self = this;
      var collapsePromise = new Promise(function (resolve) {
        if (!self.isExpanded && self.isExpanding && !self.isCollapsing) {
          resolve();
          return;
        }

        self.isCollapsing = true;
        self.wrapper.removeAttr('style'); // Puts the input wrapper back where it should be if it's been moved due to small form factors.

        self.appendToButtonset();
        self.checkContents();

        if (self.toolbarParent) {
          self.setInitalWidth();
        }

        self.clearResponsiveState();
        self.wrapper[0].classList.remove('active', 'is-open');

        if (Environment.browser.isIE11) {
          self.wrapper[0].classList.remove('is-open');
        }

        if (_this4.isContainedByFlexToolbar || !_this4.isFocused) {
          self.wrapper[0].classList.remove('has-focus');
        }

        if (self.categoryButton && self.categoryButton.length) {
          self.categoryButton.data('popupmenu').close(false, true);
        }
        /**
         * Fires before the searchfield is collapsed.
         * @event beforecollapse
         * @memberof SearchField
         * @type {object}
         * @property {object} event - The jquery event object
         */


        self.element.trigger('beforecollapse');
        delete self.isExpanded;
        delete self.isExpanding;
        var collapseTimer = new RenderLoopItem({
          duration: 10,
          updateCallback: function updateCallback() {},
          // TODO: make this work without an empty function
          timeoutCallback: function timeoutCallback() {
            delete self.isCollapsing;
            $(self.toolbarParent).triggerHandler('recalculate-buttons');
            /**
             * Fires when the searchfield has become collapsed.
             * @event collapsed
             * @memberof SearchField
             * @type {object}
             * @property {object} event - The jquery event object
             */

            self.element.trigger('collapsed');
            resolve();
          }
        });
        renderLoop.register(collapseTimer);
      });
      return collapsePromise;
    },

    /**
     * @private
     * @param {jQuery.Event} e incoming click event (driven either by keyboard or actual click)
     * @returns {void}
     */
    collapseResponsive: function collapseResponsive(e) {
      if (this.previouslyCollapsedByKey && e.type === 'click') {
        delete this.previouslyCollapsedByKey;
        return;
      } // Navigate forward unless the event has been driven by a keystroke


      var self = this;
      var dir = 1;

      if (e && !e.key) {
        dir = 0;

        if (this.toolbarFlexItem && this.toolbarFlexItem.focused) {
          dir = 1;
        }
      }

      if (e.type === 'keydown') {
        this.previouslyCollapsedByKey = true;
      } // Collapse followed by a special event trigger (gets picked up by Flex Toolbar)


      this.collapse().then(function () {
        /**
         * Fires when the searchfield has become collapsed.
         * @event collapsed-responsive
         * @memberof SearchField
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {number} dir - The direction in which the Flex Toolbar has navigated (can be 0 to stay, or 1 to navigate forward)
         */
        self.wrapper.trigger('collapsed-responsive', [dir]);
      });
    },

    /**
     * @returns {boolean} whether or not the Searchfield contains a valid value.
     */
    get hasText() {
      var value = !this.input.value ? '' : this.input.value.trim();
      return value !== '';
    },

    /**
     * Adds/removes a CSS class to the searchfield wrapper depending on whether or not the input field is empty.
     * Needed for expand/collapse scenarios, for proper searchfield resizing.
     * @private
     * @returns {void}
     */
    checkContents: function checkContents() {
      return this.wrapper[0].classList[this.hasText ? 'add' : 'remove']('has-text');
    },

    /**
     * Sets the width of the Searchfield when it closes.
     * @private
     * @returns {void}
     */
    setInitalWidth: function setInitalWidth() {
      if (!this.settings.collapsible || this.shouldBeFullWidth() || !this.hasText) {
        return;
      } // If collapsing with a search term present,
      // shrink the unfocused state to a custom-defined width instead of the default "button" size.
      // If a function is provided instead of a number, the function should eventually return a number.


      var size;

      if (this.settings.collapseSize) {
        if (typeof this.settings.collapseSize === 'function') {
          size = this.settings.collapseSize(this);
        } else {
          size = parseInt(this.settings.collapseSize, 10);
        }
      }

      if (isNaN(size)) {
        if (this.wrapper[0]) {
          this.wrapper[0].style.width = '';
        }

        return;
      } // this.wrapper.outerWidth(size);


      if (this.wrapper[0]) {
        this.wrapper[0].style.width = "".concat(size, "px");
      }
    },

    /**
     * Adds a link at the bottom of a searchfield with more than (0) results that can be used to link out to a
     * larger display of search results.
     * @private
     * @returns {void}
     */
    addMoreLink: function addMoreLink() {
      var list = $('#autocomplete-list');
      var val = this.element.val();

      if ($('.more-results', list).length > 0) {
        return;
      }

      var separator = $('<li class="separator" role="presentation"></li>').appendTo(list);
      var more = $('<li role="presentation"></li>').appendTo(list);
      this.moreLink = $('<a href="#" class="more-results" tabindex="-1" role="menuitem"></a>').html("<span>".concat(Locale.translate('AllResults'), " \"").concat(xssUtils.ensureAlphaNumericWithSpaces(val), "\"</span>")).appendTo(more);

      if (this.autocomplete.maxWidth) {
        separator.width("".concat(this.autocomplete.maxWidth, "px"));
      }
    },

    /**
     * Adds a link at the bottom of a searchfield with no results that announces no search results.
     * @private
     * @returns {void}
     */
    addNoneLink: function addNoneLink() {
      var list = $('#autocomplete-list');

      if ($('.no-results', list).length > 0) {
        return;
      }

      var none = $('<li role="presentation" class="is-placeholder"></li>').appendTo(list);
      this.noneLink = $('<a href="#" class="no-results" disabled="disabled" tabindex="-1" role="menuitem" aria-disabled="true"></a>').html("<span>".concat(Locale.translate('NoResults'), "</span>")).appendTo(none);
    },

    /**
     * Tears down and rebuilds the Searchfield. Can be called directly, but is also
     * triggered by calling the "updated.searchfield" event on the searchfield element.
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings); // `utils.mergeSettings` misses passing the empty `collapseSize` property, so we need to check for it

        if (Object.prototype.hasOwnProperty.call(settings, 'collapseSize') && settings.collapseSize === undefined) {
          this.settings.collapseSize = settings.collapseSize;
        }
      }

      this.teardown().init();
    },

    /**
     * Disables the Searchfield
     * @returns {void}
     */
    disable: function disable() {
      this.wrapper.addClass('is-disabled');
      this.element.prop('disabled', true);
    },

    /**
     * Enables the Searchfield
     * @returns {void}
     */
    enable: function enable() {
      this.wrapper.removeClass('is-disabled');
      this.element.prop('disabled', false);
    },

    /**
     * Unbinds events and removes unnecessary markup.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.element.off(["updated.".concat(this.id), "focus.".concat(this.id), "blur.".concat(this.id), "click.".concat(this.id), "keydown.".concat(this.id), "beforeopen.".concat(this.id), "input.".concat(this.id), "listopen.".concat(this.id), "listclose.".concat(this.id), "safe-blur.".concat(this.id), "selected.".concat(this.id), "populated.".concat(this.id), "cleared.".concat(this.id)].join(' '));
      this.wrapper.off(["mouseenter.".concat(this.id), "mouseleave.".concat(this.id), "focusin.".concat(this.id), "focusout.".concat(this.id), "keydown.".concat(this.id), "collapse.".concat(this.id)].join(' '));

      if (this.toolbarParent) {
        $(this.toolbarParent).off('navigate.toolbarsearchfield');
      }

      if (this.goButton && this.goButton.length) {
        this.goButton.off("click.".concat(this.id, " blur.").concat(this.id)).remove();
        delete this.goButton;
      }

      if (this.categoryButton && this.categoryButton.length) {
        this.categoryButton.off().remove();
        delete this.categoryButton;
      }

      if (this.collapseButton && this.collapseButton.length) {
        this.collapseButton.off().remove();
        delete this.collapseButton;
        delete this.previouslyCollapsedByKey;
      } // Used to determine if the "Tab" key was involved in switching focus to the searchfield.


      this.removeDocumentDeactivationEvents();
      $('body').off("resize.".concat(this.id));

      if (this.autocomplete) {
        this.autocomplete.destroy();
      }

      if (this.wrapper.hasClass('context')) {
        this.element.addClass('context');
      }

      this.element.next('.icon').remove();

      if (this.element.parent().hasClass('searchfield-wrapper')) {
        this.element.parent().find('ul').remove();
        this.element.parent().find('.icon').remove();
      }

      if (this.xButton && this.xButton.length) {
        this.xButton.off("blur.".concat(this.id));
        this.xButton.remove();
      }

      return this;
    },

    /**
     * Make the search field have an x button.
     * @public
     * @returns {void} adds 'x' button to clear the searchfield.
     */
    makeClearable: function makeClearable() {
      this.element.clearable();
      this.wrapper.addClass('has-close-icon-button');
      this.xButton = this.wrapper.children('.icon.close'); // Ignoring the close button from tabbing

      this.xButton[0].setAttribute('tabindex', '-1'); // Add test automation ids

      utils.addAttributes(this.xButton, this, this.settings.attributes, 'btn-close', true);
    },

    /**
     * Clear the search field.
     * @public
     * @returns {void} adds 'x' button to clear the searchfield.
     */
    clear: function clear() {
      if (this.xButton) {
        this.xButton.click();
      }
    },

    /**
     * Destroys the Searchfield and removes all jQuery component instancing.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$f);
    }
  };

  /**
   * jQuery Component Wrapper for SearchField
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.searchfield = function (settings) {
    return this.each(function () {
      // Normal invoke setup
      var instance = $.data(this, COMPONENT_NAME$f);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$f, new SearchField(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle, prefer-arrow-callback */

  var COMPONENT_NAME$g = 'applicationmenu';
  /**
   * The Application Menu provides access to all the functions, pages, and forms in an application.
   * @class ApplicationMenu
   * @param {object} element The element that gets the plugin established on it.
   * @param {object} [settings] The settings to use on this instance.
   * @param {string} [settings.breakpoint='phone-to-tablet'] Can be 'tablet' or 'phone-to-tablet' (+767),
   * 'phablet (+610)', 'desktop' +(1024) or 'tablet-to-desktop' (+1280). Default is 'phone-to-tablet' (767)
   * @param {boolean} [settings.dismissOnClickMobile=false] If true, causes a clicked menu option to dismiss on click when the responsive view is shown.
   * @param {boolean} [settings.filterable=false] If true a search / filter option will be added.
   * @param {boolean} [settings.filterMode='contains'] corresponds to a ListFilter component's `filterMode` for matching results.
   * @param {boolean} [settings.openOnLarge=false]  If true, will automatically open the Application Menu when a large screen-width breakpoint is met.
   * @param {array} [settings.triggers=[]]  An Array of jQuery-wrapped elements that are able to open/close this nav menu.
   */

  var APPLICATIONMENU_DEFAULTS = {
    breakpoint: 'phone-to-tablet',
    dismissOnClickMobile: false,
    filterable: false,
    filterMode: 'contains',
    openOnLarge: false,
    triggers: ['.application-menu-trigger'],
    onExpandSwitcher: null,
    onCollapseSwitcher: null
  };

  function ApplicationMenu(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, APPLICATIONMENU_DEFAULTS);
    return this.init();
  } // Plugin Methods


  ApplicationMenu.prototype = {
    /**
     * @returns {SearchField|undefined} an IDS SearchField API, if one exists.
     */
    get searchfieldAPI() {
      if (!this.searchfield || !this.searchfield.length) {
        return undefined;
      }

      return this.searchfield.data('searchfield');
    },

    /**
     * Initialize the plugin.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().handleEvents();
    },

    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      this.hasTrigger = false;
      this.isAnimating = false;

      if (this.element.find('.application-menu-footer').length) {
        this.element.addClass('has-menu-footer');
      }

      if (!this.hasTriggers()) {
        this.triggers = $();
      }

      this.menu = this.element;
      var openOnLarge = this.element.attr('data-open-on-large');
      this.settings.openOnLarge = openOnLarge !== undefined ? openOnLarge === 'true' : this.settings.openOnLarge;
      var dataBreakpoint = this.element.attr('data-breakpoint');
      this.settings.breakpoint = breakpoints[dataBreakpoint] !== undefined ? dataBreakpoint : this.settings.breakpoint; // Pull in the list of Nav Menu trigger elements and store them internally.

      this.modifyTriggers(this.settings.triggers, false, true);
      this.scrollTarget = this.menu.parents('.header');
      var masthead = this.menu.prevAll('.masthead');
      var moduleTabs = this.menu.prevAll('.module-tabs');

      if (masthead.length > 0) {
        this.scrollTarget = masthead;
        this.menu.addClass('short');
      }

      if (moduleTabs.length > 0) {
        this.scrollTarget = moduleTabs;
      }

      this.element.find('.application-menu-switcher-panel .accordion').accordion();
      this.accordion = this.menu.find('.accordion').last();
      this.accordion.addClass('panel').addClass('inverse'); // Check to make sure that the internal Accordion Control is invoked

      var accordion = this.accordion.data('accordion');

      if (!accordion) {
        this.accordion.accordion();
        accordion = this.accordion.data('accordion');
      }

      this.accordionAPI = accordion; // detect the presence of a searchfield

      this.searchfield = this.element.find('.searchfield, .searchfield-wrapper'); // Setup filtering, if applicable.

      if (this.settings.filterable && typeof $.fn.searchfield === 'function') {
        if (this.searchfield.length) {
          if (this.searchfield.is('.searchfield-wrapper')) {
            this.searchfield = this.searchfield.children('.searchfield');
          }
        } else {
          this.searchfield = $('<input id="application-menu-searchfield" class="searchfield" placeholder="Search" />').prependTo(this.element);
        }

        this.element.addClass('has-searchfield');
        var self = this;
        this.searchfield.searchfield({
          clearable: true,
          filterMode: this.settings.filterMode,
          source: function source(term, done, args) {
            done(term, self.accordion.data('accordion').toData(true, true), args);
          },
          searchableTextCallback: function searchableTextCallback(item) {
            return item.text || item.contentText || '';
          },
          resultIteratorCallback: function resultIteratorCallback(item) {
            item.highlightTarget = 'text';
            return item;
          },
          clearResultsCallback: function clearResultsCallback() {
            if (self.searchfieldAPI && !self.searchfieldAPI.isFocused) {
              self.accordionAPI.unfilter();
            }
          },
          displayResultsCallback: function displayResultsCallback(results, done, term) {
            return self.filterResultsCallback(results, done, term);
          }
        });
        this.searchfield.on("cleared.".concat(COMPONENT_NAME$g), function () {
          self.accordionAPI.unfilter();
        });
      } // Sync with application menus that have an 'is-open' CSS class.
      // Otherwise, just adjust the height.


      if (this.isOpen()) {
        this.openMenu(false, false, true);
      } else {
        this.adjustHeight();
      } // Handle Role Switcher with events and classes


      var switcherTrigger = this.element.find('.application-menu-switcher-trigger');

      if (switcherTrigger.length > 0) {
        this.switcherTrigger = switcherTrigger;
        this.switcherPanel = switcherTrigger.next('.expandable-area');
        var expandableArea = this.switcherPanel.data('expandablearea');

        if (!expandableArea) {
          this.switcherPanel.expandablearea({
            trigger: switcherTrigger
          });
        }
      }

      return this;
    },

    /**
     * Gets a reference to this Application Menu's adjacent container element.
     * @returns {jQuery[]} the adjacent container element
     */
    getAdjacentContainerElement: function getAdjacentContainerElement() {
      var container = this.element.next('.page-container');

      if (!container.length) {
        container = $('body');
      }

      return container;
    },

    /**
     * Setup click events on this.element if it's not the menu itself.
     * (this means that it's a trigger button).
     * @returns {void}
     */
    handleTriggerEvents: function handleTriggerEvents() {
      var self = this;

      function triggerClickHandler(e) {
        // Don't allow hamburger buttons that have changed state to activate/deactivate the app menu.
        if ($(e.currentTarget).find('.icon.app-header').hasClass('go-back')) {
          return false;
        }

        if (self.isAnimating) {
          return false;
        }

        var isOpen = self.menu.hasClass('is-open');

        if (!isOpen) {
          self.openMenu(undefined, true);
        } else {
          self.closeMenu(true);
        }

        return true;
      }

      if (this.triggers.length) {
        this.triggers.off('click.applicationmenu').on('click.applicationmenu', triggerClickHandler);
      }

      $(document).on('keydown.applicationmenu', function (e) {
        self.handleKeyDown(e);
      });
    },

    /**
     * Handles Keydown Events on the App Menu
     * @param {jQuery.Event} e `keydown` events
     * @returns {boolean} whether or not the keydown event was successful
     */
    handleKeyDown: function handleKeyDown(e) {
      var key = e.which;

      if (key === 121 && !e.shiftKey) {
        // F10 - opens the menu
        e.preventDefault();

        if (this.isOpen()) {
          this.closeMenu(true);

          if (this.triggers.length) {
            this.triggers.eq(0).focus();
          }
        } else {
          this.openMenu();
        }

        return false;
      }

      return true;
    },

    /**
     * Adds a visual badge-style notification to an Application Menu accordion header
     * @param {jQuery[]} anchor the anchor to target
     * @param {number} value the numeric value to attach
     * @returns {jQuery[]|undefined} a reference to the new tag markup, if applicable
     */
    notify: function notify(anchor, value) {
      if (!anchor || anchor === undefined) {
        return undefined;
      }

      if (anchor instanceof HTMLElement) {
        anchor = $(anchor);
      }

      if (!anchor.is('a')) {
        return undefined;
      }

      var tag = anchor.find('.tag'); // Close the tag if an undefined or '0' value is passed

      if (!value || value === undefined || parseInt(value, 10) === 0) {
        if (tag.length) {
          tag.remove();
        }

        return undefined;
      }

      if (!tag.length) {
        tag = $('<span class="tag"></span>').appendTo(anchor);
      }

      tag.text(value.toString());
      return tag;
    },

    /**
     * Adjusts the application menu's height to fit the page.
     * @private
     * @returns {void}
     */
    adjustHeight: function adjustHeight() {
      var isSticky = this.scrollTarget.is('.is-sticky');
      var totalHeight = this.scrollTarget.outerHeight(true);
      var offset = totalHeight - (!isSticky ? $(window).scrollTop() : 0);

      if (this.scrollTarget.prev().is('.masthead')) {
        offset += this.scrollTarget.prev().outerHeight(true);
      }

      this.menu[0].style.height = offset > 0 ? "calc(100% - ".concat(offset, "px)") : '100%';
    },

    /**
     * Toggle scroll css class on ie11.
     * @private
     * @returns {void}
     */
    toggleScrollClass: function toggleScrollClass() {
      if (Environment.browser.name === 'ie' && Environment.browser.version === '11') {
        var el = this.element[0];

        if (el && el.classList.contains('has-menu-footer')) {
          if (el.scrollHeight > el.clientHeight) {
            el.classList.add('has-scrollbar');
          } else {
            el.classList.remove('has-scrollbar');
          }
        }
      }
    },

    /**
     * Checks the window size against the defined breakpoint.
     * @private
     * @returns {boolean} whether or not the window size is larger than the
     *  settings-defined breakpoint
     */
    isLargerThanBreakpoint: function isLargerThanBreakpoint() {
      return breakpoints.isAbove(this.settings.breakpoint);
    },

    /**
     * Detects whether or not the application menu is open
     * @returns {boolean} whether or not the application menu is open
     */
    isOpen: function isOpen() {
      return this.menu[0].classList.contains('is-open');
    },

    /**
     * Detects a change in breakpoint size that can cause the Application Menu's state to change.
     * @returns {void}
     */
    testWidth: function testWidth() {
      if (this.isOpen()) {
        if (breakpoints.isAbove(this.settings.breakpoint)) {
          this.element[0].classList.remove('show-shadow');
          return;
        }

        this.element[0].classList.add('show-shadow');

        if (this.isAnimating) {
          return;
        }

        if (!this.userOpened) {
          this.closeMenu();
        }

        return;
      }

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        return;
      }

      if (this.userClosed || !this.settings.openOnLarge || this.isAnimating) {
        return;
      }

      this.openMenu(true);
    },

    /**
     * Opens the Application Menu
     * @param {boolean} noFocus If true, sets focus on the first item in the application menu.
     * @param {boolean} [userOpened] If true, notifies the component that the menu was
     *  manually opened by the user.
     * @param {boolean} [openedByClass] If true, only adjusts bare-miniumum requirements
     *  for the application menu to appear open (should be used in cases where the application
     *  menu has the `is-open` CSS appended to it via markup).  This skips events, animation, etc.
     */
    openMenu: function openMenu(noFocus, userOpened, openedByClass) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitonEndName;

      if (!openedByClass) {
        this.isAnimating = true;
      }

      this.adjustHeight();

      function isOpen() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        if (userOpened) {
          self.userOpened = true;
          self.userClosed = undefined;
        }
        /**
        * Fires the menu is opened
        *
        * @event applicationmenuopen
        * @memberof ApplicationMenu
        * @param {object} event - The jquery event object
        */


        if (!openedByClass) {
          self.isAnimating = false;
          self.element.trigger('applicationmenuopen');
          $('body').triggerHandler('resize');
        }

        self.toggleScrollClass();
        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }

      this.triggers.each(function () {
        var trig = $(this); // Update aria

        trig.attr({
          'aria-expanded': true
        });

        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          trig.find('.icon.app-header').removeClass('go-back');
          trig.trigger('icon-change');
        }
      }); // Animate the application menu open.
      // If opened by class, `is-open` is already applied to the app menu at this
      // point in the render cycle, and should not be re-applied.

      if (!openedByClass) {
        this.menu.off("".concat(transitionEnd, ".applicationmenu"));
        this.menu[0].style.display = ''; // next line forces a repaint
        // eslint-disable-next-line

        this.menu[0].offsetHeight;
        this.menu.addClass('is-open');

        if (Environment.features.touch) {
          $('body').addClass('is-open-touch');
        }
      }

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        this.menu.addClass('show-shadow');
      }

      if (!noFocus || noFocus !== true) {
        this.menu.find('.is-selected > a').focus();
      }

      if (Environment.os.name === 'ios') {
        var container = this.getAdjacentContainerElement();
        container.addClass('ios-click-target');
      }

      if (!openedByClass) {
        this.menu.one("".concat(transitionEnd, ".applicationmenu"), isOpen);
        this.timeout = setTimeout(isOpen, 300);
      } else {
        isOpen();
      } // Events that will close the nav menu
      // On a timer to prevent conflicts with the Trigger button's click events


      setTimeout(function () {
        $(document).on('click.applicationmenu', function (e) {
          if ($(e.target).parents('.application-menu').length < 1 && !self.isLargerThanBreakpoint()) {
            self.closeMenu(true);
          }
        });
      }, 0);
    },

    /**
     * Closes the Application Menu
     * @param {boolean} [userClosed] if true, sets a flag notifying the component
     *  that the user was responsible for closing.
     */
    closeMenu: function closeMenu(userClosed) {
      if (this.isAnimating === true) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      this.isAnimating = true;

      function close() {
        if (self.timeout !== null) {
          clearTimeout(self.timeout);
          self.timeout = null;
        }

        self.menu.off("".concat(transitionEnd, ".applicationmenu"));
        self.menu[0].style.display = 'none';
        self.isAnimating = false;

        if (userClosed) {
          self.userOpened = undefined;
          self.userClosed = true;
        }
        /**
        * Fires the menu is closed
        *
        * @event applicationmenuclose
        * @memberof ApplicationMenu
        * @param {object} event - The jquery event object
        */


        self.element.trigger('applicationmenuclose');
        $('body').triggerHandler('resize');
      }

      this.triggers.each(function () {
        var trig = $(this); // Update aria

        trig.attr({
          'aria-expanded': false
        });

        if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
          trig.find('.icon.app-header').removeClass('close');
          trig.find('.icon.app-header');
        }
      });

      if (Environment.os.name === 'ios') {
        var container = this.getAdjacentContainerElement();
        container.removeClass('ios-click-target');
      }

      this.menu.one("".concat(transitionEnd, ".applicationmenu"), close);
      this.timeout = setTimeout(close, 300);
      this.menu.removeClass('is-open show-shadow').find('[tabindex]');
      $(document).off('click.applicationmenu');

      if (Environment.features.touch) {
        $('body').removeClass('is-open-touch');
      }
    },

    /**
     * Detects whether or not the Application Menu has external trigger buttons setup to control it.
     * @returns {boolean} whether or not external triggers have been defined.
     */
    hasTriggers: function hasTriggers() {
      return this.triggers !== undefined && this.triggers instanceof $ && this.triggers.length;
    },

    /**
     * Externally Facing function that can be used to add/remove application nav menu triggers.
     * @param {Array[]} triggers an array of HTMLElements or jQuery-wrapped elements that
     *  will be used as triggers.
     * @param {boolean} [remove] if defined, triggers that are defined will be removed
     *  internally instead of added.
     * @param {boolean} [norebuild] if defined, this control's events won't automatically
     *  be rebound to include the new triggers.
     */
    modifyTriggers: function modifyTriggers(triggers, remove, norebuild) {
      var _this = this;

      if (!triggers || !triggers.length) {
        return;
      }

      var changed = $();
      $.each(triggers, function (i, obj) {
        changed = changed.add($(obj));
      });
      this.triggers = this.triggers[!remove ? 'add' : 'not'](changed);
      this.handleTriggerEvents(); // Setup trigger button markup

      this.triggers.each(function (i, trig) {
        var _trig$textContent;

        var $trig = $(trig);
        $trig.attr('aria-controls', 'application-menu');
        $trig.attr('aria-expanded', "".concat(_this.isOpen())); // Add accessible text about the App menu trigger's function, if applicable

        var hasText = (_trig$textContent = trig.textContent) === null || _trig$textContent === void 0 ? void 0 : _trig$textContent == null ? void 0 : _trig$textContent.length;
        var audible = $trig.find('.audible');

        if (!hasText) {
          var text = Locale.translate('AppMenuTriggerTextAlt');

          if (!audible.length) {
            trig.insertAdjacentHTML('beforeend', "<span class=\"audible\">".concat(text, "</span>"));
          } else {
            audible.text(text);
          }
        }
      });

      if (norebuild && norebuild === true) {
        return;
      }

      this.updated();
    },

    /**
     * @param {array} results list of items that passed the filtering process.
     * @param {function} done method to be called when the display of filtered items completes.
     * @param {string} term the filter term.
     * @returns {void}
     */
    filterResultsCallback: function filterResultsCallback(results, done) {
      if (!results) {
        this.accordionAPI.unfilter();
        done();
        return;
      }

      var targets = $(results.map(function (item) {
        return item.element;
      }));
      this.accordionAPI.filter(targets, true);
      this.element.triggerHandler('filtered', [results]);
      done();
    },

    /**
     * handles the Searchfield Input event
     * @param {jQuery.Event} e jQuery `input` event
     */
    handleSearchfieldInputEvent: function handleSearchfieldInputEvent() {
      if (!this.searchfield || !this.searchfield.length) {
        return;
      }

      var val = this.searchfield.val();

      if (!val || val === '') {
        var filteredParentHeaders = this.accordion.find('.has-filtered-children');
        this.accordionAPI.headers.removeClass('filtered has-filtered-children');
        this.accordionAPI.collapse(filteredParentHeaders);
        this.accordionAPI.updated();
        this.element.triggerHandler('filtered', [[]]);
      }
    },

    /**
     * @returns {void}
     */
    handleDismissOnClick: function handleDismissOnClick() {
      if (!this.settings.dismissOnClickMobile) {
        return;
      }

      this.userOpened = false;

      if (this.isLargerThanBreakpoint()) {
        return;
      }

      this.closeMenu();
    },

    /**
     * Closes the switcher panel area controlled by switcher
     */
    closeSwitcherPanel: function closeSwitcherPanel() {
      if (this.switcherPanel) {
        var expandableArea = this.switcherPanel.data('expandablearea');

        if (expandableArea) {
          expandableArea.close();

          if (this.settings.dismissOnClickMobile) {
            this.userOpened = false;

            if (this.isLargerThanBreakpoint()) {
              return;
            }

            this.closeMenu();
          }
        }
      }
    },

    /**
     * Unbinds event listeners and removes extraneous markup from the Application Menu.
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.menu.off('animateopencomplete animateclosedcomplete').removeClass('short').removeAttr('style');
      $(window).off('scroll.applicationmenu');
      $('body').off('resize.applicationmenu');
      $(document).off(['click.applicationmenu', 'open-applicationmenu', 'close-applicationmenu', 'dismiss-applicationmenu', 'keydown.applicationmenu'].join(' '));
      this.element.find('.expandable-area').off(['beforeexpand.applicationmenu', 'aftercollapse.applicationmenu', "keydown.".concat(COMPONENT_NAME$g, "-switcher")].join(' '));
      this.accordion.off(['blur.applicationmenu', 'selected.applicationmenu', 'followlink.applicationmenu', 'afterexpand.applicationmenu', 'aftercollapse.applicationmenu'].join(' '));
      this.element.find('.application-menu-toolbar').off("click.".concat(COMPONENT_NAME$g));

      if (this.accordionAPI && typeof this.accordionAPI.destroy === 'function') {
        if (this.isFiltered) {
          this.accordionAPI.collapse();
        }

        this.accordionAPI.destroy();
      }

      if (this.switcherPanel) {
        this.switcherPanel.off(['beforeexpand.applicationmenu', 'aftercollapse.applicationmenu', "afterexpand.".concat(COMPONENT_NAME$g)].join(' '));
        delete this.switcherTrigger;
        delete this.switcherPanel;
      }

      if (this.searchfield && this.searchfield.length) {
        this.searchfield.off(['input.applicationmenu', "cleared.".concat(COMPONENT_NAME$g)].join(' '));
        var sfAPI = this.searchfield.data('searchfield');

        if (sfAPI) {
          sfAPI.destroy();
        }
      }

      if (this.hasTriggers()) {
        this.triggers.off('click.applicationmenu');
      }

      return this;
    },

    /**
     * Triggers a UI Resync.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },

    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$g);
    },

    /**
     * This component fires the following events.
     * @fires Applicationmenu#events
     * @listens applicationmenuopen  Fires when the menu is opened.
     * @listens applicationmenuclose  Fires as the menu is closed.
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      this.handleTriggerEvents(); // Setup notification change events

      this.menu.on('notify.applicationmenu', function (e, anchor, value) {
        self.notify(anchor, value);
      }).on('updated.applicationmenu', function () {
        self.updated();
      }); // Fix: ie11 scrollbar causing to not calculate right height

      if (Environment.browser.name === 'ie' && Environment.browser.version === '11') {
        self.element.find('.expandable-area').on('beforeexpand.applicationmenu', function () {
          self.element[0].classList.remove('has-scrollbar');
        }).on('aftercollapse.applicationmenu', function () {
          self.toggleScrollClass();
        });
      }

      this.accordion.on('blur.applicationmenu', function () {
        self.closeMenu();
      }).on('selected.applicationmenu', function () {
        self.handleDismissOnClick();
      }).on('followlink.applicationmenu', function () {
        self.handleDismissOnClick();
      }).on('afterexpand.applicationmenu aftercollapse.applicationmenu', function () {
        self.toggleScrollClass();
      }); // If a Switcher Panel exists, handle callbacks, setup keyboard events.

      if (this.switcherPanel) {
        this.switcherPanel.on('beforeexpand.applicationmenu', function () {
          var height = _this2.element.height();

          self.element.addClass('has-open-switcher');
          self.switcherPanel.find('.content').height(height - 71); // The height of the visible header part

          if (self.settings.onExpandSwitcher) {
            self.settings.onExpandSwitcher(self, self.element, self.settings);
          } // Sets focus on the first element in the switcher panel.


          function focusElem() {
            var focusableElems = DOM.focusableElems(self.switcherPanel[0]);
            focusableElems[0].classList.remove('hide-focus');
            focusableElems[0].focus();
          }

          self.element.on("keydown.".concat(COMPONENT_NAME$g, "-switcher"), function (e) {
            var key = e.key;

            if (key === 'Escape' && self.element[0].classList.contains('has-open-switcher')) {
              e.preventDefault();
              self.closeSwitcherPanel();
            }

            if (key === 'Tab') {
              self.keyboardChangedFocus = true;
            }
          });
          self.switcherPanel.one("afterexpand.".concat(COMPONENT_NAME$g), function () {
            if (_this2.keyboardChangedFocus) {
              return;
            }

            focusElem();
          });
        }).on('aftercollapse.applicationmenu', function () {
          _this2.element.removeClass('has-open-switcher');

          if (_this2.settings.onCollapseSwitcher) {
            _this2.settings.onCollapseSwitcher(_this2, _this2.element, _this2.settings);
          }

          _this2.element.off("keydown.".concat(COMPONENT_NAME$g, "-switcher"));

          _this2.switcherPanel.off("afterexpand.".concat(COMPONENT_NAME$g));

          delete _this2.keyboardChangedFocus;
        });
      } // If application menu toolbars exist, clicking buttons on the toolbars
      // should cause the menu to close in some conditions.


      this.element.find('.application-menu-toolbar').on("click.".concat(COMPONENT_NAME$g), 'button', function (e) {
        if (e.defaultPrevented) {
          return;
        }

        _this2.handleDismissOnClick();
      });
      $(document).on('open-applicationmenu', function () {
        self.openMenu(undefined, true);
      }).on('close-applicationmenu', function () {
        self.closeMenu();
      }).on('dismiss-applicationmenu', function () {
        self.handleDismissOnClick();
      });
      $(window).on('scroll.applicationmenu', function () {
        self.adjustHeight();
      });
      $('body').on('resize.applicationmenu', function () {
        self.testWidth();
        self.toggleScrollClass();
      });

      if (this.settings.filterable === true && this.searchfield && this.searchfield.length) {
        this.searchfield.on('input.applicationmenu', function (e) {
          self.handleSearchfieldInputEvent(e);
        });
      }

      if (this.settings.openOnLarge && this.isLargerThanBreakpoint()) {
        this.menu.addClass('no-transition');
        $('.page-container').addClass('no-transition');
      }

      this.testWidth(); // Remove after initial transition

      setTimeout(function () {
        self.menu.removeClass('no-transition');
        $('.page-container').removeClass('no-transition');
      }, 800);
      return this;
    }
  };

  /**
   * jQuery component wrapper for the Application Menu
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.applicationmenu = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$g);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$g, new ApplicationMenu(this, settings));
      }

      return instance;
    });
  };

  var COMPONENT_NAME$h = 'blockgrid';
  /**
   * The Blockgrid Component displays data as selectable blocks within a simple grid.
   * @class Blockgrid
   * @param {string} element The element for the constuctor
   * @param {string} [settings] Incoming Blockgrid settings
   * @param {array} [settings.dataset=[]] An array of data objects that will be represented as blocks.
   * @param {string} [settings.selectable=false] Controls the selection mode this can be: false, 'single' or 'multiple' or 'mixed'
   * @param {boolean} paging Enable paging mode
   * @param {object} [settings.pagerSettings={}] if paging is enabled, the settings inside this object will be passed to the pager for configuration.
   * @param {number} [settings.pagerSettings.pagesize=25] Number of rows per page
   * @param {array} [settings.pagerSettings.pagesizes=[]] Array of page sizes to show in the page size dropdown.
   * @param {string|array} [settings.attributes = null] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var BLOCKGRID_DEFAULTS = {
    dataset: [],
    selectable: false,
    // false, 'single' or 'multiple' or mixed
    paging: false,
    pagerSettings: {
      pagesize: 25,
      pagesizes: [10, 25, 50, 75],
      showFirstButton: false,
      showLastButton: false
    },
    attributes: null
  }; // Moves/Converts certain settings

  function handleLegacySettings(storedSettings, incomingSettings) {
    if (!incomingSettings) {
      return storedSettings;
    } // Bypasses deep copy issues with `mergeSettings`


    if (incomingSettings.dataset) {
      storedSettings.dataset = incomingSettings.dataset;
    }

    if (incomingSettings.pagesize) {
      warnAboutDeprecation('`pagerSettings.pagesize` setting', '`pagesize` setting');
      storedSettings.pagerSettings.pagesize = incomingSettings.pagesize;
      delete storedSettings.pagesize;
    }

    if (incomingSettings.pagesizes) {
      warnAboutDeprecation('`pagerSettings.pagesizes` setting', '`pagesizes` setting');
      storedSettings.pagerSettings.pagesizes = incomingSettings.pagesizes;
      delete storedSettings.pagesizes;
    }

    return storedSettings;
  }

  function Blockgrid(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, BLOCKGRID_DEFAULTS);
    this.settings = handleLegacySettings(this.settings, settings);
    this.init();
  } // Plugin Methods


  Blockgrid.prototype = {
    /**
     * @returns {Pager|undefined} a pager API, if applicable
     */
    get pagerAPI() {
      return this.element.data('pager');
    },

    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {Blockgrid} The Component prototype, useful for chaining.
     */
    init: function init() {
      this.selectedRows = [];
      this.handlePaging();
      return this.build().handleEvents();
    },

    /**
     * Add any needed markup to the component.
     * @returns {Blockgrid} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      if (this.settings.paging) {
        this.element.empty();
      }

      this.render();
      return this;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {Blockgrid} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      this.element.on("click.".concat(COMPONENT_NAME$h), '.block', function (e) {
        var activeBlock = $(e.currentTarget);
        var target = $(e.target);
        var isCheckbox = target.is('.checkbox-label') || target.is('.checkbox');
        setTimeout(function () {
          self.select(activeBlock, isCheckbox);
        }, 0);
        e.stopPropagation();
        e.preventDefault();
      });
      this.element.on("focus.".concat(COMPONENT_NAME$h), '.checkbox', function (e) {
        var block = $(e.currentTarget).parent();
        block.addClass('has-focus');
      });
      this.element.on("blur.".concat(COMPONENT_NAME$h), '.checkbox', function (e) {
        var block = $(e.currentTarget).parent();
        block.removeClass('has-focus');
      });
      this.element.on("keypress.".concat(COMPONENT_NAME$h), '.block', function (e) {
        if (e.which !== 32) {
          return;
        }

        var activeBlock = $(e.target);
        self.select(activeBlock, false);
      });
      this.element.on("updated.".concat(COMPONENT_NAME$h), function () {
        self.updated();
      });

      if (this.pagerAPI) {
        this.element.on("page.".concat(COMPONENT_NAME$h), function () {
          _this.previousFocusedElement = true;

          _this.build();
        }).on("pagesizechange.".concat(COMPONENT_NAME$h), function () {
          _this.previousFocusedElement = true;

          _this.build();
        });
      }

      return this;
    },

    /**
     * @private
     * @returns {void}
     */
    handlePaging: function handlePaging() {
      if (!this.settings.paging) {
        return;
      }

      var pagerSettings = utils.extend({}, this.settings.pagerSettings, {
        componentAPI: this,
        dataset: this.settings.dataset
      });
      this.element.addClass('paginated');
      this.element.pager(pagerSettings);
    },

    /**
     * Run selection over a block item.
     * This method is slated to be removed in a future v4.21.0 or v5.0.0.
     * @deprecated as of v4.15.0. Please use `select()` instead.
     * @param {jQuery[]} activeBlock the jQuery-wrapped DOM element that will be selected.
     * @param {boolean} isCheckbox True if a checkbox, used for mixed mode.
     * @returns {void}
     */
    selectBlock: function selectBlock(activeBlock, isCheckbox) {
      return deprecateMethod(this.select, this.selectBlock).apply(this, [activeBlock, isCheckbox]);
    },

    /**
     * Run selection over a block item
     * @param {jQuery[]} activeBlock the jQuery-wrapped DOM element that will be selected.
     * @param {boolean} isCheckbox True if a checkbox, used for mixed mode.
     */
    select: function select(activeBlock, isCheckbox) {
      var allBlocks = this.element.find('.block');
      var allChecks = this.element.find('.checkbox');
      var activeCheckbox = activeBlock.find('.checkbox');
      var isChecked = activeCheckbox.is(':checked');
      var action = '';
      var idx = Number(activeCheckbox.data('idx'));

      if (this.settings.selectable === 'single') {
        this.selectedRows = [];
        allBlocks.removeClass('is-selected').removeAttr('aria-selected');
        allChecks.prop('checked', false);
      }

      if (this.settings.selectable === 'multiple' && isChecked || this.settings.selectable === 'mixed' && isCheckbox && isChecked) {
        activeBlock.removeClass('is-selected').removeAttr('aria-selected');
        activeCheckbox.prop('checked', false);

        for (var i = 0; i < this.selectedRows.length; i++) {
          if (idx === this.selectedRows[i].idx) {
            this.selectedRows.splice(i, 1);
          }
        }

        this.element.triggerHandler('deselected', [{
          selectedRows: this.selectedRows,
          action: 'deselect'
        }]);
        return;
      }

      if (this.settings.selectable !== false && !(this.settings.selectable === 'mixed' && !isCheckbox)) {
        if (!isChecked) {
          activeBlock.addClass('is-selected').attr('aria-selected', 'true');
          activeCheckbox.prop('checked', true);
        }

        this.selectedRows.push({
          idx: idx,
          data: this.settings.dataset[idx],
          elem: activeBlock
        });
        action = isChecked ? 'deselected' : 'selected';
      }

      if (this.settings.selectable === 'mixed' && !isCheckbox) {
        var isActivated = activeBlock.hasClass('is-activated');
        allBlocks.removeClass('is-activated');
        /**
        * Fires when a block is deactivated
        *
        * @event deactivated
        * @memberof Blockgrid
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */

        /**
        * Fires when a block is activated
        *
        * @event activated
        * @memberof Blockgrid
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */

        if (isActivated) {
          activeBlock.removeClass('is-activated');
          this.element.triggerHandler('deactivated', [{
            row: idx,
            item: this.settings.dataset[idx]
          }]);
        } else {
          activeBlock.addClass('is-activated');
          this.element.triggerHandler('activated', [{
            row: idx,
            item: this.settings.dataset[idx]
          }]);
        }

        return;
      }
      /**
      * Fires when a block is selected
      *
      * @event selected
      * @memberof Blockgrid
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */

      /**
      * Fires when a block is unselected
      *
      * @event deselected
      * @memberof Blockgrid
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */


      this.element.triggerHandler(isChecked ? 'deselected' : 'selected', [{
        selectedRows: this.selectedRows,
        action: action
      }]);
    },

    /**
     * Renders the blockgrid page.
     * @returns {void}
     */
    render: function render() {
      var _this2 = this;

      var s = this.settings;
      var selectText = Locale ? Locale.translate('Select') : 'Select';
      var blockelements = '';
      var displayedDataset = s.dataset;

      if (this.pagerAPI) {
        // If the paging information sets limits on the dataset, customize the
        // displayed dataset to fit the conditions.
        var pagerInfo = this.pagerAPI.state;

        if (pagerInfo.pages > 1) {
          var trueActivePage = pagerInfo.activePage > 0 ? pagerInfo.activePage - 1 : 0;
          var firstRecordIdx = pagerInfo.pagesize * trueActivePage;
          var lastRecordIdx = pagerInfo.pagesize * (trueActivePage + 1);
          displayedDataset = displayedDataset.slice(firstRecordIdx, lastRecordIdx); // If the dataset doesn't actually have IDs, set temporary ones for
          // tracking selected/deselected

          if (displayedDataset.length !== s.dataset.length) {
            for (var j = 0; j < displayedDataset.length; j++) {
              if (displayedDataset[j].id) {
                break;
              }

              displayedDataset[j].id = firstRecordIdx + j;
            }
          }
        }
      }

      var checkedIdxs = [];
      this.selectedRows.forEach(function (row) {
        checkedIdxs.push(row.idx);
      });

      for (var i = 0; i < displayedDataset.length; i++) {
        var data = displayedDataset[i];
        var tabindex = s.selectable === 'mixed' ? '0' : '-1';
        var selected = '';
        var checked = '';

        if (checkedIdxs.indexOf(data.id) > -1) {
          selected = ' is-selected';
          checked = ' checked';
        } // Set image alt text


        var imageAlt = data.imgAlt || data.imageAlt || "".concat(data.maintxt || data.title, " ").concat(Locale.translate('Image'));
        blockelements += "<div class=\"block is-selectable".concat(selected, "\" role=\"listitem\" tabindex=\"0\">\n        <input type=\"checkbox\" aria-hidden=\"true\" role=\"presentation\" class=\"checkbox\" id=\"checkbox").concat(i, "\" tabindex=\"").concat(tabindex, "\" data-idx=\"").concat(data.id || i, "\"").concat(checked, ">\n        <label for=\"checkbox").concat(i, "\" class=\"checkbox-label\">\n          <span class=\"audible\">").concat(selectText, "</span>\n        </label>\n        <img alt=\"").concat(imageAlt, "\" src=\"").concat(data.img || data.image, "\" class=\"image-round\">\n        <p> ").concat(data.maintxt || data.title, " <br> ").concat(data.subtxt || data.subtitle, " </p>\n      </div>");
      }

      this.element.attr('role', 'list').append(blockelements); // Add automation attributes

      if (s.attributes) {
        for (var _i = 0; _i < displayedDataset.length; _i++) {
          var checkbox = this.element.find("#checkbox".concat(_i));
          var label = this.element.find(".checkbox-label[for=\"checkbox".concat(_i, "\"]"));
          utils.addAttributes(checkbox, this, s.attributes, "blockgrid-checkbox".concat(_i));
          utils.addAttributes(label, this, s.attributes, "blockgrid-checkbox-label".concat(_i));
        }
      } // If a Blockgrid element had focus before rendering, restore focus to the first new block


      if (this.previousFocusedElement) {
        setTimeout(function () {
          _this2.element.find('.block').first().focus();

          delete _this2.previousFocusedElement;
        }, 0);
      }
    },

    /**
     * Render an individual block element.
     * This method is slated to be removed in a future v4.21.0 or v5.0.0.
     * @deprecated as of v4.15.0. Please use `render()` instead.
     * @returns {void}
     */
    renderBlock: function renderBlock() {
      return deprecateMethod(this.render, this.renderBlock).apply(this);
    },

    /**
     * Handle updated settings and values.
     * @param  {settings} settings The new settings to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.settings = handleLegacySettings(this.settings, settings);
      this.teardown();
      this.init();
      return this;
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off("updated.".concat(COMPONENT_NAME$h));
      this.element.off("click.".concat(COMPONENT_NAME$h));
      this.element.empty();
      this.selectedRows = [];
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$h);
    }
  };

  /**
   * jQuery component wrapper for the Accordion
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.blockgrid = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$h);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$h, new Blockgrid(this, settings));
      }
    });
  };

  var BREADCRUMB_ITEM_DEFAULTS = {
    attributes: null,
    callback: undefined,
    content: '',
    current: false,
    disabled: false,
    href: undefined,
    id: undefined
  };
  /**
   * Represents the current state of a single breadcrumb item.  Used internally by the IDS Breadcrumb component.
   * @class BreadcrumbItem
   * @private
   * @param {object} [settings] representing an individual breadcrumb item's properties.
   * @param {function} [settings.callback = undefined] if defined, fires a callback function when a breadcrumb item is activated.
   * @param {string} [settings.content = ''] the text/html content of the breadcrumb.
   * @param {boolean} [settings.current = false] if true, renders without a link and displays differently to indicate active status.
   * @param {boolean} [settings.disabled = false] if true, causes this breadcrumb not to be interactable.
   * @param {string} [settings.href = undefined] if defined, used as the contents of an `href` attribute.
   * @param {string} [settings.id = undefined] if defined, used as the contents of an `id` attribute.
   * @returns {this} component instance
   */

  function BreadcrumbItem(settings) {
    this.settings = utils.mergeSettings(null, settings, BREADCRUMB_ITEM_DEFAULTS);
    return this.init();
  }

  BreadcrumbItem.prototype = {
    init: function init() {
      // If an element is passed directly, scrape settings (backwards compatibility).
      if (this.settings.element instanceof HTMLElement) {
        this.getSettingsFromElement();
      }

      this.settings.callback = typeof this.settings.callback === 'function' ? this.settings.callback : null;
      this.settings.content = typeof this.settings.content === 'string' ? xssUtils.stripHTML(this.settings.content) : '';
      this.settings.current = this.settings.current === true;
      this.settings.disabled = this.settings.disabled === true;
      this.settings.id = typeof this.settings.id === 'string' ? xssUtils.stripHTML(this.settings.id) : undefined;
      this.settings.href = typeof this.settings.href === 'string' ? xssUtils.stripHTML(this.settings.href) : undefined;
      return this;
    },

    /**
     * Renders a single breadcrumb item
     * @returns {void}
     */
    render: function render() {
      var li = this.element;
      var a;
      var span;

      if (!li) {
        li = document.createElement('li');

        if (this.settings.href) {
          a = document.createElement('a');
          li.appendChild(a);
        } else {
          span = document.createElement('span');
          li.appendChild(span);
        }

        this.element = li;
      } // Base Class


      li.classList.add('breadcrumb-item');
      return li;
    },

    /**
     * Sets the current state of a single breadcrumb item
     * @returns {void}
     */
    refresh: function refresh() {
      var li = this.element;
      var a = li.querySelector('a');
      var span = li.querySelector('span:not(.audible)');
      var $a = a ? $(a) : undefined; // Disabled

      this.disabled = this.settings.disabled; // Current

      this.current = this.settings.current; // id

      (a || li).id = typeof this.settings.id === 'string' ? this.settings.id : ''; // content

      (a || span || li).innerHTML = typeof this.settings.content === 'string' ? this.settings.content : ''; // href

      if (a) {
        if (typeof this.settings.href === 'string') {
          var cleanHref = typeof this.settings.href === 'string' ? xssUtils.stripHTML(this.settings.href) : undefined;
          a.href = cleanHref;
          a.setAttribute('href', cleanHref);
        } else {
          a.href = undefined;
          a.removeAttribute('href');
        } // invoke/update IDS Hyperlink


        $a.hyperlink();
      }

      if (span) {
        if (span.parentNode.isEqualNode(li)) {
          span.classList.add('breadcrumb-text');
        }
      } // Add user-defined attributes to each breadcrumb, if applicable


      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes($a || $(li), this, this.settings.attributes);
      }

      return li;
    },

    /**
     * Set the anchor's tabIndex based on its current overflow state, if applicable
     * @private
     * @returns {void}
     */
    checkFocus: function checkFocus() {
      var a = this.a;

      if (!a) {
        return;
      }

      var isOverflowed = this.overflowed; // IE11/Edge don't implement truncated view, so never hide them due to overflow

      if (Environment.browser.isIE11 || Environment.browser.isEdge) {
        isOverflowed = false;
      }

      a.tabIndex = isOverflowed || this.disabled ? -1 : 0;
      a.setAttribute('tabindex', a.tabIndex);
    },

    /**
     * @returns {HTMLAnchorElement} reference to this breadcrumb item's anchor tag
     */
    get a() {
      return this.element.querySelector('a');
    },

    /**
     * Sets whether or not this breadcrumb is currently active.
     * @param {boolean} state whether or not this breadcrumb item is disabled
     * @returns {void}
     */
    set current(state) {
      var realState = state === true;
      this.settings.current = realState;
      this.element.classList[realState ? 'add' : 'remove']('current');
    },

    /**
     * @returns {boolean} whether or not this breadcrumb is the current one
     */
    get current() {
      return this.settings.current;
    },

    /**
     * Enables/Disables this breadcrumb item
     * @param {boolean} state whether or not this breadcrumb item is disabled
     * @returns {void}
     */
    set disabled(state) {
      var realState = state === true;
      this.settings.disabled = realState;
      this.element.classList[realState ? 'add' : 'remove']('is-disabled');
      var a = this.a;

      if (!a) {
        return;
      }

      a.disabled = realState;

      if (realState) {
        a.setAttribute('disabled', realState);
        a.setAttribute('aria-disabled', realState);
      } else {
        a.removeAttribute('disabled');
        a.removeAttribute('aria-disabled');
      }
    },

    /**
     * @returns {boolean} `true` if this Breadcrumb item is currently disabled
     */
    get disabled() {
      var _this$a;

      var aDisabled = (_this$a = this.a) === null || _this$a === void 0 ? void 0 : _this$a == null ? void 0 : _this$a.getAttribute('disabled');
      var liDisabled = this.element.getAttribute('is-disabled');
      return aDisabled || liDisabled;
    },

    /**
     * Disables the breadcrumb
     * @returns {void}
     */
    disable: function disable() {
      this.disabled = true;
    },

    /**
     * Enables the breadcrumb
     * @returns {void}
     */
    enable: function enable() {
      this.disabled = false;
    },

    /**
     * @returns {boolean} whether or not the Breadcrumb Item is pushed into overflow by the boundaries
     * of its container element.
     */
    get overflowed() {
      var li = this.element;
      var a = li.querySelector('a');
      var span = li.querySelector('span'); // Get original size first

      var elemRect = (a || span || li).getBoundingClientRect();
      var containerRect = this.element.parentNode.getBoundingClientRect();

      if (Environment.rtl) {
        return containerRect.right < elemRect.right;
      }

      return containerRect.left > elemRect.left;
    },

    /**
     * Triggers a callback function that is associated with
     * @param {jQuery.Event} e the original jQuery-wrapped 'click' event
     * @param {...object} [args] any extra number of arguments to apply to the callback
     * @returns {boolean} the callback function's returned result
     */
    callback: function callback(e) {
      if (typeof this.settings.callback !== 'function') {
        return false;
      } // Callback is run with this Breadcrumb Item's API as `this` context.


      var callbackFn = this.settings.callback;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var result = callbackFn.apply(this, [e].concat(args));

      if (!result) {
        e.preventDefault();
      }

      return result;
    },

    /**
     * @returns {Number} the current index of this breadcrumb within the parent list
     */
    get index() {
      var el = this.element;
      var i = 0;

      while (el.previousSibling !== null) {
        el = el.previousSibling;
        i++;
      }

      return i;
    },

    /**
     * Scrapes an existing HTML <li> element for breadcrumb-related settings, and saves them.
     * @returns {void}
     */
    getSettingsFromElement: function getSettingsFromElement() {
      var element = this.settings.element;
      var a = element.querySelector('a'); // Remove the "current" label if we find one

      function cleanAria(str) {
        str = str.replace('<span class="audible">Current</span>', '');
        return xssUtils.stripHTML(str);
      } // Some legacy breadcrumb items are not reprsented by a hyperlink


      if (!a) {
        this.settings.content = cleanAria(element.innerHTML);

        if (element.id) {
          this.settings.id = element.id;
        }
      } else {
        this.settings.content = cleanAria(a.innerHTML);
        this.settings.href = a.href;
        this.settings.id = a.id;
      } // Detect current by checking the list item and the anchor


      var liHasCurrent = element.classList.contains('current') === true;
      var aHasCurrent = a && a.classList.contains('current') === true;
      this.settings.current = liHasCurrent || aHasCurrent; // Disabled

      this.settings.disabled = element.classList.contains('is-disabled') === true; // Clean up reference

      this.element = element;
      this.fromElement = true;
      delete this.settings.element;
    },

    /**
     * Tears down this breadcrumb item
     * @param {boolean} [doRemove = false] if true, forces the removal of the node from the DOM.
     * @returns {void}
     */
    destroy: function destroy() {
      var doRemove = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.element || !this.element.parentNode) {
        return;
      } // If the element was auto-generated and not build from pre-existing markup,
      // destroy everything associated.


      if (!this.fromElement) {
        var a = this.a;

        if (a) {
          var $a = $(a);
          $a.off();
          $a.data('hyperlink').destroy();
        }
      } // Remove the node if it was not generated from markup,
      // or was explicitly told to remove


      if (doRemove || !this.fromElement) {
        this.element.parentNode.removeChild(this.element);
        delete this.element;
      }
    }
  }; // Breadcrumb Component Name

  var COMPONENT_NAME$i = 'breadcrumb'; // Breadcrumb Styles

  var BREADCRUMB_STYLES = ['default', 'alternate']; // Breadcrumb default settings

  var BREADCRUMB_DEFAULTS = {
    breadcrumbs: [],
    style: BREADCRUMB_STYLES[0],
    truncate: true
  };
  /**
   * IDS Breadcrumb Component.
   * Navigation Component that displays a trail of previously-accessed pages.
   * @class Breadcrumb
   * @param {HTMLElement} element the base breadcrumb element
   * @param {string} [settings] The component settings.
   * @param {array} [settings.breadcrumbs=[]] predefines breadcrumb items as plain objects.  All properties in these objects correspond to the settings available in the `BreadcrumbItem` type.
   * @param {string} [settings.style='default'] defines the style of breadcrumb this instance will render.  Can be "default" or "alternate".  Note that placing this component within a Header component has additional styles.
   * @param {boolean} [settings.truncate=true] if true, creates a "truncated" breadcrumb style that keeps all breadcrumbs on a single line.  If false, causes breadcrumbs to wrap to subsequent lines.
   * @returns {this} component instance
   */

  function Breadcrumb(element, settings) {
    if (!(element instanceof HTMLElement)) {
      throw new Error('`element` argument must be of type `HTMLElement`');
    }

    this.element = element;
    this.settings = utils.mergeSettings(element, settings, BREADCRUMB_DEFAULTS);
    this.init();
    return this;
  }

  Breadcrumb.prototype = {
    /**
     * @private
     */
    init: function init() {
      var _this = this;

      if (!Array.isArray(this.breadcrumbs)) {
        this.breadcrumbs = [];
      } // Detect existing list markup for backwards compatability.
      // If breadcrumbs are present, they are processed for settings and removed.


      var list = this.element.querySelector('ol');
      var breadcrumbs = utils.getArrayFromList(this.element.querySelectorAll('li'));

      if (list) {
        this.list = list;
      }

      if (breadcrumbs.length) {
        breadcrumbs.forEach(function (breadcrumbLi) {
          _this.add({
            element: breadcrumbLi
          });
        });
      } // Convert breadcrumbs to objects


      if (!Array.isArray(this.settings.breadcrumbs)) {
        this.settings.breadcrumbs = [];
      }

      this.settings.breadcrumbs.forEach(function (entry) {
        _this.add(entry);
      }); // Check the element for a valid style CSS class

      if (this.element.classList.contains(BREADCRUMB_STYLES[1])) {
        this.settings.style = BREADCRUMB_STYLES[1];
      } // Reset the style setting if it's not valid


      if (BREADCRUMB_STYLES.indexOf(this.settings.style) === -1) {
        this.settings.style = BREADCRUMB_STYLES[0];
      }

      this.render();
    },

    /**
     * Renders the entire breadcrumb chain
     * @private
     * @returns {void}
     */
    render: function render() {
      var _html$childNodes;

      // Build the list
      if (!this.list) {
        this.list = document.createElement('ol');
        this.element.appendChild(this.list);
      } else {
        this.teardownEvents();
        this.teardownBreadcrumbs();
      } // Build all the list items


      var html = document.createDocumentFragment();
      this.breadcrumbs.forEach(function (breadcrumb) {
        if (!breadcrumb.fromElement || !breadcrumb.element) {
          var li = breadcrumb.render();
          html.appendChild(li);
        }
      }); // Used by the popupmenu below
      // (linter doesn't like this being in the "if" block)

      function breadcrumbMoreMenuBeforeOpen(response) {
        var menuHTML = '';
        this.overflowed.forEach(function (breadcrumb, i) {
          var liDisabled = '';
          var aDisabled = '';

          if (breadcrumb.settings.disabled) {
            liDisabled = ' is-disabled';
            aDisabled = ' disabled';
          }

          var menuItemHTML = "<li class=\"".concat(liDisabled, "\">\n          <a href=\"#\" data-breadcrumb-index=\"").concat(i, "\"").concat(aDisabled, ">").concat(breadcrumb.settings.content || '', "</a>\n        </li>");
          menuHTML += menuItemHTML;
        });
        response(menuHTML);
      } // Render/Refresh an overflow button


      if (this.canDetectResize) {
        var hasoverflowBtn = this.overflowBtn;

        if (!hasoverflowBtn) {
          var overflowContainer = document.createElement('div');
          var overflowBtn = document.createElement('button');
          var overflowMenu = document.createElement('ul');
          var overflowSpan = document.createElement('span');
          overflowContainer.classList.add('breadcrumb-overflow-container');
          overflowBtn.classList.add('btn-actions');
          overflowBtn.classList.add('overflow-btn');
          overflowSpan.innerText = 'More Breadcrumbs';
          overflowSpan.classList.add('audible');
          overflowBtn.insertAdjacentHTML('afterbegin', $.createIcon({
            icon: 'more'
          }));
          overflowBtn.appendChild(overflowSpan);
          overflowContainer.appendChild(overflowBtn);
          overflowContainer.appendChild(overflowMenu);
          this.overflowContainerElem = overflowContainer;
          this.overflowBtn = overflowBtn;
          this.overflowMenu = overflowMenu;
        }

        this.element.insertBefore(this.overflowContainerElem, this.list); // Invoke popupmenu against the "More" button

        $(this.overflowBtn).popupmenu({
          menu: $(this.overflowMenu),
          beforeOpen: breadcrumbMoreMenuBeforeOpen.bind(this)
        });
      } // If markup needs to change, rebind events


      if ((_html$childNodes = html.childNodes) !== null && _html$childNodes !== void 0 && (_html$childNodes == null ? void 0 : _html$childNodes.length)) {
        this.list.appendChild(html);
      } // Add ARIA to the list container


      this.list.setAttribute('aria-label', 'Breadcrumb'); // Decorate

      this.element.classList.add('breadcrumb');
      this.list.classList.add('breadcrumb-list'); // Refresh the state of everything in the Breadcrumb list

      this.refresh();
      this.handleEvents();
    },

    /**
     * @param {object} settings representing an individual breadcrumb item's properties
     * @param {boolean} [doRender = false] if true, causes a re-render of the breadcrumb list
     * @param {boolean} [doAddToDataset = false] if true, adds the new settings object to the `settings.breadcrumbs` array
     * @returns {void}
     */
    add: function add(settings) {
      var doRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var doAddToDataset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!settings) {
        throw new Error('Settings for a new breadcrumb item must be provided.');
      }

      this.breadcrumbs.forEach(function (api) {
        if (settings.id && api.id === settings.id) {
          throw new Error('New breadcrumbs must have a unique ID attribute.');
        }
      });
      var newBreadcrumb = new BreadcrumbItem(settings);
      this.breadcrumbs.push(newBreadcrumb);

      if (doAddToDataset) {
        this.settings.breadcrumbs.push(settings);
      }

      if (doRender) {
        this.render(); // Set this one to current, if applicable

        if (newBreadcrumb.settings.current === true) {
          this.makeCurrent(newBreadcrumb);
        }
      }
    },

    /**
     * @param {BreadcrumbItem|HTMLElement|number} item an input representing a Breadcrumb API, an anchor tag linked to one, or an index number of a breadcrumb in the list.
     * @param {boolean} [doRender = false] if true, causes a re-render of the breadcrumb list
     * @param {boolean} [doRemoveFromDataset = false] if true, removes the corresponding settings object from the `settings.breadcrumbs` array
     * @returns {void}
     */
    remove: function remove(item) {
      var doRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var doRemoveFromDataset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var target = this.getBreadcrumbItemAPI(item);
      target.api.destroy(true); // Remove the API from the internal array

      this.breadcrumbs.splice(target.i, 1);

      if (doRemoveFromDataset) {
        this.settings.breadcrumbs.splice(target.i, 1);
      }

      if (doRender) {
        this.render();
      }
    },

    /**
     * Remove all breadcrumbs in the list
     * @param {boolean} [doRender = false] if true, causes the breadcrumb list to rerender
     * @param {boolean} [doResetDataset = false] if true, clears the `settings.breadcrumb` array.
     * @returns {void}
     */
    removeAll: function removeAll() {
      var doRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var doResetDataset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.breadcrumbs.forEach(function (breadcrumbAPI) {
        breadcrumbAPI.destroy(true);
      });
      this.breadcrumbs = [];

      if (doResetDataset) {
        this.settings.breadcrumbs = [];
      }

      if (doRender) {
        this.render();
      } else {
        this.refresh();
      }
    },

    /**
     * Sets a provided target breadcrumb as the "current" one, updating the rest.
     * @param {BreadcrumbItem|HTMLElement|number} item an input representing a Breadcrumb API, an anchor tag linked to one, or an index number of a breadcrumb in the list.
     * @returns {void}
     */
    makeCurrent: function makeCurrent(item) {
      var target = this.getBreadcrumbItemAPI(item);
      this.breadcrumbs.forEach(function (thisAPI) {
        var li = thisAPI.element;
        thisAPI.current = li.isEqualNode(target.api.element);
      });
    },

    /**
     * @returns {HTMLElement|undefined} representing the currently-selected breadcrumb list item
     */
    get current() {
      var api;
      var li;
      this.breadcrumbs.forEach(function (breadcrumbAPI) {
        if (!api && breadcrumbAPI.current) {
          api = breadcrumbAPI;
          li = api.element;
        }
      });
      return li;
    },

    /**
     * @param {boolean} state whether or not the component is disabled.
     * @returns {void}
     */
    set disabled(state) {
      var realState = state === true; // Add/remove a class on the container

      this.element.classList[realState ? 'add' : 'remove']('is-disabled'); // Disable/enable each one individually

      this.breadcrumbs.forEach(function (breadcrumbAPI) {
        breadcrumbAPI.disabled = realState;
      });
    },

    /**
     * Disables the entire breadcrumb list
     * @returns {void}
     */
    disable: function disable() {
      this.disabled = true;
    },

    /**
     * Enables the entire breadcrumb list
     * @returns {void}
     */
    enable: function enable() {
      this.disabled = false;
    },

    /**
     * @returns {array<BreadcrumbItem>} containing all currently-overflowed Breadcrumb items
     */
    get overflowed() {
      return this.breadcrumbs.filter(function (item) {
        return item.overflowed;
      });
    },

    /**
     * @returns {boolean} whether or not the breadcrumb list is capable of detecting a resize
     * NOTE: This allows IE11 (and other browsers that don't support ResizeObserver) to gracefully
     * degrade into a non-truncated mode.
     */
    get canDetectResize() {
      return this.settings.truncate && Environment.features.resizeObserver;
    },

    /**
     * Sets up Breadcrumb list-level events
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this; // Runs a callback associated with a breadcrumb item's anchor tag, if one's defined.

      $(this.list).on("click.".concat(COMPONENT_NAME$i), 'li', function (e) {
        var item = _this2.getBreadcrumbItemAPI(e.currentTarget);

        if (!item || !item.api) {
          return;
        }

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        item.api.callback(e, args);
      }); // Setup a resize observer for detection when truncation is enabled.
      // To prevent `ResizeObserver loop limit exceeded thrown` errors, the callback for the
      // ResizeObserver is debounced by running in a RenderLoop tick.

      if (this.canDetectResize) {
        this.previousSize = this.list.getBoundingClientRect();
        this.ro = new ResizeObserver(function () {
          // eslint-disable-line
          if (_this2.detectCheck) {
            _this2.detectCheck.destroy(true);
          }

          _this2.detectCheck = new RenderLoopItem({
            duration: 1,
            timeoutCallback: function timeoutCallback() {
              var newSize = self.list.getBoundingClientRect();

              if (newSize.width !== self.previousSize.width) {
                self.previousSize = newSize;
                self.refresh();
                delete self.detectCheck;
              }
            }
          });
          renderLoop.register(_this2.detectCheck);
        });
        this.ro.observe(this.list);
      } // Picking an item from the overflow menu should cause the original breadcrumb item's operation to occur.
      // This will either trigger the item's callback, or simply follow its `href` attribute.


      if (this.overflowBtn) {
        $(this.overflowBtn).on("selected.".concat(COMPONENT_NAME$i), function (e) {
          // First argument is the clicked item from the `popupmenu.selected` event
          var liItem = arguments.length <= 1 ? undefined : arguments[1];
          var index = liItem[0].getAttribute('data-breadcrumb-index');

          var breadcrumbAPI = _this2.overflowed[Number(index)];

          $(breadcrumbAPI.a).trigger('click');
        });
      }

      this.hasEvents = true;
    },

    /**
     * Accesses a Breadcrumb Item's API using various methods.
     * @param {BreadcrumbItem|HTMLElement|number} item the anchor/list-item to check for a Breadcrumb Item API.
     * @returns {BreadcrumbItem|undefined} a Breadcrumb Item API, if applicable.
     */
    getBreadcrumbItemAPI: function getBreadcrumbItemAPI(item) {
      var api;
      var li;
      var index;
      var compareByIndex = false; // If a breadcrumb item is passed, use that instead of searching the array.

      if (item instanceof BreadcrumbItem) {
        api = item;
        li = item.element;
        index = this.breadcrumbs.indexOf(item); // Search the breadcrumb array for a matching anchor.
      } else if (item instanceof HTMLAnchorElement) {
        li = item.parentNode;
      } else if (item instanceof HTMLLIElement) {
        li = item; // If the item is a number type, this will be used as in index number, and
        // the Breadcrumb array will be checked for an matching index instead.
      } else if (!isNaN(item) && item > -1) {
        compareByIndex = true;
        index = item;
        api = this.breadcrumbs[index];
        li = api.element;
      } // If the list item's been defined (but nothing else) grok the others


      if (li && !api && !index) {
        this.breadcrumbs.forEach(function (breadcrumbAPI, i) {
          var thisLi = breadcrumbAPI.element;

          if (thisLi.isEqualNode(li)) {
            api = breadcrumbAPI;
            index = i;
          }
        });
      }

      if (!api) {
        var matchType = compareByIndex ? 'at index ' : ' with matching HTML List Item';
        var match = compareByIndex ? index : li;
        throw new Error("No matching Breadcrumb was found by ".concat(matchType, " \"").concat(match, "\""));
      }

      return {
        api: api,
        li: li,
        i: index
      };
    },

    /**
     * Refreshes the state of the Breadcrumb list while re-rendering as little as possible.
     * @param {boolean} [doHandleEvents = false] if true, causes all events to unbind/rebind
     * @returns {void}
     */
    refresh: function refresh() {
      var doHandleEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (doHandleEvents) {
        this.teardownEvents();
      } // Refresh the state of all breadcrumb items


      this.breadcrumbs.forEach(function (breadcrumbAPI) {
        breadcrumbAPI.refresh();
      }); // Add/remove the Alternate class, if applicable

      this.element.classList[this.settings.style === 'alternate' ? 'add' : 'remove']('alternate'); // Setup truncation, if applicable
      // Truncation only occurs when the list of breadcrumbs is larger than the container

      if (this.canDetectResize) {
        this.element.classList[this.overflowed.length ? 'add' : 'remove']('truncated');
      } else {
        this.element.classList.remove('truncated');
        this.element.classList.add('no-truncate');
      } // Reset the tabindex separately (needs to be done after content renders for all breadcrumbs)


      this.breadcrumbs.forEach(function (breadcrumbAPI) {
        breadcrumbAPI.checkFocus();
      });

      if (doHandleEvents) {
        this.handleEvents();
      }
    },

    /**
     * Removes bound events and generated markup from this component, and tears down all
     * breadcrumb items.
     * @private
     * @returns {Breadcrumb} This component's API.
     */
    teardown: function teardown() {
      this.teardownEvents();
      this.teardownBreadcrumbs();
      this.breadcrumbs = [];

      if (this.overflowContainerElem) {
        var popupmenuAPI = $(this.overflowBtn).data('popupmenu');

        if (popupmenuAPI) {
          popupmenuAPI.destroy();
        }

        if (this.overflowContainerElem.parentNode) {
          this.element.removeChild(this.overflowContainerElem);
        }
      }

      return this;
    },

    /**
     * Only tears down this breadcrumb list's events.
     * @private
     * @returns {void}
     */
    teardownEvents: function teardownEvents() {
      if (!this.hasEvents) {
        return;
      }

      if (this.ro) {
        this.ro.disconnect();
        delete this.ro;
      }

      if (this.overflowBtn) {
        $(this.overflowBtn).off(["beforeopen.".concat(COMPONENT_NAME$i), "selected.".concat(COMPONENT_NAME$i)].join(' '));
      }

      $(this.list).off();
      $(this.element).off();
      delete this.hasEvents;
    },

    /**
     * Only tears down the breadcrumb items themselves.  Does not reset the internal
     * breadcrumb array.
     * @private
     * @returns {void}
     */
    teardownBreadcrumbs: function teardownBreadcrumbs() {
      this.breadcrumbs.forEach(function (breadcrumbAPI) {
        breadcrumbAPI.destroy();
      });
    },

    /**
     * Update the component with new settings.
     * @param {object} settings The settings you would like to modify.
     * @returns {Breadcrumb} This component's API.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
      return this;
    },

    /**
    * Teardown and remove any added markup and events.
    * @returns {void}
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$i);
    }
  };

  /**
   * jQuery Component Wrapper for the IDS Breadcrumb Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.breadcrumb = function jQueryBreadcrumb(settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$i);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$i, new Breadcrumb(this, settings));
      }
    });
  };

  var COMPONENT_NAME$j = 'busyindicator';
  /**
   * A Busy Indicator notifies the user that the system is processing a request, and that they must
   * wait for that request to be processed before continuing with the current task.
   * @class BusyIndicator
   * @param {object} element The plugin starting element.
   * @param {object} [settings] The settings to use.
   * @param {string} [settings.blockUI=true] makes the element that Busy Indicator is invoked on unusable while it's displayed.
   * @param {string} [settings.text=null] Custom Text To Show or Will Show Localized Loading....
   * @param {string} [settings.displayDelay=1000] Number in miliseconds to pass before the markup is displayed. If 0, displays immediately.
   * @param {boolean} [settings.timeToComplete=0] fires the 'complete' trigger at a certain timing interval. If 0, goes indefinitely.
   * @param {string} [settings.transparentOverlay=false] If true, allows the "blockUI" setting to display
   * an overlay that prevents interaction, but appears transparent instead of gray.
   * @param {string} [settings.overlayOnly=false] If true, the busy indicator will only be the overlay.
   * @param {string} [settings.attributes=null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  var BUSYINDICATOR_DEFAULTS = {
    blockUI: true,
    text: null,
    displayDelay: 1000,
    timeToComplete: 0,
    transparentOverlay: false,
    overlayOnly: false,
    attributes: null
  };

  function BusyIndicator(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BUSYINDICATOR_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  BusyIndicator.prototype = {
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');
      this.setup().handleEvents();
    },
    // Sanitize incoming option values
    setup: function setup() {
      var blockUI = this.element.attr('data-block-ui');
      var delay = this.element.attr('data-display-delay');
      var completionTime = this.element.attr('data-completion-time');
      this.blockUI = blockUI !== undefined ? blockUI : this.settings.blockUI;

      if (!this.settings.overlayOnly) {
        this.loadingText = this.settings.text ? this.settings.text : Locale.translate('Loading'); // Support updating the label while open

        if (this.label) {
          this.label.text(this.loadingText);
        }
      }

      var isDelayDefined = delay !== undefined && !isNaN(delay) && parseInt(delay, 10) > 20;
      var displayDelay = !isNaN(this.settings.displayDelay) && this.settings.displayDelay >= 20 ? this.settings.displayDelay : 20;
      this.delay = isDelayDefined ? delay : displayDelay;
      this.completionTime = completionTime !== undefined && !isNaN(completionTime) ? parseInt(completionTime, 10) : this.settings.timeToComplete;
      return this;
    },

    /**
    * Builds and starts the indicator
    * @private
    * @returns {void}
    */
    activate: function activate() {
      var self = this;

      if (self.isActive()) {
        return; // safety, don't activate this code if already active
      } // If the markup already exists don't do anything but clear


      if (this.container) {
        if (self.closeTimeout) {
          clearTimeout(self.closeTimeout);
        }

        this.label.remove();

        if (!this.settings.overlayOnly) {
          this.label = $("<span>".concat(this.loadingText, "</span>")).appendTo(this.container);

          if (this.element.is('input, .dropdown, .multiselect, .busy-xs, .busy-sm')) {
            this.label.addClass('audible');
          }
        }

        this.container.removeClass('is-hidden').trigger('afterstart');
        return;
      } // Build all the markup


      this.container = $('<div class="busy-indicator-container is-hidden"></div>').attr({
        'aria-live': 'polite',
        role: 'status'
      });
      this.loader = $('<div class="busy-indicator active"></div>').appendTo(this.container);

      if (!this.settings.overlayOnly) {
        $('<div class="bar one"></div>' + '<div class="bar two"></div>' + '<div class="bar three"></div>' + '<div class="bar four"></div>' + '<div class="bar five"></div>').appendTo(this.loader);
        this.label = $("<span>".concat(this.loadingText, "</span>")).appendTo(this.container);
      }

      var transparency = '';

      if (this.blockUI) {
        if (this.settings.transparentOverlay) {
          transparency = ' transparent';
        }

        this.originalPositionProp = this.element[0].style.position;
        var elComputedPos = window.getComputedStyle(this.element[0], null).getPropertyValue('position');

        if (elComputedPos !== 'absolute') {
          this.element[0].style.position = 'relative';
        }

        this.overlay = $("<div class=\"overlay busy is-hidden".concat(transparency, "\"></div>")).appendTo(this.element);
        this.container.addClass('blocked-ui');
      }

      if (this.label && this.element.is('.busy-xs, .busy-sm')) {
        this.label.addClass('audible');
      } // Append the markup to the page
      // Use special positioning logic for compatibility with certain controls


      if (this.element.is('input, .dropdown, .multiselect')) {
        this.element.addClass('is-loading');

        if (this.blockUI) {
          this.element.addClass('is-blocked');
        }

        if (this.label) {
          this.label.addClass('audible');
        }

        var target;

        if (this.element.is('input')) {
          target = this.element;
          this.container.insertAfter(this.isInlineLabel ? this.inlineLabel : this.element);
        } else {
          var dd = this.element.data('dropdown');
          target = dd.pseudoElem;
          this.container.appendTo(target.parent());
        }

        if (this.overlay) {
          this.overlay.insertAfter(this.container);
        }

        var rect = target.position();
        var h = target.outerHeight();
        var w = target.outerWidth();
        var elements = this.container.add(this.overlay);

        var setCssStyle = function setCssStyle(el, key, value) {
          el.style[key] = "".concat(value, "px");
        };

        for (var i = 0, l = elements.length; i < l; i++) {
          setCssStyle(elements[i], 'left', rect.left);
          setCssStyle(elements[i], 'top', rect.top);
          setCssStyle(elements[i], 'bottom', rect.bottom);
          setCssStyle(elements[i], 'right', rect.right);
          setCssStyle(elements[i], 'height', h);
          setCssStyle(elements[i], 'width', w);
        }
      } else {
        // Normal Operations
        this.container.appendTo(this.element);
      } // Fade in shortly after adding the markup to the page
      // (prevents the indicator from abruptly showing)


      setTimeout(function () {
        if (self.container) {
          self.container.removeClass('is-hidden');
        }

        if (self.overlay) {
          self.overlay.removeClass('is-hidden');
        } // Add in view from scroll parent.


        if (self.blockUI) {
          self.addScrollParent();
        }
      }, self.delay); // Lets external code know that we've successully kicked off.

      this.element.trigger('afterstart'); // Start the JS Animation Loop if IE9

      if (!$.fn.cssPropSupport('animation')) {
        self.isAnimating = true;
        self.animateWithJS();
      } // Triggers complete if the "timeToComplete" option is set.


      if (this.completionTime > 0) {
        setTimeout(function () {
          self.element.trigger('complete');
        }, self.completionTime);
      }

      utils.addAttributes(this.container, this, this.settings.attributes);
      utils.addAttributes(this.container.find('.busy-indicator.active'), this, this.settings.attributes, 'busyindicator');
      utils.addAttributes(this.container.find('span'), this, this.settings.attributes, 'text');
      utils.addAttributes(this.overlay, this, this.settings.attributes, 'overlay');
    },

    /**
     * Removes the appended markup and hides any trace of the indicator.
     * @param {boolean} fromEvent Designates the close is coming from an event (internal)
     * @returns {void}
     */
    close: function close(fromEvent) {
      var self = this;

      if (!self.isActive()) {
        return; // safety, don't try and close this if not already active
      }

      this.removeScrollParent(); // If closed from an event, fire the necessary event triggers
      // and removes the 'is-loading' CSS class.

      if (fromEvent) {
        this.element.removeClass('is-loading');
        this.element.removeClass('is-blocked');
      }

      if (this.container) {
        this.container.addClass('is-hidden');
      }

      if (this.overlay) {
        this.overlay.addClass('is-hidden');
      } // Give the indicator time to fade out before removing all of its components from view


      self.closeTimeout = setTimeout(function () {
        clearTimeout(self.closeTimeout);

        if (self.container) {
          self.container.remove();
        }

        self.container = undefined;
        self.loader = undefined;
        self.label = undefined;

        if (self.overlay) {
          self.overlay.remove();
          self.element[0].style.position = self.originalPositionProp;
          self.originalPositionProp = undefined;
        }

        self.overlay = undefined;
        self.element.trigger('aftercomplete.busyindicator');
        self.element.off('complete.busyindicator');
      }, 600);
    },

    /**
     * Browsers that don't support CSS-based animation can still show the animating Busy Indicator.
     * @private
     */
    animateWithJS: function animateWithJS() {
      var self = this;
      var bar1 = this.container.find('.bar.one');
      var bar2 = this.container.find('.bar.two');
      var bar3 = this.container.find('.bar.three');
      var bar4 = this.container.find('.bar.four');
      var bar5 = this.container.find('.bar.five');
      var t = 0;
      var interval = null; // Animation Loop

      function animate() {
        if (!self.isAnimating) {
          clearInterval(interval);
          return;
        }

        t += 1;

        if (t === 1) {
          bar1.addClass('half');
        }

        if (t === 13) {
          bar1.removeClass('half').addClass('full');
          bar2.addClass('half');
        }

        if (t === 26) {
          bar1.removeClass('full').addClass('half');
          bar2.removeClass('half').addClass('full');
          bar3.addClass('half');
        }

        if (t === 39) {
          bar1.removeClass('half');
          bar2.removeClass('full').addClass('half');
          bar3.removeClass('half').addClass('full');
          bar4.addClass('half');
        }

        if (t === 51) {
          bar2.removeClass('half');
          bar3.removeClass('full').addClass('half');
          bar4.removeClass('half').addClass('full');
          bar5.addClass('half');
        }

        if (t === 64) {
          bar3.removeClass('half');
          bar4.removeClass('full').addClass('half');
          bar5.removeClass('half').addClass('full');
        }

        if (t === 77) {
          bar4.removeClass('half');
          bar5.removeClass('full').addClass('half');
        }

        if (t === 90) {
          bar5.removeClass('half');
        }

        if (t === 103) {
          t = 0;
        }
      }

      setInterval(animate, 10);
    },

    /**
     * Adjust top position, if any of the parents is scrollable
     * @private
     * @returns {void}
     */
    addScrollParent: function addScrollParent() {
      var _this = this;

      if (this.blockUI) {
        var elem = this.element[0];
        this.scrollParent = $(this.getScrollParent(elem));
        var sElem = this.scrollParent[0];
        var height = sElem ? sElem.offsetHeight : 0;
        var elComputedPos = window.getComputedStyle(this.overlay[0], null).getPropertyValue('position');
        var isOverlayAbsolute = elComputedPos === 'absolute';

        if (height && this.container && height <= elem.offsetHeight) {
          var winHeight = window.innerHeight || document.documentElement.clientHeight;

          var isHeight = function isHeight(el) {
            return el.scrollHeight > el.clientHeight && el.clientHeight < winHeight - 60;
          };

          var loc = height / 2 - 58;

          var setTop = function setTop() {
            if (isOverlayAbsolute && _this.element.is(sElem)) {
              var scrollTop = elem.scrollTop;

              _this.overlay.css({
                top: scrollTop
              });

              _this.container.css({
                top: loc + scrollTop
              });
            } else if (utils.isInViewport(sElem) && isHeight(sElem)) {
              if (_this.container[0].offsetHeight) {
                _this.container.css({
                  top: loc + sElem.scrollTop
                });
              }
            } else {
              var loaderHeight = 85;
              var visibleHeight = 0;
              var extra = 0;
              var b = elem.getBoundingClientRect();

              if (b.top < 0) {
                var diff = b.height + b.top;
                visibleHeight = diff > winHeight ? winHeight : diff;
                extra = b.top;
              } else {
                visibleHeight = winHeight - b.top;
              }

              _this.container.css({
                top: (visibleHeight - loaderHeight) / 2 - extra
              });
            }
          };

          setTop();
          this.scrollParent.off('scroll.parent.busyindicator').on('scroll.parent.busyindicator', function () {
            if (_this.container) {
              setTop();
            }
          });
        }
      }
    },

    /**
     * Remove scroll parent.
     * @private
     * @returns {void}
     */
    removeScrollParent: function removeScrollParent() {
      if (this.scrollParent) {
        this.scrollParent.off('scroll.parent.busyindicator');
        delete this.scrollParent;
      }
    },

    /**
     * Get if any of the parents is scrollable.
     * @private
     * @param {object} elem to get scroll parent.
     * @returns {object} the scroll parent.
     */
    getScrollParent: function getScrollParent(elem) {
      var properties = ['overflow', 'overflow-x', 'overflow-y'];

      var style = function style(el, prop) {
        return getComputedStyle(el, null).getPropertyValue(prop);
      };

      var styleMerged = function styleMerged(el) {
        return properties.reduce(function (a, b) {
          return a + style(el, b);
        }, 0);
      };

      var regex = /(auto|scroll)/;

      var isScroll = function isScroll(el) {
        return regex.test(styleMerged(el));
      };

      var scrollParent = function scrollParent(el) {
        var found = false;
        var parent = el;

        while (!found && parent && parent.tagName && parent.tagName.toLowerCase() !== 'body') {
          if (isScroll(parent)) {
            found = true;
            break;
          }

          parent = parent.parentNode;
        }

        return found ? parent : null;
      };

      return scrollParent(elem);
    },

    /**
     * Update the component and apply current settings.
     * @param {object} settings the settings to update to.
     * @returns {this} component instance.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      return this.setup();
    },

    /**
     * Returns if the indicator is active or not.
     * @returns {boolean} If the busy indicator is active.
     */
    isActive: function isActive() {
      if (this.container) {
        return this.container.children('.busy-indicator').is('.active');
      }

      return false;
    },

    /**
     * Teardown and remove any added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.removeScrollParent();
      this.close(true);
      this.element.off('start.busyindicator complete.busyindicator afterstart.busyindicator aftercomplete.busyindicator updated.busyindicator');
      $.removeData(this.element[0], COMPONENT_NAME$j);
    },
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      /**
      *  Fires when the indicator starts / shows.
      *
      * @event start
      * @memberof BusyIndicator
      * @param {object} event - The jquery event object.
      */

      self.element.on('start.busyindicator', function (e) {
        e.stopPropagation();

        _this2.activate();
      }).on('afterstart.busyindicator', function () {
        /**
         * Fires when the indicator is "started"
         *
         * @event complete
         * @memberof BusyIndicator
         * @param {object} event - The jquery event object.
         * @param {object} ui - The dialog object
         */
        _this2.element.on('complete.busyindicator', function (e) {
          e.stopPropagation();

          _this2.close(true);
        });
      })
      /**
      * Sync the UI/Settings. Fx chnaging the text in the DOM.
      * @event updated
      * @memberof BusyIndicator
      * @param {object} event - The jquery event object.
      */
      .on('updated.busyindicator', function () {
        _this2.close(true);

        _this2.updated();
      });
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for the BusyIndicator
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.busyindicator = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$j);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$j, new BusyIndicator(this, settings));
      }
    });
  };

  var charts = {}; // Reference to the tooltip

  charts.tooltip = {};
  charts.isIE = Environment.browser.name === 'ie';
  charts.isIEEdge = Environment.browser.name === 'edge';
  /**
   * Get the current height and width of the tooltip.
   * @private
   * @param  {string} content The tooltip content.
   * @returns {object} Object with the height and width.
   */

  charts.tooltipSize = function tooltipSize(content) {
    DOM.html(this.tooltip.find('.tooltip-content'), content, '*');
    return {
      height: this.tooltip.outerHeight(),
      width: this.tooltip.outerWidth()
    };
  };
  /**
   * Format the value based on settings.
   * @private
   * @param  {object} data The data object.
   * @param  {object} settings The sttings to use
   * @returns {string} the formatted string.
   */


  charts.formatToSettings = function formatToSettings(data, settings) {
    var d = data.data ? data.data : data;
    var percentValue = settings.formatter && settings.formatter !== '.0f' ? d3.format(settings.formatter)(d.percent) : "".concat(isNaN(d.percentRound) ? 0 : d.percentRound, "%");

    if (settings.show === 'value') {
      return settings.formatter ? d3.format(settings.formatter)(d.value) : d.value;
    }

    if (settings.show === 'label') {
      return d.name;
    }

    if (settings.show === 'label (percent)') {
      return "".concat(d.name, " (").concat(percentValue, ")");
    }

    if (settings.show === 'label (value)') {
      return "".concat(d.name, " (").concat(settings.formatter ? d3.format(settings.formatter)(d.value) : d.value, ")");
    }

    if (settings.show === 'percent') {
      return percentValue;
    }

    if (typeof settings.show === 'function') {
      return settings.show(d);
    }

    return d.value;
  };
  /**
  * Add Toolbar to the page.
  * @private
  * @param {string} extraClass class to add (needed for pie)
  * @returns {void}
  */


  charts.appendTooltip = function appendTooltip(extraClass) {
    var _this = this;

    this.tooltip = $('#svg-tooltip');

    if (this.tooltip.length === 0) {
      extraClass = extraClass ? " ".concat(extraClass) : '';
      this.tooltip = $("<div id=\"svg-tooltip\" class=\"tooltip right is-hidden".concat(extraClass, "\">\n      <div class=\"arrow\"></div>\n        <div class=\"tooltip-content\">\n          <p><b>32</b> Element</p>\n        </div>\n      </div>")).appendTo('body');

      if (this.isTouch) {
        this.tooltip[0].style.pointerEvents = 'auto';
        this.tooltip.on('touchend.svgtooltip', function () {
          _this.hideTooltip();
        });
      }
    }
  };
  /**
   * Hide the visible tooltip.
   * @private
   * @returns {void}
   */


  charts.hideTooltip = function hideTooltip() {
    var _this2 = this;

    d3.select('#svg-tooltip').classed('is-personalizable', false).classed('is-hidden', true).style('left', '-999px'); // Remove scroll events

    $('body, .scrollable').off('scroll.chart-tooltip', function () {
      _this2.hideTooltip();
    });
  };
  /**
   * Remove the tooltip from the DOM
   * @private
   * @returns {void}
   */


  charts.removeTooltip = function removeTooltip() {
    if (this.tooltip && this.tooltip.remove) {
      this.tooltip.remove();
    }
  };
  /**
   * The color sequences to use across charts
   * @private
   * @returns {array} The list of colors in the current theme in a range for charts.
   */


  charts.colorRange = function () {
    var palette = theme.themeColors().palette;

    if (theme.uplift) {
      return [palette.azure['80'].value, palette.turquoise['40'].value, palette.amethyst['60'].value, palette.graphite['40'].value, palette.amber['40'].value, palette.emerald['70'].value, palette.ruby['60'].value, palette.azure['30'].value, palette.amber['70'].value, palette.graphite['60'].value, palette.turquoise['60'].value, palette.emerald['90'].value, palette.amethyst['30'].value, palette.azure['50'].value, palette.ruby['30'].value, palette.amethyst['80'].value, palette.emerald['30'].value, palette.turquoise['80'].value, palette.graphite['20'].value, palette.amber['90'].value];
    }

    return [palette.azure['70'].value, palette.turquoise['30'].value, palette.amethyst['30'].value, palette.graphite['60'].value, palette.amber['50'].value, palette.emerald['60'].value, palette.ruby['60'].value, palette.azure['30'].value, palette.amber['90'].value, palette.turquoise['80'].value, palette.ruby['20'].value, palette.graphite['50'].value, palette.emerald['50'].value, palette.azure['50'].value, palette.amethyst['80'].value, palette.emerald['30'].value, palette.turquoise['50'].value, palette.amber['70'].value, palette.graphite['20'].value, palette.azure['20'].value];
  };

  charts.colorNameRange = function () {
    if (theme.uplift) {
      return ['azure08', 'turquoise04', 'amethyst06', 'graphite04', 'amber04', 'emerald07', 'ruby06', 'azure03', 'amber07', 'graphite06', 'turquoise06', 'emerald09', 'amethyst03', 'azure05', 'ruby03', 'amethyst08', 'emerald03', 'turquoise08', 'graphite02', 'amber09'];
    }

    return ['azure07', 'turquoise03', 'amethyst03', 'graphite06', 'amber05', 'emerald06', 'ruby06', 'azure03', 'amber09', 'turquoise08', 'ruby02', 'graphite05', 'emerald05', 'amethyst03', 'azure05', 'amethyst08', 'emerald03', 'turquoise06', 'amber07', 'graphite02'];
  };
  /**
   * Calculate and return the correct color to use. Fx
   * error, alert, alertYellow, good, neutral or hex.
   * @private
   * @param  {number} i The line/bar object index.
   * @param  {string} chartType The type of chart.
   * @param  {object} data The data for this element.
   * @returns {string} The hex code
   */


  charts.chartColor = function chartColor(i, chartType, data) {
    var themeColors = charts.colorRange();
    var specifiedColor = data && data.color ? data.color : null; // Handle passed in colors.

    if (specifiedColor) {
      if (specifiedColor === 'error') {
        return theme.themeColors().status.danger.value;
      }

      if (specifiedColor === 'alert') {
        return theme.themeColors().status.warning.value;
      }

      if (specifiedColor === 'alertYellow') {
        return theme.themeColors().status.caution.value;
      }

      if (specifiedColor === 'good') {
        return theme.themeColors().status.success.value;
      }

      if (specifiedColor === 'neutral') {
        return theme.themeColors().palette.graphite['30'].value;
      }

      if (specifiedColor && specifiedColor.indexOf('#') === 0) {
        return data.color;
      }
    } // Some configuration by specific chart types


    if (/^(pie|donut)$/.test(chartType)) {
      return themeColors[i];
    }

    if (/^(bar-single|column-single)$/.test(chartType)) {
      return themeColors[0];
    }

    if (/^(bar|bar-stacked|bar-grouped|bar-normalized|line|scatterplot|column-stacked|column-grouped|column-positive-negative)$/.test(chartType)) {
      return themeColors[i];
    }

    return '';
  };

  charts.chartColorName = function chartColor(i, chartType, data) {
    var specifiedColor = data && data.color ? data.color : null; // Handle passed in colors.

    if (specifiedColor) {
      if (specifiedColor === 'error') {
        return 'alert01';
      }

      if (specifiedColor === 'alert') {
        return 'alert02';
      }

      if (specifiedColor === 'alertYellow') {
        return 'alert03';
      }

      if (specifiedColor === 'good') {
        return 'alert04';
      }

      if (specifiedColor === 'neutral') {
        return 'graphite03';
      }

      if (specifiedColor && specifiedColor.indexOf('#') === 0) {
        return data.color;
      }
    } // Some configuration by specific chart types


    if (/^(pie|donut)$/.test(chartType)) {
      return this.colorNameRange()[i];
    }

    if (/^(bar-single|column-single)$/.test(chartType)) {
      return this.colorNameRange()[0];
    }

    if (/^(bar|bar-stacked|bar-grouped|bar-normalized|line|scatterplot|column-stacked|column-grouped|column-positive-negative)$/.test(chartType)) {
      return this.colorNameRange()[i];
    }

    return '';
  };
  /**
   * Show Tooltip
   * @private
   * @param  {number} x The x position.
   * @param  {number} y The y position.
   * @param  {string} content The tooltip contents.
   * @param  {string} arrow The arrow direction.
   * @param  {object} customCss Some custom tooltip css settings.
   */


  charts.showTooltip = function (x, y, content, arrow, customCss) {
    var _customCss$tooltip,
        _customCss$arrow,
        _this3 = this;

    // Simple Collision of left side
    if (x < 0) {
      x = 2;
    }

    this.tooltip[0].style.left = "".concat(x, "px");
    this.tooltip[0].style.top = "".concat(y, "px");
    DOM.html(this.tooltip.find('.tooltip-content'), content, '*');
    this.tooltip.removeClass('bottom top left right').addClass(arrow);
    this.tooltip.css('max-width', (customCss === null || customCss === void 0 ? void 0 : (_customCss$tooltip = customCss == null ? void 0 : customCss.tooltip) === null || _customCss$tooltip === void 0 ? void 0 : _customCss$tooltip == null ? void 0 : _customCss$tooltip.maxWidth) || '');
    this.tooltip.find('.arrow').css('left', (customCss === null || customCss === void 0 ? void 0 : (_customCss$arrow = customCss == null ? void 0 : customCss.arrow) === null || _customCss$arrow === void 0 ? void 0 : _customCss$arrow == null ? void 0 : _customCss$arrow.left) || '');
    this.tooltip.removeClass('is-hidden'); // Hide the tooltip when the page scrolls.

    $('body').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function () {
      _this3.hideTooltip();
    });
    $('.scrollable').off('scroll.chart-tooltip').on('scroll.chart-tooltip', function () {
      _this3.hideTooltip();
    });
  };
  /**
   * Add the legend to the Chart Container.
   * @private
   * @param  {array} series The groups series object.
   * @param  {string} chartType The type of chart.
   * @param  {object} settings The chart setting
   * @param  {object} container The dom container.
   * @returns {void}
   */


  charts.addLegend = function (series, chartType, settings, container) {
    var i;

    if (series.length === 0) {
      return;
    }

    var isTwoColumn = series[0].display && series[0].display === 'twocolumn';
    var legend = isTwoColumn ? $("<div class=\"chart-legend ".concat(series[0].placement ? "is-".concat(series[0].placement) : 'is-bottom', "\"></div>")) : $('<div class="chart-legend"></div>');

    if ((chartType === 'pie' || chartType === 'donut') && settings.showMobile) {
      legend = $('<div class="chart-legend"><div class="container"></div></div>');
    } // Legend width


    var width = 0;
    var currentWidth;

    for (i = 0; i < series.length; i++) {
      currentWidth = series[i].name ? series[i].name.length * 6 : 6;
      width = series[i].name && currentWidth > width ? currentWidth : width;
    }

    width += 55;
    var widthPercent = width / $(container).width() * 100;

    for (i = 0; i < series.length; i++) {
      var _series$i, _series$i$data;

      if (!series[i].name) {
        continue; // eslint-disable-line
      }

      var extraClass = '';

      if (isTwoColumn || series[i].display && series[i].display === 'block') {
        extraClass += ' lg';
      }

      if (settings.type === 'column-positive-negative' && series[i].option) {
        extraClass += " ".concat(series[i].option);
      }

      var seriesLine = "<span class=\"chart-legend-item".concat(extraClass, "\" tabindex=\"0\"></span>");
      var hexColor = charts.chartColor(i, chartType || (series.length === 1 ? 'bar-single' : 'bar'), series[i]);
      var colorName = charts.chartColorName(i, chartType || (series.length === 1 ? 'bar-single' : 'bar'), series[i]);
      var color = '';

      if (colorName.substr(0, 1) === '#') {
        color = $('<span class="chart-legend-color"></span>');

        if (!series[i].pattern) {
          color.css('background-color', hexColor);
        }
      } else {
        color = $("<span class=\"chart-legend-color ".concat(series[i].pattern ? '' : colorName, "\"></span>"));
      }

      if (chartType === 'scatterplot') {
        color = $('<span class="chart-legend-color"></span>');
      }

      var textBlock = $("<span class=\"chart-legend-item-text\">".concat(xssUtils.stripTags(series[i].name), "</span>"));

      if (series[i].pattern) {
        color.append("<svg width=\"12\" height=\"12\"><rect height=\"12\" width=\"12\" mask=\"url(#".concat(series[i].pattern, ")\"/></svg>"));
        color.find('rect').css('fill', hexColor);
      }

      if (series[i].percent) {
        var pct = $('<span class="chart-legend-percent"></span>').text(series[i].percent);
        textBlock.append(pct);
      }

      if (series[i].display && series[i].display === 'block') {
        seriesLine = "<span class=\"chart-legend-item".concat(extraClass, "\" tabindex=\"0\"></span>");
      }

      if (isTwoColumn) {
        if (widthPercent > 45 && settings.legendPlacement !== 'right') {
          seriesLine = "<span class=\"chart-legend-item".concat(extraClass, "\" tabindex=\"0\"></span>");
        } else {
          seriesLine = "<span class=\"chart-legend-item".concat(extraClass, " is-two-column\" tabindex=\"0\" ></span>");
        }
      }

      seriesLine = $(seriesLine);
      seriesLine.append(color, textBlock);
      utils.addAttributes(seriesLine, series[i], (_series$i = series[i]) === null || _series$i === void 0 ? void 0 : (_series$i$data = _series$i == null ? void 0 : _series$i.data) === null || _series$i$data === void 0 ? void 0 : _series$i$data == null ? void 0 : _series$i$data.attributes, 'legend');

      if ((chartType === 'pie' || chartType === 'donut') && settings.showMobile) {
        legend.find('.container').append(seriesLine);
      } else {
        legend.append(seriesLine);
      }

      if (series[i].display && series[i].display === 'block' || isTwoColumn && widthPercent > 45 && settings.legendPlacement !== 'right') {
        seriesLine.css({
          float: 'none',
          display: 'block',
          margin: '0 auto',
          width: "".concat(width, "px")
        });
      } // Add shapes


      if (chartType === 'scatterplot') {
        self.svg = d3.select(color[0]).append('svg').attr('width', '24').attr('height', '24').append('path').attr('class', 'symbol').attr('transform', 'translate(10, 10)').attr('d', d3.symbol().size('80').type(function () {
          return d3.symbols[i];
        })) //eslint-disable-line
        .style('fill', hexColor);
      } // Change text of legend depends of the width


      if (innerWidth <= 480 && series[i].data && series[i].data.legendAbbrName) {
        textBlock.replaceWith("<span class=\"chart-legend-item-text\">".concat(series[i].data.legendAbbrName, "</span>"));
      }

      if (innerWidth >= 481 && innerWidth <= 768 && series[i].data && series[i].data.legendShortName) {
        textBlock.replaceWith("<span class=\"chart-legend-item-text\">".concat(series[i].data.legendShortName, "</span>"));
      }
    }

    if (legend instanceof $) {
      legend.on('click.chart', '.chart-legend-item', function () {
        charts.handleElementClick(this, series, settings);
      }).on('keypress.chart', '.chart-legend-item', function (e) {
        if (e.which === 13 || e.which === 32) {
          charts.handleElementClick(this, series, settings);
        }
      });
      $(container).append(legend);
    }
  };
  /**
   * Helper Function to Select from legend click
   * @private
   * @param {object} line The element that was clicked.
   * @param {array} series The data series.
   * @param {object} settings [description]
   */


  charts.handleElementClick = function (line, series, settings) {
    var _settings$svg;

    var api = $(settings === null || settings === void 0 ? void 0 : (_settings$svg = settings == null ? void 0 : settings.svg) === null || _settings$svg === void 0 ? void 0 : _settings$svg == null ? void 0 : _settings$svg.node()).closest('.chart-container').data('chart');
    var noTrigger = api === null || api === void 0 ? void 0 : api == null ? void 0 : api.initialSelectCall;
    var idx = $(line).index();
    var elem = series[idx];
    var selector;

    if (settings.type === 'radar') {
      selector = d3.select(settings.svg.selectAll('.chart-radar-area').nodes()[idx]);
    }

    if (settings.type === 'pie' || settings.type === 'donut') {
      selector = d3.select(settings.svg.selectAll('.slice').nodes()[idx]);
    } else if (/positive-negative/.test(settings.type)) {
      if (!elem.option || elem.option && elem.option === 'target') {
        selector = settings.svg.select('.target-bar');
      } else {
        selector = settings.svg.select(".bar.".concat(elem.option));
      }
    } else if (['column', 'bar', 'bar-stacked', 'bar-grouped', 'bar-normalized', 'column-grouped', 'column-stacked', 'column-positive-negative', 'positive-negative'].indexOf(settings.type) !== -1) {
      // Grouped or singlular
      if (settings.isGrouped || settings.isSingle) {
        selector = settings.svg.select(".series-".concat(idx));
      } else if (settings.isStacked && !settings.isSingle) {
        // Stacked
        var thisGroup = d3.select(settings.svg.selectAll(settings.type === 'bar' || settings.type === 'bar-stacked' || settings.type === 'bar-normalized' ? '.series-group' : '.g').nodes()[idx]); // eslint-disable-line

        selector = thisGroup.select('.bar');
      }
    }

    if (['radar', 'pie', 'donut', 'column', 'bar', 'bar-stacked', 'bar-grouped', 'bar-normalized', 'column-grouped', 'column-stacked', 'column-positive-negative', 'positive-negative'].indexOf(settings.type) !== -1) {
      charts.clickedLegend = true;
      selector.dispatch('click');
    }

    if (elem.selectionObj) {
      charts.selectElement(d3.select(elem.selectionObj.nodes()[idx]), elem.selectionInverse, elem.data, undefined, settings.dataset, noTrigger); // eslint-disable-line
    }
  }; // The selected array for this instance.


  charts.selected = [];
  /**
   * Delete all `selected` keys/value from given dataset.
   * @private
   * @param  {array} dataset  The data object
   * @returns  {void}
   */

  charts.clearSelected = function (dataset) {
    if (dataset) {
      var deleteSelected = function deleteSelected(obj) {
        if (Object.prototype.hasOwnProperty.call(obj, 'selected')) {
          delete obj.selected;
        }
      };

      var clear = function clear(ds) {
        if (Array.isArray(ds)) {
          ds.forEach(function (node) {
            deleteSelected(node);

            if (node.data) {
              clear(node.data);
            }
          });
        }

        deleteSelected(ds);
      };

      clear(dataset);
    }
  };
  /**
   * Select the element and fire the event, make the inverse selector opace.
   * @private
   * @param  {object} element The DOM element
   * @param  {object} inverse The opposite selection.
   * @param  {array} data  The data object
   * @param  {object} container  The DOM object
   * @param  {array} dataset  The dataset object
   * @param  {boolean} noTrigger  if true will not trigger
   */


  charts.selectElement = function (element, inverse, data, container, dataset, noTrigger) {
    var isSelected = element.node() && element.classed('is-selected');
    charts.clearSelected(dataset);

    if (!isSelected) {
      data.selected = true;
    }

    var triggerData = [{
      elem: element.nodes(),
      data: !isSelected ? data : {}
    }];
    inverse.classed('is-selected', false).classed('is-not-selected', !isSelected);
    element.classed('is-not-selected', false).classed('is-selected', !isSelected);
    charts.selected = $.isEmptyObject(triggerData[0].data) ? [] : triggerData; // Fire Events

    if (!noTrigger) {
      $(container).triggerHandler('selected', [triggerData]);
    }
  };
  /**
   * Style bars as selected or unselected
   * TODO: Refactor into individual components;
   * @private
   * @param  {object} o The object to handle.
   */


  charts.setSelectedElement = function (o) {
    var dataset = o.dataset;
    var isPositiveNegative = /positive-negative/.test(o.type);
    var isBar = /^(bar|bar-stacked|bar-grouped|bar-normalized)$/.test(o.type);
    var isTypePie = o.type === 'pie' || o.type === 'donut';
    var isTypeColumn = /^(column|column-grouped|column-stacked|column-positive-negative|positive-negative)$/.test(o.type);
    var svg = o.svg;
    var isSingle = o.isSingle;
    var isGrouped = o.isGrouped;
    var isStacked = o.isStacked;
    var taskSelected = o.task === 'selected';
    var selector = d3.select(o.selector);
    var isPositive = selector.classed('positive');
    var ticksX = o.svg.selectAll('.axis.x .tick');
    var ticksY = o.svg.selectAll('.axis.y .tick');
    var pnPositiveText = o.svg.selectAll('.bartext.positive, .target-bartext.positive');
    var pnNegativeText = o.svg.selectAll('.bartext.negative, .target-bartext.negative');
    var pnTargetText = o.svg.selectAll('.target-bartext.positive, .target-bartext.negative');
    var thisGroup = d3.select(o.selector.parentNode);
    var thisGroupId = parseInt(thisGroup.node() ? thisGroup.attr('data-group-id') : 0, 10);
    var triggerData = [];
    var selectedBars = [];
    var thisData;

    if (isStacked || isTypePie) {
      dataset = dataset || null;
    } else {
      dataset = dataset && dataset[thisGroupId] ? dataset[thisGroupId].data || dataset[thisGroupId] : null;
    }

    ticksX.style('font-weight', 'normal');
    ticksY.style('font-weight', 'normal');
    pnPositiveText.style('font-weight', 'normal');
    pnNegativeText.style('font-weight', 'normal');
    svg.selectAll('.is-selected').classed('is-selected', false);
    charts.clearSelected(o.dataset);

    if (isTypePie) {
      svg.selectAll('.is-not-selected').classed('is-not-selected', false);
    }

    if (isPositiveNegative) {
      if (Object.prototype.hasOwnProperty.call(o.dataset[0], 'targetBarsSelected')) {
        delete o.dataset[0].targetBarsSelected;
      }
    } // Task make selected


    if (taskSelected) {
      svg.selectAll('.bar, .target-bar').style('opacity', 0.6); // By legends only

      if (charts.clickedLegend && !isTypePie) {
        if (isPositiveNegative) {
          if (o.isTargetBar) {
            o.svg.selectAll('.target-bar').classed('is-selected', true).style('opacity', 1);
            pnTargetText.style('font-weight', 'bolder');
            o.dataset[0].targetBarsSelected = true;
          } else {
            o.svg.selectAll(isPositive ? '.bar.positive, .target-bar.positive' : '.bar.negative, .target-bar.negative').classed('is-selected', true).style('opacity', 1);
            (isPositive ? pnPositiveText : pnNegativeText).style('font-weight', 'bolder');
          }

          svg.selectAll('.bar').each(function (d, i) {
            var bar = d3.select(this);

            if (bar.classed('is-selected')) {
              var bardata = dataset ? dataset[i] : d;
              bardata.selected = true;
              selectedBars.push({
                elem: bar.node(),
                bardata: bardata
              });
            }
          });
          triggerData = selectedBars;
        } else if (isTypeColumn || isBar) {
          // Grouped and stacked only -NOT singular-
          if (isGrouped || isSingle) {
            o.svg.selectAll('.series-' + o.i).classed('is-selected', true).style('opacity', 1); //eslint-disable-line
          } else {
            thisGroup.classed('is-selected', true).selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          svg.selectAll('.bar.is-selected').each(function (d, i) {
            var bar = d3.select(this);
            thisData = o.dataset;

            if (!thisData) {
              thisData = d;
            }

            if (isBar && !isStacked) {
              if (isGrouped) {
                thisData = o.dataset[i].data[o.i];
              } else {
                if (thisData[i][o.i]) {
                  thisData = thisData[i][o.i];
                }

                if (thisData[o.i] && thisData[o.i][i]) {
                  thisData = thisData[o.i][i];
                }

                if (thisData[i] && thisData[i][o.i]) {
                  thisData = thisData[i][o.i];
                }
              }
            } else if (isStacked && !isSingle) {
              if (thisData[thisGroupId] && thisData[thisGroupId].data[i]) {
                thisData = thisData[thisGroupId].data[i];
              }

              if (isBar) {
                o.dataset[thisGroupId].selected = true;
              }
            } else {
              if (thisData[i].data[o.i]) {
                thisData = thisData[i].data[o.i];
              }

              if (thisData[o.i] && thisData[o.i].data[i]) {
                thisData = thisData[o.i].data[i];
              }

              if (thisData[i] && thisData[i].data[o.i]) {
                thisData = thisData[i].data[o.i];
              }
            }

            thisData.selected = true;
            selectedBars.push({
              elem: bar.node(),
              data: thisData
            });
          });
          triggerData = selectedBars;
        }
      } else if (isSingle && isStacked && isTypeColumn) {
        // Single and stacked only -NOT grouped-
        thisData = dataset[0] && dataset[0].data ? dataset[0].data : o.d;
        selector.classed('is-selected', true).style('opacity', 1);
        triggerData.push({
          elem: selector.nodes(),
          data: thisData[o.i]
        });
      } else if ((isSingle || isGrouped) && !isStacked && (isTypeColumn || isBar)) {
        // Single or groups only -NOT stacked-
        svg.selectAll("".concat(isTypeColumn ? '.axis.x' : '.axis.y', " .tick:nth-child(").concat((isGrouped ? thisGroupId : o.i) + 2, ")")).style('font-weight', 'bolder');
        selector.classed('is-selected', true).style('opacity', 1);

        if (isPositiveNegative) {
          var thisIndex = o.isTargetBar ? o.i : o.i - o.dataset[0].data.length;
          svg.select(".target-bar.series-".concat(thisIndex)).classed('is-selected', true).style('opacity', 1);
          svg.select(".bar.series-".concat(thisIndex)).classed('is-selected', true).style('opacity', 1);
          d3.select(svg.selectAll('.bartext').nodes()[thisIndex]).style('font-weight', 'bolder');
          d3.select(svg.selectAll('.target-bartext').nodes()[thisIndex]).style('font-weight', 'bolder');
        }

        if (isGrouped || isPositiveNegative || isTypeColumn) {
          if (!isPositiveNegative && !isTypeColumn || isTypeColumn && isGrouped) {
            thisGroup.classed('is-selected', true).selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          thisGroup.selectAll('.bar').each(function (d, i) {
            var bar = d3.select(this);

            if (bar.classed('is-selected')) {
              var data = dataset ? dataset[i] : d;
              data.selected = true;
              selectedBars.push({
                elem: bar.node(),
                data: data
              });
            }
          });

          if (isGrouped) {
            triggerData.push({
              groupIndex: thisGroupId,
              groupElem: thisGroup.nodes()[0],
              //eslint-disable-line
              groupItems: selectedBars
            });
          } else {
            triggerData = selectedBars;
          }
        }
      } else if (isTypeColumn || isBar) {
        // Stacked Only
        svg.selectAll("".concat(isTypeColumn ? '.axis.x' : '.axis.y', " .tick:nth-child(").concat(o.i + 2, ")")).style('font-weight', 'bolder');
        svg.selectAll(".bar:nth-child(".concat(o.i + 1, ")")).classed('is-selected', true).style('opacity', 1);
        svg.selectAll('.bar.is-selected').each(function (d, i) {
          var bar = d3.select(this);
          var data = d;

          if (dataset) {
            data = isBar && isStacked && typeof dataset[i][o.i] !== 'undefined' ? dataset[i][o.i] : dataset[i].data[o.i];
          }

          data.selected = true;
          selectedBars.push({
            elem: bar.node(),
            data: data
          });
        });
        triggerData = selectedBars;
      } else if (isTypePie) {
        // Pie
        // Unselect selected ones
        svg.selectAll('.slice').classed('is-selected', false).classed('is-not-selected', true).attr('transform', '');
        var thisArcData = dataset && dataset[0] && dataset[0].data ? //eslint-disable-line
        dataset[0].data[o.i] : o.d ? o.d.data : o.d; //eslint-disable-line

        thisArcData = thisArcData || {};
        thisArcData.selected = true;
        selector.classed('is-selected', true).classed('is-not-selected', false).attr('transform', 'scale(1.025, 1.025)');
        triggerData.push({
          elem: selector.nodes(),
          data: thisArcData,
          index: o.i
        });
      }
    } else {
      // Task make unselected
      svg.selectAll('.bar, .target-bar').style('opacity', 1);
      pnPositiveText.style('font-weight', 'bolder');
      pnNegativeText.style('font-weight', 'bolder');

      if (isTypePie) {
        selector.classed('is-selected', false).style('stroke', '#fff').style('stroke-width', '1px').attr('transform', '');
      }
    }

    if (charts.clickedLegend) {
      charts.clickedLegend = false;
    }

    charts.selected = triggerData;

    if (o.isTrigger) {
      $(o.container).triggerHandler(taskSelected ? 'selected' : 'unselected', [triggerData]);
    }
  };
  /**
   * Set the select element based on provided options and fire the events.
   * @private
   * @param {object} o An object with various
   * @param {boolean} isToggle If the select is a toggle of the state
   * @param {object} internals An object passing in chart internals
  */


  charts.setSelected = function (o, isToggle, internals) {
    if (!o) {
      return;
    }

    var selected = 0;
    var equals = utils.equals;
    var legendsNode = internals.isPie ? internals.svg.node().nextSibling : internals.svg.node().parentNode.nextSibling;
    var legends = d3.select(legendsNode);
    var isLegends = legends.node() && legends.classed('chart-legend');
    var barIndex;
    var selector;
    var isStackedGroup;
    var xGroup;

    var setSelectedBar = function setSelectedBar(g) {
      var isGroup = !!g;
      g = isGroup ? d3.select(g) : internals.svg;
      g.selectAll('.bar').each(function (d, i) {
        if (!d) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === d[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, internals.chartData[d.index].data[i]) || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            barIndex = i;

            if (isGroup && !internals.isStacked) {
              isStackedGroup = true;
            }
          }
        }
      });
    };

    var setSelectedGroup = function setSelectedGroup() {
      var groups = internals.svg.selectAll('.series-group');

      if (groups.nodes().length) {
        groups.each(function () {
          setSelectedBar(this);
        });
      }
    };

    if (internals.isGrouped || internals.isStacked && !internals.isSingle) {
      internals.chartData.forEach(function (d, i) {
        //eslint-disable-line
        if (selected < 1) {
          xGroup = $(internals.svg.select('[data-group-id="' + i + '"]').node()); //eslint-disable-line

          if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i || o.data && equals(o.data, d) || o.elem && xGroup.is(o.elem)) {
            if (typeof o.fieldName === 'undefined' && typeof o.fieldValue === 'undefined' && typeof o.index === 'undefined') {
              selected++;
              selector = internals.svg.select('[data-group-id="' + i + '"]').select('.bar'); //eslint-disable-line

              barIndex = i;

              if (internals.isStacked && !internals.isGrouped) {
                isStackedGroup = true;
              }
            }
          }
        }
      });

      if (selected < 1) {
        setSelectedGroup();
      }
    } else {
      setSelectedBar();
    }

    if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
      if (isStackedGroup) {
        if (isLegends) {
          $(legends.selectAll('.chart-legend-item').nodes()[barIndex]).trigger('click.chart');
        }
      } else {
        selector.on('click').call(selector.node(), selector.datum(), barIndex);
      }
    }
  };
  /**
   * Check if the labels collide.
   * @private
   * @param {object} svg The svg dom element.
   * @returns {boolean} True if the labels collide.
  */


  charts.labelsColide = function (svg) {
    var ticks = svg.selectAll('.x text');
    var collides = false;
    ticks.each(function (d1, i) {
      var rect1 = this.getBoundingClientRect();
      var rect2;
      ticks.each(function (d2, j) {
        if (i !== j) {
          rect2 = this.getBoundingClientRect();
          var overlaps = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);

          if (overlaps) {
            collides = true;
          }
        }
      });
    });
    return collides;
  };
  /**
   * Apply a different length label
   * @private
   * @param  {object}  svg  The svg element.
   * @param  {array}  dataArray The data.
   * @param  {object}  elem The dom element
   * @param  {object}  selector The d3 selection
   * @param  {boolean} isNoEclipse True if its an eclipse.
   */


  charts.applyAltLabels = function (svg, dataArray, elem, selector, isNoEclipse) {
    var ticks = selector ? svg.selectAll(selector) : svg.selectAll('.x text');
    ticks.each(function (d1, i) {
      var text = dataArray[i] ? dataArray[i][elem] : '';
      text = text || (isNoEclipse ? d3.select(this).text().substring(0, 1) : "".concat(d3.select(this).text().substring(0, 6), "..."));
      d3.select(this).text(text);
    });
  };
  /**
   * Trigger the right click event.
   * @private
   * @param  {object} container  The svg container.
   * @param  {object} elem The element that was right clicked.
   * @param  {object} d The data object
   */


  charts.triggerContextMenu = function (container, elem, d) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
    d3.event.stopImmediatePropagation();
    var e = $.Event('contextmenu');
    e.target = elem;
    e.pageX = d3.event.pageX;
    e.pageY = d3.event.pageY;
    $(container).trigger(e, [elem, d]);
  };
  /**
   * Calculates the width to render given text string.
   * @private
   * @param  {string} textStr The text to render.
   * @param  {object} fonts Optional for each theme.
   * @returns {number} The calculated text width in pixels.
   */


  charts.calculateTextRenderWidth = function (textStr, fonts) {
    var _theme$currentTheme;

    var defaultFonts = {
      soho: '700 12px arial',
      uplift: '600 14px arial'
    };
    fonts = utils.mergeSettings(undefined, fonts, defaultFonts);
    var themeId = ((theme === null || theme === void 0 ? void 0 : (_theme$currentTheme = theme == null ? void 0 : theme.currentTheme) === null || _theme$currentTheme === void 0 ? void 0 : _theme$currentTheme == null ? void 0 : _theme$currentTheme.id) || '').match(/soho|uplift/);
    themeId = themeId ? themeId[0] : 'soho';
    this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
    var context = this.canvas.getContext('2d');
    context.font = fonts[themeId];
    return context.measureText(textStr).width;
  };
  /**
   * Calculate the percentage for given partial and total value.
   * @private
   * @param  {number} value The partial value.
   * @param  {number} total The total value.
   * @returns {number} The calculated percentage.
   */


  charts.calculatePercentage = function (value, total) {
    return 100 * value / total;
  };
  /**
   * Get the percent value for given total value and percentage amount.
   * @private
   * @param  {number} total The total value.
   * @param  {number} amount The percentage amount.
   * @returns {number} The percent value.
   */


  charts.getPercentage = function (total, amount) {
    return total * amount / 100;
  };
  /**
   * Trim given text to threshold and add `...` at the end.
   * @private
   * @param  {string} text The text to be trimed.
   * @param  {number} threshold The number of characters.
   * @returns {number} The calculated percent value.
   */


  charts.trimText = function (text, threshold) {
    return text.length <= threshold ? text : "".concat(text.substr(0, threshold), "...");
  };
  /**
   * Get the label to use for given data and viewport area.
   * @private
   * @param  {object} d The data.
   * @param  {number} viewport The viewport area.
   * @returns {string} The label to use.
   */


  charts.getLabel = function (d, viewport) {
    var r = d.name;

    if (viewport.xxsmall || viewport.xsmall || viewport.small) {
      r = d.shortName || d.abbrName || d.name;
    } else if (viewport.medium) {
      r = d.abbrName || d.name;
    }

    return r;
  };
  /**
   * Wraps SVG text http://bl.ocks.org/mbostock/7555321
   * @private
   * @param {object} node  The svg element.
   * @param {number}  width The width at which to wrap
   * @param {object} labelFactor The dom element
   */


  charts.wrap = function (node, width, labelFactor) {
    if (!labelFactor) {
      labelFactor = 1.27;
    }

    if (!width) {
      labelFactor = 60;
    }

    node.each(function () {
      var text = d3.select(this);
      var words = text.text().split(/\s+/).reverse();
      var word = '';
      var line = [];
      var lineNumber = 0;

      if (words.length <= 1) {
        return;
      }

      var lineHeight = labelFactor; // ems

      var y = text.attr('y');
      var x = text.attr('x');
      var dy = parseFloat(text.attr('dy'));
      var tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', "".concat(dy, "em"));

      while (word = words.pop()) {
        //eslint-disable-line
        line.push(word);
        tspan.text(line.join(' '));

        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(' '));
          line = [word];
          tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', "".concat(++lineNumber * lineHeight + dy, "em")).text(word);
        }
      }
    });
  };

  var COMPONENT_NAME$k = 'bullet';
  /**
   * A bullet graph is a variation of a bar graph developed by Stephen Few.
   * Seemingly inspired by the traditional thermometer charts and progress bars found in many
   * dashboards, the bullet graph serves as a replacement for dashboard gauges and meters.
   * @class Bullet
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset.data] The data to use in the chart.
   * @param {array} [settings.dataset.data.tooltip] Tooltip contents for each point.
   * @param {boolean|string} [settings.animate=true] true|false - will do or not do the animation, 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true] If set to false the component will not redraw when the page or parent is resized.
   * @param {object} [settings.format] The format element.
   * @param {string|function} [settings.format.ranges] The `d3` formatter string or callback function.
   * @param {string|function} [settings.format.difference] The `d3` formatter string or callback function.
   */

  var BULLET_DEFAULTS = {
    dataset: [],
    animate: false,
    redrawOnResize: true,
    format: {
      ranges: null,
      difference: null
    }
  };

  function Bullet(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BULLET_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  Bullet.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The bullet chart prototype for chaining.
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.width = 0; // Do initialization. Build or Events ect

      this.build().handleEvents(); // Handle initial option

      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      return this;
    },

    /**
     * Build the Bullet Chart.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var _this = this;

      var chartData = this.settings.dataset[0];
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0;
      this.element.addClass('bullet-chart');
      var tooltipInterval = 0;
      var tooltipDataCache = [];
      var tooltipData = chartData.data[0] ? chartData.data[0].tooltip : []; // Append the SVG into its parent area.

      var noMarkers = false;
      var parent = this.element.parent();
      var margin = {
        top: 30,
        right: 35,
        bottom: 35,
        left: 40
      };
      var width = parent.width() - margin.left - margin.right;
      var height = parent.height() - margin.top - margin.bottom - 30; // 30 for legend

      height = height < 0 ? 50 : height; // default minimum height

      var svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', "translate(".concat(margin.left, ",").concat(margin.top, ")"));

      function bulletWidth(x) {
        var x0 = x(0);
        return function (d) {
          return Math.abs(x(d) - x0);
        };
      } // Prepare the format callback function


      var formatCallback = function formatCallback(type, d, i) {
        function callback(func, d2, i2) {
          var results = func(d2, i2);
          return typeof results !== 'undefined' ? results : d2;
        }

        if (chartData.format && typeof chartData.format[type] === 'function') {
          return callback(chartData.format[type], d, i);
        }

        if (chartData.format && typeof chartData.format[type] === 'string') {
          return d3.format(chartData.format[type])(d);
        }

        if (_this.settings.format && typeof _this.settings.format[type] === 'function') {
          return callback(_this.settings.format[type], d, i);
        }

        if (_this.settings.format && typeof _this.settings.format[type] === 'string') {
          return d3.format(_this.settings.format[type])(d);
        }

        return d;
      }; // Set format functions


      var format = {
        ranges: function ranges(d, i) {
          return formatCallback('ranges', d, i);
        },
        difference: function difference(d) {
          return formatCallback('difference', d);
        }
      };
      var isSingle = chartData.data.length === 1;

      var _loop = function _loop(i) {
        var duration = _this.settings.animate ? 400 : 0;
        var barHeight = 20;
        var self = _this;
        var rowData = chartData.data[i];
        var ranges = rowData.ranges.slice().sort(d3.descending);
        var markers = rowData.markers ? rowData.markers.slice().sort(d3.descending) : [];
        var measures = rowData.measures ? rowData.measures.slice().sort(d3.descending) : [];
        var rangesAsc = rowData.ranges.slice().sort(d3.ascending);
        var markersAsc = rowData.markers ? rowData.markers.slice().sort(d3.ascending) : [];
        var measuresAsc = rowData.measures ? rowData.measures.slice().sort(d3.ascending) : [];
        var groupSuffix = isSingle ? '' : "-group".concat(i);

        if (markers.length === 0) {
          markers = measures;
          markersAsc = measuresAsc;
          noMarkers = true;
        }

        var g = svg.append('g').attr('class', 'bullet').attr('transform', "translate(0, ".concat(i * (barHeight * 3.5), ")")); // Add Title and Subtitle

        var title = g.append('g');
        var text = title.append('text').attr('class', 'title').attr('dy', '-10px').text(function () {
          return rowData.title;
        }).call(function (d) {
          var node = d._groups[0][0];
          utils.addAttributes($(node), chartData, chartData.attributes, "title".concat(groupSuffix));
        });
        text.append('tspan').attr('class', 'subtitle').attr('dx', '15px').text(function () {
          return rowData.subtitle;
        }).call(function (d) {
          var node = d._groups[0][0];
          utils.addAttributes($(node), chartData, chartData.attributes, "subtitle".concat(groupSuffix));
        });
        var maxAll = Math.max(ranges[0], markers[0], measures[0]);
        var minAll = Math.min(rangesAsc[0], markersAsc[0], measuresAsc[0]);
        minAll = minAll < 0 ? minAll : 0; // Compute the new x-scale.

        var x1 = d3.scaleLinear().domain([minAll, maxAll]).range([0, width]).nice(); // Derive width-scales from the x-scales.

        var w1 = bulletWidth(x1); // Update the range rects.

        var range = g.selectAll('rect.range').data(ranges);
        range.enter().append('rect').call(function (d) {
          d._groups.forEach(function (thisRanges) {
            thisRanges.forEach(function (thisRange, idx) {
              utils.addAttributes($(thisRange), chartData, chartData.attributes, "range".concat(idx).concat(groupSuffix));
            });
          });
        }).attr('class', function (d, a) {
          return "range s".concat(a);
        }).attr('data-idx', i).attr('width', 0).attr('x', function (d) {
          return x1(d < 0 ? d : 0);
        }).style('fill', function (d, b) {
          if (chartData.barColors) {
            return chartData.barColors[b];
          }

          return '';
        }).attr('height', barHeight).on("click.".concat(self.namespace), function () {
          var bar = d3.select(this);
          self.element.trigger('selected', [bar, chartData.data[bar.attr('data-idx')]]);
        }).on("mouseenter.".concat(self.namespace), function (d, mouseEnterIdx) {
          var bar = d3.select(this);
          var data = chartData.data[bar.attr('data-idx')];
          var rect = this.getBoundingClientRect();
          var content = "<p>".concat(format.ranges(d, mouseEnterIdx), "</p>");

          var show = function show() {
            var size = charts.tooltipSize(content);
            var x = rect.left + rect.width - size.width / 2;
            var y = rect.top - size.height + $(window).scrollTop() - 5;

            if (content !== '') {
              if (charts.tooltip && charts.tooltip.length) {
                charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
              }

              charts.showTooltip(x, y, content, 'top');
            }
          };

          if (data.tooltip && data.tooltip[mouseEnterIdx]) {
            content = data.tooltip[data.tooltip.length - mouseEnterIdx - 1];
          }

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[mouseEnterIdx]) {
            content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (da) {
                  content = da;
                  tooltipDataCache[i] = da;
                });
              }

              if (content !== '') {
                clearInterval(tooltipInterval);
                show();
              }
            }, 10);
          } else {
            tooltipData = _typeof(tooltipData) === 'object' ? '' : tooltipData;
            content = tooltipDataCache[i] || tooltipData || content || '';
            show();
          }
        }).on("mouseleave.".concat(self.namespace), function () {
          clearInterval(tooltipInterval);
          charts.hideTooltip();
        }).on("contextmenu.".concat(self.namespace), function (d) {
          charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
        }).merge(range).transition().duration(duration).attr('width', w1); // Update the measure rects.

        var measure = g.selectAll('rect.measure').data(measures);
        measure.enter().append('rect').call(function (d) {
          d._groups.forEach(function (thisMeasures) {
            thisMeasures.forEach(function (thisMeasure, idx) {
              utils.addAttributes($(thisMeasure), chartData, chartData.attributes, "measure".concat(idx).concat(groupSuffix));
            });
          });
        }).attr('class', function (d, k) {
          return "measure s".concat(k);
        }).attr('width', 0).attr('height', 3).attr('x', function (d) {
          return x1(d < 0 ? d : 0);
        }).style('fill', function (d, j) {
          if (chartData.lineColors) {
            return chartData.lineColors[j];
          }

          return '';
        }).attr('y', 8.5).merge(measure).transition().duration(duration).attr('width', w1); // Update the marker lines.

        var isSingleMarker = markers.length === 1;
        var marker = g.selectAll('line.marker').data(markers);
        marker.enter().append('line').call(function (d) {
          d._groups.forEach(function (thisMarkers) {
            thisMarkers.forEach(function (thisMarker, idx) {
              var suffix = isSingleMarker ? "marker".concat(groupSuffix) : "marker".concat(idx).concat(groupSuffix);
              utils.addAttributes($(thisMarker), chartData, chartData.attributes, suffix);
            });
          });
        }).attr('class', noMarkers ? 'hidden' : 'marker').attr('x1', 0).attr('x2', 0).style('stroke', function (d, l) {
          if (chartData.markerColors) {
            return chartData.markerColors[l];
          }

          return '';
        }).attr('y1', barHeight / 6).attr('y2', barHeight * 5 / 6).merge(marker).transition().duration(duration).attr('x1', x1).attr('x2', x1).attr('y1', barHeight / 6).attr('y2', barHeight * 5 / 6); // Difference

        var diff = (markers[0] > measures[0] ? '-' : '+') + Math.abs(markers[0] - measures[0]);

        if (Math.abs(markers[0] - measures[0]) !== 0) {
          marker.enter().append('text').call(function (d) {
            var node = d._groups[0][0];
            utils.addAttributes($(node), chartData, chartData.attributes, "difference".concat(groupSuffix));
          }).attr('class', 'inverse').attr('text-anchor', 'middle').attr('y', barHeight / 2 + 4).attr('dx', charts.isRTL ? '-20px' : '20px').attr('x', 0).text(format.difference(diff)).merge(marker).transition().duration(duration).attr('x', function () {
            var total = 0;
            g.selectAll('.measure').each(function (d) {
              var w = w1(d);
              var x = x1(d);

              if (w > total) {
                total = w;
              }

              if (x > total) {
                total = x;
              }
            });
            return charts.isRTL ? -total : total;
          }).style('opacity', 1);
        } // Update the tick groups.


        var tick = g.selectAll('g.tick').data(x1.ticks(8)); // Initialize the ticks with the old scale, x0.

        var tickEnter = tick.enter().append('g').attr('class', 'tick').attr('transform', 'translate(0,0)').style('opacity', 0);
        tickEnter.append('line').attr('y1', barHeight).attr('y2', Math.round(barHeight * 7 / 4.7));
        tickEnter.append('text').attr('text-anchor', 'middle').attr('dy', '1.1em').attr('y', Math.round(barHeight * 7 / 4.7)).attr('class', function (d) {
          return d < 0 ? 'negative-value' : 'positive-value';
        }).text(function (d, k) {
          return format.ranges(d, k);
        }); // Transition the entering ticks to the new scale, x1

        tickEnter.transition().duration(duration).attr('transform', function (d) {
          return "translate(".concat(x1(d), ",0)");
        }).style('opacity', 1);

        if (charts.isRTL && charts.isIE) {
          svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        }
      };

      for (var i = 0; i < chartData.data.length; i++) {
        _loop(i);
      }

      charts.appendTooltip();
      this.element.trigger('rendered');
      return this;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on("updated.".concat(this.namespace), function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this2.updated();
      });
      return this;
    },

    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.build();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      var _this3 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this3.namespace, " ")), ".").concat(_this3.namespace);
      };

      if (this.element) {
        this.element.find('.range').off(events(['mouseenter', 'mouseleave', 'click', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));
      delete this.namespace;
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('bullet-chart');
        $.removeData(this.element[0], COMPONENT_NAME$k);
        $.removeData(this.element[0], 'chart');
      }
    }
  };

  // Other Shared Imports

  var COMPONENT_NAME$l = 'completion-chart';
  /**
  * A completion chart shows completion over a target value. Usually used to show progress as a percentage.
  * @class CompletionChart
  * @param {string} element The plugin element for the constuctor
  * @param {string} [settings] The settings element.
  *
  * @param {array} [settings.dataset.data] The data to use in the chart (See examples)
  * @param {string} [settings.dataset.data.name] - Required object with the title text `{text: 'Available Credit'}`
  * @param {number} [settings.dataset.data.completed] - Required data for the complete section `{text: 'Spent', value: 50000, format: '$,.0f'}`
  * @param {array} [settings.dataset.data.remaining] - Required data for the remaining section `{text: 'Pending', value: 10000, format: '$,.0f'}`
  * @param {array} [settings.dataset.data.total] - Optional data for the total section `{value: 95000, format: '$,.0f'}`
  */

  var COMPLETION_CHART_DEFAULTS = {
    dataset: []
  };

  function CompletionChart(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPLETION_CHART_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  CompletionChart.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The completion chart prototype for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      this.build().handleEvents();
      return this;
    },

    /**
     * Build the Completion Chart.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var _this = this;

      var chartData = this.settings.dataset[0]; // Handle Empty Data Set

      if (this.settings.dataset.length === 0) {
        chartData = {};
        chartData.data = [{
          name: {
            text: Locale ? Locale.translate('NoData') : 'No Data Available'
          },
          completed: {
            value: 0
          }
        }];
      }

      var dataset = chartData.data[0];
      var isTarget = this.settings.type === 'completion-target';
      var isAchievment = this.settings.type === 'targeted-achievement';
      this.element.addClass('completion-chart').addClass("".concat(this.settings.type === 'targeted-achievement' ? ' chart-targeted-achievement' : '')).attr('role', 'image'); // Set total defaults

      dataset.total = $.extend({}, {
        value: 100
      }, dataset.total); // Basic functions

      var isUndefined = function isUndefined(value) {
        return typeof value === 'undefined';
      };

      var fixUndefined = function fixUndefined(value, isNumber) {
        var defaultValue = isNumber ? 0 : '';
        return !isUndefined(value) ? value : defaultValue;
      };

      var toValue = function toValue(percent, ds) {
        ds = ds || dataset;
        return percent / 100 * fixUndefined(ds.total.value, true);
      };

      var toPercent = function toPercent(value, ds) {
        ds = ds || dataset;
        return Math.round(100 * (value / fixUndefined(ds.total.value, true)));
      };

      var localePercent = function localePercent(value) {
        return Locale.formatNumber(value / 100, {
          style: 'percent',
          maximumFractionDigits: 0
        });
      };

      var format = function format(value, formatterString, ds) {
        if (formatterString === '.0%') {
          return localePercent(toPercent(value, ds));
        }

        return d3.format(formatterString || 'm')(value);
      };

      var fixPercent = function fixPercent(value, ds) {
        var s = value.toString();

        if (s.indexOf('%') !== -1) {
          return toValue(s.replace(/%/g, ''), ds);
        }

        return value;
      };

      var updateWidth = function updateWidth(elem, value, ds) {
        var percent = toPercent(value, ds);
        percent = percent < 0 ? 0 : percent;
        var w = percent > 100 ? 100 : percent;
        elem[0].style.width = "".concat(w, "%");

        if (w === 0) {
          elem[0].className += 'is-empty';
        }
      };

      var updateTargetline = function updateTargetline(elem, value) {
        var min = value < 0 ? 0 : value;
        var w = value > 100 ? 100 : min;
        elem[0].style.left = "".concat(w, "%");
      };

      var setFormat = function setFormat(obj, ds, isPrivate) {
        var value = isPrivate ? obj._value : obj.value; //eslint-disable-line

        return obj && !isUndefined(value) && obj.format ? //eslint-disable-line
        format(fixPercent(value, ds), obj.format, ds) : //eslint-disable-line
        obj ? fixPercent(value, ds) : 0;
      };

      var self = this;

      var setOverlap = function setOverlap() {
        if (isTarget && !isAchievment) {
          setTimeout(function () {
            var remaining = $('.remaining', self.element);
            var total = $('.total', self.element);
            var rect1 = $('.completed .value', self.element)[0].getBoundingClientRect();
            var rect2 = remaining.find('.value')[0].getBoundingClientRect();
            remaining.add(total)[rect1.right > rect2.left - 20 ? 'addClass' : 'removeClass']('overlap');
          }, 500);
        }
      };

      var getSpecColor = function getSpecColor(ds) {
        var specColor = {};
        ds = ds || dataset;

        if (ds.info && !isUndefined(ds.info.color)) {
          if (dataset.info.color.indexOf('#') === 0) {
            specColor.info = true;
          }
        }

        if (ds.completed && !isUndefined(ds.completed.color)) {
          if (ds.completed.color.indexOf('#') === 0) {
            specColor.completed = true;
          }
        }

        if (ds.remaining && !isUndefined(ds.remaining.color)) {
          if (ds.remaining.color.indexOf('#') === 0) {
            specColor.remaining = true;
          }
        }

        if (ds.targetline && !isUndefined(ds.targetline.color)) {
          if (ds.targetline.color.indexOf('#') === 0) {
            specColor.targetline = true;
          }
        }

        return specColor;
      };

      var getTotalText = function getTotalText(ds) {
        var totalText = '';
        var difference = {};
        ds = ds || dataset;

        if (ds.total.difference) {
          difference.value = ds.total.value - ds.completed.value;
          difference.format = dataset.total.format;
        }

        totalText = (!ds.total.textOnly ? setFormat(ds.total.difference ? difference : ds.total) : '') + (ds.total.text || '');
        totalText = isAchievment && ds.remaining ? (!ds.remaining.textOnly ? setFormat(ds.remaining) : '') + (ds.remaining.text || '') : totalText;
        return totalText;
      };

      var percentTextDefault = {
        show: false,
        color1: '',
        color2: 'inverse'
      };
      var percentText = $.extend({}, percentTextDefault, dataset.percentText);

      var setPercentText = function setPercentText(ds) {
        ds = ds || dataset;
        percentText._value = ds.completed ? ds.completed.value : 0; //eslint-disable-line

        percentText.percent = toPercent(fixUndefined(percentText._value, true), ds); //eslint-disable-line

        percentText.format = '.0%';
        percentText._text = typeof percentText.text !== 'undefined' ? //eslint-disable-line
        percentText.text : typeof percentText.value !== 'undefined' ? //eslint-disable-line
        localePercent(percentText.value) : setFormat(percentText, ds, true);
        percentText.color = percentText[percentText.percent > 55 ? 'color2' : 'color1'];
      };

      var c; // Cache will after created

      var cacheElements = function cacheElements() {
        c = {
          name: $('.name', _this.element),
          info: {
            value: $('.info .value', _this.element),
            text: $('.info .text', _this.element)
          },
          plainInfo: {
            value: $('>.value', _this.element),
            text: $('>.text', _this.element)
          },
          completed: {
            bar: $('.completed.bar', _this.element),
            value: $('.completed .value', _this.element),
            text: $('.completed .text, .completed-label .text', _this.element)
          },
          remaining: {
            bar: $('.remaining.bar', _this.element),
            value: $('.remaining .value', _this.element),
            text: $('.remaining .text', _this.element)
          },
          targetline: {
            bar: $('.targetline', _this.element),
            value: $('.targetline .value', _this.element),
            text: $('.targetline .text', _this.element)
          },
          total: {
            bar: $('.total.bar', _this.element),
            value: $('.total.value', _this.element)
          },
          percentText: $('.chart-percent-text', _this.element)
        };
      }; // Add automation attributes


      var setAutomationAttributes = function setAutomationAttributes() {
        var attr = chartData.attributes;

        if (attr) {
          var addAttributes = function addAttributes(elem, suffix) {
            return utils.addAttributes(elem, chartData, chartData.attributes, suffix);
          };

          addAttributes(c.name, 'name');
          addAttributes(c.info.value, 'info-value');
          addAttributes(c.info.text, 'info-text');
          addAttributes(c.plainInfo.value, 'info-value');
          addAttributes(c.plainInfo.text, 'info-text');
          addAttributes(c.completed.bar, 'completed-bar');
          addAttributes(c.completed.value, 'completed-value');
          addAttributes(c.completed.text, 'completed-text');
          addAttributes(c.remaining.bar, 'remaining-bar');
          addAttributes(c.remaining.value, 'remaining-value');
          addAttributes(c.remaining.text, 'remaining-text');
          addAttributes(c.targetline.bar, 'targetline-bar');
          addAttributes(c.targetline.value, 'targetline-value');
          addAttributes(c.targetline.text, 'targetline-text');
          addAttributes(c.total.bar, 'total-bar');
          addAttributes(c.total.value, 'total-value');
          addAttributes(c.percentText, 'percent-text');
        }
      };

      var setJsonData = function setJsonData(ds) {
        ds = ds || dataset;
        c.name.data('jsonData', {
          name: ds.name
        });
        c.info.value.add(c.info.text).data('jsonData', {
          info: ds.info
        });
        c.completed.bar.add(c.completed.value).add(c.completed.text).data('jsonData', {
          completed: ds.completed
        });
        c.remaining.bar.add(c.remaining.value).add(c.remaining.text).data('jsonData', {
          remaining: ds.remaining
        });
        c.targetline.bar.add(c.targetline.value).add(c.targetline.text).data('jsonData', {
          targetline: ds.targetline
        });
        c.total.bar.add(c.total.value).data('jsonData', {
          total: ds.total
        });
        c.percentText.data('jsonData', {
          percentText: ds.percentText
        });
      };

      var updateBars = function updateBars(ds) {
        var w;
        ds = ds || dataset; // Update completed bar width

        if (ds.completed) {
          w = fixPercent(ds.completed.value, ds);
          updateWidth(c.completed.bar, w, ds);
        } // Update remaining bar width


        if (ds.remaining) {
          w = fixPercent(ds.completed.value, ds) + fixPercent(ds.remaining.value, ds);
          updateWidth(c.remaining.bar, w, ds);
          setOverlap();
        } // Update target line bar position


        if (ds.targetline) {
          w = fixPercent(ds.targetline.value, ds);
          updateTargetline(c.targetline.bar, w);
        }
      };

      if (!isUndefined(percentText.color) && percentText.color1 === '') {
        percentText.color1 = percentText.color;
      } // Render


      var html = {
        body: $('<div class="total bar" />')
      };
      var specColor = getSpecColor();

      if (isTarget || isAchievment) {
        var totalText = getTotalText();
        html.body.addClass("chart-completion-target".concat(isAchievment ? ' chart-targeted-achievement' : ''));
        html.label = "<span class=\"label\">\n        <span class=\"name\">".concat(fixUndefined(dataset.name.text), " ").concat(dataset.completed.color && dataset.completed.color === 'error' ? $.createIcon({
          icon: 'error',
          classes: 'icon-error'
        }) : '', "</span>\n        <span class=\"l-pull-right total value\">").concat(totalText, "</span>\n      </span>");
      } else {
        html.body.addClass('chart-completion');
        var name = fixUndefined(dataset.name.text);
        var completedColor = fixUndefined(dataset.completed.color);
        var infoColor = fixUndefined(dataset.info.color);
        var bColor = dataset.info.color && !specColor.info ? infoColor : '';
        var infoText = fixUndefined(dataset.info.text);

        if (!specColor.completed) {
          bColor = completedColor;
        }

        var styleColor = '';

        if (dataset.info.color && specColor.info) {
          styleColor = infoColor;
        }

        if (specColor.completed) {
          styleColor = completedColor;
        }

        var styleValue = dataset.info && !isUndefined(dataset.info.value) ? fixUndefined(dataset.info.value) : setFormat(dataset.completed);
        html.label = "<b class=\"label name\">".concat(name, "</b>\n      <b class=\"label info ").concat(bColor, " colored\">\n      <span class=\"value ").concat(bColor, "\" ").concat(styleColor ? "style=\"color:".concat(styleColor) : '', "\">").concat(styleValue, "</span>\n      <span class=\"text ").concat(bColor, "\" ").concat(styleColor ? "style=\"color:".concat(styleColor) : '', "\">").concat(infoText, "</span>\n      </b>");
      }

      if (dataset.remaining) {
        html.remaining = "".concat('' + '<div class="target remaining bar').concat(!specColor.remaining ? " ".concat(fixUndefined(dataset.remaining.color)) : '', "\"").concat(specColor.remaining ? " style=\"color:".concat(dataset.remaining.color, ";background-color:").concat(dataset.remaining.color, ";\"") : '', "\">").concat(isAchievment ? '' : "<span".concat(!isTarget && !isAchievment ? ' class="audible"' : '', ">") + "<span class=\"value".concat(!specColor.remaining ? " ".concat(fixUndefined(dataset.remaining.color)) : '', "\"").concat(specColor.remaining ? " style=\"color:".concat(dataset.remaining.color, ";\"") : '', "\">").concat(setFormat(dataset.remaining), "</span><br />") + "<span class=\"text".concat(!specColor.remaining ? " ".concat(fixUndefined(dataset.remaining.color)) : '', "\"").concat(specColor.remaining ? " style=\"color:".concat(dataset.remaining.color, ";\"") : '', "\">").concat(fixUndefined(dataset.remaining.text), "</span>") + '</span>', "</div>");
      } else {
        html.remaining = '<div class="target remaining bar" style="opacity: 0"></div>';
      }

      if (dataset.completed && isAchievment) {
        setPercentText();
        specColor.percentText = percentText.color.indexOf('#') === 0;
        html.completed = "".concat('' + '<div class="completed bar').concat(!specColor.completed ? " ".concat(fixUndefined(dataset.completed.color)) : '', "\"").concat(specColor.completed ? " style=\"color:".concat(dataset.completed.color, ";background-color:").concat(dataset.completed.color, ";\"") : '', "\"></div>").concat(percentText.show ? "<div class=\"chart-percent-text".concat(!specColor.percentText && percentText.color !== '' ? " ".concat(percentText.color) : '', "\"").concat(specColor.percentText ? " style=\"color:".concat(percentText.color, ";\"") : '', ">").concat(percentText._text, "</div>") : '' //eslint-disable-line
        , "<span class=\"completed-label\"").concat(!isTarget && !isAchievment ? ' class="audible"' : '', ">") + "<span class=\"text\">".concat(fixUndefined(dataset.completed.text), "</span>") + '</span>';
      }

      if (dataset.completed.text || dataset.completed.format && !isAchievment) {
        this.element.addClass('chart-completion-target-padding');
      }

      if (dataset.completed && !isAchievment) {
        html.completed = "".concat('' + '<div class="completed bar').concat(!specColor.completed ? " ".concat(fixUndefined(dataset.completed.color)) : '', "\"").concat(specColor.completed ? " style=\"color:".concat(dataset.completed.color, ";background-color:").concat(dataset.completed.color, ";\"") : '', ">") + "<span".concat(!isTarget && !isAchievment ? ' class="audible"' : '', ">") + "<span class=\"value".concat(!specColor.completed ? " ".concat(fixUndefined(dataset.completed.color)) : '', "\"").concat(specColor.completed ? " style=\"color:".concat(dataset.completed.color, ";\"") : '', "\">").concat(setFormat(dataset.completed), "</span><br />") + "<span class=\"text".concat(!specColor.completed ? " ".concat(fixUndefined(dataset.completed.color)) : '', "\"").concat(specColor.completed ? " style=\"color:".concat(dataset.completed.color, ";\"") : '', "\">").concat(fixUndefined(dataset.completed.text), "</span>") + '</span></div>';
      }

      if (dataset.targetline) {
        html.targetline = "".concat('' + '<div class="target-line targetline bar').concat(!specColor.targetline ? " ".concat(fixUndefined(dataset.targetline.color)) : '', "\"").concat(specColor.targetline ? " style=\"color:".concat(dataset.targetline.color, ";background-color:").concat(dataset.targetline.color, ";\"") : '', "\">") + "<span".concat(!isTarget && !isAchievment ? ' class="audible"' : '', ">") + "<span class=\"value".concat(!specColor.targetline ? " ".concat(fixUndefined(dataset.targetline.color)) : '', "\"").concat(specColor.targetline ? " style=\"color:".concat(dataset.targetline.color, ";\"") : '', "\">").concat(setFormat(dataset.targetline), "</span><br />") + "<span class=\"text".concat(!specColor.targetline ? " ".concat(fixUndefined(dataset.targetline.color)) : '', "\"").concat(specColor.targetline ? " style=\"color:".concat(dataset.targetline.color, ";\"") : '', "\">").concat(fixUndefined(dataset.targetline.text), "</span>") + '</span>' + '</div>';
      }

      DOM.append(html.body, (html.remaining || '') + (html.completed || '') + (html.targetline || ''), '<a><use><svg><div><span><br>');
      DOM.append(this.element, html.label + html.body.prop('outerHTML'), '<a><use><svg><div><span><br>');
      cacheElements();
      setAutomationAttributes();
      setJsonData();
      updateBars();
      return this;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on("updated.".concat(COMPONENT_NAME$l), function () {
        _this2.updated();
      });
      return this;
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings object
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      var type = settings.type || this.settings.type;
      this.settings = settings;
      this.settings.type = type;

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off("updated.".concat(COMPONENT_NAME$l));
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('completion-chart');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$l);
      $.removeData(this.element[0], 'chart');
    }
  };

  var COMPONENT_NAME$m = 'sparkline'; // The Component Defaults

  var SPARKLINE_DEFAULTS = {
    dataset: [],
    colors: null,
    isDots: false,
    isPeakDot: false,
    isMinMax: false,
    isMedianRange: false
  };
  /**
   * Sparklines are a compact way to show trends.
   * @class Sparkline
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} [settings.dataset] The data to use in the sparklines.
   * @param {array} [settings.colors = ['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8']] An array of color sequences in hex format fx #1D5F8A,
   * defaulting to the correct standard colors.
   * @param {boolean} [settings.isDots = false] Shows dots on the data points.
   * @param {boolean} [settings.isPeakDot = false] Highlights the top value as peak with a special dot.
   * @param {boolean} [settings.isMinMax  = false] Shows a continuous shading to highlight the min and max values.
   * @param {boolean} [settings.isMedianRange  = false] Adds a median range display.
   */

  function Sparkline(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SPARKLINE_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  Sparkline.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The sparkline prototype for chaining.
     */
    init: function init() {
      if (!this.settings.colors) {
        var palette = theme.themeColors().palette;
        this.settings.colors = [];
        this.settings.colors[0] = palette.azure[theme.uplift ? '80' : '70'].value;
        this.settings.colors[1] = palette.slate['40'].value;
        this.settings.colors[2] = palette.slate['30'].value;
        this.settings.colors[3] = palette.slate['20'].value;
      }

      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.sparklineColors = d3.scaleOrdinal().range(this.settings.colors);
      return this.build().handleEvents();
    },

    /**
     * Build the Sparkline Chart.
     * @private
     * @returns {object} The sparkline prototype for chaining.
     */
    build: function build() {
      var _this = this;

      // chartData, options
      // Sparkline Chart
      var self = this;
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0;
      var tooltipIntervalMedianRange;
      var tooltipIntervalDots;
      var tooltipDataCacheMedianRange = [];
      var tooltipDataCacheDots = [];
      var tooltipData = self.settings.tooltip; // calculate max and min values in the NLWest data

      var max = 0;
      var min = 0;
      var len = 0;
      var i;
      var dimensions = this.calculateAspectRatioFit({
        srcWidth: 385,
        srcHeight: 65,
        maxWidth: this.element.width(),
        maxHeight: 600 // container min-height

      });
      var dotsize = dimensions.width > 300 ? 4 : 3;
      var chartData = self.settings.dataset;

      for (i = 0; i < chartData.length; i++) {
        min = d3.min([d3.min(chartData[i].data), min]);
        max = d3.max([d3.max(chartData[i].data), max]);
        len = d3.max([chartData[i].data.length, len]);
      } // Make the lines based on the range of values and width


      var p = 10;
      var w = dimensions.width;
      var h = dimensions.height;
      var x = d3.scaleLinear().domain([0, len]).range([p, w - p]);
      var y = d3.scaleLinear().domain([min, max]).range([h - p, p]);
      var line = d3.line().x(function (d, j) {
        return x(j);
      }).y(function (d) {
        return y(d);
      }); // Add the tooltip dom element

      charts.appendTooltip(); // Append to the main dom element

      var svg = d3.select(this.element[0]).append('svg').attr('height', h).attr('width', w); // Add Median Range
      // https://www.purplemath.com/modules/meanmode.htm

      if (self.settings.isMedianRange) {
        max = d3.max(chartData[0].data);
        min = d3.min(chartData[0].data);
        var minWidth = 10;
        var maxWidth = w - 45;
        var median = d3.median(chartData[0].data);
        var range = max - min;
        var scaleMedianRange = d3.scaleLinear().domain([min, max]).range([0, h]);
        var top = h - scaleMedianRange(median > range ? median : range);
        var bot = h - scaleMedianRange(median < range ? median : range);
        svg.append('g').attr('class', 'medianrange').attr('transform', function () {
          return "translate(".concat(minWidth, ",").concat(top, ")");
        }).append('rect').attr('width', maxWidth).attr('height', bot).style('opacity', '0.06').call(function (d) {
          d._groups.forEach(function (medianranges) {
            medianranges.forEach(function (medianrange) {
              var dat = chartData[0];
              utils.addAttributes($(medianrange), dat, dat.attributes, 'medianrange');
            });
          });
        }).on("mouseenter.".concat(self.namespace), function () {
          var rect = this.getBoundingClientRect();
          var content = '<p class="sparkline-tooltip">' + // eslint-disable-line
          Locale.translate('Median') + ': <b>' + median + '</b><br>' + Locale.translate('Range') + ': <b>' + range + '</b>' + (self.settings.isPeakDot ? '<br>' + Locale.translate('Peak') + ': <b>' + max + '</b>' : '') + '</p>'; // eslint-disable-line

          var show = function show() {
            var size = charts.tooltipSize(content);
            var posX = rect.left + (rect.width - size.width) / 2;
            var posY = rect.top - size.height - 5; // 5 is extra padding

            if (content !== '') {
              if (charts.tooltip && charts.tooltip.length) {
                charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
              }

              charts.showTooltip(posX, posY, content, 'top');
            }
          };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheMedianRange[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalMedianRange = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = data;
                  tooltipDataCacheMedianRange[i] = data;
                });
              }

              if (content !== '') {
                clearInterval(tooltipIntervalMedianRange);
                show();
              }
            }, 10);
          } else {
            tooltipData = _typeof(tooltipData) === 'object' ? '' : tooltipData;
            content = tooltipDataCacheMedianRange[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }
        }).on("mouseleave.".concat(self.namespace), function () {
          clearInterval(tooltipIntervalMedianRange);
          charts.hideTooltip();
        });
      }

      var _loop = function _loop() {
        var set = chartData[i];
        var g = svg.append('g');
        g.append('path').attr('d', line(set.data)).attr('stroke', self.settings.isMinMax ? '#999999' : _this.sparklineColors(i)).attr('class', 'team connected-line').call(function (d) {
          d._groups.forEach(function (lines) {
            lines.forEach(function (connectedLine) {
              utils.addAttributes($(connectedLine), set, set.attributes, 'connected-line');
            });
          });
        });
      };

      for (i = 0; i < chartData.length; i++) {
        _loop();
      } // Add Dots (Dots/Peak/MinMAx)


      min = d3.min(chartData[0].data);
      svg.selectAll('.point').data(chartData[0].data).enter().append('circle').attr('r', function (d) {
        return self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 1 : self.settings.isDots || self.settings.isPeakDot && max === d ? dotsize : 0;
      }).attr('class', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? 'point peak' : self.settings.isMinMax && max === d ? 'point max' : self.settings.isMinMax && min === d ? 'point min' : 'point';
      }).style('fill', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? '#ffffff' : self.settings.isMinMax && max === d ? '#56932E' : self.settings.isMinMax && min === d ? '#941E1E' : self.sparklineColors(0);
      }).style('stroke', function (d) {
        return self.settings.isPeakDot && max === d && !self.settings.isMinMax ? self.sparklineColors(0) : self.settings.isMinMax && max === d ? 'none' : self.settings.isMinMax && min === d ? 'none' : '#ffffff';
      }).style('cursor', 'pointer').attr('cx', function (d, m) {
        return x(m);
      }).attr('cy', function (d) {
        return y(d);
      }).call(function (d) {
        d._groups.forEach(function (points) {
          points.forEach(function (point, idx) {
            var dat = chartData[0];
            utils.addAttributes($(point), dat, dat.attributes, "point-".concat(idx));
          });
        });
      }).on("mouseenter.".concat(self.namespace), function (d) {
        var rect = this.getBoundingClientRect();
        var content = "<p>".concat(chartData[0].name ? "".concat(chartData[0].name, "<br> ").concat(self.settings.isMinMax && max === d ? "".concat(Locale.translate('Highest'), ": ") : self.settings.isMinMax && min === d ? "".concat(Locale.translate('Lowest'), ": ") : self.settings.isPeakDot && max === d ? "".concat(Locale.translate('Peak'), ": ") : '') : '', "<b>").concat(d, "</b></p>");

        var show = function show() {
          var size = charts.tooltipSize(content);
          var posX = rect.left - size.width / 2 + 6;
          var posY = rect.top - size.height - 8;

          if (content !== '') {
            if (charts.tooltip && charts.tooltip.length) {
              charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
            }

            charts.showTooltip(posX, posY, content, 'top');
          }
        };

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheDots[i]) {
          content = '';
          var runInterval = true;
          tooltipIntervalDots = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = data;
                tooltipDataCacheDots[i] = data;
              });
            }

            if (content !== '') {
              clearInterval(tooltipIntervalDots);
              show();
            }
          }, 10);
        } else {
          tooltipData = _typeof(tooltipData) === 'object' ? '' : tooltipData;
          content = tooltipDataCacheDots[i] || tooltipData || chartData[0].tooltip || content || '';
          show();
        }

        d3.select(this).attr('r', self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 2 : dotsize + 1);
      }).on("mouseleave.".concat(self.namespace), function (d) {
        clearInterval(tooltipIntervalDots);
        charts.hideTooltip();
        d3.select(this).attr('r', self.settings.isMinMax && max === d || self.settings.isMinMax && min === d ? dotsize + 1 : dotsize);
      }).on("contextmenu.".concat(self.namespace), function (d) {
        var data = {
          value: d,
          name: chartData[0].name || ''
        };

        if (self.settings.isMinMax && max === d) {
          data.highest = true;
        }

        if (self.settings.isMinMax && min === d) {
          data.lowest = true;
        }

        if (self.settings.isPeakDot && max === d) {
          data.peak = true;
        }

        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], data);
      });
      /**
      * Fires when the sparkline is fully renders.
      *
      * @event close
      * @memberof About
      * @property {object} event - The jquery event object
      * @property {object} ui - The svg element.
      */

      this.element.trigger('rendered', svg);
      return this;
    },

    /**
     * Conserve aspect ratio of the orignal region. Useful when shrinking/enlarging
     * @private
     * @param  {object} d the data element with the properties
     * @returns {object} Object with the calculated width and height
     */
    calculateAspectRatioFit: function calculateAspectRatioFit(d) {
      var ratio = Math.min(d.maxWidth / d.srcWidth, d.maxHeight / d.srcHeight);
      return {
        width: d.srcWidth * ratio,
        height: d.srcHeight * ratio
      };
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on("updated.".concat(COMPONENT_NAME$m), function (e, settings) {
        _this2.updated(settings);
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this2.updated();
      });
      return this;
    },

    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings object
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.element.empty();
      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      var _this3 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this3.namespace, " ")), ".").concat(_this3.namespace);
      };

      if (this.element) {
        this.element.find('.medianrange').off(events(['mouseenter', 'mouseleave']));
        this.element.find('.point').off(events(['mouseenter', 'mouseleave', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));
      delete this.namespace;
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('sparkline');
        $.removeData(this.element[0], COMPONENT_NAME$m);
        $.removeData(this.element[0], 'chart');
      }
    }
  };

  /* eslint-disable consistent-return */

  var COMPONENT_NAME$n = 'emptymessage';
  /**
  * The Empty Message is a message with an icon that can be used when no data is present.
  * @class EmptyMessage
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.title = null] The Main text to show.
  * @param {string} [settings.info = null] Longer paragraph text to show
  * @param {string} [settings.icon = null] The name of the icon to use. See {@link https://design.infor.com/code/ids-enterprise/latest/demo/icons/example-empty-widgets?font=source-sans} for options.
  * @param {boolean} [settings.button = null] The button settings to use (click, isPrimary, cssClass ect)
  * @param {string} [settings.height = null]  The container height. If set to 'small' will show only title and all other will not be render (like: icon, button, info)
  * @param {string} [settings.color = 'slate']  Defaults to 'slate' but can also be azure. Later may be expanded to all personalization colors.
  * @param {string} [settings.attributes = null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var EMPTYMESSAGE_DEFAULTS = {
    title: null,
    info: null,
    icon: null,
    button: null,
    height: null,
    // null|'small'
    color: 'slate',
    // or azure for now until personalization works
    attributes: null
  };

  function EmptyMessage(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EMPTYMESSAGE_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Component Methods


  EmptyMessage.prototype = {
    init: function init() {
      this.setup().build();
    },
    setup: function setup() {
      this.element.addClass('empty-message');
      return this;
    },
    build: function build() {
      var _opts$button;

      var opts = this.settings;
      var isHeightSmall = opts.height === 'small';

      if (opts !== null && opts !== void 0 && (_opts$button = opts == null ? void 0 : opts.button) !== null && _opts$button !== void 0 && (_opts$button == null ? void 0 : _opts$button.isPrimary)) {
        this.settings.color = 'azure';
      }

      if (opts.icon && !isHeightSmall) {
        $("<div class=\"empty-icon\">\n          <svg class=\"icon-empty-state is-".concat(this.settings.color, "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n            <use href=\"#").concat(opts.icon, "\"></use>\n          </svg></div>")).appendTo(this.element);
      }

      if (opts.title) {
        // Re-evaluate the text
        if (opts.title === '[NoData]') {
          opts.title = Locale ? Locale.translate('NoData') : 'No Data Available';
        }

        $("<div class=\"empty-title\">".concat(opts.title, "</div>")).appendTo(this.element);
      }

      if (opts.info && !isHeightSmall) {
        $("<div class=\"empty-info\">".concat(opts.info, "</div>")).appendTo(this.element);
      }

      if (opts.button && !isHeightSmall) {
        var buttonMarkup = "<div class=\"empty-actions\">\n          <button type=\"button\" class=\"".concat(opts.button.isPrimary ? 'btn-primary' : 'btn-secondary', " ").concat(opts.button.cssClass, " hide-focus\" id=\"").concat(opts.button.id, "\">\n            <span>").concat(opts.button.text, "</span>\n          </button>\n        </div>");
        $(buttonMarkup).appendTo(this.element);

        if (opts.button.click) {
          this.element.on('click', 'button', opts.button.click);
        }
      }

      utils.addAttributes(this.element, this, opts.attributes, '', true);
      utils.addAttributes(this.element.find('.empty-actions button'), this, opts.attributes, 'btn', true);
      return this;
    },

    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {void}
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();
      this.build();
    },

    /**
     * Teardown - Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      $.removeData(this.element[0], COMPONENT_NAME$n);
      this.element.empty();
      this.element.removeClass('empty-message');
    }
  };

  $.fn.emptymessage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$n);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$n, new EmptyMessage(this, settings));
      }
    });
  };

  var COMPONENT_NAME$o = 'line';
  /**
   * A line chart or line graph is a type of chart which displays information as a series of data
   * points called 'markers' connected by straight line segments.
   * @class Line
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset=[]] The data to use in the line/area/bubble.
   * @param {function|string} [settings.tooltip] A custom tooltip or tooltip renderer function
   * for the whole chart.
   * @param {string} [settings.isArea] Render as an area chart.
   * @param {string} [settings.isBubble=false] Render as a bubble chart.
   * @param {string} [settings.isScatterPlot=false] Render as a Scatter Plot Chart.
   * @param {string} [settings.showLegend=true] If false the label will not be shown.
   * @param {object} [settings.xAxis] A series of options for the xAxis
   * @param {number} [settings.xAxis.rotate] Rotate the elements on the x axis.
   * Recommend -65 deg but this can be tweaked depending on look.
   * @param {object} [settings.yAxis] A series of options for the yAxis
   * @param {object} [settings.xAxis.ticks] Data to control the number of ticks and y axis format.
   * For example `{number: 5, format: ',.1s'}` would show only 5 yaxis points and format the
   * data to show 1K, 1M, 1G ect.. This uses the d3 formatter.
   * @param {function} [settings.xAxis.formatText] A function that passes the text element and a counter.
   * You can return a formatted svg markup element to replace the current element.
   * For example you could use tspans to wrap the strings or color them.
   * @param {object} [settings.yAxis] A series of options for the yAxis
   * @param {function} [settings.yAxis.formatter] A d3 formatter for the yAxis points.
   * @param {boolean} [settings.hideDots=false] If true no dots are shown
   * @param {array} [settings.axisLabels]  Option to a label to one of the four sides. For Example
   * `{left: 'Left axis label', top: 'Top axis label',
   * right: 'Right axis label', bottom: 'Bottom axis label'}`
   * @param {boolean|string} [settings.animate] true|false - will do or not do the animation.
   * 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true]  If set to false the component will not redraw when the page or parent is resized.
   * @param {object} [settings.dots] Option to customize the dot behavior. You can set the dot size (radius),
   * the size on hover and stroke or even add a custom class.
   * Example `dots: { radius: 3, radiusOnHover: 4, strokeWidth: 0, class: 'custom-dots'}`
   * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
   * @param {boolean} [settings.fitHeight=true] If true chart height will fit in parent available height.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   * @param {object} [settings.localeInfo] If passed in you can override the default formatting https://github.com/d3/d3-format/blob/master/README.md#formatDefaultLocale
   */

  var LINE_DEFAULTS = {
    dataset: [],
    isArea: false,
    isBubble: false,
    isScatterPlot: false,
    showLegend: true,
    hideDots: false,
    animate: true,
    redrawOnResize: true,
    fitHeight: true,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };

  function Line(element, settings) {
    this.settings = utils.mergeSettings(element, settings, LINE_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  Line.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.initialSelectCall = false;

      if (this.settings.localeInfo) {
        d3.formatDefaultLocale(this.settings.localeInfo);
      }

      this.build().handleEvents(); // Handle initial option

      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }
      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Line
      * @param {object} event - The jquery event object
      * @param {array} svg - The svg object.
      */


      this.element.trigger('rendered', [this.svg]);
      return this;
    },

    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var _s$xAxis, _s$xAxis2, _s$yAxis, _s$yAxis2;

      var self = this;
      var s = this.settings;
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0;

      var format = function format(value) {
        return d3.format(s.formatterString || ',')(value);
      }; // Add css class


      var cssClass = 'line-chart';
      cssClass += s.isBubble ? ' bubble' : '';
      cssClass += s.isScatterPlot ? ' scatterplot' : '';
      this.element.addClass(cssClass); // Handle Empty Data Set

      if (s.dataset.length === 0) {
        self.element.emptymessage(s.emptyMessage);
        return this;
      }

      var dots = {
        radius: 5,
        radiusOnHover: 7,
        strokeWidth: 2,
        class: 'dot'
      }; // Set to zero for animation

      if (s.isBubble) {
        dots.radius = 0;
        dots.radiusOnHover = 0;
        dots.strokeWidth = 0;
      }

      if (s.isScatterPlot) {
        dots.radius = 0;
        dots.strokeWidth = 50;
      }

      $.extend(true, dots, s.dots);
      self.dots = dots;
      this.isRTL = Locale.isRTL();
      var tooltipInterval;
      var tooltipDataCache = [];
      var tooltipData = s.tooltip; // Config axis labels

      var i;
      var l;
      var axisLabels = {};
      var isAxisLabels = {
        atLeastOne: false
      };
      var axisArray = ['left', 'top', 'right', 'bottom'];

      if (s.axisLabels) {
        $.extend(true, axisLabels, s.axisLabels);
      }

      if (!$.isEmptyObject(axisLabels)) {
        for (i = 0, l = axisArray.length; i < l; i++) {
          var thisAxis = axisLabels[axisArray[i]];

          if (thisAxis && typeof thisAxis === 'string' && $.trim(thisAxis) !== '') {
            isAxisLabels[axisArray[i]] = true;
            isAxisLabels.atLeastOne = true;
          }
        }
      } // Append the SVG in the parent area.


      var longestLabel = '';
      var xRotateMarginBot = 0;
      var dataset = s.dataset;
      var hideDots = s.hideDots;
      var parent = this.element.parent();
      var isCardAction = !!$('.widget-chart-action', parent).length;
      var isViewSmall = parent.width() < 450;

      var getRotateValue = function getRotateValue(v) {
        var defaultAngle = '-45';
        return typeof v !== 'undefined' && typeof v !== 'function' && v !== null ? typeof v === 'boolean' ? v ? defaultAngle : null : v : null;
      };

      var xRotate = {
        large: getRotateValue((_s$xAxis = s.xAxis) === null || _s$xAxis === void 0 ? void 0 : _s$xAxis == null ? void 0 : _s$xAxis.rotate),
        small: getRotateValue((_s$xAxis2 = s.xAxis) === null || _s$xAxis2 === void 0 ? void 0 : _s$xAxis2 == null ? void 0 : _s$xAxis2.rotateOnSmallView)
      };
      var isAxisXRotate = !!xRotate.large;

      if (isAxisXRotate) {
        xRotate.use = xRotate.large;
      }

      if (isViewSmall && !!xRotate.small) {
        isAxisXRotate = true;
        xRotate.use = xRotate.small;
      } // If card action present then use instead fit height.


      if (isCardAction) {
        s.fitHeight = false;
      } // Get maxes


      var getMaxes = function getMaxes(d, opt) {
        return d3.max(d.data, function (d2) {
          return opt ? d2.value[opt] : d2.value;
        });
      };

      if (isAxisXRotate) {
        // get the longeset label
        dataset[0].data.forEach(function (d) {
          if (d.name.length > longestLabel.length) {
            longestLabel = d.name;
          }
        });
        var angle = Math.abs(xRotate.use);
        angle = !isNaN(angle) ? angle : 0;
        xRotateMarginBot = longestLabel.length * (angle > 50 ? 5 : 2);
      }

      var margin = {
        top: isAxisLabels.top ? isCardAction ? 15 : 40 : isCardAction ? 5 : 30,
        right: isAxisLabels.right ? 65 : 55,
        bottom: isAxisLabels.bottom ? isAxisXRotate ? 60 : 50 : xRotateMarginBot + 35,
        left: isAxisLabels.left ? 75 : 65
      };
      var parentAvailableHeight = utils.getParentAvailableHeight(self.element[0]);
      var useHeight = s.fitHeight ? parentAvailableHeight : parseInt(parent.height(), 10);
      var width = parent.width() - margin.left - margin.right;
      var height = useHeight - margin.top - margin.bottom - 30; // legend
      // let height = parent.height() - margin.top - margin.bottom - 30; // legend

      if (isCardAction) {
        height -= 42;
      }

      self.svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', "translate(".concat(margin.left, ",").concat(margin.top, ")"));
      var names = dataset[0].data.map(function (d) {
        return d.name;
      });
      var valueFormatterString = {};

      if (dataset[0] && dataset[0].valueFormatterString) {
        $.extend(true, valueFormatterString, dataset[0].valueFormatterString);
      }

      var formatValue = function formatValue(str, value) {
        return !$.isEmptyObject(valueFormatterString) && !!str ? d3.format(str)(str === '0.0%' ? value / 100 : value) : value;
      };

      var labels = {
        name: 'Name',
        value: {
          x: 'Value.x',
          y: 'Value.y',
          z: 'Value.z'
        }
      };

      if (dataset[0] && dataset[0].labels) {
        $.extend(true, labels, dataset[0].labels);
      } // Calculate the Domain X and Y Ranges


      var maxes;
      var x = (!!s.xAxis && !!s.xAxis.scale ? s.xAxis.scale : d3.scaleLinear()).range([0, width]);
      var y = d3.scaleLinear().range([height, 0]);
      var z = d3.scaleLinear().range([1, 25]);

      if (s.isBubble) {
        maxes = {
          x: dataset.map(function (d) {
            return getMaxes(d, 'x');
          }),
          y: dataset.map(function (d) {
            return getMaxes(d, 'y');
          }),
          z: dataset.map(function (d) {
            return getMaxes(d, 'z');
          })
        };
      } else if (s.isScatterPlot) {
        maxes = {
          x: dataset.map(function (d) {
            return getMaxes(d, 'x');
          }),
          y: dataset.map(function (d) {
            return getMaxes(d, 'y');
          })
        };
      } else {
        maxes = dataset.map(function (d) {
          return getMaxes(d);
        });
      }

      var maxDataLen = d3.max(dataset.map(function (d) {
        return d.data.length;
      }));
      var entries = maxDataLen <= 1 ? maxDataLen : maxDataLen - 1;
      var xScale = x.domain(!!s.xAxis && !!s.xAxis.domain ? s.xAxis.domain : [0, s.isBubble || s.isScatterPlot ? d3.max(maxes.x) : entries]);
      var yScale = y.domain([0, d3.max(s.isBubble || s.isScatterPlot ? maxes.y : maxes)]).nice();
      var zScale = z.domain([0, d3.max(s.isBubble ? maxes.z : maxes)]).nice();
      var numTicks = entries;

      if (s.xAxis && s.xAxis.ticks) {
        numTicks = s.xAxis.ticks === 'auto' ? Math.max(width / 85, 2) : s.xAxis.ticks;

        if (s.isBubble || s.isScatterPlot && isViewSmall) {
          numTicks = Math.round(entries / 2);
        }
      }

      if (isViewSmall) {
        var _s$xAxis3;

        if ((_s$xAxis3 = s.xAxis) !== null && _s$xAxis3 !== void 0 && (_s$xAxis3 == null ? void 0 : _s$xAxis3.numTicksOnSmallView)) {
          var _s$xAxis4;

          numTicks = (_s$xAxis4 = s.xAxis) === null || _s$xAxis4 === void 0 ? void 0 : _s$xAxis4 == null ? void 0 : _s$xAxis4.numTicksOnSmallView;
        }
      }

      var xAxis = d3.axisBottom(xScale).ticks(numTicks).tickPadding(10).tickSize(s.isBubble || s.isScatterPlot ? -(height + 10) : 0).tickFormat(function (d, j) {
        var _s$xAxis5, _s$xAxis6;

        if (typeof ((_s$xAxis5 = s.xAxis) === null || _s$xAxis5 === void 0 ? void 0 : _s$xAxis5 == null ? void 0 : _s$xAxis5.formatter) === 'function') {
          return s.xAxis.formatter(d, j);
        }

        if (((_s$xAxis6 = s.xAxis) === null || _s$xAxis6 === void 0 ? void 0 : _s$xAxis6 == null ? void 0 : _s$xAxis6.ticks) === 'auto') {
          return names[d];
        }

        return s.isBubble || s.isScatterPlot ? d : names[d];
      });
      var yAxis = d3.axisLeft(yScale).ticks(8).tickSize(-(width + 20)).tickPadding(self.isRTL ? -18 : 20);

      if ((_s$yAxis = s.yAxis) !== null && _s$yAxis !== void 0 && (_s$yAxis == null ? void 0 : _s$yAxis.formatter)) {
        yAxis.tickFormat(function (d, k) {
          return typeof s.yAxis.formatter === 'function' ? s.yAxis.formatter(d, k) : d;
        });
      }

      if ((_s$yAxis2 = s.yAxis) !== null && _s$yAxis2 !== void 0 && (_s$yAxis2 == null ? void 0 : _s$yAxis2.ticks)) {
        yAxis.ticks(s.yAxis.ticks.number, s.yAxis.ticks.format);
      } // Append The Axis Labels


      if (isAxisLabels.atLeastOne) {
        var axisLabelsGroup = self.svg.append('g').attr('class', 'axis-labels');
        var place = {
          top: "translate(".concat(width / 2, ",").concat(-10, ")"),
          right: "translate(".concat(width + 28, ",").concat(height / 2, ")rotate(90)"),
          bottom: "translate(".concat(width / 2, ",").concat(height + 40, ")"),
          left: "translate(".concat(-40, ",").concat(height / 2, ")rotate(-90)")
        };
        var placeStyle = {
          top: "rotate(0deg) scaleX(-1) translate(-".concat(width / 2, "px, ").concat(-10, "px)"),
          right: "rotate(90deg) scaleX(-1) translate(-".concat(height / 2 + 5, "px, -").concat(width + 28, "px)"),
          bottom: "rotate(0deg) scaleX(-1) translate(-".concat(width / 2, "px, ").concat(height + 40, "px)"),
          left: "rotate(90deg) scaleX(-1) translate(-".concat(height / 2 - 5, "px, ", 55, "px)")
        };

        var addAxis = function addAxis(pos) {
          if (isAxisLabels[pos]) {
            axisLabelsGroup.append('text').attr('class', "axis-label-".concat(pos)).attr('text-anchor', 'middle').attr('transform', self.isRTL ? '' : place[pos]).style('font-size', '1.25em').style('transform', self.isRTL ? placeStyle[pos] : '').text(axisLabels[pos]);
          }
        };

        for (i = 0, l = axisArray.length; i < l; i++) {
          addAxis(axisArray[i]);
        }
      } // Append The Axis to the svg


      self.svg.append('g').attr('class', 'x axis').attr('transform', "translate(0,".concat(height, ")")).call(xAxis);
      self.svg.append('g').attr('class', 'y axis').call(yAxis); // Offset the tick inside, uses the fact that the yAxis has 20 added.

      self.svg.selectAll('.tick line').attr('x1', '-10');

      if (s.isBubble || s.isScatterPlot) {
        self.svg.selectAll('.x.axis .tick line, .y.axis .tick line').style('opacity', 0);
        var firstLineX = self.svg.select('.x.axis .tick line');
        firstLineX.attr('x2', '-10');

        if (!s.xAxis || s.xAxis && !s.xAxis.hideLine) {
          firstLineX.style('opacity', 1);
        }

        if (!s.yAxis || s.yAxis && !s.yAxis.hideLine) {
          self.svg.select('.y.axis .tick line').style('opacity', 1);
        }
      }

      if (self.isRTL) {
        self.svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        self.svg.selectAll('.y.axis text').style('text-anchor', 'end');
      }

      if (isAxisXRotate) {
        self.svg.selectAll('.x.axis .tick text') // select all the text for the xaxis
        .attr('y', 0).attr('x', function () {
          return -(this.getBBox().width + 10);
        }).attr('dy', '1em').attr('transform', "rotate(".concat(xRotate.use, ")")).style('text-anchor', 'start');
      }

      if (s.xAxis && s.xAxis.formatText) {
        self.svg.selectAll('.x.axis .tick text').each(function (m) {
          var elem = d3.select(this);
          var text = d3.select(this).text();
          var markup = s.xAxis.formatText(text, m);
          DOM.html(elem.node(), markup, '<tspan><text><glyph>');
        });
      } // Create the line generator


      var line = d3.line().x(function (d, n) {
        var _s$xAxis7;

        return xScale(typeof ((_s$xAxis7 = s.xAxis) === null || _s$xAxis7 === void 0 ? void 0 : _s$xAxis7 == null ? void 0 : _s$xAxis7.parser) === 'function' ? s.xAxis.parser(d, n) : s.isBubble || s.isScatterPlot ? d.value.x : n);
      }).y(function (d) {
        return yScale(s.isBubble || s.isScatterPlot ? d.value.y : d.value);
      }); // Append the lines

      dataset.forEach(function (d, lineIdx) {
        var lineGroups = self.svg.append('g').attr('data-group-id', lineIdx).attr('class', 'line-group');

        if (s.isArea) {
          var area = d3.area().x(function (dc, p) {
            return xScale(p);
          }).y0(height).y1(function (db) {
            return yScale(s.isBubble || s.isScatterPlot ? db.value.y : db.value);
          });
          lineGroups.append('path').datum(d.data).attr('fill', function () {
            return charts.chartColor(lineIdx, 'line', d);
          }).style('opacity', '.2').attr('class', 'area').attr('d', area).call(function (d2) {
            d2._groups.forEach(function (lines) {
              lines.forEach(function (thisLine) {
                utils.addAttributes($(thisLine), d, d.attributes, 'area');
              });
            });
          });
        }

        var path = lineGroups.append('path').datum(d.data).attr('d', line(d.data)).attr('stroke', function () {
          return s.isBubble || s.isScatterPlot ? '' : charts.chartColor(lineIdx, 'line', d);
        }).attr('stroke-width', 2).attr('fill', 'none').attr('class', 'line').call(function (d2) {
          d2._groups.forEach(function (lines) {
            lines.forEach(function (thisLine) {
              utils.addAttributes($(thisLine), d, d.attributes, 'line');
            });
          });
        }).on("click.".concat(self.namespace), function () {
          charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), d, self.element, dataset, self.initialSelectCall);
        }).on("contextmenu.".concat(self.namespace), function () {
          charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
        }); // Add animation

        var totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', "".concat(totalLength, " ").concat(totalLength)).attr('stroke-dashoffset', totalLength).transition().duration(s.animate ? 600 : 0).ease(d3.easeCubic).attr('stroke-dashoffset', 0);

        var handleMouseEnter = function handleMouseEnter(elem, mouseEnterData) {
          var rect = elem.getBoundingClientRect();
          var content = "<p><b>".concat(mouseEnterData.name, " </b> ").concat(format(mouseEnterData.value), "</p>");

          var show = function show() {
            var size = charts.tooltipSize(content);
            var posX = rect.left - size.width / 2 + 6;
            var posY = rect.top - size.height - 18;
            posX = s.isBubble || s.isScatterPlot ? rect.left + rect.width / 2 - size.width / 2 : posX;

            if (content !== '') {
              if (charts.tooltip && charts.tooltip.length) {
                charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
              }

              charts.showTooltip(posX, posY, content, 'top');
            }
          };

          if (s.isBubble || s.isScatterPlot) {
            content = "<div class=\"chart-swatch line\"><div class=\"swatch-caption\"><span class=\"indicator-box\"></span>\n            <b>".concat(mouseEnterData.name, "</b></div>");

            for (var key in mouseEnterData) {
              //eslint-disable-line
              if (mouseEnterData.hasOwnProperty(key)) {
                //eslint-disable-line
                if (_typeof(mouseEnterData[key]) !== 'object') {
                  if (labels[key]) {
                    content += "".concat('' + '<div class="swatch-row">' + '<span>').concat(labels[key], "</span>") + "<b>".concat(d.name, "</b>") + '</div>';
                  }
                } else {
                  var obj2 = mouseEnterData[key];

                  for (var key2 in obj2) {
                    //eslint-disable-line
                    if (obj2.hasOwnProperty(key2) && labels[key]) {
                      //eslint-disable-line
                      content += "".concat('' + '<div class="swatch-row">' + '<span class="text-capitalize">').concat(labels[key][key2], "</span>") + "<b>".concat(formatValue(valueFormatterString[key2], obj2[key2]), "</b>") + '</div>';
                    }
                  }
                }
              }
            }

            content += '</div>';
          }

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
            content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function () {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = data;
                  tooltipDataCache[i] = data;
                });
              }

              if (content !== '') {
                clearInterval(tooltipInterval);
                show();
              }
            }, 10);
          } else {
            tooltipData = _typeof(tooltipData) === 'object' ? '' : tooltipData;
            content = tooltipDataCache[i] || tooltipData || mouseEnterData.tooltip || d.tooltip || content || '';
            show(); // Set the colors

            var spans = document.querySelectorAll('#svg-tooltip .swatch-caption span');

            for (var k = 0; k < spans.length; k++) {
              spans[k].style.backgroundColor = charts.chartColor(s.isBubble || s.isScatterPlot ? mouseEnterData.lineIdx : k, 'line', mouseEnterData);
            }
          } // Circle associated with hovered point


          d3.select(this).attr('r', function (df) {
            return s.isBubble ? 2 + zScale(df.value.z) : dots.radiusOnHover;
          });
        };

        if (!hideDots) {
          if (!s.isScatterPlot) {
            lineGroups.selectAll('circle').data(d.data).enter().append('circle').attr('class', dots.class).call(function (d2) {
              d2._groups.forEach(function (thisDots) {
                thisDots.forEach(function (dot) {
                  var dat = dot.__data__;
                  utils.addAttributes($(dot), dat, dat.attributes, 'dot');
                });
              });
            }).attr('cx', function (dd, p) {
              if (!!s.xAxis && !!s.xAxis.parser) {
                return xScale(s.xAxis.parser(dd, p));
              }

              return xScale(s.isBubble || s.isScatterPlot ? dd.value.x : p);
            }).attr('cy', function (de) {
              return yScale(s.isBubble || s.isScatterPlot ? 0 : de.value);
            }).attr('r', dots.radius).style('stroke-width', dots.strokeWidth).style('fill', function () {
              return charts.chartColor(lineIdx, 'line', d);
            }).style('opacity', s.isBubble || s.isScatterPlot ? '.7' : '1').on("mouseenter.".concat(self.namespace), function (mouseEnterData) {
              mouseEnterData.lineIdx = lineIdx;
              handleMouseEnter(this, mouseEnterData);
            }).on("mouseleave.".concat(self.namespace), function () {
              clearInterval(tooltipInterval);
              charts.hideTooltip();
              d3.select(this).attr('r', function (dg) {
                return s.isBubble ? zScale(dg.value.z) : dots.radius;
              });
            }).on("click.".concat(self.namespace), function (dh) {
              charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), dh, self.element, dataset, self.initialSelectCall);
            }).on("contextmenu.".concat(self.namespace), function (di) {
              charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], di);
            });
          }

          if (s.isScatterPlot) {
            lineGroups.selectAll('.symbol').data(d.data).enter().append('path').attr('class', 'symbol').call(function (d2) {
              d2._groups.forEach(function (thisSymbols) {
                thisSymbols.forEach(function (symbol) {
                  var dat = symbol.__data__;
                  utils.addAttributes($(symbol), dat, dat.attributes, 'symbol');
                });
              });
            }).attr('transform', function (ds) {
              return "translate(".concat(xScale(ds.value.x), ",").concat(yScale(ds.value.y), ")");
            }).attr('d', d3.symbol().size(dots.strokeWidth).type(function () {
              return d3.symbols[lineIdx];
            })).style('opacity', 0).style('fill', function () {
              return charts.chartColor(lineIdx, 'line', d);
            }).on("mouseenter.".concat(self.namespace), function (mouseEnterData) {
              mouseEnterData.lineIdx = lineIdx;
              handleMouseEnter(this, mouseEnterData);
            }).on("mouseleave.".concat(self.namespace), function () {
              clearInterval(tooltipInterval);
              charts.hideTooltip();
              d3.select(this).attr('r', function () {
                return dots.radius;
              });
            }).on("click.".concat(self.namespace), function (dh) {
              charts.selectElement(d3.select(this.parentNode), self.svg.selectAll('.line-group'), dh, self.element, dataset, self.initialSelectCall);
            }).on("contextmenu.".concat(self.namespace), function (di) {
              charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], di);
            });
          }

          if (s.isBubble) {
            // Add animation
            lineGroups.selectAll('circle').attr('cy', function (di) {
              return yScale(di.value.y);
            }).transition().duration(s.animate ? 750 : 0).ease(d3.easeCubic).attr('r', function (dj) {
              return zScale(dj.value.z);
            });
          }

          if (s.isScatterPlot) {
            // Add animation
            lineGroups.selectAll('.symbol').transition().duration(s.animate ? 750 : 0).ease(d3.easeCubic).style('opacity', 1);
          }
        }
      }); // Set y-axix tick css class

      self.svg.selectAll('.y.axis .tick').attr('class', function (di) {
        return "tick".concat(di === 0 ? ' tick0' : '');
      });
      var series = dataset.map(function (d) {
        return {
          color: d.color,
          name: d.name,
          selectionObj: self.svg.selectAll('.line-group'),
          selectionInverse: self.svg.selectAll('.line-group'),
          data: d
        };
      });

      if (s.showLegend) {
        charts.addLegend(series, s.isScatterPlot ? 'scatterplot' : 'line', s, this.element);
      }

      charts.appendTooltip();

      charts.setSelected = function (o, isToggle) {
        var selected = 0;
        var equals = utils.equals;
        var selector;
        var selectorData;
        var elem;

        var setSelected = function setSelected(d, i1, d2, i2) {
          if (d2) {
            elem = self.svg.select("[data-group-id=\"".concat(i1, "\"]")).select(".dot:nth-child(".concat(i2 + 2, ")"));

            if (typeof o.groupIndex === 'number' && typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.groupIndex === i1 && o.fieldValue === d2[o.fieldName] || typeof o.index !== 'undefined' && typeof o.groupIndex === 'number' && o.groupIndex === i1 && o.index === i2 || o.elem && $(elem.node()).is(o.elem) || o.data && equals(o.data, d2)) {
              selected++;
              selectorData = d2;
              selector = self.svg.select("[data-group-id=\"".concat(i1, "\"]"));
            }
          } else {
            elem = self.svg.select("[data-group-id=\"".concat(i1, "\"]"));

            if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i1 || o.elem && $(elem.node()).is(o.elem) || o.data && equals(o.data, d)) {
              selected++;
              selectorData = d;
              selector = elem;
            }
          }
        };

        dataset.forEach(function (d, i3) {
          if (selected < 1 && d && d.data) {
            d.data.forEach(function (d2, i2) {
              if (selected < 1 && d2) {
                setSelected(d, i3, d2, i2);
              }
            });

            if (selected < 1) {
              setSelected(d, i3);
            }
          }
        });

        if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
          charts.selectElement(selector, self.svg.selectAll('.line-group'), selectorData, self.element, dataset, self.initialSelectCall);
        }
      };

      this.setInitialSelected();
      this.setTextValues();
      this.element.trigger('rendered');
      return this;
    },

    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var self = this;
      var selected = 0;
      var selector;
      var selectorData;

      var setInitialSelected = function setInitialSelected(node, d, selectedIdx) {
        if (node.selected && selected < 1) {
          selected++;
          selector = d3.select(self.svg.selectAll('.line-group').nodes()[selectedIdx]);
          selectorData = d;
        }
      };

      this.settings.dataset.forEach(function (d, setIdx) {
        if (d) {
          setInitialSelected(d, d, setIdx);
        }
      });
      this.settings.dataset.forEach(function (d, setIdx) {
        if (d || d.data) {
          d.data.forEach(function (d2) {
            setInitialSelected(d2, d, setIdx);
          });
        }
      });

      if (selected > 0) {
        self.initialSelectCall = true;
        charts.selectElement(selector, self.svg.selectAll('.line-group'), selectorData, self.element, self.settings.dataset, self.initialSelectCall);
      }

      self.initialSelectCall = false;
    },

    /**
     * Sets yaxis labels to not cut off or overlap.
     * @private
     */
    setTextValues: function setTextValues() {
      var _this$settings,
          _this$settings$axisLa,
          _this$svg,
          _this$svg$node,
          _this$svg$node$transf,
          _this$svg$node$transf2,
          _this$svg$node$transf3,
          _brief$transMatrix,
          _this = this;

      var self = this;
      var yAxis = {
        el: this.element[0].querySelector('.line-chart .axis.y')
      };
      var line = {
        el: yAxis.el.querySelector('.tick line')
      };
      var ticks = [].slice.call(yAxis.el.querySelectorAll('.tick text'));
      var leftAxis = (_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : (_this$settings$axisLa = _this$settings == null ? void 0 : _this$settings.axisLabels) === null || _this$settings$axisLa === void 0 ? void 0 : _this$settings$axisLa == null ? void 0 : _this$settings$axisLa.left;
      var isLeftAxis = typeof leftAxis === 'string' && leftAxis.trim() !== '';
      var brief = {
        maxWidth: this.element.width(),
        boxWidth: isLeftAxis ? 23 : 43,
        transMatrix: (_this$svg = this.svg) === null || _this$svg === void 0 ? void 0 : (_this$svg$node = _this$svg == null ? void 0 : _this$svg.node()) === null || _this$svg$node === void 0 ? void 0 : (_this$svg$node$transf = _this$svg$node == null ? void 0 : _this$svg$node.transform) === null || _this$svg$node$transf === void 0 ? void 0 : (_this$svg$node$transf2 = _this$svg$node$transf == null ? void 0 : _this$svg$node$transf.baseVal) === null || _this$svg$node$transf2 === void 0 ? void 0 : (_this$svg$node$transf3 = _this$svg$node$transf2 == null ? void 0 : _this$svg$node$transf2.consolidate()) === null || _this$svg$node$transf3 === void 0 ? void 0 : _this$svg$node$transf3 == null ? void 0 : _this$svg$node$transf3.matrix
      };
      brief.transY = ((_brief$transMatrix = brief.transMatrix) === null || _brief$transMatrix === void 0 ? void 0 : _brief$transMatrix == null ? void 0 : _brief$transMatrix.f) || 30;

      brief.customCss = function () {
        return {
          tooltip: {
            maxWidth: "".concat(brief.maxWidth, "px")
          },
          arrow: {
            left: _this.isRTL ? 'calc(100% - 20px)' : '20px'
          }
        };
      };

      yAxis.width = yAxis.el.getBBox().width;
      line.width = line.el.getBBox().width;
      brief.xDiff = yAxis.width - line.width;
      ticks.forEach(function (tick, i) {
        var text = tick.textContent;
        var textWidth = charts.calculateTextRenderWidth(text);
        var parentNode = tick.parentNode;

        if (textWidth >= brief.boxWidth) {
          var calculatePos = function calculatePos(rect) {
            var numOfLines = Math.ceil(textWidth / brief.maxWidth);
            var x = rect.left;
            var y = rect.top;
            x = x < 0 ? 30 : x;
            y = (y < 0 ? 30 : y) - 36;

            if (numOfLines > 1) {
              y -= 33 * ((numOfLines - 1) * 0.5);
            }

            if (_this.isRTL) {
              x = rect.left - textWidth + 5;
            }

            return {
              x: x,
              y: y
            };
          };

          brief.elem = tick;

          if (!Environment.browser.isIE11()) {
            tick.classList.add('hidden');
            d3.select(parentNode).append('foreignObject').attr('overflow', 'visible').attr('width', "".concat(brief.boxWidth)).attr('height', '16').attr('class', "foreign-object tick-y".concat(i)).attr('x', "-".concat(brief.boxWidth + (_this.isRTL ? 12 : 16))).attr('y', '-1em').attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility').html("<div class=\"text ellipsis\" resizeable=\"false\" xmlns=\"http://www.w3.org/1999/xhtml\">".concat(text, "</div>"));
            brief.elem = parentNode.querySelector('.text');
          } else {
            tick.textContent = charts.trimText(text, 5);
          }

          d3.select(brief.elem).on("mouseover.".concat(self.namespace), function () {
            var pos = calculatePos(this.getBoundingClientRect());
            charts.showTooltip(pos.x, pos.y, text, 'top', brief.customCss());
          }).on("mouseout.".concat(_this.namespace), function () {
            return charts.hideTooltip();
          });
        }
      });

      if (!isLeftAxis) {
        // Reasign values, could be truncation applied
        yAxis.width = yAxis.el.getBBox().width;
        line.width = line.el.getBBox().width;
        brief.xDiff = yAxis.width - line.width;
        var variations = [{
          min: 0,
          max: 23,
          val: 62
        }, {
          min: 23,
          max: 26,
          val: 65
        }, {
          min: 26,
          max: 30,
          val: 67
        }, {
          min: 30,
          max: 32,
          val: 69
        }, {
          min: 32,
          max: 34,
          val: 70
        }, {
          min: 34,
          max: 38,
          val: 71
        }, {
          min: 38,
          max: 42,
          val: 73
        }, {
          min: 42,
          max: 47,
          val: 77
        }, {
          min: 47,
          max: 55,
          val: 78
        }];
        var altered = variations.filter(function (n) {
          return brief.xDiff >= n.min && brief.xDiff < n.max;
        }); // Some manually altered variations

        if (altered.length) {
          brief.newX = altered[0].val;
          d3.select(this.svg.node()).attr('transform', "translate(".concat(brief.newX, ",").concat(brief.transY, ")"));

          if (Environment.browser.isIE11() && this.isRTL) {
            d3.selectAll('.line-chart .axis.y .tick text').attr('x', brief.boxWidth + 3);
          }
        }
      }
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on("updated.".concat(this.namespace), function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this2.updated();
      });
      return this;
    },
    width: 0,

    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },

    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: false,
        isGrouped: false,
        isSingle: false
      };
      charts.setSelected(options, isToggle, internals);
    },

    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },

    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      var _this3 = this;

      var resize = function resize() {
        if (_this3.width === _this3.element.width()) {
          return;
        }

        _this3.width = _this3.element.width();

        if (!_this3.element.is(':visible')) {
          return;
        }

        _this3.updated();
      }; // Waiting to complete the animatin on widget


      if (this.element.closest('.homepage').length) {
        setTimeout(function () {
          return resize();
        }, 300);
      } else {
        resize();
      }
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      return this.build();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      var _this4 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this4.namespace, " ")), ".").concat(_this4.namespace);
      };

      if (this.element) {
        this.element.find('.line-group .line').off(events(['click', 'contextmenu']));
        this.element.find('.line-group .symbol').off(events(['mouseenter', 'mouseleave', 'click', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));

      if (this.dots && this.element) {
        this.element.find(".line-group .".concat(this.dots.class)).off(events(['mouseenter', 'mouseleave', 'click', 'contextmenu']));
        delete this.dots;
      }

      delete this.namespace;
      return this;
    },

    /**
     * Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('line-chart');
        $.removeData(this.element[0], COMPONENT_NAME$o);
        $.removeData(this.element[0], 'chart');
      }
    }
  };

  var COMPONENT_NAME$p = 'column';
  /**
  * A column chart displays a series as a set of vertical bars that are grouped by category.
  * Column charts are useful for showing data changes over a period of time or for illustrating
  * comparisons among items.
  * @class Column
  * @param {string} element The plugin element for the constuctor
  * @param {string} [settings] The settings element.
  *
  * @param {array} [settings.dataset = []] The data to use in the line/area/bubble.
  * @param {boolean} [settings.isStacked = false] Set to true if its a stacked column chart
  * @param {boolean} [settings.showLegend = true] If false the legend will not be shown.
  * @param {boolean|string} [settings.animate = true] true|false - will do or not do the animation. 'initial' will do only first time the animation.
  * @param {boolean} [settings.redrawOnResize = true]  If set to false the component will not redraw when the page or parent is resized.
  * @param {string} [settings.format = null] The d3 axis format
  * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
  * @param {number} [settings.ticks = 9] The number of ticks to show.
  * @param {boolean} [settings.fitHeight=true] If true chart height will fit in parent available height.
  * @param {function} [settings.xAxis.formatText] A function that passes the text element and a counter.
  * You can return a formatted svg markup element to replace the current element.
  * For example you could use tspans to wrap the strings or color them.
  * @param {object} [settings.emptyMessage = { title: 'No Data', info: , icon: 'icon-empty-no-data' }]
  * An empty message will be displayed when there is no chart data. This accepts an object of the form
  * `emptyMessage: {
  *   title: 'No Data Available',
  *   info: 'Make a selection on the list above to see results',
  *   icon: 'icon-empty-no-data',
  *   button: {text: 'xxx', click: <function>
  *   }`
  * Set this to null for no message or will default to 'No Data Found with an icon.'
  * @param {object} [settings.localeInfo] If passed in you can override the default formatting https://github.com/d3/d3-format/blob/master/README.md#formatDefaultLocale
  */

  var COLUMN_DEFAULTS = {
    dataset: [],
    isStacked: false,
    showLegend: true,
    animate: true,
    format: null,
    redrawOnResize: true,
    ticks: 9,
    fitHeight: true,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };

  function Column(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COLUMN_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  Column.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.width = 0;
      this.initialSelectCall = false;

      if (this.settings.localeInfo) {
        d3.formatDefaultLocale(this.settings.localeInfo);
      }

      this.build().handleEvents(); // Handle initial option

      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }

      return this;
    },

    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0;

      var format = function format(value) {
        return d3.format(self.settings.formatterString || ',')(value);
      };

      var datasetStacked;
      var dataset = this.settings.dataset;
      this.dataset = dataset; // Handle Empty Data Set

      if (dataset.length === 0) {
        self.element.emptymessage(self.settings.emptyMessage);
        return this;
      }

      var parent = this.element.parent();
      var isRTL = Locale.isRTL();
      var isPositiveNegative = this.settings.type === 'column-positive-negative' || this.settings.type === 'positive-negative';
      var isSingle = dataset.length === 1;
      this.isSingle = isSingle;
      var isGrouped = !(isSingle || !isSingle && self.settings.isStacked);
      this.isGrouped = isGrouped;
      var margin = {
        top: 40,
        right: 40,
        bottom: isSingle && dataset[0].name === undefined ? self.settings.isStacked ? 20 : 50 : 35,
        left: 45
      };
      var legendHeight = 40;
      var parentAvailableHeight = utils.getParentAvailableHeight(self.element[0]);
      var useHeight = this.settings.fitHeight ? parentAvailableHeight : parseInt(parent.height(), 10);
      var width = parent.width() - margin.left - margin.right - 10;
      var height = useHeight - margin.top - margin.bottom - (isSingle && dataset[0].name === undefined ? self.settings.isStacked || isPositiveNegative ? legendHeight - 10 : 0 : legendHeight);
      var yMinTarget;
      var yMaxTarget;
      var series;
      var seriesStacked;
      var pnAttributes;
      var pnColors;
      var pnPatterns;
      var pnLegends;
      var pnSeries;
      var yMin = d3.min(dataset, function (group) {
        return d3.min(group.data, function (d) {
          return d.value;
        });
      });
      var yMax = d3.max(dataset, function (group) {
        //eslint-disable-line
        return d3.max(group.data, function (d) {
          return d.value;
        });
      });

      if (isPositiveNegative) {
        yMinTarget = d3.min(dataset, function (group) {
          return d3.min(group.data, function (d) {
            return d.target;
          });
        });
        yMaxTarget = d3.max(dataset, function (group) {
          return d3.max(group.data, function (d) {
            return d.target;
          });
        });
        yMin = d3.min([yMin, yMinTarget]);
        yMax = d3.max([yMax, yMaxTarget]);
        pnAttributes = {
          target: null,
          positive: null,
          negative: null
        };
        pnLegends = {
          target: 'Target',
          positive: 'Positive',
          negative: 'Negative'
        };
        pnColors = {
          target: 'neutral',
          positive: 'good',
          negative: 'error'
        };
        pnPatterns = {};

        if (dataset[0]) {
          if (dataset[0].attributes) {
            $.extend(true, pnAttributes, dataset[0].attributes);
          }

          if (dataset[0].colors) {
            $.extend(true, pnColors, dataset[0].colors);
          }

          if (dataset[0].legends) {
            $.extend(true, pnLegends, dataset[0].legends);
          }

          if (dataset[0].patterns) {
            $.extend(true, pnPatterns, dataset[0].patterns);
          }
        } // Converting object into array


        pnSeries = [];
        $.each(pnLegends, function (key, val) {
          var args = {
            name: val,
            color: pnColors[key],
            pattern: pnPatterns[key],
            option: key
          };

          if (pnAttributes[key]) {
            args.data = {
              attributes: pnAttributes[key]
            };
          }

          pnSeries.push(args);
        });
      }

      this.element.addClass('column-chart');
      var tooltipInterval;
      var tooltipDataCache = [];
      var tooltipData = self.settings.tooltip;
      var x0 = d3.scaleBand().range([0, width]).round(true).padding(this.settings.type === 'column-grouped' ? 0.1 : 0);
      var x1 = d3.scaleBand();
      var y = d3.scaleLinear().range([height, 0]);
      var xScale = null;
      var yScale = null;

      if (self.settings.isStacked) {
        // Map the Data Sets and Stack them.
        var yStack = {
          y1: [],
          y2: []
        };

        if (isSingle) {
          datasetStacked = dataset[0].data.map(function (d, i) {
            var y0 = 0;

            if (i === 0) {
              yStack.y1.push(d.value);
              yStack.y2.push(0);
            } else {
              y0 = yStack.y1[0] + yStack.y2[0];
              yStack.y1[0] = d.value;
              yStack.y2[0] = y0;
            }

            return [$.extend({}, d, {
              y0: y0,
              y: d.value,
              x: d.name,
              color: d.color,
              pattern: d.pattern,
              parentName: d.name,
              tooltip: d.tooltip
            })];
          });
        } else {
          datasetStacked = dataset.map(function (d, i) {
            return d.data.map(function (o, i2) {
              var y0 = 0;

              if (i === 0) {
                yStack.y1.push(o.value);
                yStack.y2.push(0);
              } else {
                y0 = yStack.y1[i2] + yStack.y2[i2];
                yStack.y1[i2] = o.value;
                yStack.y2[i2] = y0;
              }

              return $.extend({}, o, {
                y0: y0,
                y: o.value,
                x: o.name,
                color: o.color,
                pattern: o.pattern,
                parentName: d.name,
                tooltip: d.tooltip
              });
            });
          });
        }

        var stack = d3.stack();
        stack(datasetStacked);
        xScale = d3.scaleBand().domain(d3.range(datasetStacked[0].length)).rangeRound([0, width], 0.05);

        if (isSingle && self.settings.isStacked) {
          xScale.paddingInner(0.095);
        }

        yScale = d3.scaleLinear().domain([0, d3.max(datasetStacked, function (d) {
          return d3.max(d, function (d1) {
            return d1.y0 + d1.y;
          });
        })]).range([0, height]);
      } // List the values along the x axis


      var xAxisValues = dataset[0].data.map(function (d) {
        return d.name;
      });
      var xAxis = d3.axisBottom(x0).tickSize(0).tickPadding(12);
      var yAxis = d3.axisLeft(y).tickSize(-width).tickPadding(isRTL ? -12 : 12).ticks(self.settings.ticks || 9, d3.format(self.settings.format || 's'));

      if (self.settings.yAxis) {
        if (self.settings.yAxis.formatter) {
          yAxis.tickFormat(function (d, k) {
            if (typeof self.settings.yAxis.formatter === 'function') {
              return self.settings.yAxis.formatter(d, k);
            }

            return d;
          });
        }

        if (self.settings.yAxis.ticks && self.settings.yAxis.ticks.number > 1 && self.settings.yAxis.ticks.format) {
          yAxis.ticks(self.settings.yAxis.ticks.number, self.settings.yAxis.ticks.format);
        }
      }

      var svg = d3.select(this.element[0]).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', "translate(".concat(margin.left, ",").concat(margin.top, ")"));
      this.svg = svg; // Get the Different Names

      var names = dataset.map(function (d) {
        return d.name;
      }); // Get the Maxes of each series

      var maxesStacked;
      var maxes = dataset.map(function (d) {
        return d3.max(d.data, function (maxD) {
          return isPositiveNegative ? maxD.target : maxD.value;
        });
      });

      if (self.settings.isStacked) {
        maxesStacked = datasetStacked.map(function (maxesD) {
          return d3.max(maxesD, function (d) {
            return d.y + d.y0;
          });
        });
      }

      if (isSingle) {
        names = dataset[0].data.map(function (d) {
          return d.name;
        });
      } // Extra ticks


      if (isPositiveNegative) {
        yMin += yMin / y.ticks().length;
        maxes[0] += maxes[0] / (y.ticks().length / 2);
      } // Set series


      (function () {
        if (self.settings.isStacked && isSingle) {
          series = dataset[0].data;
        } else {
          var lm; // Loop backwards to catch and override with found first custom info from top

          for (var i = dataset.length - 1, l = -1; i > l; i--) {
            lm = dataset[i].data.map(function (d) {
              return d;
            });
            $.extend(true, series, lm); // Convert back to array from object

            series = $.map(series, function (d) {
              return d;
            });
          }
        }
      })();

      if (self.settings.isStacked && !isSingle) {
        seriesStacked = names.map(function (d, i) {
          return dataset[i];
        });
      }

      x0.domain(self.settings.isStacked ? xAxisValues : names);
      x1.domain(xAxisValues).rangeRound([0, isSingle || self.settings.isStacked ? width : x0.bandwidth()]);
      y.domain([yMin < 0 ? yMin : self.settings.minValue || 0, d3.max(self.settings.isStacked ? maxesStacked : maxes)]).nice();

      if (!isSingle || isSingle && !self.settings.isStacked) {
        svg.append('g').attr('class', 'x axis').attr('transform', "translate(0,".concat(height + (isPositiveNegative ? 10 : 0), ")")).call(xAxis);
      }

      svg.append('g').attr('class', 'y axis').call(yAxis); // Adjust extra(x) space for negative values for RTL

      if (isRTL && yMin < 0) {
        var yMaxLength = 0;
        var tempLength;
        svg.selectAll('.axis.y text').attr('class', function (d) {
          tempLength = d3.select(this).text().length;
          yMaxLength = tempLength > yMaxLength ? tempLength : yMaxLength;
          return d < 0 ? 'negative-value' : 'positive-value';
        }).attr('x', function (d) {
          return yMaxLength * (d < 0 ? 9 : 5);
        });
      } // Make an Array of objects with name + array of all values


      var dataArray = [];
      dataset.forEach(function (d) {
        dataArray.push($.extend({}, d, {
          values: d.data
        }));
      });

      if (isSingle) {
        dataArray = [];
        names = dataset[0].data.forEach(function (d) {
          dataArray.push(d);
        });
      }

      var targetBars;
      var pnBars;
      var barMaxWidth = 35;
      var barsInGroup = dataArray[0] && dataArray[0].values ? dataArray[0].values.length : 0;
      var isGroupSmaller = width / dataArray.length > barMaxWidth * (barsInGroup + 1);

      var color = function color(colorStr) {
        return charts.chartColor(0, '', {
          color: colorStr
        });
      };

      var onEndAllTransition = function onEndAllTransition(transition, callback) {
        var n;

        if (transition.empty()) {
          callback();
        } else {
          n = transition.size();
          transition.on("end.".concat(self.namespace), function () {
            n--;

            if (n === 0) {
              callback();
            }
          });
        }
      };

      var drawBars = function drawBars(isTargetBars) {
        var bars; //eslint-disable-line

        isTargetBars = isPositiveNegative && isTargetBars; // Add the bars - done different depending on if grouped or singlular

        if (isSingle || isPositiveNegative) {
          var barsType = isTargetBars ? 'target-bar' : 'bar';
          bars = self.svg.selectAll("rect.".concat(barsType)).data(self.settings.isStacked ? datasetStacked : dataArray).enter().append('rect').call(function (d) {
            d._groups.forEach(function (thisBars) {
              thisBars.forEach(function (bar) {
                var dat = bar.__data__;
                utils.addAttributes($(bar), dat, dat.attributes, barsType);
              });
            });
          }).attr('class', function (d, i) {
            var classStr = "bar series-".concat(i);

            if (isPositiveNegative) {
              classStr = (isTargetBars ? "target-bar series-".concat(i) : classStr) + (d.value > 0 ? ' positive' : ' negative');
            }

            return classStr;
          }).attr('width', Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth])).attr('x', function (d) {
            return self.settings.isStacked ? xScale(0) : x1(d.name) + (x1.bandwidth() - barMaxWidth) / 2;
          }).attr('y', function () {
            return y(0) > height ? height : y(0);
          }).attr('height', function () {
            return 0;
          }).attr('mask', function (d) {
            return !isPositiveNegative ? null : isTargetBars ? pnPatterns.target ? "url(#".concat(pnPatterns.target, ")") : null : d.value < 0 ? pnPatterns.negative ? "url(#".concat(pnPatterns.negative, ")") : null : pnPatterns.positive ? "url(#".concat(pnPatterns.positive, ")") : null;
          }).style('fill', function (d) {
            return !isPositiveNegative ? null : color(isTargetBars ? pnColors.target : d.value < 0 ? pnColors.negative : pnColors.positive);
          });

          if (isPositiveNegative) {
            var yTextPadding = 12;
            svg.selectAll(isTargetBars ? '.target-bartext' : '.bartext').data(dataArray).enter().append('text').attr('class', function (d) {
              return (isTargetBars ? 'target-bartext' : 'bartext') + (d.value > 0 ? ' positive' : ' negative');
            }).attr('text-anchor', 'middle').attr('x', function (d) {
              return (x1(d.name) + x1.bandwidth() / 2) * (isRTL ? -1 : 1);
            }).attr('y', function (d) {
              return isTargetBars ? y(d.target) - yTextPadding / 2 : y(d.value > 0 ? 0 : d.value) + yTextPadding;
            }).style('opacity', 0).style('fill', function (d) {
              return isTargetBars ? ''
              /* color(pnColors.target) */
              : d.value < 0 ? color(pnColors.negative) : color(pnColors.positive);
            }).style('font-weight', 'bold').text(function (d) {
              return format(isTargetBars ? d.target : d.value);
            });
          }

          bars.transition().duration(self.settings.animate ? 1000 : 0).call(onEndAllTransition, function () {
            svg.selectAll('.target-bartext, .bartext').transition().duration(self.settings.animate ? 300 : 0).style('opacity', 1);
          }).attr('y', function (d) {
            var r = self.settings.isStacked ? height - yScale(d[0].y) - yScale(d[0].y0) : d.value < 0 ? y(0) : y(d.value);
            return isTargetBars ? y(d.target) : d.value < 0 ? r : r > height - 3 ? height - 2 : r;
          }).attr('height', function (d) {
            var r;

            if (self.settings.isStacked) {
              r = yScale(d[0].y);
            } else if (d.value < 0) {
              r = height - y(0) - (height - y(d.value));
            } else {
              r = height - y(d.value) - (height - y(0));
            }

            r = d.value < 0 ? r : r < 3 ? 2 : r > height ? height - y(d.value) : r;
            return isTargetBars ? height - y(d.target) - (height - y(0)) : r;
          });
        } else {
          var xValues = svg.selectAll('.x-value').data(self.settings.isStacked ? datasetStacked : dataArray).enter().append('g').attr('class', 'series-group g').attr('data-group-id', function (d, i) {
            return i;
          }).attr('transform', function (d) {
            var x = x0(self.settings.isStacked ? xAxisValues[0] : d.name);
            var bandwidth = x0.bandwidth();

            if (!self.settings.isStacked && isGroupSmaller && bandwidth > barMaxWidth * dataArray.length * 2) {
              x += bandwidth / 2 / dataArray.length / 2;
            }

            if (self.isGrouped && !self.settings.isStacked) {
              if (d.data.length === 2) {
                if (bandwidth < 120) {
                  x -= barMaxWidth / 2 - 4;
                } else {
                  x = x0(d.name);
                }
              } else {
                var barDiff = barMaxWidth / (bandwidth > 150 ? 2 : 4);
                x -= barDiff;
              }
            }

            if (self.settings.isStacked && width < 290 && bandwidth < 40) {
              var _dataArray$, _dataArray$$data;

              var len = ((_dataArray$ = dataArray[0]) === null || _dataArray$ === void 0 ? void 0 : (_dataArray$$data = _dataArray$ == null ? void 0 : _dataArray$.data) === null || _dataArray$$data === void 0 ? void 0 : _dataArray$$data == null ? void 0 : _dataArray$$data.length) || 0;
              x = (width - bandwidth * len) / len / 2;
            }

            return "translate(".concat(x, ",0)");
          });
          bars = xValues.selectAll('rect').data(function (d) {
            return self.settings.isStacked ? d : d.values;
          }).enter().append('rect').call(function (d) {
            d._groups.forEach(function (thisBars) {
              thisBars.forEach(function (bar) {
                var dat = bar.__data__;
                utils.addAttributes($(bar), dat, dat.attributes, 'bar');
              });
            });
          }).attr('class', function (d, i) {
            return "series-".concat(i, " bar");
          }).attr('width', Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth])).attr('x', function (d, i) {
            var width = Math.min.apply(null, [x1.bandwidth() - 2, barMaxWidth]); //eslint-disable-line

            return self.settings.isStacked ? xScale(i) : x1.bandwidth() / 2 + (width + 2) * i - (dataArray[0].values.length === 1 || dataArray[0].values.length === 5 || dataArray[0].values.length === 4 ? width / 2 : 0);
          }).attr('y', function () {
            return y(0) > height ? height : y(0);
          }).attr('height', function () {
            return 0;
          });
          bars.transition().duration(self.settings.animate ? 600 : 0).attr('y', function (d) {
            var r = self.settings.isStacked ? height - yScale(d.y) - yScale(d.y0) : d.value < 0 ? y(0) : y(d.value);
            return d.value < 0 ? r : r > height - 3 ? height - 2 : r;
          }).attr('height', function (d) {
            var r;

            if (self.settings.isStacked) {
              r = yScale(d.y);
            } else if (d.value < 0) {
              r = height - y(0) - (height - y(d.value));
            } else {
              r = height - y(d.value) - (height - y(0));
            }

            return d.value < 0 ? r : r < 3 ? 2 : r > height ? height - y(d.value) : r;
          });
        }

        return bars;
      };

      if (isPositiveNegative) {
        targetBars = drawBars(true); // Draw target bars
      }

      var bars = drawBars();

      if (isPositiveNegative) {
        pnBars = d3.selectAll([].concat(_toConsumableArray(targetBars.nodes()), _toConsumableArray(bars.nodes())));
      }

      if (!isPositiveNegative) {
        // Style the bars and add interactivity
        if (!self.settings.isStacked) {
          bars.style('fill', function (d, i) {
            return isSingle ? charts.chartColor(i, 'column-single', dataset[0].data[i]) : charts.chartColor(i, 'bar', series[i]);
          }).attr('mask', function (d, i) {
            return isSingle ? dataset[0].data[i].pattern ? "url(#".concat(dataset[0].data[i].pattern, ")") : null : series[i].pattern ? "url(#".concat(series[i].pattern, ")") : null;
          });
        } else if (self.settings.isStacked && !isSingle) {
          bars.style('fill', function () {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return charts.chartColor(thisGroup, 'bar', dataset[thisGroup]);
          }).attr('mask', function () {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return dataset[thisGroup].pattern ? "url(#".concat(dataset[thisGroup].pattern, ")") : null;
          });
        } else if (self.settings.isStacked && isSingle) {
          bars.style('fill', function (d, i) {
            return charts.chartColor(i, 'bar', d[0]);
          }).attr('mask', function (d) {
            return d[0].pattern ? "url(#".concat(d[0].pattern, ")") : null;
          });
        }
      }

      $.extend(charts.settings, {
        svg: svg,
        chartType: 'Column',
        isSingle: isSingle,
        isGrouped: isGrouped,
        isStacked: self.settings.isStacked
      });
      (isPositiveNegative ? pnBars : bars).on("mouseenter.".concat(self.namespace), function (d, i) {
        var x;
        var y; //eslint-disable-line

        var j;
        var l;
        var hexColor;
        var size;
        var isTooltipBottom;
        var maxBarsForTopTooltip = 6;
        var thisShape = this;
        var shape = $(this);
        var content = '';
        var ePageY = d3.event.pageY;

        var setPattern = function setPattern(pattern, hexColor) {
          //eslint-disable-line
          return !pattern || !hexColor ? '' : "".concat('<svg width="12" height="12">' + '<rect style="fill: ').concat(hexColor, "\" mask=\"url(#").concat(pattern, ")\" height=\"12\" width=\"12\" />") + '</svg>';
        };

        var show = function show(isTooltipBottom) {
          //eslint-disable-line
          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;

          if (self.settings.isStacked) {
            y = shape[0].getBoundingClientRect().top - size.height - 10;
          } else {
            y = ePageY - charts.tooltip.outerHeight() - 25;

            if (dataset.length > 1) {
              x = thisShape.parentNode.getBoundingClientRect().left - size.width / 2 + thisShape.parentNode.getBoundingClientRect().width / 2;

              if (isTooltipBottom) {
                y += charts.tooltip.outerHeight() + 50;

                if (y > thisShape.parentNode.getBoundingClientRect().bottom + 10) {
                  y = thisShape.parentNode.getBoundingClientRect().bottom + 10;
                }
              } else {
                y = thisShape.parentNode.getBoundingClientRect().top - charts.tooltip.outerHeight() + 25;
              }
            }
          }

          if (content !== '') {
            if (charts.tooltip && charts.tooltip.length) {
              charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
            }

            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        }; // Replace matched pattern in given string


        var replaceMatch = function replaceMatch(str, callback, expr) {
          if (typeof expr === 'undefined' || expr === null) {
            expr = /{{(\w+)}}/g;
          } else if (typeof expr === 'string') {
            expr = new RegExp(expr, 'g');
          }

          if (typeof str === 'string' && typeof callback === 'function' && expr instanceof RegExp) {
            var max = 9999;

            while (expr.test(str) && max > 0) {
              str = str.replace(expr, function (match, key) {
                return callback(match, key);
              });
              max--;
            }
          }

          return str;
        }; // Replace key/value and set type as string


        var replaceMatchAndSetType = function replaceMatchAndSetType() {
          if (typeof content === 'string') {
            content = replaceMatch(content, function (match, key) {
              var r = format(d[key]);
              return isNaN(r) ? d[key] : r;
            });
          } else if (typeof content === 'number') {
            content = content.toString();
          }
        }; // Set custom tooltip callback method


        var setCustomTooltip = function setCustomTooltip(method) {
          content = '';
          var args = {
            index: i,
            data: d
          };

          var req = function req(res) {
            if (typeof res === 'string' || typeof res === 'number') {
              content = res;
              replaceMatchAndSetType();
              tooltipDataCache[i] = content;
            }
          };

          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              method(req, args);
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        }; // Stacked


        if (self.settings.isStacked) {
          if (isSingle) {
            content = "<p><b>".concat(format(d[0].value), "</b> ").concat(d[0].name, "</p>");
          } else {
            content = "".concat('' + '<div class="chart-swatch">' + '<div class="swatch-caption"><b>').concat(datasetStacked[0][i].name, "</b></div>");

            for (j = datasetStacked.length - 1, l = 0; j >= l; j--) {
              hexColor = charts.chartColor(j, 'bar', dataset[j]);
              content += "".concat('' + '<div class="swatch-row">' + '<div style="background-color:').concat(dataset[j].pattern ? 'transparent' : hexColor, ";\">").concat(setPattern(dataset[j].pattern, hexColor), "</div>") + "<span>".concat(datasetStacked[j][i].parentName, "</span><b>").concat(format(datasetStacked[j][i].value), "</b>") + '</div>';
            }

            content += '</div>';
          }

          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;
          y = shape[0].getBoundingClientRect().top - size.height - 10;
        } else {
          // Not Stacked
          if (isPositiveNegative) {
            content = "".concat('' + '<div class="chart-swatch">' + '<div class="swatch-caption"><b>').concat(d.name, "</b></div>") + '<div class="swatch-row">' + "<div style=\"background-color:".concat(pnPatterns.target ? 'transparent' : color(pnColors.target), ";\">").concat(setPattern(pnPatterns.target, color(pnColors.target)), "</div>") + "<span>".concat(pnLegends.target, "</span><b>").concat(format(d.target), "</b>") + '</div>' + '<div class="swatch-row">' + "<div style=\"background-color:".concat(d.value < 0 ? pnPatterns.negative ? 'transparent' : color(pnColors.negative) : pnPatterns.positive ? 'transparent' : color(pnColors.positive), ";\">").concat(d.value < 0 ? setPattern(pnPatterns.negative, color(pnColors.negative)) : setPattern(pnPatterns.positive, color(pnColors.positive)), "</div>") + "<span>".concat(pnLegends[d.value < 0 ? 'negative' : 'positive'], "</span><b>").concat(format(d.value), "</b>") + '</div>' + '</div>';
          } else if (dataset.length === 1) {
            content = "<p><b>".concat(format(d.value), "</b> ").concat(d.name, "</p>");
          } else {
            var data = d3.select(this.parentNode).datum().values;
            content = '<div class="chart-swatch">';

            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              content += "".concat('' + '<div class="swatch-row">' + '<div style="background-color:').concat(series[j].pattern ? 'transparent' : hexColor, ";\">").concat(setPattern(series[j].pattern, hexColor), "</div>") + "<span>".concat(data[j].name, "</span><b>").concat(format(data[j].value), "</b>") + '</div>';
            }

            content += '</div>';
            isTooltipBottom = data.length > maxBarsForTopTooltip;
          }

          size = charts.tooltipSize(content);
          x = shape[0].getBoundingClientRect().left - size.width / 2 + shape.attr('width') / 2;
          y = ePageY - charts.tooltip.outerHeight() - 25;

          if (dataset.length > 1) {
            x = this.parentNode.getBoundingClientRect().left - size.width / 2 + this.parentNode.getBoundingClientRect().width / 2;
            y = this.parentNode.getBoundingClientRect().top - charts.tooltip.outerHeight() + 25;
          }
        }

        if (tooltipData && typeof tooltipData === 'function' && typeof d.tooltip === 'undefined' && !tooltipDataCache[i]) {
          setCustomTooltip(tooltipData);
        } else {
          content = tooltipDataCache[i] || tooltipData || content || '';

          if (!tooltipDataCache[i] && d.tooltip !== false && typeof d.tooltip !== 'undefined' && d.tooltip !== null) {
            if (typeof d.tooltip === 'function') {
              setCustomTooltip(d.tooltip);
            } else {
              content = d.tooltip.toString();
              replaceMatchAndSetType();
              tooltipDataCache[i] = content;
            }
          }

          if (typeof content === 'string' && content !== '') {
            show(isTooltipBottom);
          }
        }
      }) // Mouseleave
      .on("mouseleave.".concat(self.namespace), function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      }) // Click
      .on("click.".concat(self.namespace), function (d, i, clickedLegend) {
        var isTargetBar = this && d3.select(this).classed('target-bar');
        var isSelected = this && d3.select(this).classed('is-selected');
        var thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10); // Set isSelected to false if even 1 bar is selected

        if (isTargetBar) {
          var allBars = d3.selectAll('.bar').nodes();
          var len = allBars.length;

          for (var j = 0; j < len; j++) {
            var bar = allBars[j];

            if (d3.select(bar).classed('is-selected')) {
              isSelected = false;
              break;
            }
          }
        }

        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: this,
          isTrigger: self.initialSelectCall ? false : !isSelected,
          isTargetBar: isTargetBar,
          triggerGroup: isGrouped,
          d: d,
          i: i,
          type: self.settings.type,
          dataset: self.dataset,
          isSingle: self.isSingle,
          isGrouped: self.isGrouped,
          isStacked: self.settings.isStacked,
          svg: self.svg,
          clickedLegend: clickedLegend === true
        });

        if (isSelected && !self.initialSelectCall) {
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, isGrouped ? thisGroupId : i]);
        }
      }) // Contextmenu
      .on("contextmenu.".concat(self.namespace), function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
      }); // Add Legend

      self.settings.isGrouped = isGrouped;
      self.settings.isSingle = isSingle;
      self.settings.svg = this.svg;

      if (self.settings.showLegend) {
        if (isSingle && dataset[0].name) {
          charts.addLegend(dataset, 'column-single', self.settings, self.element);
        } else if (isPositiveNegative) {
          charts.addLegend(pnSeries, self.settings.type, self.settings, self.element);
        } else if (self.settings.isStacked && isSingle) {
          charts.addLegend(series, self.settings.type, self.settings, self.element);
        } else if (!isSingle) {
          var legendSeries = self.settings.isStacked ? seriesStacked : series;
          legendSeries = legendSeries.map(function (d) {
            var _d$data;

            if (d.attributes && !((_d$data = d.data) !== null && _d$data !== void 0 && (_d$data == null ? void 0 : _d$data.attributes))) {
              if (d.data) {
                d.data.attributes = d.attributes;
              } else {
                d.data = {
                  attributes: d.attributes
                };
              }
            }

            return d;
          });
          charts.addLegend(legendSeries, self.settings.type, self.settings, self.element);
        }
      }

      if (self.settings.xAxis && self.settings.xAxis.formatText) {
        self.svg.selectAll('.x.axis .tick text').each(function (m) {
          var elem = d3.select(this);
          var text = d3.select(this).text();
          var markup = self.settings.xAxis.formatText(text, m);
          DOM.html(elem.node(), markup, '<tspan>');
        });
      }

      if (charts.isRTL && charts.isIE) {
        svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        svg.selectAll('.y.axis text').style('text-anchor', 'start');

        if (isPositiveNegative) {
          svg.selectAll('.negative-value').style('text-anchor', 'end');
        }
      } // Set y-axix tick css class


      svg.selectAll('.y.axis .tick').attr('class', function (d) {
        return "tick".concat(d === 0 ? ' tick0' : '');
      }); // Add Tooltips and legend

      charts.appendTooltip(); // See if any labels overlap and use shorter */
      // [applyAltLabels] - function(svg, dataArray, elem, selector, isNoEclipse)

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, 'shortName');
      }

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, 'abbrName');
      }

      if (charts.labelsColide(svg)) {
        charts.applyAltLabels(svg, dataArray, null, null, true); // Adjust extra(x) space with short name for RTL

        if (isPositiveNegative) {
          svg.selectAll('.target-bartext, .bartext').attr('x', function () {
            return +d3.select(this).attr('x') - (isRTL ? -6 : 6);
          });
        }
      }

      charts.setSelected = function (o, isToggle) {
        var selected = 0;
        var equals = utils.equals;
        var legendsNode = svg.node().parentNode.nextSibling;
        var legends = d3.select(legendsNode);
        var isLegends = legends.node() && legends.classed('chart-legend');
        var barIndex;
        var selector;
        var isStackedGroup;
        var xGroup;

        var setSelectedBar = function setSelectedBar(g, gIdx) {
          var isGroup = !!g;
          g = isGroup ? d3.select(g) : svg;
          gIdx = typeof gIdx !== 'undefined' ? gIdx : 0;
          g.selectAll('.bar').each(function (d, i) {
            if (!d) {
              return;
            }

            if (selected < 1) {
              if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === (isSingle && self.settings.isStacked ? d[0][o.fieldName] : d[o.fieldName]) || //eslint-disable-line
              typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, dataset[gIdx].data[i]) || o.elem && $(this).is(o.elem)) {
                selected++;
                selector = d3.select(this);
                barIndex = i;

                if (isGroup && !self.settings.isStacked) {
                  isStackedGroup = true;
                }
              }
            }
          });
        };

        var setSelectedGroup = function setSelectedGroup() {
          var groups = svg.selectAll('.series-group');

          if (groups.nodes().length) {
            groups.each(function (d, i) {
              setSelectedBar(this, i);
            });
          }
        };

        if (isGrouped || self.settings.isStacked && !isSingle && !isGrouped) {
          dataset.forEach(function (d, i) {
            if (selected < 1) {
              xGroup = $(svg.select("[data-group-id=\"".concat(i, "\"]")).node());

              if (typeof o.groupName !== 'undefined' && typeof o.groupValue !== 'undefined' && o.groupValue === d[o.groupName] || typeof o.groupIndex !== 'undefined' && o.groupIndex === i || o.data && equals(o.data, d) || o.elem && xGroup.is(o.elem)) {
                if (typeof o.fieldName === 'undefined' && typeof o.fieldValue === 'undefined' && typeof o.index === 'undefined') {
                  selected++;
                  selector = svg.select("[data-group-id=\"".concat(i, "\"]")).select('.bar');
                  barIndex = i;

                  if (self.settings.isStacked && !isGrouped) {
                    isStackedGroup = true;
                  }
                }
              }
            }
          });

          if (selected < 1) {
            setSelectedGroup();
          }
        } else {
          setSelectedBar();
        }

        if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
          if (isStackedGroup) {
            if (isLegends) {
              $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
            }
          } else {
            selector.on("click.".concat(self.namespace)).call(selector.node(), selector.datum(), barIndex);
          }
        }
      };

      this.setInitialSelected();
      this.element.trigger('rendered');
      return this;
    },

    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var self = this;
      var isPositiveNegative = /positive-negative/.test(self.settings.type);
      var legendsNode = self.svg.node().parentNode.nextSibling;
      var legends = d3.select(legendsNode);
      var isLegends = legends.node() && legends.classed('chart-legend');
      var isLegendsCall = false;
      var selected = 0;
      var barIndex;
      var selector;
      var isStacked;
      var isStackedGroup;

      var setSelectedBar = function setSelectedBar(g) {
        g = g ? d3.select(g) : self.svg;
        g.selectAll('.bar').each(function (d, i) {
          if (!d) {
            return;
          }

          var data = self.isSingle && self.settings.isStacked ? d[0] : d;

          if (data.selected && selected < 1) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
          }
        });
      };

      var setSelectedGroup = function setSelectedGroup() {
        var groups = self.svg.selectAll('.series-group');

        if (groups.nodes().length) {
          var getSelected = function getSelected(arr) {
            return arr.reduce(function (acc, n) {
              return n.selected ? acc + 1 : acc;
            }, 0);
          };

          var sel = {
            groups: [],
            itemsInGroup: 0
          };
          groups.each(function (d, i) {
            setSelectedBar(this);
            isStacked = Array.isArray(d);

            if (isStacked || d !== null && d !== void 0 && (d == null ? void 0 : d.data) && Array.isArray(d === null || d === void 0 ? void 0 : d == null ? void 0 : d.data)) {
              sel.itemsInGroup = (isStacked ? d : d.data).length;

              if (selected > 0) {
                sel.groups.push({
                  i: i,
                  totalSel: getSelected(isStacked ? d : d.data)
                });
              }
            }
          });
          sel.gLen = sel.groups.length;

          if (!isLegendsCall && (isStacked && sel.gLen && sel.groups[0].totalSel > 1 || sel.gLen === groups.size() && !isStacked)) {
            var results = sel.groups.filter(function (n) {
              return (n === null || n === void 0 ? void 0 : n == null ? void 0 : n.totalSel) > 1;
            }).length;
            isLegendsCall = isStacked ? !!results : !results;

            if (isStacked) {
              barIndex = sel.groups[0].i;
            }
          }
        }
      }; // Positive Negative and Legends


      if (isPositiveNegative) {
        var setLegendsCall = function setLegendsCall(idx) {
          isLegendsCall = true;
          barIndex = idx;
          selected++;
        };

        if (self.dataset[0].targetBarsSelected) {
          setLegendsCall(0);
        } else {
          var sel = {
            selected: 0,
            i: -1
          };
          self.dataset[0].data.forEach(function (d, i) {
            if (d.selected) {
              sel.selected++;
              sel.i = i;
            }
          });

          if (sel.selected > 1) {
            sel.elem = self.svg.select(".target-bar.series-".concat(sel.i));
            setLegendsCall(sel.elem.classed('positive') ? 1 : 2);
          }
        }
      }

      if (!isLegendsCall && (self.isGrouped || self.settings.isStacked && !self.isSingle && !self.isGrouped)) {
        self.dataset.forEach(function (d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = self.svg.select("[data-group-id=\"".concat(i, "\"]")).select('.bar');
            barIndex = i;

            if (self.settings.isStacked && !self.isSingle && !self.isGrouped) {
              isStackedGroup = true;
            }
          }
        });

        if (selected < 1) {
          setSelectedGroup();
        }
      } else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup || isLegendsCall) {
          if (isLegends) {
            this.initialSelectCall = true;
            $(legends.node()).find('.chart-legend-item').eq(barIndex).trigger('click.chart');
          }
        } else {
          this.initialSelectCall = true;
          selector.on("click.".concat(self.namespace)).call(selector.node(), selector.datum(), barIndex);
        }
      }

      this.initialSelectCall = false;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on("updated.".concat(this.namespace), function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this.updated();
      });
      return this;
    },

    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },

    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: false,
        isGrouped: false,
        isSingle: false
      };
      charts.setSelected(options, isToggle, internals);
    },

    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },

    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.build();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      var _this2 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this2.namespace, " ")), ".").concat(_this2.namespace);
      };

      if (this.element) {
        this.element.find('.target-bartext, .bartext').off("end.".concat(self.namespace));
        this.element.find('.bar, .target-bar').off(events(['mouseenter', 'mouseleave', 'click', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));
      delete this.namespace;
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('column-chart');
        $.removeData(this.element[0], COMPONENT_NAME$p);
        $.removeData(this.element[0], 'chart');
      }
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback, no-underscore-dangle */

  var COMPONENT_NAME$q = 'bar';
  /**
   * A bar chart or bar graph is a chart or graph that presents categorical data with rectangular bars
   * with heights or lengths proportional to the values that they represent. This is adapated from
   * http://jsfiddle.net/datashaman/rBfy5/2/
   * @class Bar
   * @param {string} element The plugin element for the constuctor.
   * @param {string} [settings] The settings element.
   * @param {array} [settings.dataset=[]] The data to use in the line/area/bubble.
   * @param {boolean} [settings.isStacked=true] Default is a single or stacked chart.
   * @param {boolean} [settings.isNormalized=false] If true its a 100% bar chart
   * @param {boolean} [settings.isGrouped=false] If true its a grouped bar chart
   * @param {boolean} [settings.showLegend=true] If false the legend will not be shown.
   * @param {boolean|string} [settings.animate=true] true|false - will do or not do the animation, 'initial' will do only first time the animation.
   * @param {boolean} [settings.redrawOnResize=true]  If set to false the component will not redraw when the page or parent is resized.
   * @param {string} [settings.formatterString] Use d3 format some examples can be found on http://bit.ly/1IKVhHh
   * @param {string} [settings.format=true] The d3 axis format
   * @param {string} [settings.tooltip=null] A tooltip for the whole chart
   * @param {boolean} [settings.useLogScale=false] If true log scale is enabled.
   * @param {object} [settings.ticks=null] Settings for the chart ticks. Can set ticks: {format: d3Format, number: n}
   * @param {boolean} [settings.showLines=true] Show the in the axis lines or not.
   * @param {number} [settings.labelFactor=1.27] How far out than the outer circle should the labels be placed, this
   * may be useful to adjust for some labels.
   * @param {number} [settings.wrapWidth=60] The number of pixels after which a label needs to be given a new line.
   * @param {boolean} [settings.fitHeight=true] If true chart height will fit in parent available height.
   * You may want to change this based on label data.
   * @param {object} [settings.emptyMessage={
   *  title: (Locale ? Locale.translate('NoData') : 'No Data Available'),
   *   info: '',
   *  icon: 'icon-empty-no-data' }]
   * An empty message will be displayed when there is no chart data. This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results'
   *  icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}  }`
   * Set this to null for no message or will default to 'No Data Found with an icon.'
   * @param {object} [settings.localeInfo] If passed in you can override the default formatting https://github.com/d3/d3-format/blob/master/README.md#formatDefaultLocale
   */

  var BAR_DEFAULTS = {
    dataset: [],
    isStacked: true,
    isNormalized: false,
    isGrouped: false,
    showLegend: true,
    animate: true,
    longText: false,
    format: null,
    redrawOnResize: true,
    tooltip: null,
    useLogScale: false,
    ticks: null,
    showLines: true,
    labelFactor: 1.27,
    wrapWidth: 60,
    fitHeight: true,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };

  function Bar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, BAR_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  Bar.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.width = 0;
      this.initialSelectCall = false;

      if (this.settings.localeInfo) {
        d3.formatDefaultLocale(this.settings.localeInfo);
      }

      this.build().handleEvents(); // Handle initial option

      if (this.settings.animate === 'initial') {
        this.settings.animate = false;
      }
      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Bar
      * @param {object} event - The jquery event object
      * @param {array} svg - The svg object.
      */


      this.element.trigger('rendered', [this.svg]);
      return this;
    },

    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      var self = this;
      var s = this.settings;
      var parent = this.element.parent();
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0;
      var isFormatter = !!s.formatterString;

      var format = function format(value) {
        return d3.format(self.settings.formatterString || ',')(value);
      };

      var maxTextWidth;
      var largestText;
      var yMap;
      var legendMap = [];
      var gindex;
      var totalBarsInGroup;
      var totalGroupArea;
      var totalHeight;
      var gap;
      var barHeight;
      var tooltipInterval;
      var tooltipDataCache = [];
      var tooltipData = s.tooltip;
      var barSpace = 0;
      var maxBarHeight = 30;
      var legendHeight = 30;
      var gapBetweenGroups = 0.6; // Makes it one bar in height (barHeight * 0.5)

      var isViewSmall = parent.width() < 450;
      var dataset = s.dataset;
      this.isRTL = Locale.isRTL();
      this.dataset = dataset;
      var innerWidth = window.innerWidth;
      this.viewport = {
        xxsmall: innerWidth <= 380,
        xsmall: innerWidth >= 381 && innerWidth <= 450,
        small: innerWidth >= 451 && innerWidth <= 480,
        medium: innerWidth >= 481 && innerWidth <= 992,
        large: innerWidth > 992
      };
      var margins = {
        top: 20,
        left: 30,
        right: 30,
        bottom: dataset.length === 1 ? 5 : 30
      };

      if (s.isGrouped && dataset.length === 1) {
        margins.bottom = 30;
        barSpace = 2;
      }

      this.element.addClass('bar-chart');

      if (s.isGrouped) {
        this.element.addClass('bar-chart-grouped');
      }

      if (s.isStacked) {
        this.element.addClass('bar-chart-stacked');
      } // Handle Empty Data Set


      if (dataset.length === 0) {
        self.element.emptymessage(s.emptyMessage);
        return this;
      } // Get the Legend Series


      var series = dataset.map(function (d) {
        return {
          name: d.name,
          color: d.color,
          pattern: d.pattern,
          attributes: d.attributes
        };
      }); // Ellipsis

      this.ellipsis = {
        use: false,
        percentageWidth: 25,
        threshold: 12
      };

      if (this.viewport.xxsmall) {
        this.ellipsis.percentageWidth = 37;
        this.ellipsis.threshold = 10;
      } else if (this.viewport.xsmall) {
        this.ellipsis.percentageWidth = 28;
        this.ellipsis.threshold = 10;
      } else if (this.viewport.small) {
        this.ellipsis.percentageWidth = 35;
      } // Map the Data Sets and Stack them.


      var yStack = {
        y1: [],
        y2: []
      };
      dataset = dataset.map(function (d, i) {
        return d.data.map(function (o, i2) {
          var y0 = 0;

          if (i === 0) {
            yStack.y1.push(o.value);
            yStack.y2.push(0);
          } else {
            y0 = yStack.y1[i2] + yStack.y2[i2];
            yStack.y1[i2] = o.value;
            yStack.y2[i2] = y0;
          }

          return $.extend({}, o, {
            y0: y0,
            y: o.value,
            x: charts.getLabel(o, self.viewport),
            color: o.color,
            pattern: o.pattern
          });
        });
      }); // Calculate max text width

      maxTextWidth = 0;
      largestText = '';
      dataset = dataset.map(function (group, i) {
        // eslint-disable-line
        if (!s.isStacked) {
          if (series[i]) {
            var label = charts.getLabel(series[i], self.viewport);
            var len = label.length;
            largestText = len > maxTextWidth ? label : largestText;
            maxTextWidth = len > maxTextWidth ? len : maxTextWidth;
          }
        }

        return group.map(function (d) {
          // eslint-disable-line
          if (s.isStacked) {
            var _len = d.x.length;
            largestText = _len > maxTextWidth ? d.x : largestText;
            maxTextWidth = _len > maxTextWidth ? _len : maxTextWidth;
          } // Invert the x and y values, and y0 becomes x0


          return $.extend({}, d, {
            x: d.y,
            y: d.x,
            x0: d.y0,
            color: d.color,
            pattern: d.pattern
          });
        });
      }); // influences the bar width

      var parentAvailableHeight = utils.getParentAvailableHeight(self.element[0]);
      var useHeight = s.fitHeight ? parentAvailableHeight : parseInt(parent.height(), 10);
      var height = useHeight - margins.top - margins.bottom - legendHeight;
      var h = useHeight - margins.bottom - (s.isStacked ? 0 : legendHeight / 2);
      var w = parseInt(parent.width(), 10) - margins.left;
      var textWidth = charts.calculateTextRenderWidth(largestText);

      if (textWidth < 200) {
        textWidth += 26;
      }

      if (charts.calculatePercentage(textWidth, w) > 55) {
        textWidth = charts.getPercentage(w, this.ellipsis.percentageWidth);
        this.ellipsis.use = true;
      }

      self.svg = d3.select(this.element[0]).append('svg').attr('width', w).attr('height', h).append('g').attr('class', 'group').attr('transform', "translate(".concat(textWidth, ",").concat(margins.top, ")"));
      var xMin = d3.min(dataset, function (g) {
        return d3.min(g, function (d) {
          return s.isStacked ? d.x + d.x0 : d.x;
        });
      });
      var xMax = d3.max(dataset, function (g) {
        return d3.max(g, function (d) {
          return s.isStacked ? d.x + d.x0 : d.x;
        });
      });

      if (s.isStacked && s.isNormalized) {
        var gMax = []; // get the max for each array group

        dataset.forEach(function (d) {
          d.forEach(function (d2, i) {
            gMax[i] = (gMax[i] === undefined ? 0 : gMax[i]) + d2.x;
          });
        }); // Normalize Each Group

        dataset.forEach(function (d) {
          d.forEach(function (d2, i) {
            var xDif = gMax[i] / 100;
            d2.x /= xDif;
            d2.x0 /= xDif;
          });
        });
        xMax = 100;
      } // Width of the bar minus the margin


      var barWith = w - textWidth - margins.left;
      var xScale;

      if (s.useLogScale) {
        xScale = d3.scaleLog().domain([xMin > 0 ? xMin : 1, xMax]).range([1, barWith]).nice();
      } else {
        xScale = d3.scaleLinear().domain([xMin < 0 ? xMin : 0, xMax]).range([0, barWith]).nice();
      }

      if (s.isStacked) {
        yMap = dataset[0].map(function (d) {
          return d.y;
        });
        barHeight = 0.32;
      } else {
        yMap = series.map(function (d) {
          return d.name;
        });

        (function () {
          // Loop backwards to catch and override with found first custom info from top
          for (var lm, i = dataset.length - 1, l = -1; i > l; i--) {
            lm = dataset[i].map(function (d) {
              return d;
            });
            $.extend(true, legendMap, lm); // Convert back to array from object

            legendMap = $.map(legendMap, function (d) {
              return d;
            });
          }
        })();

        gindex = 0;
        totalBarsInGroup = legendMap.length;
        totalGroupArea = height / yMap.length;
        barHeight = totalGroupArea / totalBarsInGroup;
        totalHeight = totalBarsInGroup > 1 ? totalGroupArea - barHeight * gapBetweenGroups : maxBarHeight;
        gap = totalGroupArea - totalHeight;
        maxBarHeight = totalHeight / totalBarsInGroup;
        barHeight = 0;
      }

      var yScale = d3.scaleBand().domain(yMap).rangeRound([0, height]).padding(barHeight, barHeight); // TODO

      var xAxis = d3.axisBottom().scale(xScale).tickSize(-height); //  .orient('middle') ??

      if (isViewSmall) {
        xAxis.ticks(textWidth < 100 ? 5 : 3);
      }

      if (s.isStacked && s.isNormalized) {
        xAxis.tickFormat(function (d) {
          return "".concat(d, "%");
        });
      }

      if (s.useLogScale) {
        xAxis.ticks(10, ',.1s');

        if (s.showLines === false) {
          xAxis.tickSize(0);
        }
      }

      if (s.ticks && !s.useLogScale) {
        if (self.viewport.small) {
          xAxis.ticks(s.ticks.smallNumber, s.ticks.format);
        } else if (self.viewport.medium) {
          xAxis.ticks(s.ticks.mediumNumber, s.ticks.format);
        } else if (self.viewport.large) {
          xAxis.ticks(s.ticks.largeNumber, s.ticks.format);
        }
      }

      var yAxis = d3.axisLeft().scale(yScale).tickPadding(15).tickSize(0);
      self.svg.append('g').attr('class', 'axis x').attr('transform', "translate(0,".concat(height, ")")).call(xAxis);
      self.svg.append('g').attr('class', 'axis y').call(yAxis);
      var groups = self.svg.selectAll('g.group').data(dataset).enter().append('g').attr('class', 'series-group').attr('data-group-id', function (d, i) {
        return i;
      });
      s.isGrouped = self.svg.selectAll('.series-group').nodes().length > 1 && !s.isStacked || s.isGrouped && dataset.length === 1;
      s.isSingle = self.svg.selectAll('.series-group').nodes().length === 1 && s.isStacked;
      groups.selectAll('rect').data(function (d, i) {
        d.forEach(function (d3) {
          d3.index = i;

          if (!s.isStacked) {
            d3.gindex = gindex++;
          }
        });
        return d;
      }).enter().append('rect').call(function (d) {
        d._groups.forEach(function (bars) {
          bars.forEach(function (bar) {
            var dat = bar.__data__;
            utils.addAttributes($(bar), dat, dat.attributes, 'bar');
          });
        });
      }).attr('class', function (d, i) {
        return "bar series-".concat(i);
      }).style('fill', function (d, i) {
        return s.isStacked ? // eslint-disable-line
        series.length === 1 ? charts.chartColor(i, 'bar-single', d) : // eslint-disable-line
        charts.chartColor(d.index, 'bar', series[d.index]) : // eslint-disable-line
        charts.chartColor(i, 'bar', legendMap[i]);
      }) // eslint-disable-line
      .attr('mask', function (d, i) {
        if (dataset.length === 1 && dataset[0][i].pattern) {
          return "url(#".concat(dataset[0][i].pattern, ")");
        }

        if (s.isStacked && series[d.index].pattern) {
          return "url(#".concat(series[d.index].pattern, ")");
        }

        if (!s.isStacked && legendMap[i] && legendMap[i].pattern) {
          return "url(#".concat(legendMap[i].pattern, ")");
        }

        return '';
      }).attr('x', function (d) {
        if (s.useLogScale) {
          return 0;
        }

        return s.isStacked && !s.isSingle ? xScale(d.x0) + 1 : xScale(0) + 1;
      }).attr('y', function (d) {
        return s.isStacked ? yScale(d.y) : (totalGroupArea - totalHeight) / 2 + (d.gindex * maxBarHeight + d.gindex * barSpace) + d.index * gap;
      }) // eslint-disable-line
      .attr('height', function () {
        return s.isStacked ? yScale.bandwidth() : maxBarHeight;
      }).attr('width', 0) // Animated in later
      .on("mouseenter.".concat(self.namespace), function (d, i) {
        var j;
        var l;
        var hexColor;
        var total = 0;
        var totals = [];
        var content = '';
        var data = d3.select(this.parentNode).datum();
        var mid = Math.round(data.length / 2);
        var shape = d3.select(this);

        var setPattern = function setPattern(pattern, hexColor2) {
          return !pattern || !hexColor2 ? '' : "<svg width=\"12\" height=\"12\"><rect mask=\"url(#".concat(pattern, ")\" height=\"12\" width=\"12\" /></svg>");
        };

        var show = function show(xPosS, yPosS, isTooltipBottom) {
          var size = charts.tooltipSize(content);
          var x = xPosS + parseFloat(shape.attr('width')) / 2 - size.width / 2;
          var y = isTooltipBottom ? yPosS : yPosS - size.height - 13;

          if (content !== '') {
            if (charts.tooltip && charts.tooltip.length) {
              charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
            }

            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        }; // Replace matched pattern in given string


        var replaceMatch = function replaceMatch(str, callback, expr) {
          if (typeof expr === 'undefined' || expr === null) {
            expr = /{{(\w+)}}/g;
          } else if (typeof expr === 'string') {
            expr = new RegExp(expr, 'g');
          }

          if (typeof str === 'string' && typeof callback === 'function' && expr instanceof RegExp) {
            var max = 9999;

            while (expr.test(str) && max > 0) {
              str = str.replace(expr, function (match, key) {
                return callback(match, key);
              });
              max--;
            }
          }

          return str;
        }; // Replace key/value and set type as string


        var replaceMatchAndSetType = function replaceMatchAndSetType() {
          if (typeof content === 'string') {
            content = replaceMatch(content, function (match, key) {
              var r = format(d[key]);
              return isNaN(r) ? d[key] : r;
            });
          } else if (typeof content === 'number') {
            content = content.toString();
          }
        }; // Set custom tooltip callback method


        var setCustomTooltip = function setCustomTooltip(method) {
          content = '';
          var args = {
            index: i,
            data: d
          };

          var req = function req(res) {
            if (typeof res === 'string' || typeof res === 'number') {
              content = res;
              replaceMatchAndSetType();
              tooltipDataCache[i] = content;
            }
          };

          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              method(req, args);
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        };

        if (dataset.length === 1) {
          content = "<p><b>".concat(d.y, " </b>").concat(d.x, "</p>");
        } else {
          content = '<div class="chart-swatch">';

          if (s.isStacked) {
            for (j = 0, l = dataset.length; j < l; j++) {
              total = 0;
              hexColor = charts.chartColor(j, 'bar', series[j]);

              for (var k = 0, kl = dataset.length; k < kl; k++) {
                total += dataset[k][i].x;
                totals[k] = dataset[k][i].x;
              }

              content += "<div class=\"swatch-row\">\n                  <div class=\"swatch-color\">".concat(setPattern(series[j].pattern, hexColor), "</div>\n                  <span>").concat(series[j].name, "</span>\n                  <b> ").concat(isFormatter ? format(totals[j]) : "".concat(Math.round(totals[j] / total * 100), "%"), " </b>\n                </div>");
            }
          } else {
            if (mid > 1) {
              shape = d3.select(this.parentNode).select(".series-".concat(mid));
            }

            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);
              content += "<div class=\"swatch-row\">\n                    <div class=\"swatch-color\">".concat(setPattern(legendMap[j].pattern, hexColor), "</div>\n                  <span>").concat(data[j].name, "</span><b>").concat(format(data[j].value), "</b>\n                </div>");
            }
          }

          content += '</div>';
        }

        if (total > 0) {
          content = "<span class=\"chart-tooltip-total\"><b>".concat(total, "</b> ").concat(Locale.translate('Total'), "</span>").concat(content);
        }

        var yPosS = shape.nodes()[0].getBoundingClientRect().top + $(window).scrollTop();
        var xPosS = shape.nodes()[0].getBoundingClientRect().left + $(window).scrollLeft();
        var maxBarsForTopTooltip = 6;
        var isTooltipBottom = !s.isStacked && data.length > maxBarsForTopTooltip;

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function () {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data2) {
                content = data2;
                tooltipDataCache[i] = data2;
              });
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show(xPosS, yPosS, isTooltipBottom);
            }
          }, 10);
        } else {
          content = tooltipDataCache[i] || tooltipData || content || '';

          if (!tooltipDataCache[i] && d.tooltip !== false && typeof d.tooltip !== 'undefined' && d.tooltip !== null) {
            if (typeof d.tooltip === 'function') {
              setCustomTooltip(d.tooltip);
            } else {
              content = d.tooltip.toString();
              replaceMatchAndSetType();
              tooltipDataCache[i] = content;
            }
          }

          if (typeof content === 'string' && content !== '') {
            show(xPosS, yPosS, isTooltipBottom);
          } // set inline colors


          if (s.isStacked) {
            for (j = 0, l = dataset.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              var row = $('#svg-tooltip').find('.swatch-row').eq(j);

              if (!series[j].pattern) {
                row.find('div').css('background-color', hexColor);
              }

              row.find('rect').css('fill', hexColor);
            }
          } else {
            for (j = 0, l = data.length; j < l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);

              var _row = $('#svg-tooltip').find('.swatch-row').eq(j);

              if (!legendMap[j].pattern) {
                _row.find('div').css('background-color', hexColor);
              }

              _row.find('rect').css('fill', hexColor);
            }
          }
        }
      }).on("mouseleave.".concat(self.namespace), function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      }).on('click', function (d, i) {
        var isSelected = this && d3.select(this).classed('is-selected');
        var thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);
        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: this,
          isTrigger: self.initialSelectCall ? false : !isSelected,
          triggerGroup: s.isGrouped,
          d: d,
          i: i,
          type: s.type,
          dataset: s.dataset,
          isSingle: self.isSingular,
          isGrouped: s.isGrouped,
          isStacked: s.isStacked,
          svg: self.svg,
          clickedLegend: s.clickedLegend
        });

        if (isSelected && !self.initialSelectCall) {
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {},  i]);
        }
      }).on("contextmenu.".concat(self.namespace), function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
      }); // Adjust the labels

      self.svg.selectAll('.axis.y text').attr('x', function () {
        return self.isRTL ? 15 : -15;
      });
      self.svg.selectAll('.axis.x text').attr('class', function (d) {
        return d < 0 ? 'negative-value' : 'positive-value';
      });

      if (self.isRTL && (charts.isIE || charts.isIEEdge)) {
        self.svg.selectAll('text').attr('transform', 'scale(-1, 1)');
        self.svg.selectAll('.y.axis text').style('text-anchor', 'start');
      }

      if (isViewSmall && s.useLogScale) {
        var ticks = d3.selectAll('.x .tick text');
        var foundMid = false; // At small breakpoint hide the last ones

        ticks.attr('class', function (d, i) {
          var middleTick = Math.round(ticks.size() / 2);

          if (i >= middleTick && !foundMid && d.toString().startsWith('1')) {
            foundMid = true;
            middleTick = d;
          }

          if (i !== 0 && i !== ticks.size() - 1 && (s.useLogScale ? d !== middleTick : i !== middleTick)) {
            d3.select(this).remove();
          }
        });
      } // Set x-axix tick css class


      self.svg.selectAll('.x.axis .tick').attr('class', function (d) {
        return "tick".concat(d === 0 ? ' tick0' : '');
      }); // Animate the Bars In

      self.svg.selectAll('.bar').transition().duration(s.animate ? 600 : 0).attr('width', function (d) {
        var scale = xScale(d.x);
        var scale0 = xScale(0);

        if (isNaN(scale) || !math.isFinite(scale)) {
          scale = 0;
        }

        if (isNaN(scale0) || !math.isFinite(scale0)) {
          scale0 = 0;
        }

        return Math.abs(scale - scale0);
      }).attr('x', function (d) {
        if (s.useLogScale) {
          return 0;
        }

        return s.isStacked && !s.isSingle ? xScale(d.x0) + 1 : //eslint-disable-line
        d.x < 0 ? xScale(d.x) + 1 : xScale(0) + 1;
      });
      s.svg = self.svg; // Add Legends

      if (s.showLegend) {
        var legendSeries = s.isStacked ? series : legendMap;
        legendSeries = legendSeries.map(function (d) {
          var _d$data;

          if (d.attributes && !((_d$data = d.data) !== null && _d$data !== void 0 && (_d$data == null ? void 0 : _d$data.attributes))) {
            if (d.data) {
              d.data.attributes = d.attributes;
            } else {
              d.data = {
                attributes: d.attributes
              };
            }
          }

          return d;
        });
        charts.addLegend(legendSeries, s.type, s, this.element);
      }

      charts.appendTooltip();
      this.setInitialSelected();
      this.setTextValues();
      this.element.trigger('rendered');
      return this;
    },

    /**
     * Set the text value in three viewport of bar chart
     * @private
     */
    setTextValues: function setTextValues() {
      var _this$settings,
          _this = this;

      var dataset = (_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : _this$settings == null ? void 0 : _this$settings.dataset;

      if (!dataset || dataset && dataset.constructor !== Array) {
        return;
      }

      var elems = this.element[0].querySelectorAll('.bar-chart .axis.y .tick text');
      var brief = {};

      if (this.ellipsis.use) {
        var _this$svg, _this$svg$node, _this$svg$node$transf, _this$svg$node$transf2, _this$svg$node$transf3, _this$svg$node$transf4;

        brief.maxWidth = this.element.width();
        brief.transX = ((_this$svg = this.svg) === null || _this$svg === void 0 ? void 0 : (_this$svg$node = _this$svg == null ? void 0 : _this$svg.node()) === null || _this$svg$node === void 0 ? void 0 : (_this$svg$node$transf = _this$svg$node == null ? void 0 : _this$svg$node.transform) === null || _this$svg$node$transf === void 0 ? void 0 : (_this$svg$node$transf2 = _this$svg$node$transf == null ? void 0 : _this$svg$node$transf.baseVal) === null || _this$svg$node$transf2 === void 0 ? void 0 : (_this$svg$node$transf3 = _this$svg$node$transf2 == null ? void 0 : _this$svg$node$transf2.consolidate()) === null || _this$svg$node$transf3 === void 0 ? void 0 : (_this$svg$node$transf4 = _this$svg$node$transf3 == null ? void 0 : _this$svg$node$transf3.matrix) === null || _this$svg$node$transf4 === void 0 ? void 0 : _this$svg$node$transf4 == null ? void 0 : _this$svg$node$transf4.e) || 1;

        brief.customCss = function () {
          return {
            tooltip: {
              maxWidth: "".concat(brief.maxWidth, "px")
            },
            arrow: {
              left: _this.isRTL ? 'calc(100% - 20px)' : '20px'
            }
          };
        };
      }

      var getText = function getText(d, i) {
        var r;

        if (_this.ellipsis.use) {
          r = charts.trimText(d.name, _this.ellipsis.threshold);

          if (r.substr(-3) === '...') {
            var textWidth = charts.calculateTextRenderWidth(d.name);
            var truncatedWidth = charts.calculateTextRenderWidth(r);
            var parentNode = elems[i].parentNode;

            var calculatePos = function calculatePos(rect) {
              var numOfLines = Math.ceil(textWidth / brief.maxWidth);
              var x = brief.transX - truncatedWidth;
              var y = rect.top;
              x = (x < 0 ? 30 : x) + 20;
              y = (y < 0 ? 30 : y) - 36;

              if (numOfLines > 1) {
                y -= 33 * ((numOfLines - 1) * 0.5);
              }

              if (_this.isRTL) {
                x = rect.left - textWidth + brief.transX;
              }

              return {
                x: x,
                y: y
              };
            };

            if (!Environment.browser.isIE11()) {
              r = d.name;
              elems[i].classList.add('hidden');
              d3.select(parentNode).append('foreignObject').attr('overflow', 'visible').attr('width', "".concat(brief.transX)).attr('height', '16').attr('class', "foreign-object tick-y".concat(i)).attr('x', "-".concat(brief.transX)).attr('y', '-1em').attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility').html("<div class=\"text ellipsis\" resizeable=\"false\" xmlns=\"http://www.w3.org/1999/xhtml\">".concat(d.name, "</div>"));
            }

            d3.select(parentNode).on("mouseover.".concat(_this.namespace), function () {
              var pos = calculatePos(parentNode.getBoundingClientRect());
              charts.showTooltip(pos.x, pos.y, d.name, 'top', brief.customCss());
            }).on("mouseout.".concat(_this.namespace), function () {
              return charts.hideTooltip();
            });
          }
        } else {
          r = charts.getLabel(d, _this.viewport);
        }

        return r;
      };

      if (this.settings.isGrouped) {
        dataset.forEach(function (d, i) {
          elems[i].textContent = getText(d, i);
        });
      } else {
        dataset.forEach(function (d) {
          var keys = Object.keys(d).map(function (key) {
            return key;
          });
          var values = Object.keys(d).map(function (key) {
            return d[key];
          });
          values.forEach(function (key, i) {
            if (key && key.constructor === Array) {
              key.forEach(function (k, i2) {
                if (keys[i] !== 'attributes') {
                  elems[i2].textContent = getText(k, i2);
                }
              });
            }
          });
        });
      }
    },

    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var self = this;
      var legendsNode = self.svg.node().parentNode.nextSibling;
      var legends = d3.select(legendsNode);
      var isLegends = legends.node() && legends.classed('chart-legend');
      var isLegendsCall = false;
      var selected = 0;
      var barIndex;
      var selector;
      var isStackedGroup;

      var setSelectedBar = function setSelectedBar(g) {
        g = g ? d3.select(g) : self.svg;
        g.selectAll('.bar').each(function (d, i) {
          if (!d) {
            return;
          }

          if (d.selected && selected < 1) {
            selected++;
            selector = d3.select(this);
            barIndex = i;
          }
        });
      };

      var setSelectedGroup = function setSelectedGroup() {
        var groups = self.svg.selectAll('.series-group');

        if (groups.nodes().length) {
          var _sel$groups$;

          var getSelected = function getSelected(arr) {
            return arr.reduce(function (acc, n) {
              return n.selected ? acc + 1 : acc;
            }, 0);
          };

          var sel = {
            groups: [],
            itemsInGroup: 0
          };
          groups.each(function (d, i) {
            setSelectedBar(this);

            if (Array.isArray(d)) {
              sel.itemsInGroup = d.length;

              if (selected > 0) {
                sel.groups.push({
                  i: i,
                  d: d,
                  totalSel: getSelected(d)
                });
              }
            }
          });
          sel.gLen = sel.groups.length;

          if (!isLegendsCall && self.settings.isGrouped && sel.gLen === groups.size() && ((_sel$groups$ = sel.groups[0]) === null || _sel$groups$ === void 0 ? void 0 : _sel$groups$ == null ? void 0 : _sel$groups$.totalSel) === 1) {
            isLegendsCall = true;

            for (var i = 0, l = sel.groups[0].d; i < l; i++) {
              if (sel.groups[0].d[i].selected) {
                barIndex = i;
                break;
              }
            }
          }
        }
      };

      if (self.settings.isGrouped || self.settings.isStacked && !self.settings.isSingle) {
        self.settings.dataset.forEach(function (d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = self.svg.select("[data-group-id=\"".concat(i, "\"]")).select('.bar');
            barIndex = i;

            if (self.settings.isStacked && !self.settings.isGrouped) {
              isStackedGroup = true;
            }
          }
        });

        if (selected < 1) {
          setSelectedGroup();
        }
      } else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup || isLegendsCall) {
          if (isLegends) {
            this.initialSelectCall = true;
            $(legends.node()).find('.chart-legend-item').eq(barIndex).trigger('click.chart');
          }
        } else {
          this.initialSelectCall = true;
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

      this.initialSelectCall = false;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on("updated.".concat(this.namespace), function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this2.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this2.updated();
      });
      return this;
    },

    /*
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },

    /*
     * Get info on the currently selected lines.
     */
    setSelected: function setSelected(options, isToggle) {
      var internals = {
        svg: this.svg,
        chartData: this.settings.dataset,
        isStacked: this.settingsisStacked,
        isGrouped: this.settings.isGrouped,
        isSingle: this.settings.isSingle
      };
      charts.setSelected(options, isToggle, internals);
    },

    /*
     * Get info on the currently selected lines.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },

    /*
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      var _this3 = this;

      var resize = function resize() {
        if (_this3.width === _this3.element.width()) {
          return;
        }

        _this3.width = _this3.element.width();

        if (!_this3.element.is(':visible')) {
          return;
        }

        _this3.updated();
      }; // Waiting to complete the animatin on widget


      if (this.element.closest('.homepage').length) {
        setTimeout(function () {
          return resize();
        }, 300);
      } else {
        resize();
      }
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.build().element.trigger('rendered', [this.svg]);
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      var _this4 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this4.namespace, " ")), ".").concat(_this4.namespace);
      };

      if (this.element) {
        this.element.find('.group .series-group .bar').off(events(['mouseenter', 'mouseleave', 'click', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));
      delete this.namespace;
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('bar-chart');
        $.removeData(this.element[0], COMPONENT_NAME$q);
        $.removeData(this.element[0], 'chart');
      }
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback, no-underscore-dangle */

  var COMPONENT_NAME$r = 'pie';
  /**
   * A pie chart (or a circle chart) is a circular statistical graphic which is divided
    into slices to illustrate numerical proportion. In a pie chart, the arc length of each slice is proportional to the quantity it represents.
   * @class Pie
   * @constructor
   *
   * @param {jquery[]|htmlelement} element The plugin element for the constuctor
   * @param {object} [settings] The component settings.
   * @param {array} [settings.dataset] The data to use in the line/area/bubble.
   * @param {boolean} [settings.isDonut=false] If true it renders as a donut chart.
   * @param {boolean} [settings.redrawOnResize=true]  If set to false the component will not redraw when the page or parent is resized. There is tooltip values provided.
    It will not be shown. If you still want lines at the lower breakpoint you can set this to true
   * @param {boolean} [settings.hideCenterLabel=false] If false the center label will not be shown.
   * @param {boolean} [settings.showLines=true] If false connector lines wont be shown
   * @param {boolean} [settings.showLinesMobile=false] This defaults to false, when false and under 450px the lines
   * @param {object} [settings.lines] A setting that controls the line values and format.
   * @param {string} [settings.line.show='value'] Controls the line value, this can be value, label or percent or custom function.
   * @param {string} [settings.line.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.showLegend=true] If false the legend will not be shown.
   * @param {boolean} [settings.showMobile=false] If true the chart is better formed to fit in a single widget.
   * @param {string} [settings.legendPlacement='right'] Where to locate the legend. This can be bottom or right at the moment.
   * @param {object} [settings.legend] A setting that controls the legend values and format.
   * @param {string} [settings.legend.show='label (percent)'] Controls what is visible
    in the legend, this can be value, value (percent), label or percent or your own custom function.
   * @param {string} [settings.legend.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.showTooltips=true] If false now tooltips will be shown
   * @param {object} [settings.tooltip] A setting that controls the tooltip values and format.
   * @param {string} [settings.tooltip.show='label (value)'] Controls what is visible in
    the tooltip, this can be value, label or percent or custom function.
   * @param {string} [settings.tooltip.formatter='.0f'] The d3.formatter string.
   * @param {boolean} [settings.fitHeight=true] If true chart height will fit in parent available height.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */

  var PIE_DEFAULTS = {
    dataset: [],
    isDonut: false,
    redrawOnResize: true,
    hideCenterLabel: false,
    showLines: true,
    showLinesMobile: false,
    lines: {
      show: 'value',
      // value, label or percent or custom function
      formatter: '.0f'
    },
    showLegend: true,
    legendPlacement: 'right',
    // Can be bottom or right
    legend: {
      show: 'label (percent)',
      // value, label, label (percent) or percent or custom function
      formatter: '.0f'
    },
    showTooltips: true,
    tooltip: {
      show: 'label (value)',
      // value, label, label (value) or percent or custom function
      formatter: '.0f'
    },
    fitHeight: true,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };

  function Pie(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PIE_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  Pie.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.width = 0;
      this.isFirefox = Environment.browser.name === 'firefox'; // Handle Empty Data Set

      if (this.settings.dataset.length === 0) {
        this.element.emptymessage(this.settings.emptyMessage);
        return this;
      }

      this.initialSelectCall = false;
      this.build().handleEvents();
      /**
       * Fires when the chart is complete done rendering, for customization.
       * @event rendered
       * @memberof Pie
       * @property {object} event - The jquery event object
       * @property {object} svg - The svg object.
       */

      this.element.trigger('rendered', [this.svg]);
      return this;
    },

    /**
     * Build the Component.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    build: function build() {
      var self = this;
      var s = this.settings;
      self.svg = d3.select(this.element[0]).append('svg');
      self.mainGroup = self.svg.append('g');
      self.mainGroup.append('g').attr('class', 'slices');
      self.mainGroup.append('g').attr('class', 'labels');
      self.mainGroup.append('g').attr('class', 'lines');
      this.element.addClass('chart-pie');

      if (s.showMobile) {
        s.legendPlacement = 'bottom';
      }

      if (s.legendPlacement) {
        this.element.addClass("has-".concat(s.legendPlacement, "-legend"));
      }

      var w = parseInt(this.element.width(), 10);
      var h = parseInt(this.element.height(), 10);
      var dims = {
        height: h,
        width: w
      };
      dims.isSmallView = dims.width < 360;
      var legendBotOnSingleWidget = s.legendPlacement === 'bottom' && dims.isSmallView && !s.showMobile;

      if (legendBotOnSingleWidget) {
        this.element.closest('.widget-content').css({
          height: '',
          'min-height': ''
        });
        h = parseInt(this.element.height(), 10);
        dims.height = h;
      }

      if (!legendBotOnSingleWidget && s.fitHeight && dims.isSmallView) {
        h = utils.getParentAvailableHeight(self.element[0]);
        dims.height = h;
      }

      if (s.lines.show === 'label' && s.legendPlacement === 'bottom' || s.lines.show === 'label' && s.showLegend === 'false') {
        self.mainGroup.attr('transform', "translate(".concat(dims.width * 0.67777, ", ").concat(dims.height / 2, ")"));
      }

      if (s.legendPlacement === 'right') {
        dims.width = w * 0.75;
      }

      if (s.showMobile) {
        dims.height = h * 0.80; // make some more room for the legend

        this.element.addClass('is-mobile');
      }

      var heightAdjusted = 0;

      if (legendBotOnSingleWidget) {
        heightAdjusted = 35;
        this.element.closest('.widget-content').css({
          height: 'auto',
          'min-height': 'auto'
        });
        var minHeight = dims.height - (23 + Math.round(s.dataset[0].data.length / 2) * 25);

        if (this.element.closest('.auto-height ').length) {
          minHeight += 78;
        }

        if (s.fitHeight) {
          minHeight -= utils.getSiblingsHeight(self.element[0]);
        }

        $(this.svg.node()).css({
          'min-height': minHeight
        });
        dims.height = parseInt(this.element.height(), 10) + heightAdjusted;
      }

      dims.radius = Math.min(dims.width, dims.height) / 2;
      self.dims = dims;
      self.pie = d3.pie().sort(null).value(function (d) {
        return d.value;
      });
      self.arc = d3.arc().outerRadius(dims.radius * 0.75).innerRadius(s.isDonut ? dims.radius * 0.5 : 0); // Influences the label position

      self.outerArc = d3.arc().innerRadius(dims.radius * 0.75).outerRadius(dims.radius * 0.75 + 20);
      self.svg.attr('width', s.legendPlacement === 'right' ? '75%' : '100%').attr('height', s.showMobile ? '80%' : '100%');
      self.mainGroup.attr('transform', "translate(".concat(dims.width / 2, ",").concat((dims.height - heightAdjusted) / 2, ")"));

      if (dims.isSmallView) {
        if (!legendBotOnSingleWidget) {
          self.svg.attr('height', "".concat(dims.height, "px"));
          this.element.css({
            height: 'auto'
          });
        }

        if (!s.fitHeight) {
          this.element.closest('.widget-content').css({
            height: ''
          });
          this.element.css({
            height: 'auto'
          });
        }
      } // move the origin of the group's coordinate space to the center of the SVG element


      dims.center = {
        x: dims.width / 2,
        y: dims.height / 2
      };

      self.key = function (d) {
        return d.data.name;
      };

      var isEmpty = !s.dataset || s.dataset.length === 0;
      this.chartData = !isEmpty ? s.dataset[0].data : [];
      this.sum = d3.sum(this.chartData, function (d) {
        return d.value;
      }); // Calculate the percentages

      var values = this.chartData.map(function (d) {
        return d.value / self.sum * 100;
      });
      var rounded = this.roundLargestRemainer(values);
      this.chartData = this.chartData.map(function (d, i) {
        d.percent = d.value / self.sum;
        d.percentRound = rounded[i];
        return d;
      });
      var sum = 0;
      this.chartData.map(function (d) {
        // eslint-disable-line
        sum += d.percentRound;
      }); // Handle zero sum or empty pies

      if (isEmpty || sum === 0 || isNaN(sum)) {
        var palette = theme.themeColors().palette;
        this.chartData.push({
          data: {},
          color: palette.slate['30'].value,
          name: 'Empty-Pie',
          value: 100,
          percent: 1,
          percentRound: 100
        });
      }

      self.updateData(self.chartData);

      if (s.showTooltips) {
        charts.appendTooltip('is-pie');
      }

      if (s.showLegend) {
        var series = self.chartData.map(function (d) {
          var name = charts.formatToSettings(d, s.legend);

          if (s.legendFormatter) {
            name = "".concat(d.name, " (").concat(d3.format(s.legendFormatter)(d.value), ")");
          }

          if (d.name === 'Empty-Pie') {
            name = '';
          }

          return {
            name: name,
            display: 'twocolumn',
            placement: s.legendPlacement,
            color: d.color,
            data: d
          };
        });
        s.svg = self.svg;
        charts.addLegend(series, 'pie', s, this.element);
        var setClass = heightAdjusted > 0 ? 'addClass' : 'removeClass';
        this.element.find('.chart-legend')[setClass]('adjusted-height');
      }

      this.setInitialSelected();
      this.addCenterLabel();
      this.element.trigger('rendered');
      return this;
    },

    /**
     * Randomize the data for testing.
     * @private
     * @param  {boolean} toZero Set them all to zero value.
     * @returns {void}
     */
    randomize: function randomize(toZero) {
      var self = this;
      this.chartData = this.chartData.map(function (d) {
        d.value = toZero ? 0 : Math.random();
        return d;
      });
      this.sum = d3.sum(this.chartData, function (d) {
        return d.value;
      });
      var values = this.chartData.map(function (d) {
        return d.value / self.sum * 100;
      });
      var rounded = this.roundLargestRemainer(values);
      this.chartData = this.chartData.map(function (d, i) {
        d.percent = d.value / self.sum;
        d.percentRound = rounded[i];
        return d;
      });
      return this.chartData;
    },

    /**
     * Add the center label for donut chart.
     * @private
     * @returns {void}
     */
    addCenterLabel: function addCenterLabel() {
      var self = this;

      if (self.settings.isDonut && !self.settings.hideCenterLabel) {
        var centerLabel = self.settings.dataset[0].centerLabel;
        var arcs = self.svg.selectAll('.slices');
        arcs.append('text').attr('dy', '.35em').style('text-anchor', 'middle').attr('class', 'chart-donut-text').html(centerLabel); // FIX: IE does not render .html
        // http://stackoverflow.com/questions/13962294/dynamic-styling-of-svg-text

        if (charts.isIE && !charts.isIEEdge) {
          if (utils.isHTML(centerLabel)) {
            var text = arcs.select('.chart-donut-text');
            var tmp = document.createElement('text');
            tmp.innerHTML = centerLabel;
            var nodes = Array.prototype.slice.call(tmp.childNodes);
            nodes.forEach(function (node) {
              text.append('tspan').attr('style', node.getAttribute && node.getAttribute('style')).attr('x', node.getAttribute && node.getAttribute('x')).attr('dy', node.getAttribute && node.getAttribute('dy')).text(node.textContent);
            });
          } else {
            arcs.select('.chart-donut-text').text(centerLabel);
          }
        }
      }
    },

    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     * @returns {void}
     */
    updateData: function updateData(data) {
      var _self$settings$toolti, _self$settings$lines;

      // Pie Slices
      var self = this;
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0;
      var tooltipInterval;
      var isEmpty = !self.settings.dataset || self.settings.dataset.length === 0;
      var slice = self.svg.select('.slices').selectAll('path.slice').data(self.pie(data), self.key);
      var formatters = {
        str: null,
        isTooltip: ((_self$settings$toolti = self.settings.tooltip) === null || _self$settings$toolti === void 0 ? void 0 : _self$settings$toolti == null ? void 0 : _self$settings$toolti.formatter) && self.settings.tooltip.formatter !== PIE_DEFAULTS.tooltip.formatter,
        isLines: ((_self$settings$lines = self.settings.lines) === null || _self$settings$lines === void 0 ? void 0 : _self$settings$lines == null ? void 0 : _self$settings$lines.formatter) && self.settings.lines.formatter !== PIE_DEFAULTS.lines.formatter
      };

      if (formatters.isTooltip) {
        formatters.str = self.settings.tooltip.formatter;
      } else if (formatters.isLines) {
        formatters.str = self.settings.lines.formatter;
      }

      var getOffset = function getOffset(node) {
        var body = document.body;
        var rect; // Fix: With firefox `getBoundingClientRect` not working if node is hidden

        if (self.isFirefox && self.settings.dotSize === 0) {
          var dot = d3.select(node);
          dot.attr('r', 2);
          rect = node.getBoundingClientRect();
          dot.attr('r', self.settings.dotSize);
        } else {
          rect = node.getBoundingClientRect();
        }

        return {
          top: rect.top + body.scrollTop,
          left: rect.left + body.scrollLeft
        };
      };

      self.isRTL = Locale.isRTL();
      slice.enter().insert('path').style('fill', function (d, i) {
        return charts.chartColor(i, 'pie', d.data);
      }).attr('class', 'slice').call(function (d) {
        d._groups.forEach(function (slices) {
          slices.forEach(function (pieSlice) {
            var dat = pieSlice.__data__;
            utils.addAttributes($(pieSlice), dat, dat.data.attributes);
          });
        });
      }).on("contextmenu.".concat(self.namespace), function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d); // charts.triggerContextMenu(self.element, d3.select(this).select('path').nodes()[0], d);
      }).on("click.".concat(self.namespace), function (d, i) {
        clearTimeout(tooltipInterval); // Handle Click to select

        var isSelected = this && d3.select(this).classed('is-selected'); // Make unselected

        charts.setSelectedElement({
          task: isSelected ? 'unselected' : 'selected',
          container: self.element,
          selector: isSelected ? '.chart-container .is-selected' : this,
          isTrigger: self.initialSelectCall ? false : !isSelected,
          d: d.data,
          i: i,
          type: self.settings.type,
          dataset: self.settings.dataset,
          svg: self.svg
        });

        if (isSelected && !self.initialSelectCall) {
          /**
           * Fires when arc/slice is selected.
           * @event selected
           * @memberof Pie
           * @property {object} event - The jquery event object
           * @property {object} selected arc/slice.
           * @property {object} data of selected arc/slice.
           * @property {number} index of selected arc/slice.
           */
          self.element.triggerHandler('selected', [d3.select(this).nodes(), {}, i]);
        }
      }).on("mouseenter.".concat(self.namespace), function (d, i) {
        if (!self.settings.showTooltips) {
          return;
        } // See where to position


        var dot = self.svg.selectAll('circle').nodes()[i];
        var offset = getOffset(dot); // See where we want the arrow

        var rads = self.midAngle(d); // https://www.wyzant.com/resources/lessons/math/trigonometry/unit-circle

        var isTop = rads <= Math.PI / 4 && rads >= 0 || rads > 7 * Math.PI / 4;
        var isRight = rads <= 3 * Math.PI / 4 && rads >= Math.PI / 4;
        var isBottom = rads <= 5 * Math.PI / 4 && rads >= 3 * Math.PI / 4;
        var isLeft = rads <= 7 * Math.PI / 4 && rads >= 5 * Math.PI / 4; // Build the content

        var content = '';

        var show = function show() {
          if (content === '') {
            return;
          }

          var size = charts.tooltipSize(content);
          var x = offset.left;
          var y = offset.top;
          var padding = 5;

          if (charts.tooltip && charts.tooltip.length && (isTop || isRight || isBottom || isLeft)) {
            charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
          }

          if (isTop) {
            x -= size.width / 2;
            y -= size.height - padding;
            charts.showTooltip(x, y, content, 'top');
          }

          if (isRight) {
            y -= size.height / 2;
            charts.showTooltip(x, y, content, 'right');
          }

          if (isBottom) {
            x -= size.width / 2; // y -= padding;

            charts.showTooltip(x, y, content, 'bottom');
          }

          if (isLeft) {
            x -= size.width - padding;
            y -= size.height / 2;
            charts.showTooltip(x, y, content, 'left');
          }
        };

        var value = charts.formatToSettings(d, self.settings.tooltip);
        var formatted = {
          value: formatters.str && !formatters.isTooltip ? d3.format(formatters.str)(d.value) : value,
          percent: formatters.str ? d3.format(formatters.str)(d.data.percent) : "".concat(isNaN(d.data.percentRound) ? 0 : d.data.percentRound, "%")
        };
        content = d.data.tooltip || formatted.value;
        content = content.replace('{{percent}}', "".concat(formatted.percent));
        content = content.replace('{{value}}', d.value);
        content = content.replace('%percent%', "".concat(formatted.percent));
        content = content.replace('%value%', d.value);

        if (content.indexOf('<b>') === -1) {
          content = content.replace('(', '<b>');
          content = content.replace(')', '</b>');
        } // Debounce it a bit


        if (tooltipInterval != null) {
          clearTimeout(tooltipInterval);
        }

        tooltipInterval = setTimeout(function () {
          show();
        }, 300);
      }).on("mouseleave.".concat(self.namespace), function () {
        clearTimeout(tooltipInterval);
        charts.hideTooltip();
      }).merge(slice).transition().duration(self.settings.animationSpeed).attrTween('d', function (d) {
        this.current = this.current || d;
        var interpolate = d3.interpolate(this.current, d);
        this.current = interpolate(0);
        return function (t) {
          return self.arc(interpolate(t));
        };
      });
      slice.exit().remove();

      if (isEmpty) {
        return;
      }

      var isMobile = self.element.parent().width() < 520;
      var shouldShow = self.settings.showLines;

      if (!self.settings.showLinesMobile && shouldShow) {
        shouldShow = !isMobile;
      }

      self.settings.dotSize = shouldShow ? 2 : 0; // Text Labels

      if (shouldShow) {
        var padding = 20;
        var text = self.svg.select('.labels').selectAll('text').data(self.pie(data), self.key);
        text.enter().append('text').attr('dy', '.35em').text(function (d) {
          return isMobile ? d.data.shortName : charts.formatToSettings(d, self.settings.lines);
        }).merge(text).transition().duration(self.settings.animationSpeed).attrTween('transform', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);
            var pos = self.outerArc.centroid(d2);
            pos[0] = self.dims.radius * (self.midAngle(d2) < Math.PI ? 1 : -1);
            pos[0] -= self.midAngle(d2) < Math.PI ? padding : -padding;
            return "translate(".concat(pos, ")");
          };
        }).styleTween('text-anchor', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);

            if (self.isRTL) {
              return self.midAngle(d2) > Math.PI ? 'start' : 'end';
            }

            return self.midAngle(d2) < Math.PI ? 'start' : 'end';
          };
        });
        text.exit().remove(); // Slice to text poly lines

        var polyline = self.svg.select('.lines').selectAll('polyline').data(self.pie(data), self.key);
        polyline.enter().append('polyline').merge(polyline).transition().duration(self.settings.animationSpeed).attrTween('points', function (d) {
          this.current = this.current || d;
          var interpolate = d3.interpolate(this.current, d);
          this.current = interpolate(0);
          return function (t) {
            var d2 = interpolate(t);
            var pos = self.outerArc.centroid(d2);
            pos[0] = self.dims.radius * 0.85 * (self.midAngle(d2) < Math.PI ? 1 : -1);
            return [self.outerArc.centroid(d2), self.outerArc.centroid(d2), pos];
          };
        });
        polyline.exit().remove();
      }

      var dots = self.svg.select('.lines').selectAll('circle').data(self.pie(data), self.key);
      dots.enter().append('circle').attr('class', 'circles').attr('r', self.settings.dotSize).merge(dots).transition().duration(self.settings.animationSpeed).attrTween('transform', function (d) {
        this.current = this.current || d;
        var interpolate = d3.interpolate(this.current, d);
        this.current = interpolate(0);
        return function (t) {
          var d2 = interpolate(t);
          return "translate(".concat(self.outerArc.centroid(d2), " )");
        };
      });
      dots.exit().remove();
    },

    /**
     * Set the initially selected elements
     * @private
     * @returns {void}
     */
    setInitialSelected: function setInitialSelected() {
      var self = this;
      var selected = 0;
      var selector;
      this.svg.selectAll('.slice').each(function (d, i) {
        if (!d || !d.data) {
          return;
        }

        if (d.data.selected && selected < 1) {
          selected++;
          self.initialSelectCall = true;
          selector = d3.select(this);
          selector.on("click.".concat(self.namespace)).call(selector.node(), selector.datum(), i);
        }
      });
      this.initialSelectCall = false;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on("updated.".concat(this.namespace), function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this.updated();
      });
      return this;
    },

    /**
     * Get info on the currently selected lines.
     * @private
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },

    /**
     * Get info on the currently selected lines.
     * @private
     * @param {object} o The selection data object
     * @param {boolean} isToggle If true toggle the current state.
     */
    setSelected: function setSelected(o, isToggle) {
      var self = this;
      var selector;
      var arcIndex;
      var selected = 0;
      var equals = utils.equals;
      this.svg.selectAll('.slice').each(function (d, i) {
        if (!d || !d.data) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === d.data[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.data && equals(o.data, self.chartData[i].data) || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on("click.".concat(self.namespace)).call(selector.node(), selector.datum(), arcIndex);
      }
    },

    /**
     * Get info on the currently selected lines.
     * @param {object} options The selected info object.
     * @returns {void}
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },

    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.element.empty();
      return this.build().element.trigger('rendered', [this.svg]);
    },

    /**
     * Handle updated settings and values.
     * @private
     * @param  {array} values A list of values
     * @returns {array} The values rounded to 100
     */
    roundLargestRemainer: function roundLargestRemainer(values) {
      var sum = 0;
      var count = 0;
      var dVala = 0;
      var dValb = 0;
      var order = []; // Round everything down

      for (var i = 0; i < values.length; i++) {
        sum += parseInt(values[i], 10);
        order[i] = i;
      } // Getting the difference in sum and 100


      var diff = 100 - sum; // Distributing the difference by adding 1 to items in decreasing order of their decimal parts

      order.sort(function (a, b) {
        dVala = values[a] - parseInt(values[a], 10);
        dValb = values[b] - parseInt(values[b], 10);
        return dValb - dVala;
      });
      values.sort(function (a, b) {
        dVala = a - parseInt(a, 10);
        dValb = b - parseInt(b, 10);
        return dValb - dVala;
      });

      for (var j = 0; j < values.length; j++) {
        count = j;

        if (count < diff) {
          values[j] = parseInt(values[j], 10) + 1;
        } else {
          values[j] = parseInt(values[j], 10);
        }
      } // Set back the order


      var unsorted = [];

      for (var _i = 0; _i < values.length; _i++) {
        unsorted[order[_i]] = values[_i];
      }

      return unsorted;
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      var _this2 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this2.namespace, " ")), ".").concat(_this2.namespace);
      };

      if (this.element) {
        this.element.find('.slice').off(events(['mouseenter', 'mouseleave', 'click', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));
      delete this.namespace;
      return this;
    },

    /**
     * Calculate the middle angle.
     * @private
     * @param  {object} d The d3 data.
     * @returns {boolean} The mid angule
     */
    midAngle: function midAngle(d) {
      return d.startAngle + (d.endAngle - d.startAngle) / 2;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('pie-chart');
        $.removeData(this.element[0], COMPONENT_NAME$r);
        $.removeData(this.element[0], 'chart');
      }
    }
  };

  /* eslint-disable no-nested-ternary, prefer-arrow-callback, no-underscore-dangle */

  var COMPONENT_NAME$s = 'radar'; // Default Radar Options

  var RADAR_DEFAULTS = {
    dataset: [],
    redrawOnResize: true,
    margin: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    levels: 4,
    maxValue: 0,
    labelFactor: 1.27,
    wrapWidth: 60,
    opacityArea: 0.2,
    dotRadius: 3,
    opacityCircles: 0,
    strokeWidth: 1,
    roundStrokes: true,
    showCrosslines: true,
    showAxisLabels: true,
    colors: null,
    showTooltips: true,
    tooltip: {
      show: 'value',
      // value, label, label (value) or percent or custom function
      formatter: '.0%' // or .0% ?

    },
    axisFormatter: '.0%',
    showLegend: true,
    legendPlacement: 'right',
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };
  /**
   * A radar chart is a graphical method of displaying multivariate data in the form of a
   * two-dimensional chart of three or more quantitative variables represented on axes starting
   * from the same poin
   * @class Radar
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} settings.dataset The data to use in the radar
   * @param {boolean} [settings.redrawOnResize = true] If false, the component will not resize when resizing the page.
   * @param {object} [settings.margin] The margins of the SVG, you may want to adjust
   * depending on text location.
   * @param {number} [settings.levels = 4] How many levels or inner circles should there be drawn.
   * @param {number} [settings.maxValue = 0] What is the value that the biggest circle will represent
   * @param {number} [settings.labelFactor = 1.27] How far out than the outer circle should the labels be placed,
   * this may be useful to adjust for some charts.
   * @param {number} [settings.wrapWidth = 60] The number of pixels after which a label needs to be
   * given a new line. You may want to change this based on label data.
   * @param {boolean} [settings.showCrosslines = true] Set to false to hide the cross line axes.
   * @param {boolean} [settings.showAxisLabels = true] Set to false to hide percent labels.
   * @param {number} [settings.opacityArea = 0.2] The opacity value of the blobs. This is set to the correct Infor Style.
   * @param {number} [settings.dotRadius = 3] The size of the colored circles of each blog. Set to zero to remove dots.
   * @param {number} [settings.opacityCircles  = 0]The opacity of the circles of each blob 0 or .1 are good values.
   * This is set to the correct Infor Style.
   * @param {number} [settings.strokeWidth = 1] The width of the stroke around each blob.
   * This is set to the correct Infor Style.
   * @param {boolean} [settings.roundStrokes = true] If true the area and stroke will follow a
   * round path (cardinal-closed).
   * @param {boolean} [settings.showCrosslines = true]  If false the axis lines will not be shown in the diagonals.
   * @param {boolean} [settings.showAxisLabels = true]  If false the axis labels will not be shown.
   * @param {string} [settings.axisFormatter = '.0%'] D3 formatter to use on the axis labels
   * @param {array} [settings.colors] An array of colors to use.
   * @param {boolean} [settings.showTooltips = true] If false no tooltips will be shown.
   * @param {object} [settings.tooltip] A setting that controls the tooltip values and format.
   * @param {string} [settings.tooltip.show = 'value'] Controls what is visible in the tooltip, this can be value, label
   * or percent or custom function.
   * @param {object} [settings.tooltip.formatter = '.0%'] The d3.formatter string.
   * @param {boolean} [settings.showLegend = true] If false the legend will not be shown.
   * @param {string} [settings.legendPlacement = 'right'] Where to locate the legend. This can be bottom or right at
   * the moment.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   *  Set this to null for no message or will default to 'No Data Found with an icon.'
   */

  function Radar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, RADAR_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  Radar.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [this.settings.type, 'chart']
      });
      this.width = 0;
      this.setupColors().build().handleEvents();
      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Radar
      * @property {object} event - The jquery event object
      * @property {array} svg - The svg object.
      */

      this.element.trigger('rendered', [this.svg]);
      return this;
    },

    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      this.updateData(this.settings.dataset);
      this.setInitialSelected();
      return this;
    },

    /**
     * Sets up the internal colors.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    setupColors: function setupColors() {
      if (!this.settings.colors || this.useBuiltInColors) {
        this.settings.colors = charts.colorRange();
        this.useBuiltInColors = true;
      }

      return this;
    },

    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     */
    updateData: function updateData(data) {
      var self = this;
      var s = this.settings;
      var isPersonalizable = this.element.closest('.is-personalizable').length > 0; // Add css class to container

      this.element.addClass('chart-radar'); // Handle Empty Data Set

      if (data.length === 0) {
        self.element.emptymessage(s.emptyMessage);
        return;
      } // Set dimensions


      var parent = this.element.parent();
      var dims = {
        w: parent.width(),
        h: parent.height(),
        extra: 0.957 // approximate calc

      };

      if (s.legendPlacement === 'right') {
        dims.w *= 0.75;
      }

      if (theme.uplift && dims.w >= 420) {
        dims.extra -= 0.12;
      } // Manually adjust height to fit legend on mobile view


      if (s.showLegend && dims.w < 420 && !s.margin.bottom) {
        var adjust;

        if (dims.w > 405) {
          adjust = 5;
        } else if (dims.w > 390) {
          adjust = 3;
        } else if (dims.w > 350) {
          adjust = 0.9;
        } else {
          adjust = 0.5;
        }

        dims.h -= (420 - dims.w) * adjust;
      }

      dims.transform = {
        x: dims.w / 2 + (s.margin.left + s.margin.right) / 2,
        y: dims.h / 2 * dims.extra + (s.margin.top + s.margin.bottom) / 2
      }; // Get the name text from given data

      var getNameText = function getNameText(d) {
        var size = {
          min: 328,
          max: 469
        };
        var text = '';

        if (dims.w <= size.min) {
          text = d.shortName || d.abbrName || d.name || '';
        } else if (dims.w >= size.min + 1 && dims.w <= size.max) {
          text = d.abbrName || d.name || '';
        } else if (dims.w > size.max) {
          text = d.name || '';
        }

        return text;
      };

      var tooltipInterval;
      var colors = d3.scaleOrdinal(s.colors); // If the supplied maxValue is smaller than the actual one, replace by the max in the data

      var maxValue = Math.max(s.maxValue, d3.max(data, function (i) {
        return d3.max(i.data.map(function (o) {
          return o.value;
        }));
      }));
      var allAxes = data[0].data.map(function (d) {
        return getNameText(d);
      }); // Map the names to the axes

      var total = allAxes.length; // The number of different axes

      var angleSlice = Math.PI * 2 / total; // The width in radians of each 'slice'

      var radius = Math.min(dims.w / 3, dims.h / 3) * dims.extra; // Radius of the outermost circle
      // Create the Scale for the radius

      var rScale = d3.scaleLinear().range([0, radius]).domain([0, maxValue]); // Create the container SVG and parent g
      // Remove whatever chart with the same id/class was present before

      var elem = this.element[0];
      d3.select(elem).select('svg').remove(); // Initiate the radar chart SVG

      var svg = d3.select(elem).append('svg').attr('width', dims.w + (s.margin.left + s.margin.right)).attr('height', dims.h + (s.margin.top + s.margin.bottom)).attr('class', 'chart-radar');
      this.svg = svg; // Pointer for selection states
      // Append a g element

      var g = svg.append('g').attr('transform', "translate(".concat(dims.transform.x, ",").concat(dims.transform.y, ")")); // Filter for the outside glow effect

      if (s.opacityCircles > 0) {
        var filter = g.append('defs').append('filter').attr('id', 'glow');
        filter.append('feGaussianBlur').attr('stdDeviation', '2.5').attr('result', 'coloredBlur');
        var feMerge = filter.append('feMerge');
        feMerge.append('feMergeNode').attr('in', 'coloredBlur');
        feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
      } // Draw the Circular grid
      // Wrapper for the grid & axes


      var axisGrid = g.append('g').attr('class', 'chart-radar-axis-wrapper'); // Draw the background circles

      axisGrid.selectAll('.levels').data(d3.range(1, s.levels + 1).reverse()).enter().append('circle').attr('class', 'chart-radar-grid-circle').attr('r', function (d) {
        return radius / s.levels * d;
      }).style('fill-opacity', s.opacityCircles).style('filter', s.opacityCircles > 0 ? 'url(#glow)' : ''); // Text indicating at what % each level is

      if (s.showAxisLabels) {
        axisGrid.selectAll('.axis-label').data(d3.range(1, s.levels + 1).reverse()).enter().append('text').attr('class', 'axis-label').attr('x', 4).attr('y', function (d) {
          return -d * radius / s.levels;
        }).attr('dy', '0.4em').style('font-size', theme.uplift ? '12px' : '10px').attr('fill', '#737373').text(function (d) {
          var text = '';
          var roundedVal = Math.round(maxValue * 10) / 10;

          if (s.axisFormatter.indexOf('%') > -1) {
            text = d3.format(s.axisFormatter)(roundedVal * d / s.levels);
          } else {
            text = d3.format(s.axisFormatter)(d / s.levels);
          }

          return text;
        });
      } // Draw the axes
      // Create the straight lines radiating outward from the center


      var axis = axisGrid.selectAll('.axis').data(allAxes).enter().append('g').attr('class', 'axis'); // Append the cross lines

      if (s.showCrosslines) {
        axis.append('line').attr('x1', 0).attr('y1', 0).attr('x2', function (d, i) {
          return rScale(maxValue * 1.05) * Math.cos(angleSlice * i - Math.PI / 2);
        }).attr('y2', function (d, i) {
          return rScale(maxValue * 1.05) * Math.sin(angleSlice * i - Math.PI / 2);
        }).attr('class', 'chart-radar-crossline').style('stroke-width', '1px');
      } // Append the labels at each axis


      axis.append('text').attr('class', 'legend').style('font-size', theme.uplift ? '14px' : '12px').attr('text-anchor', 'middle').attr('dy', '0.35em').attr('x', function (d, i) {
        return rScale(maxValue * s.labelFactor) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('y', function (d, i) {
        return rScale(maxValue * s.labelFactor) * Math.sin(angleSlice * i - Math.PI / 2);
      }).text(function (d) {
        return d;
      });
      this.element[dims.w < 420 ? 'addClass' : 'removeClass']('is-small');

      if (dims.w > 456) {
        svg.selectAll('.chart-radar-axis-wrapper .axis .legend').each(function () {
          charts.wrap(d3.select(this), s.wrapWidth, s.labelFactor);
        });
      } // Draw the radar chart blobs
      // The radial line function


      var radarLine = d3.lineRadial().curve(d3.curveBasisClosed).radius(function (d) {
        return rScale(d.value);
      }).angle(function (d, i) {
        return i * angleSlice;
      });

      if (s.roundStrokes) {
        radarLine.curve(d3.curveCardinalClosed);
      } // Create a wrapper for the blobs


      var blobWrapper = g.selectAll('.radarWrapper').data(data.map(function (i) {
        return i.data;
      })).enter().append('g').attr('class', 'chart-radar-wrapper'); // Append the backgrounds

      blobWrapper.append('path').attr('class', 'chart-radar-area').call(function (d) {
        d._groups.forEach(function (areas) {
          areas.forEach(function (area, i) {
            var dat = data[i];
            utils.addAttributes($(area), dat, dat.attributes, 'area');
          });
        });
      }).attr('d', function (d) {
        return radarLine(d);
      }).style('fill', function (d, i) {
        return colors(i);
      }).style('fill-opacity', s.opacityArea).on("click.".concat(self.namespace), function (d, i) {
        // Handle Click to select
        clearTimeout(tooltipInterval);
        var selectElem = d3.select(this);
        var isSelected = selectElem.classed('is-selected');
        svg.selectAll('.is-selected').classed('is-selected', false);
        svg.selectAll('.is-not-selected').classed('is-not-selected', false);
        charts.clearSelected(s.dataset);

        if (!isSelected) {
          svg.selectAll('.chart-radar-area').classed('is-not-selected', true);
          selectElem.classed('is-selected', true).classed('is-not-selected', false);
          selectElem.style('fill-opacity', s.opacityArea);
          s.dataset[i].selected = true;
        }

        var triggerData = {
          elem: selectElem.nodes(),
          data: d,
          index: i
        };
        /**
        * Fires when the chart is complete done rendering, for customization.
        * @event selected
        * @memberof Radar
        * @property {object} data - The data element attached
        * @property {HTMLElement} elem - The dom element
        * @property {number} index - The index for this blob.
        */

        /**
        * Fires when the chart is complete done rendering, for customization.
        * @event deselected
        * @memberof Radar
        * @property {object} data - The data element attached
        * @property {HTMLElement} elem - The dom element
        * @property {number} index - The index for this blob.
        */

        self.element.triggerHandler(isSelected ? 'deselected' : 'selected', triggerData);
        charts.selected = !isSelected ? triggerData : [];
      }).on("contextmenu.".concat(self.namespace), function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
      }); // Create the outlines

      blobWrapper.append('path').attr('class', 'chart-radar-stroke').call(function (d) {
        d._groups.forEach(function (strokes) {
          strokes.forEach(function (stroke, i) {
            var dat = data[i];
            utils.addAttributes($(stroke), dat, dat.attributes, 'stroke');
          });
        });
      }).attr('d', function (d) {
        return radarLine(d);
      }).style('stroke-width', "".concat(s.strokeWidth, "px")).style('stroke', function (d, i) {
        return colors(i);
      }).style('fill', 'none').style('filter', s.opacityCircles > 0 ? 'url(#glow)' : ''); // Append the circles

      blobWrapper.selectAll('.chart-radar-circle').data(function (d) {
        return d;
      }).enter().append('circle').call(function (d) {
        d._groups.forEach(function (circles) {
          circles.forEach(function (circle) {
            var dat = circle.__data__;
            utils.addAttributes($(circle), dat, dat.attributes, 'circle');
          });
        });
      }).attr('class', 'chart-radar-circle').attr('r', s.dotRadius).attr('cx', function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('cy', function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      }).style('fill', function () {
        return colors($(this.parentNode).index() - 1);
      }).style('fill-opacity', 0.6); // Wrapper for the invisible circles on top

      var blobCircleWrapper = g.selectAll('.radar-circle-wrapper').data(data.map(function (i) {
        return i.data;
      })).enter().append('g').attr('class', 'radar-circle-wrapper'); // Append a set of invisible circles on top for the mouseover pop-up

      blobCircleWrapper.selectAll('.radar-invisible-circle').data(function (d) {
        return d;
      }).enter().append('circle').call(function (d) {
        d._groups.forEach(function (circles) {
          circles.forEach(function (circle) {
            var dat = circle.__data__;
            utils.addAttributes($(circle), dat, dat.attributes, 'invisible-circle');
          });
        });
      }).attr('class', 'radar-invisible-circle').attr('r', s.dotRadius * 1.5).attr('cx', function (d, i) {
        return rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2);
      }).attr('cy', function (d, i) {
        return rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2);
      }).style('fill', 'none').style('pointer-events', 'all').on("mouseenter.".concat(self.namespace), function (d) {
        if (!s.showTooltips) {
          return;
        }

        var offset = $(this).offset();
        var content = charts.formatToSettings(d, s.tooltip);

        if (content.indexOf('<b>') === -1) {
          content = content.replace('(', '<b>');
          content = content.replace(')', '</b>');
        }

        var size = charts.tooltipSize(content);
        var x = offset.left;
        var y = offset.top;
        var padding = 6;
        x -= size.width / 2 - padding;
        y -= size.height + padding; // Debounce it a bit

        if (tooltipInterval != null) {
          clearTimeout(tooltipInterval);
        }

        tooltipInterval = setTimeout(function () {
          if (charts.tooltip && charts.tooltip.length) {
            charts.tooltip[isPersonalizable ? 'addClass' : 'removeClass']('is-personalizable');
          }

          charts.showTooltip(x, y, content, 'top');
        }, 300);
      }).on("mouseleave.".concat(self.namespace), function () {
        clearTimeout(tooltipInterval);
        charts.hideTooltip();
      }).on("contextmenu.".concat(self.namespace), function (d) {
        charts.triggerContextMenu(self.element, d3.select(this).nodes()[0], d);
      }); // Add tooltip object

      if (s.showTooltips) {
        charts.appendTooltip('is-pie');
      }

      if (s.showLegend) {
        if (s.legendPlacement) {
          this.element.addClass("has-".concat(s.legendPlacement, "-legend"));
        }

        var series = s.dataset.map(function (d, i) {
          var args = {
            name: d.name,
            display: 'twocolumn',
            placement: s.legendPlacement,
            color: colors(i)
          };

          if (d.attributes) {
            args.data = {
              attributes: d.attributes
            };
          }

          return args;
        });
        s.svg = self.svg;
        charts.addLegend(series, 'pie', s, this.element);
      }
    },

    /**
     * Set the initially selected elements
     * @private
     */
    setInitialSelected: function setInitialSelected() {
      var s = this.settings;

      if (Array.isArray(s.dataset)) {
        for (var i = 0, l = s.dataset.length; i < l; i++) {
          if (s.dataset[i].selected) {
            var elems = this.svg.selectAll('.chart-radar-area').nodes();
            var selectElem = d3.select(elems[i]);
            this.svg.selectAll('.is-selected').classed('is-selected', false);
            this.svg.selectAll('.is-not-selected').classed('is-not-selected', false);
            this.svg.selectAll('.chart-radar-area').classed('is-not-selected', true);
            selectElem.classed('is-selected', true).classed('is-not-selected', false);
            selectElem.style('fill-opacity', s.opacityArea);
            break;
          }
        }
      }
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.element.on("updated.".concat(this.namespace), function () {
        _this.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this.handleResize();
        });
        this.element.on("resize.".concat(this.namespace), function () {
          _this.handleResize();
        });
      }

      $('html').on("themechanged.".concat(this.namespace), function () {
        _this.updated();
      });
      return this;
    },

    /**
     * Get info on the currently selected lines.
     * @returns {object} An object with the matching data and reference to the triggering element.
     */
    getSelected: function getSelected() {
      return charts.selected;
    },

    /**
     * Get info on the currently selected lines.
     * @param {object} o The selection data object
     * @param {boolean} isToggle If true toggle the current state.
     */
    setSelected: function setSelected(o, isToggle) {
      var selector;
      var arcIndex;
      var selected = 0;
      var self = this;
      this.svg.selectAll('.chart-radar-area').each(function (d, i) {
        var set = self.settings.dataset[i];

        if (!set || !set.data) {
          return;
        }

        if (selected < 1) {
          if (typeof o.fieldName !== 'undefined' && typeof o.fieldValue !== 'undefined' && o.fieldValue === set[o.fieldName] || typeof o.index !== 'undefined' && o.index === i || o.elem && $(this).is(o.elem)) {
            selected++;
            selector = d3.select(this);
            arcIndex = i;
          }
        }
      });

      if (selected > 0 && (isToggle || !selector.classed('is-selected'))) {
        selector.on("click.".concat(self.namespace)).call(selector.node(), selector.datum(), arcIndex);
      }
    },

    /**
     * Get info on the currently selected lines.
     * @param {object} options The selected info object.
     */
    toggleSelected: function toggleSelected(options) {
      this.setSelected(options, true);
    },

    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.element.find('.chart-legend').remove();
        this.settings.dataset = settings.dataset;
        this.updateData(this.settings.dataset);
        return this;
      }

      this.element.empty();
      return this.setupColors().build();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      var _this2 = this;

      var events = function events(arr) {
        return "".concat(arr.join(".".concat(_this2.namespace, " ")), ".").concat(_this2.namespace);
      };

      if (this.element) {
        this.element.find('.chart-radar-area').off(events(['click', 'contextmenu']));
        this.element.find('.radar-invisible-circle').off(events(['mouseenter', 'mouseleave', 'contextmenu']));
        this.element.off(events(['updated', 'resize']));
      }

      $('body').off("resize.".concat(this.namespace));
      $('html').off("themechanged.".concat(this.namespace));
      delete this.namespace;
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      charts.removeTooltip();

      if (this.element) {
        this.element.empty().removeClass('radar-chart');
        $.removeData(this.element[0], COMPONENT_NAME$s);
        $.removeData(this.element[0], 'radar');
      }
    }
  };

  /*
  * jQuery Component Wrapper for Charts. It maps the singlular components
  * to the previous versions single jquery wrapper.
  * @param  {object} settings The settings to apply.
  * @returns {object} The jquery object for chaining.
  */

  $.fn.chart = function (settings) {
    var instance = null;
    this.empty(); // allow changing chart type

    switch (settings.type) {
      case 'targeted-achievement':
      case 'completion':
      case 'completion-target':
        {
          instance = this.data(settings.type);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var chartComponent = new CompletionChart(this, settings);
          this.data(COMPONENT_NAME$l, chartComponent);
          this.data('chart', chartComponent); // Compatibility

          this.data(settings.type, chartComponent); // Compatibility

          break;
        }

      case 'bullet':
        {
          instance = this.data(COMPONENT_NAME$k);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent = new Bullet(this, settings);

          this.data(COMPONENT_NAME$k, _chartComponent);
          this.data('chart', _chartComponent); // Compatibility

          break;
        }

      case 'radar':
        {
          instance = this.data(COMPONENT_NAME$s);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent2 = new Radar(this, settings);

          this.data(COMPONENT_NAME$s, _chartComponent2);
          this.data('chart', _chartComponent2); // Compatibility

          break;
        }

      case 'sparkline':
        {
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent3 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent3);
          this.data('chart', _chartComponent3); // Compatibility

          break;
        }

      case 'sparkline-dots':
        {
          settings.isDots = true;
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent4 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent4);
          this.data('chart', _chartComponent4); // Compatibility

          break;
        }

      case 'sparkline-peak':
        {
          settings.isPeakDot = true;
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent5 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent5);
          this.data('chart', _chartComponent5); // Compatibility

          break;
        }

      case 'sparkline-dots-n-peak':
        {
          settings.isPeakDot = true;
          settings.isDots = true;
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent6 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent6);
          this.data('chart', _chartComponent6); // Compatibility

          break;
        }

      case 'sparkline-minmax':
        {
          settings.isMinMax = true;
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent7 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent7);
          this.data('chart', _chartComponent7); // Compatibility

          break;
        }

      case 'sparkline-medianrange':
        {
          settings.isMedianRange = true;
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent8 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent8);
          this.data('chart', _chartComponent8); // Compatibility

          break;
        }

      case 'sparkline-medianrange-n-peak':
        {
          settings.isMedianRange = true;
          settings.isPeakDot = true;
          instance = this.data(COMPONENT_NAME$m);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent9 = new Sparkline(this, settings);

          this.data(COMPONENT_NAME$m, _chartComponent9);
          this.data('chart', _chartComponent9); // Compatibility

          break;
        }

      case 'line':
        {
          instance = this.data(COMPONENT_NAME$o);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent10 = new Line(this, settings);

          this.data(COMPONENT_NAME$o, _chartComponent10);
          this.data('chart', _chartComponent10); // Compatibility

          break;
        }

      case 'area':
        {
          settings.isArea = true;
          instance = this.data(COMPONENT_NAME$o);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent11 = new Line(this, settings);

          this.data(COMPONENT_NAME$o, _chartComponent11);
          this.data('chart', _chartComponent11); // Compatibility

          break;
        }

      case 'bubble':
        {
          settings.isBubble = true;
          instance = this.data(COMPONENT_NAME$o);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent12 = new Line(this, settings);

          this.data(COMPONENT_NAME$o, _chartComponent12);
          this.data('chart', _chartComponent12); // Compatibility

          break;
        }

      case 'scatterplot':
        {
          settings.isScatterPlot = true;
          instance = this.data(COMPONENT_NAME$o);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent13 = new Line(this, settings);

          this.data(COMPONENT_NAME$o, _chartComponent13);
          this.data('chart', _chartComponent13); // Compatibility

          break;
        }

      case 'column':
      case 'column-grouped':
      case 'positive-negative':
      case 'column-positive-negative':
        {
          instance = this.data(COMPONENT_NAME$p);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent14 = new Column(this, settings);

          this.data(COMPONENT_NAME$p, _chartComponent14);
          this.data('chart', _chartComponent14); // Compatibility

          break;
        }

      case 'column-stacked':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$p);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent15 = new Column(this, settings);

          this.data(COMPONENT_NAME$p, _chartComponent15);
          this.data('chart', _chartComponent15); // Compatibility

          break;
        }

      case 'bar':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$q);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent16 = new Bar(this, settings);

          this.data(COMPONENT_NAME$q, _chartComponent16);
          this.data('chart', _chartComponent16); // Compatibility

          break;
        }

      case 'bar-stacked':
        {
          settings.isStacked = true;
          instance = this.data(COMPONENT_NAME$q);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent17 = new Bar(this, settings);

          this.data(COMPONENT_NAME$q, _chartComponent17);
          this.data('chart', _chartComponent17); // Compatibility

          break;
        }

      case 'bar-normalized':
        {
          settings.isNormalized = true;
          instance = this.data(COMPONENT_NAME$q);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent18 = new Bar(this, settings);

          this.data(COMPONENT_NAME$q, _chartComponent18);
          this.data('chart', _chartComponent18); // Compatibility

          break;
        }

      case 'bar-grouped':
        {
          settings.isStacked = false;
          settings.isGrouped = true;
          instance = this.data(COMPONENT_NAME$q);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent19 = new Bar(this, settings);

          this.data(COMPONENT_NAME$q, _chartComponent19);
          this.data('chart', _chartComponent19); // Compatibility

          break;
        }

      case 'pie':
        {
          instance = this.data(COMPONENT_NAME$r);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent20 = new Pie(this, settings);

          this.data(COMPONENT_NAME$r, _chartComponent20);
          this.data('chart', _chartComponent20); // Compatibility

          break;
        }

      case 'donut':
        {
          settings.isDonut = true;
          instance = this.data(COMPONENT_NAME$r);

          if (instance) {
            instance.updated(settings);
            return this;
          }

          var _chartComponent21 = new Pie(this, settings);

          this.data(COMPONENT_NAME$r, _chartComponent21);
          this.data('chart', _chartComponent21); // Compatibility

          break;
        }

      default:
        instance = null;
    }

    return this;
  };

  var dateUtils = {};
  /**
  * Determine whether or not a date is todays date.
  * @param {date} date The date to check.
  * @returns {boolean} Returns true or false if the compared date is today.
  */

  dateUtils.isToday = function splice(date) {
    var today = new Date();
    return date.getDate() === today.getDate() && date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();
  };
  /**
  * Gets the first day of the week.
  * @param {date} date The date to check.
  * @param {number} startsOn Day of the week to start on. Sunday is 0, Monday is 1, and so on.
  * @returns {boolean} Returns true or false if the compared date is today.
  */


  dateUtils.firstDayOfWeek = function firstDayOfWeek(date) {
    var startsOn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var dayOfWeek = date.getDay();
    var firstDay = new Date(date);
    var diff = dayOfWeek >= startsOn ? dayOfWeek - startsOn : 6 - dayOfWeek;
    firstDay.setDate(date.getDate() - diff);
    firstDay.setHours(0, 0, 0, 0);
    return firstDay;
  };
  /**
  * Gets the first day of the week.
  * @param {date} date The date to check.
  * @param {number} startsOn Day of the week to start on. Sunday is 0, Monday is 1, and so on.
  * @returns {boolean} Returns true or false if the compared date is today.
  */


  dateUtils.lastDayOfWeek = function lastDayOfWeek(date) {
    var startsOn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var lastDay = this.firstDayOfWeek(date, startsOn);
    lastDay.setDate(lastDay.getDate() + 6);
    lastDay.setHours(23, 59, 59, 999);
    return lastDay;
  };
  /**
   * Get the difference between two dates.
   * @param {date} first The first date.
   * @param {date} second The second date.
   * @param {boolean} useHours The different in hours if true, otherways days.
  * @returns {number} The difference between the two dates.
   */


  dateUtils.dateDiff = function (first, second, useHours) {
    // Take the difference between the dates and divide by milliseconds per day.
    // Round to nearest whole number to deal with DST.
    var dtoday = new Date();
    return Math.round((second - first) / (1000 * 60 * 60 * (useHours ? 1 : Math.abs(dtoday.getTimezoneOffset()))));
  };
   //eslint-disable-line

  var calendarShared = {};
  /**
  * Add calculated fields to an event object.
  * @param {object} event The starting event object
  * @param {object} locale The locale instance to use
  * @param {object} language The language instance to use
  * @param {array} eventTypes The event types to attach
  * @returns {object} The event object with stuff added.
  */

  calendarShared.addCalculatedFields = function addCalculatedFields(event, locale, language, eventTypes) {
    //eslint-disable-line
    var formatDate = function formatDate(d, o) {
      return Locale.formatDate(d, utils.extend(true, {
        locale: locale.name
      }, o));
    };

    var parseDateOpts = {
      pattern: 'yyyy-MM-ddTHH:mm:ss.SSS',
      locale: locale.name
    };

    var parseDate = function parseDate(dtStr) {
      var retDate = Locale.parseDate(dtStr, parseDateOpts);

      if (Locale.isIslamic(locale.name)) {
        retDate = new Date(retDate[0], retDate[1], retDate[2], retDate[3], retDate[4], retDate[5], retDate[6]);
      }

      return retDate;
    };

    var translate = function translate(str) {
      return Locale.translate(str, {
        locale: locale.name,
        language: language
      });
    };

    event.color = this.getEventTypeColor(event, eventTypes);
    event.duration = Math.abs(dateUtils.dateDiff(new Date(event.ends), new Date(event.starts), false)); // Get today's date and convert to UTC

    var today = new Date();
    var dateTodayUTC = Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()); // Get event start date and convert to UTC

    var eventStart = new Date(event.starts);
    var eventStartUTC = Date.UTC(eventStart.getUTCFullYear(), eventStart.getUTCMonth(), eventStart.getUTCDate());
    var eventStartFormatted = "".concat(eventStart.getDate(), "-").concat(eventStart.getMonth() + 1, "-").concat(eventStart.getFullYear());
    var todayFormatted = "".concat(today.getDate(), "-").concat(today.getMonth() + 1, "-").concat(today.getFullYear());
    event.durationUnits = translate(event.duration > 1 ? 'Days' : 'Day');
    event.daysUntil = event.starts ? dateUtils.dateDiff(eventStartUTC, dateTodayUTC) : 0;
    var diff = (new Date(event.ends) - new Date(event.starts)) / (1000 * 60 * 60);
    event.durationHours = diff > 0 && diff < 0.5 ? 1 : Math.round(diff);
    event.isDays = true; // Condition to not display in the upcoming events section

    if (dateTodayUTC > eventStartUTC && eventStartFormatted !== todayFormatted) {
      event.daysUntil = 1;
    }

    if (event.isAllDay === undefined) {
      event.isAllDay = true;
    }

    if (event.durationHours < 24) {
      event.isDays = false;
      event.isAllDay = false;
      event.durationUnits = translate(event.durationHours > 1 ? 'Hours' : 'Hour');
    }

    if (event.isAllDay.toString() === 'true') {
      var dayDiff = function dayDiff(d1, d2) {
        return Math.abs(Math.round((d2 - d1) / (1000 * 60 * 60 * 24)));
      };

      event.duration = dayDiff(new Date(event.starts), new Date(event.ends)) || 1;
      event.durationUnits = translate(event.duration > 1 ? 'Days' : 'Day');
      event.isDays = true;
      delete event.durationHours;
    }

    if (event.starts) {
      var startsLocale = parseDate(event.starts);
      event.startsLocale = formatDate(startsLocale);

      if (Locale.isIslamic(locale.name)) {
        event.startsLocale = formatDate(Locale.gregorianToUmalqura(startsLocale));
      }

      event.startsHourLocale = formatDate(startsLocale, {
        date: 'hour'
      });

      if (Array.isArray(startsLocale)) {
        event.startsHour = parseFloat(startsLocale[3] + startsLocale[4] / 60);
      } else {
        event.startsHour = parseFloat(startsLocale.getHours() + startsLocale.getMinutes() / 60);
      }
    }

    if (event.ends) {
      var endsLocale = parseDate(event.ends);
      event.endsLocale = formatDate(endsLocale);

      if (Locale.isIslamic(locale.name)) {
        event.endsLocale = formatDate(Locale.gregorianToUmalqura(endsLocale));
      }

      event.endsHourLocale = formatDate(endsLocale, {
        date: 'hour'
      });

      if (Array.isArray(endsLocale)) {
        event.endsHour = parseFloat(endsLocale[3] + endsLocale[4] / 60);
      } else {
        event.endsHour = parseFloat(endsLocale.getHours() + endsLocale.getMinutes() / 60);
      }
    }

    event.eventTypes = eventTypes;
    event.isAllDay = event.isAllDay.toString();

    if (event.isAllDay.toString() === 'false') {
      delete event.isAllDay;
    }

    if (!event.isAllDay && event.durationHours >= 24) {
      event.isAllDay = false;
      event.durationUnits = translate('Hours');
      event.isDays = false;
      delete event.duration;
    } // Duration in time


    if (event.starts && event.ends) {
      var diffInSeconds = this.timeDiffInSeconds(parseDate(event.starts), parseDate(event.ends));
      event.durationInTime = this.timeBySeconds(diffInSeconds);
    } else if (event.durationInTime) {
      delete event.durationInTime;
    }

    return event;
  };
  /**
   * Get difference between two dates in seconds.
   * @private
   * @param {number} starts The starts date
   * @param {number} ends The ends date
   * @returns {number} The calculated difference in seconds.
   */


  calendarShared.timeDiffInSeconds = function timeDiffInSeconds(starts, ends) {
    var diff = Math.abs(ends.getTime() - starts.getTime()); // in miliseconds

    return Math.ceil(diff / 1000); // in seconds
  };
  /**
   * Get time object, days, hours, minutes and seconds by given total seconds.
   * @private
   * @param {number} seconds The total seconds
   * @returns {object} The time with hours and minutes.
   */


  calendarShared.timeBySeconds = function timeBySeconds(seconds) {
    seconds = Number(seconds);
    return {
      days: Math.floor(seconds / (3600 * 24)),
      hours: Math.floor(seconds % (3600 * 24) / 3600),
      minutes: Math.floor(seconds % 3600 / 60),
      seconds: Math.floor(seconds % 60)
    };
  };
  /**
   * Formate the time string for hours and minutes to given event data.
   * @private
   * @param {object} event The event data
   * @param {object} locale The locale instance to use
   * @param {object} language The language instance to use
   * @returns {void}
   */


  calendarShared.formateTimeString = function formateTimeString(event, locale, language) {
    if (event.durationInTime) {
      var translate = function translate(str) {
        return Locale.translate(str, {
          locale: locale.name,
          language: language
        });
      };

      var d = event.durationInTime;
      var text = '';

      if (d.days) {
        var label = translate(d.days > 1 ? 'Days' : 'Day');
        text += "".concat(d.days, " ").concat(label);
      }

      if (d.hours) {
        var _label = translate(d.hours > 1 ? 'Hours' : 'Hour');

        if (d.days) {
          text += "".concat(d.minutes || d.seconds ? ', ' : " ".concat(translate('And'), " "));
        }

        text += "".concat(d.hours, " ").concat(_label);
      }

      if (d.minutes) {
        var _label2 = translate(d.minutes > 1 ? 'Minutes' : 'Minute');

        if (d.days || d.hours) {
          text += "".concat(d.seconds ? ', ' : " ".concat(translate('And'), " "));
        }

        text += "".concat(d.minutes, " ").concat(_label2);
      }

      if (d.seconds) {
        var _label3 = translate(d.seconds > 1 ? 'Seconds' : 'Second');

        text += "".concat(d.days || d.hours || d.minutes ? " ".concat(translate('And'), " ") : '');
        text += "".concat(d.seconds, " ").concat(_label3);
      }

      if (text !== '') {
        event.duration = '';
        event.durationUnits = '';
        event.durationHours = text;
      }
    }
  };
  /**
   * Find the matching type and get the color.
   * @param {object} event The eventType type or color to find.
   * @param {object} eventTypes The event types to use
   * @returns {object} The Calendar prototype, useful for chaining.
   */


  calendarShared.getEventTypeColor = function getEventTypeColor(event, eventTypes) {
    var _event$color;

    var color = 'azure';

    if (!event.type && !event.color) {
      return color;
    }

    if (((_event$color = event.color) === null || _event$color === void 0 ? void 0 : _event$color == null ? void 0 : _event$color.substr(0, 1)) === '#') {
      return event.color;
    }

    var eventInfo = eventTypes.filter(function (eventType) {
      return eventType.id === event.type;
    });

    if (eventInfo.length === 1) {
      color = eventInfo[0].color || 'azure';
      return color;
    }

    return color;
  };
  /**
   * Fix missing / incomlete event data
   * @param {object} event The event object with common event properties.
   * @param {boolean} addPlaceholder If true placeholder text will be added for some empty fields.
   * @param {date} currentDate Active date in the calendar.
   * @param {object} locale The locale to use.
   * @param {string} language The language to use.
   * @param {array} events The events array.
   * @param {array} eventTypes The event types array.
   * @private
   */


  calendarShared.cleanEventData = function cleanEventData(event, addPlaceholder, currentDate, locale, language, events, eventTypes) {
    var formatDateOptions = {
      pattern: 'yyyy-MM-ddTHH:mm:ss.SSS',
      locale: locale.name
    };

    var formatDate = function formatDate(d) {
      return Locale.formatDate(d, formatDateOptions);
    };

    var parseDate = function parseDate(d, o) {
      return Locale.parseDate(d, utils.extend(true, {
        locale: locale.name
      }, o));
    };

    var isAllDay = event.isAllDay === 'on' || event.isAllDay === 'true' || event.isAllDay;
    var startDate = currentDate;
    var endDate = currentDate;

    if (event.startsLocale && event.endsLocale) {
      startDate = new Date(parseDate(event.startsLocale));
      endDate = new Date(parseDate(event.endsLocale));
    }

    if (typeof event.starts === 'string' && !event.startsLocale) {
      startDate = new Date(event.starts);
    }

    if (typeof event.ends === 'string' && !event.endsLocale) {
      endDate = new Date(event.ends);
    }

    if (!Locale.isValidDate(startDate)) {
      startDate = currentDate;
    }

    if (!Locale.isValidDate(endDate)) {
      endDate = currentDate;
    }

    if (isAllDay) {
      startDate.setHours(0, 0, 0, 0);
      event.starts = formatDate(new Date(startDate));
      endDate.setHours(23, 59, 59, 999);
      event.ends = formatDate(new Date(endDate));
      event.duration = event.starts === event.ends ? 1 : null;
      event.isAllDay = true;
    } else {
      if (startDate === endDate) {
        endDate.setHours(endDate.getHours() + parseInt(event.durationHours, 10));
        event.ends = formatDate(Environment.browser.name === 'safari' ? endDate : endDate.toISOString());
        event.duration = null;
      } else if (event.endsHourLocale && event.startsHourLocale) {
        var startsHours = parseDate(event.startsHourLocale, {
          date: 'hour'
        });
        var endsHours = parseDate(event.endsHourLocale, {
          date: 'hour'
        });
        startDate.setHours(startsHours.getHours(), startsHours.getMinutes(), startsHours.getSeconds(), startsHours.getMilliseconds());
        endDate.setHours(endsHours.getHours(), endsHours.getMinutes(), endsHours.getSeconds(), endsHours.getMilliseconds());

        if (Environment.browser.name === 'safari') {
          event.starts = formatDate(startDate);
          event.ends = formatDate(endDate);
        } else {
          event.starts = formatDate(startDate.toISOString());
          event.ends = formatDate(endDate.toISOString());
        }

        event.duration = dateUtils.dateDiff(new Date(event.starts), new Date(event.ends));
      } else {
        event.ends = formatDate(new Date(endDate));
      }

      event.starts = formatDate(new Date(startDate));
      event.isAllDay = false;
    }

    if (event.comments === undefined && addPlaceholder) {
      event.comments = Locale.translate('NoCommentsEntered', {
        locale: locale.name,
        language: language
      });
      event.noComments = true;
    }

    if (!event.subject && addPlaceholder) {
      event.subject = Locale.translate('NoTitle', {
        locale: locale.name,
        language: language
      });
    }

    if (!event.type) {
      // Default to the first one
      event.type = eventTypes[0].id;
    }

    if (event.id === undefined && addPlaceholder) {
      var lastId = events.length === 0 ? 0 : parseInt(events[events.length - 1].id, 10);
      event.id = (lastId + 1).toString();
    }

    if (event.title === 'NewEvent') {
      event.title = Locale.translate('NewEvent', {
        locale: locale.name,
        language: language
      });
    }
  };
   //eslint-disable-line

  var COMPONENT_NAME$t = 'tag'; // Tag style states

  var tagStyles = ['default', 'neutral', 'secondary', 'error', 'alert', 'good', 'info']; // Default Tag Options

  var TAG_DEFAULTS = {
    audibleContent: undefined,
    clickable: false,
    clickHandler: undefined,
    content: ' ',
    disabled: false,
    dismissible: false,
    dismissHandler: undefined,
    href: undefined,
    id: undefined,
    parent: undefined,
    style: tagStyles[0],
    value: undefined
  };
  /**
   * Implements functionality on tag objects, such as dismissable, hyperlink, disable, and more.
   * @class Tag
   * @param {string} element The element representing a Tag.
   * @param {string} [settings=object] The Tag component's desired settings.
   * @param {string} [settings.audibleContent=undefined] if defined, will contain screen-reading only content for tags that will be read out upon focus/click.
   * @param {boolean} [settings.clickable=false] if true, allows click/focus functionality on this tag and turns it into an HTMLAnchorElement.
   * @param {function} [settings.clickHandler=undefined] a callback function that will occur on click. Passes this tag's component instance as an argument.
   * @param {string} settings.content the Tag's visible text content
   * @param {boolean} [settings.disabled=false] if true, causes the tag to become disabled when settings are updated.
   * @param {boolean} [settings.dismissible=false] if true, creates an "X" button on the tag, and allows it to be dismissed from the page by click or keyboard command (Alt+Del)
   * @param {function} [settings.dismissHandler=undefined] a callback function that will occur when the tag is dismissed. Passes this tag's component instance as an argument.
   * @param {string} [settings.href=undefined] if provded when `settings.clickable` is true, allows this tag to link out to another page.
   * @param {string} [settings.id=undefined] sets an HTML `id` attribute on this tag.
   * @param {HTMLElement} [settings.parent=undefined] if defined, creates a reference to a parent node that can be used for operations like removal, or to check a parent's TagList component instance.
   * @param {string} [settings.style='default'] optionally creates a different visual style on this tag, such as "error", "alert", "good", "info", or "secondary"
   * @param {string} [settings.value=undefined] if provided, creates a hidden "value" against this tag that can represent properties in corresponding components.  This correlation is user-defined.
   */

  function Tag(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TAG_DEFAULTS); // Normalize the element type

    var span;

    if (!(element instanceof HTMLElement)) {
      // If no element or the wrong element exists, we just create it from scratch.
      // If a valid element was passed in, we "replace" it in the DOM.
      // Otherwise, it's up to the implementing dev to place/insert the tag.
      span = document.createElement('span');
      span.classList.add('tag');

      if (this.settings && this.settings.parent instanceof HTMLElement) {
        this.settings.parent.appendChild(span);
      }

      if (typeof this.settings.id === 'string' && this.settings.id.length) {
        span.id = this.settings.id;
        delete this.settings.id;
      }
    } else if (element.querySelector('.tag-content')) {
      // The tag is fully formed and doesn't need modification
      span = element;
    } else {
      // Create the internal bit of tag content
      span = document.createElement('span');
      span.className += "".concat(element.className);

      if (element.id && element.id.length) {
        span.id = element.id;
        element.removeAttribute('id');
      } else if (typeof this.settings.id === 'string' && this.settings.id.length) {
        span.id = this.settings.id;
        delete this.settings.id;
      }

      element.insertAdjacentElement('beforebegin', span);
      span.appendChild(element);
      span.classList.add('tag');
      element.className = '';
      element.classList.add('tag-content');
    } // Move the audible content around, if applicable


    if (element) {
      var audibleContent = element.querySelector('.audible');

      if (audibleContent) {
        span.insertAdjacentElement('afterbegin', audibleContent);
      }
    }

    this.element = span; // Use the element to change settings object, if applicable

    this.getSettingsFromElement();
    this.init();
  } // Tag Methods


  Tag.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.render();
      this.handleEvents();
    },

    /**
     * @returns {HTMLElement|undefined} the element that contains the Tag's text copy
     */
    get contentElement() {
      return this.element.querySelector('.tag-content');
    },

    /**
     * Renders the contents of this tag on its base element.
     * @returns {void}
     */
    render: function render() {
      var elemClasses = this.element.classList;
      var elemClassArr = utils.getArrayFromList(this.element.classList);
      var currentState = this.settings.style; // Update "style" class on the top-level element

      elemClassArr.forEach(function (cssClass) {
        if (tagStyles.indexOf(cssClass) > -1) {
          elemClasses.remove(cssClass);
        }
      });

      if (this.element.className.indexOf(currentState) === -1 && currentState !== 'default') {
        elemClasses.add(currentState);
      } // Disabled


      if (this.settings.disabled) {
        elemClasses.add('is-disabled');
      } // Auduble content


      var audibleContent = '';

      if (this.settings.audibleContent) {
        audibleContent = "<span class=\"audible\">".concat(xssUtils.stripHTML(this.settings.audibleContent), "</span>");
      } // Content Area (can just be text, or a hyperlink)


      var contentTagType = 'span';
      var href = '';
      var linkableBtn = '';
      var tabIndex = '';
      var hasHref = this.settings.href && this.settings.href.length;

      if (hasHref || this.originallyAnchor) {
        contentTagType = 'a';

        if (this.settings.disabled) {
          tabIndex = ' tabIndex="-1"';
        }
      }

      if (hasHref) {
        href = " href=\"".concat(this.settings.href, "\"");
      }

      if (this.settings.clickable || typeof this.settings.clickHandler === 'function') {
        elemClasses.add('is-linkable');
        linkableBtn = "<button class=\"btn-linkable\" focusable=\"false\" tabIndex=\"-1\">\n        ".concat($.createIcon('caret-right'), "\n      </button>");
      }

      var content = "<".concat(contentTagType, " class=\"tag-content\"").concat(href).concat(tabIndex, ">").concat(xssUtils.sanitizeHTML(this.settings.content), "</").concat(contentTagType, ">"); // Dismissible Button

      var dismissibleBtn = '';

      if (this.settings.dismissible) {
        elemClasses.add('is-dismissible');
        dismissibleBtn = "<button class=\"btn-dismissible\" focusable=\"false\" tabIndex=\"-1\">\n        ".concat($.createIcon('close'), "\n        <span class=\"audible\">").concat(Locale.translate('Close'), "</span>\n      </button>");
      } // Do the render!


      this.element.innerHTML = "".concat(audibleContent).concat(content).concat(linkableBtn).concat(dismissibleBtn); // Setup the HideFocus behavior

      $(this.element).hideFocus();
    },

    /**
     * @returns {HTMLElement} containing a reference to a dismissible button on a tag, if applicable.
     */
    get dismissibleBtn() {
      return this.element.querySelector('.btn-dismissible');
    },

    /**
     * Backwards compatability method for tags that were previously defined by markup.
     * This will take an existing DOM element representing a tag, and rectify internal settings
     * to match the element's state.
     * @private
     * @returns {void}
     */
    getSettingsFromElement: function getSettingsFromElement() {
      // Style State
      var elemClasses = this.element.className;
      var styleState = '';
      tagStyles.forEach(function (style) {
        if (elemClasses.indexOf(style) > -1) {
          styleState = style;
        }
      });

      if (styleState) {
        this.settings.style = styleState;
      } // Disabled State


      this.settings.disabled = this.disabled; // Dismissible State

      var dismissibleBtn = this.dismissibleBtn;
      var hasDismissibleCss = this.element.className.indexOf('is-dismissible') > -1;

      if (dismissibleBtn || hasDismissibleCss) {
        this.settings.dismissible = true;
      } // Hyperlink State, href, show/hide the "clickable" icon


      var hyperlink = this.element.querySelector('a');
      var hasHyperlinkCss = this.element.className.indexOf('is-linkable') > -1;
      var hasLinkableIcon = this.element.querySelector('.btn-linkable');

      if (hyperlink || hasHyperlinkCss || hasLinkableIcon) {
        this.originallyAnchor = true;
        var href = hyperlink.getAttribute('href');

        if (href && href.length) {
          href = xssUtils.stripTags(href);
          this.settings.href = href;
        }
      }

      if (hasHyperlinkCss || hasLinkableIcon) {
        this.settings.clickable = true;
      } // Audible content


      var audibleContent = this.element.querySelector('.audible');

      if (audibleContent instanceof HTMLElement) {
        this.settings.audibleContent = xssUtils.stripHTML(audibleContent.innerText);
      } // Text Content


      var contentElem = this.contentElement;

      if (contentElem) {
        this.settings.content = xssUtils.sanitizeHTML(contentElem.innerText);
      }
    },

    /**
     * Remove the tag from the DOM
     * @returns {void}
     */
    remove: function remove() {
      var thisNode = this.element;
      var parentNode = thisNode.parentNode;

      if (this.settings.parentAPI) {
        parentNode = this.settings.parentAPI.element;
      }
      /**
      * Fires before tag remove.
      *
      * @event beforetagremove
      * @memberof Tag
      * @type {object}
      * @property {object} event - The jquery event object
      * @property {object} The event used for removing and element
      */


      $(parentNode).triggerHandler('beforetagremove', [this]);
      this.destroy();
      thisNode.remove();
      /**
      * Fires after tag remove.
      *
      * @event aftertagremove
      * @memberof Tag
      * @type {object}
      * @property {object} event - The jquery event object
      */

      $(parentNode).triggerHandler('aftertagremove', [this]);
    },

    /**
     * Glorified way to remove a tag with an extra callback, and a check for disabled
     * @param {jQuery.Event} [e] the event that triggered dismissal, if applicable.
     * @returns {void}
     */
    dismiss: function dismiss(e) {
      if (this.disabled) {
        return;
      }

      this.remove(e);

      if (typeof this.settings.dismissHandler === 'function') {
        this.settings.dismissHandler(this);
      } // If a keypress is dismissing the tag from a taglist,
      // find the previous tag in the chain and focus it.


      var parentAPI = this.settings.parentAPI;

      if (parentAPI) {
        parentAPI.focusPreviousElement(this.element);
      }
    },

    /**
     * @returns {boolean} whether or not this component is currently disabled
     */
    get disabled() {
      return this.element.className.indexOf('is-disabled') > -1;
    },

    /**
     * Disables the tag.
     * @returns {void}
     */
    disable: function disable() {
      if (this.disabled) {
        return;
      }

      if (this.contentElement.tagName === 'A') {
        this.contentElement.tabIndex = -1;
      }

      this.settings.disabled = true;
      this.element.classList.add('is-disabled');
    },

    /**
     * Enables the tag.
     * @returns {void}
     */
    enable: function enable() {
      if (!this.disabled) {
        return;
      }

      if (this.contentElement.tagName === 'A') {
        this.contentElement.tabIndex = 0;
      }

      this.settings.disabled = false;
      this.element.classList.remove('is-disabled');
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {Tag} This component's API.
     */
    teardown: function teardown() {
      var $element = $(this.element);
      $element.off(['focusin.tag', 'focusout.tag', 'keydown.tag', 'click.tag'].join(' ')); // Remove the dismissible btn

      var dismissibleBtn = this.dismissibleBtn;

      if (dismissibleBtn) {
        dismissibleBtn.parentNode.removeChild(dismissibleBtn);
      }

      var hideFocusAPI = $element.data('hidefocus');

      if (hideFocusAPI && typeof hideFocusAPI.destroy === 'function') {
        hideFocusAPI.destroy();
      }

      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} [settings] representing updated component settings.
     * @returns {Tag} This component's API.
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TAG_DEFAULTS);
      }

      return this.teardown().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$t);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      // Standard events
      $(this.element).on('focusin.tag', function () {
        _this.element.classList.add('is-focused');
      }).on('focusout.tag', function () {
        _this.element.classList.remove('is-focused');
      }); // Handle clicks on tags, and setup a callback, if applicable.

      var self = this;
      $(this.element).on('click.tag', 'a, .btn-linkable', function (e) {
        var handlerResult;

        if (typeof self.settings.clickHandler === 'function') {
          handlerResult = self.settings.clickHandler(self);
        }

        if (handlerResult === false || self.settings.href && self.settings.href === '#') {
          e.preventDefault();
          return false;
        }

        return true;
      }); // Dismissible Tag events

      if (this.settings.dismissible) {
        /**
         * Fires when the tag is clicked (if enabled).
         * @event click
         * @memberof Tag
         * @type {object}
         * @property {object} e - The jquery event object
         */
        $(this.element).on('click.tag', '.btn-dismissible', function (e) {
          _this.dismiss(e);
        });
        /**
        * Fires when the tag is focused.
        * @event keydown
        * @memberof Tag
        * @type {object}
        * @property {object} e - The jquery event object
        */

        $(this.element).on('keydown.tag', 'a', function (e) {
          if (e.keyCode === 8) {
            // Backspace
            _this.dismiss(e);
          }
        });
      }
    }
  };

  var COMPONENT_NAME$u = 'taglist'; // Default Tag Options

  var TAG_LIST_DEFAULTS = {
    tags: []
  };
  /**
  * Creates a collection of Tag Components and controls their rendering/value setting process.
  * @class Tag
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  */

  function TagList(element, settings) {
    var _this = this;

    if (!(element instanceof HTMLElement)) {
      throw new Error('TagList base element must be defined');
    }

    this.settings = utils.mergeSettings(element, settings, TAG_LIST_DEFAULTS);
    this.element = element;
    var tags = utils.getArrayFromList(this.element.querySelectorAll('.tag'));

    if (tags.length) {
      this.settings.tags = [];
      tags.forEach(function (tag) {
        _this.settings.tags.push(new Tag(tag));
      });
    }

    this.init();
  }

  TagList.prototype = {
    /**
     * @returns {number} representing the number of tags in the list.
     */
    get length() {
      return this.tags.length;
    },

    /**
     * @returns {array<HTMLElement>} containing a list of HTMLElement objects representing
     * the current list of tags.
     */
    get elements() {
      return this.tags.map(function (tag) {
        return tag.element;
      });
    },

    /**
     * Initialize the collection
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this2 = this;

      // Build tags list
      this.tags = [];

      if (Array.isArray(this.settings.tags)) {
        this.settings.tags.forEach(function (tag) {
          _this2.add(tag);
        });
      }

      this.render();
    },

    /**
     * Given an object representation of a Tag, returns a string containing a key to use for
     * comparisons when checking if one Tag is equivalent to another
     * @private
     * @param {object} tagObj an object representation of a Tag
     * @returns {string} containing the name of the property to use.
     */
    getTargetProp: function getTargetProp() {
      var targetProp = 'content';
      return targetProp;
    },

    /**
     * Adds a new tag to the collection
     * @param {Tag|object} tagObj an incoming Tag Component instance, or object representing tag data.
     * @returns {Tag|array<Tag>} the newly formed tag object.
     */
    add: function add(tagObj) {
      var _this3 = this;

      var tag;

      if (!tagObj) {
        throw new Error('No object was provided');
      } // Re-run this function on each item in an array


      if (Array.isArray(tagObj)) {
        var tags = [];
        tagObj.forEach(function (thisTagObj) {
          tags.push(_this3.add(thisTagObj));
        });
        return tags;
      }

      if (objectUtils.isEmpty(tagObj)) {
        throw new Error('Provided object has no unique keys to use for creation of a Tag.');
      }

      if (!(tagObj instanceof Tag)) {
        tagObj.parent = this.element;
        tagObj.parentAPI = this;
        tag = new Tag(undefined, tagObj);
      } else {
        tag = tagObj;
        tagObj.settings.parentAPI = this;
      }

      if (this.tags.indexOf(tag) === -1) {
        this.tags.push(tag);
      }

      return tag;
    },

    /**
     * Removes a tag from the collection.
     * @param {Tag|object} tagObj an incoming Tag Component instance, or object representing tag data.
     * @param {boolean} [doDestroy=false] if true, calls `Tag.prototype.remove()` and removes the tag from the DOM.
     * @returns {Tag|undefined} a reference to the removed tag, if one has been removed. Returns undefined if no tags
     * have been removed.
     */
    remove: function remove(tagObj, doDestroy) {
      if (tagObj instanceof Tag) {
        tagObj = tagObj.settings;
      } // Figure out the property to use when checking for a match.


      var targetProp = this.getTargetProp(tagObj); // Filter out matching result(s) from the current tags array.

      var removedTag;
      var updatedTagsList = this.tags.filter(function (tag) {
        var settings = tag.settings;

        if (settings[targetProp] !== tagObj[targetProp]) {
          removedTag = tag;
          return false;
        }

        return true;
      }); // Update the internal list of tags if we've removed one.

      if (updatedTagsList.length < this.tags.length) {
        this.tags = updatedTagsList;
      } // Destroy the tag, if applicable


      if (doDestroy) {
        removedTag.remove();
      }

      return removedTag;
    },

    /**
     * Removes all tags from this tag list.
     * @returns {void}
     */
    removeAll: function removeAll() {
      this.tags.forEach(function (tag) {
        tag.remove();
      });
      this.tags = [];
    },

    /**
     * Renders all Tags contained by the internal tag list.
     * @returns {void}
     */
    render: function render() {
      this.tags.forEach(function (tag) {
        tag.render();
      });
      this.element.classList[this.tags.length ? 'remove' : 'add']('empty');
    },

    /**
     * Focuses a tag in the taglist by referencing its Index within the `.tag-list` element.
     * @param {number} [tagIndex=0] the index of the tag within the tag list
     * @returns {HTMLElement} the element that will be focused
     */
    focusByIndex: function focusByIndex() {
      var tagIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var elems = this.elements;
      var min = 0;
      var max = elems.length;

      if (tagIndex < min) {
        tagIndex = min;
      }

      if (tagIndex > max) {
        tagIndex = max;
      }

      var targetElem = elems[tagIndex];
      var targetAnchor = targetElem.querySelector('a');

      if (targetAnchor) {
        targetAnchor.focus();
      }

      return targetElem;
    },

    /**
     * Focuses a tag in the taglist by referencing its Element.
     * @param {HTMLElement} element the element that will be focused
     * @returns {HTMLElement} the element that will be focused
     */
    focusPreviousElement: function focusPreviousElement(element) {
      if (!(element instanceof HTMLElement)) {
        throw new Error("".concat(element, " is not an HTMLElement"));
      }

      var index = this.elements.indexOf(element);
      var hasElem = index > -1;

      if (!hasElem) {
        throw new Error("".concat(element, " does not exist within this TagList"));
      }

      return this.focusByIndex(index - 1);
    },

    /**
     * Updates the component with new settings
     * @param {object} [settings] if provided, updates the settings on this component instance
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);

        if (Array.isArray(settings.tags)) {
          this.settings.tags = settings.tags;
        }
      }

      this.removeAll();
      this.init();
    },

    /**
     * Destroys this component instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.tags.forEach(function (tag) {
        tag.remove();
      });
      delete this.tags;
      var $api = $(this.element).data(COMPONENT_NAME$u);

      if ($api) {
        $.removeData(this.element, COMPONENT_NAME$u);
      }
    }
  };

  var COMPONENT_NAME$v = 'dropdown'; // Dropdown Settings and Options

  var moveSelectedOpts = ['none', 'all', 'group'];
  var reloadSourceStyles = ['none', 'open', 'typeahead'];
  /**
  * The Dropdown allows users to select from a list. Like an Html Select.
  * @class Dropdown
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.closeOnSelect = true]  When an option is selected, the list will close if set to "true".  List stays open if "false".
  * @param {string} [settings.cssClass = null]  Append an optional css class to dropdown-list
  * @param {string} [settings.filterMode = 'contains']  Search mode to use between 'startsWith' and 'contains', false will not allow client side filter
  * @param {boolean} [settings.noSearch = false]  If true, disables the ability of the user to enter text
  * in the Search Input field in the open combo box
  * @param {boolean} [settings.showEmptyGroupHeaders = false]  If true, displays optgroup headers in the list
  * even if no selectable options are present underneath.
  * @param {boolean} [settings.showSelectAll] if true, shows a `Select All` option at the top of a multiselect.
  * @param {boolean} [settings.showTags] if true, replaces the text-based pseudo-element in the page with a dismissible, tag-based display.
  * @param {boolean} [settings.showSearchUnderSelected=false] if true, moves the Searchfield in the Dropdown list from directly on top of the pseudo-element to underneath/above, providing visibility into the currently selected results.  When configured as a Multiselect with Tags, this is the default option.
  * @param {boolean} [settings.source]  A function that can do an ajax call.
  * @param {boolean} [settings.sourceArguments = {}]  If a source method is defined, this flexible object can be
  * passed into the source method, and augmented with parameters specific to the implementation.
  * @param {boolean|string} [settings.reload = 'none']  Determines how a Dropdown list will repopulate its contents, when operating via AJAX.
  * @param {boolean} [settings.reloadSourceOnOpen = false]  If set to true, will always perform an ajax call
  * whenever the list is opened.  If false, the first AJAX call's results are cached.
  * @param {boolean} [settings.empty = false]  Initialize Empty Value
  * @param {boolean} [settings.delay = 300]  Typing buffer delay in ms
  * @param {number} [settings.maxWidth = null] If set the width of the dropdown is limited to this pixel width.
  * Fx 300 for the 300 px size fields. Default is size of the largest data.
  * @param {object} [settings.placementOpts = null]  Gets passed to this control's Place behavior
  * @param {function} [settings.onKeyDown = null]  Allows you to hook into the onKeyDown. If you do you can access the keydown event data. And optionally return false to cancel the keyDown action.
  * @param {object} [settings.tagSettings] if defined, passes along 'clickHandler' and 'dismissHandler' functions to any Tags in the Taglist
  * @param {number|undefined} [settings.tagListMaxHeight=120] if defined, sets a maximum height for a rendered tag list, and makes it scrollable.
  * @param {string} [settings.allTextString]  Custom text string for `All` text header use in MultiSelect.
  * @param {string} [settings.selectedTextString]  Custom text string for `Selected` text header use in MultiSelect.
  * @param {boolean} [settings.selectAllFilterOnly = true] if true, when using the optional "Select All" checkbox, the Multiselect will only select items that are in the current filter.  If false, or if there is no filter present, all items will be selected.
  * @param {string|array} [settings.attributes = null] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var DROPDOWN_DEFAULTS = {
    closeOnSelect: true,
    cssClass: null,
    filterMode: 'contains',
    maxSelected: undefined,
    // (multiselect) sets a limit on the number of items that can be selected
    moveSelected: 'none',
    moveSelectedToTop: undefined,
    multiple: false,
    // Turns the dropdown into a multiple selection box
    noSearch: false,
    showEmptyGroupHeaders: false,
    showSelectAll: false,
    showTags: false,
    showSearchUnderSelected: false,
    source: undefined,
    sourceArguments: {},
    reload: reloadSourceStyles[0],
    empty: false,
    delay: 300,
    maxWidth: null,
    placementOpts: null,
    onKeyDown: null,
    tagSettings: {},
    tagListMaxHeight: 120,
    allTextString: null,
    selectedTextString: null,
    selectAllFilterOnly: true,
    attributes: null
  };

  function Dropdown(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DROPDOWN_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Actual DropDown Code


  Dropdown.prototype = {
    /**
     * @returns {array|string} currently-selected options
     */
    get value() {
      var reload = this.settings.reload;
      var multiple = this.settings.multiple;

      if (reload === 'typeahead') {
        if (multiple) {
          return this.selectedValues;
        }

        return this.element.val();
      }

      var result = [];
      var options = this.element[0].options;
      var opt;

      for (var i = 0; i < options.length; i++) {
        opt = options[i];

        if (opt.selected) {
          result.push(opt.value || opt.text);
        }
      }

      if (!multiple && result.length === 1) {
        return result[0];
      }

      return result;
    },

    /**
     * @returns {boolean} whether or not the text inside the in-page pseudo element too big to fit
     */
    get overflowed() {
      if (!this.isMobile() || this.isMobile() && !this.isOpen()) {
        var span = this.pseudoElem.find('span').css('max-width', '');

        if (Math.round(span.width()) > Math.round(this.pseudoElem.width())) {
          span.css('max-width', '100%');
          return true;
        }
      }

      return false;
    },

    /**
     * @returns {boolean} whether or not the pseudo-element, or one of elements inside the Dropdown List has focus.
     */
    get isFocused() {
      var active = document.activeElement;
      var pseudoIsActive = this.pseudoElem.length && this.pseudoElem.is($(active));
      var listContainsActive = this.list && this.list.length && this.list[0].contains(active);
      var tagActive = this.tagListAPI && this.tagListAPI.element.contains(active);

      if (pseudoIsActive || listContainsActive || tagActive) {
        return true;
      }

      return false;
    },

    /**
     * @returns {boolean} whether or not this Dropdown component is a "short" field.
     */
    get isShortField() {
      return this.element.closest('.field-short').length > 0 || this.element.closest('.form-layout-compact').length > 0;
    },

    /**
     * @returns {array} a list of currently selected options' values.
     */
    get selectedValues() {
      return this.selectedOptions.map(function (opt) {
        return opt.value;
      });
    },

    /**
     * @returns {array} a list of selected options from inside this component's base element.
     */
    get selectedOptions() {
      return utils.getArrayFromList(this.element[0].querySelectorAll('option')).filter(function (opt) {
        return opt.selected;
      });
    },

    /**
     * Initialize the dropdown.
     * @private
     * @returns {object} The api for chaining
     */
    init: function init() {
      var _this = this;

      var orgId = this.element.attr('id');
      orgId = orgId ? xssUtils.stripTags(orgId) : '';
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline');
      this.timer = null;
      this.filterTerm = '';

      if (!orgId) {
        orgId = utils.uniqueId(this.element, 'dropdown');
        DOM.setAttribute(this.element[0], 'id', orgId);
        DOM.setAttribute(this.element.parent().find('label').first()[0], 'for', orgId);
      }

      if (Environment.os.name === 'ios' || Environment.os.name === 'android') {
        this.settings.noSearch = true;
      } // Add "is-disabled" class to greyed-out the field


      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      } // convert <select> tag's size css classes for the pseudo element


      var elemClassList = this.element[0].classList;

      if (elemClassList.length === 0) {
        this.element[0].classList = 'dropdown';
      }

      var pseudoClassString = elemClassList.contains('dropdown-xs') ? 'dropdown input-xs' : //eslint-disable-line
      elemClassList.contains('dropdown-sm') ? 'dropdown input-sm' : //eslint-disable-line
      elemClassList.contains('dropdown-lg') ? 'dropdown input-lg' : 'dropdown'; //eslint-disable-line
      // Detect Inline Styles

      var style = this.element.attr('style');
      this.isHidden = style && style.indexOf('display: none') >= 0; // Build the wrapper if it doesn't exist

      var baseElement = this.isInlineLabel ? this.inlineLabel : this.element;
      this.wrapper = baseElement.next('.dropdown-wrapper');
      this.isWrapped = this.wrapper.length > 0;

      if (!this.isWrapped) {
        this.wrapper = $('<div class="dropdown-wrapper"></div>').insertAfter(baseElement);
      }

      if (this.isWrapped) {
        this.pseudoElem = this.wrapper.find(".".concat(pseudoClassString));
        this.trigger = this.wrapper.find('.trigger');
      } else {
        this.pseudoElem = $("div#".concat(orgId, "-shdo"));
      }

      if (elemClassList.contains('text-align-reverse')) {
        pseudoClassString += ' text-align-reverse';
      } else if (elemClassList.contains('text-align-center')) {
        pseudoClassString += ' text-align-center';
      } // Build sub-elements if they don't exist


      this.label = $("label[for=\"".concat(xssUtils.stripTags(orgId), "\"]"));

      if (!this.pseudoElem.length) {
        this.pseudoElem = $("<div class=\"".concat(pseudoClassString, "\">"));
      } else {
        this.pseudoElem[0].setAttribute('class', pseudoClassString);
      }

      if (!this.isWrapped) {
        this.pseudoElem.append($('<span></span>'));
      }

      var toExclude = ['data-validate'];
      var attributes = DOM.getAttributes(this.element[0]);
      var attributesToCopy = this.getDataAttributes(attributes, toExclude);
      this.pseudoElem.attr(attributesToCopy.obj).attr({
        role: 'button',
        'aria-haspopup': 'listbox'
      });

      if (this.settings.attributes) {
        utils.addAttributes(this.pseudoElem, this, this.settings.attributes, 'dropdown', true);
      } // Pass disabled/readonly from the original element, if applicable
      // "disabled" is a stronger setting than "readonly" - should take precedent.


      function handleStates(self) {
        var disabled = self.element.prop('disabled');
        var readonly = self.element.prop('readonly');

        if (disabled) {
          return self.disable();
        }

        if (readonly) {
          return self.readonly();
        }

        return self.enable();
      }

      handleStates(this);

      if (!this.isWrapped) {
        this.wrapper.append(this.pseudoElem, this.trigger);
      } // Check for and add the icon


      this.icon = this.wrapper.find('.icon');

      if (!this.icon.length) {
        this.icon = $.createIconElement('dropdown');
        this.wrapper.append(this.icon);
      } // Setup the incoming options that can be set as properties/attributes


      if (this.element.prop('multiple') && !this.settings.multiple) {
        this.settings.multiple = true;
      }

      if (this.settings.multiple && !this.element.prop('multiple')) {
        this.element.prop('multiple', true);
      } // Create a taglist, if applicable


      if (this.settings.showTags) {
        // Force searchfield to be beneath/above the pseudo element
        // to prevent conflicts with the Tag List.
        this.settings.showSearchUnderSelected = true;
        this.pseudoElem[0].classList.add('has-tags');
        this.renderTagList();
      }

      var dataSource = this.element.attr('data-source');

      if (dataSource && dataSource !== 'source') {
        this.settings.source = dataSource;
      }

      var dataMaxselected = this.element.attr('data-maxselected');

      if (dataMaxselected && !isNaN(dataMaxselected)) {
        //eslint-disable-line
        this.settings.maxSelected = parseInt(dataMaxselected, 10);
      } // TODO: deprecate "moveSelectedToTop" in favor of "moveSelected"
      // _getMoveSelectedSetting()_ converts the old setting to the new text type.


      function getMoveSelectedSetting(incomingSetting, useText) {
        switch (incomingSetting) {
          case useText ? 'true' : true:
            return 'all';

          case useText ? 'false' : false:
            return 'none';

          default:
            if (moveSelectedOpts.indexOf(incomingSetting) > -1) {
              return incomingSetting;
            }

            return 'none';
        }
      } // Backwards compatibility for deprecated "moveSelectedToTop" setting.


      if (this.settings.moveSelectedToTop !== undefined) {
        this.settings.moveSelected = this.settings.moveSelectedToTop;
      }

      var dataMoveSelected = this.element.attr('data-move-selected');

      if (dataMoveSelected) {
        this.settings.moveSelected = getMoveSelectedSetting(dataMoveSelected, true);
      } else {
        this.settings.moveSelected = getMoveSelectedSetting(this.settings.moveSelected);
      } // Backwards compatibility with `settings.reloadSourceOnOpen`


      if (this.settings.reloadSourceOnOpen) {
        this.settings.reload = 'open';
        delete this.settings.reloadSourceOnOpen;
      }

      var dataCloseOnSelect = this.element.attr('data-close-on-select');

      if (dataCloseOnSelect && !this.settings.closeOnSelect) {
        this.settings.closeOnSelect = dataCloseOnSelect === 'true';
      }

      var dataNoSearch = this.element.attr('data-no-search');

      if (dataNoSearch && !this.settings.noSearch) {
        this.settings.noSearch = dataNoSearch === 'true';
      } // Persist sizing defintions


      var sizingStrings = ['-xs', '-sm', '-mm', '-md', '-lg'];
      var classString = this.element.attr('class');
      var s = null;

      for (var i = 0; i < sizingStrings.length; i++) {
        s = sizingStrings[i];

        if (classString.match(s)) {
          this.pseudoElem.addClass("dropdown".concat(s));
        }
      } // Cached dataset (from AJAX, if applicable)


      this.dataset = [];
      this.listfilter = new ListFilter({
        filterMode: this.settings.filterMode
      });
      this.setListIcon();
      this.setDisplayedValues();
      this.setInitial();
      this.setWidth();
      setTimeout(function () {
        _this.toggleTooltip();
      }, 0);
      this.element.triggerHandler('rendered');
      return this.handleEvents();
    },

    /**
     * Updates/Renders the TagList
     * @private
     * @returns {void}
     */
    renderTagList: function renderTagList() {
      var self = this;

      function dismissHandler(tag) {
        // Run a dismissHandler, if defined
        if (self.settings.dismissHandler) {
          self.settings.dismissHandler(tag);
        }

        var targets = self.selectedOptions.filter(function (el) {
          var optionValue = xssUtils.stripHTML(el.value);
          return optionValue === tag.settings.value;
        });

        if (targets.length) {
          self.deselect(targets[0]);
        }

        self.tagListAPI.element.classList[self.selectedOptions.length ? 'remove' : 'add']('empty');

        if (self.isOpen()) {
          self.updateList();
        }
      }

      var tags = this.toTagData();
      tags.forEach(function (tag) {
        tag.dismissHandler = dismissHandler;

        if (self.settings.clickHandler) {
          tag.clickHandler = self.settings.clickHandler;
        }

        if (self.isDisabled()) {
          tag.disabled = true;
        }
      });
      var span = this.pseudoElem.children('span')[0];

      if (!this.tagListAPI) {
        this.tagListAPI = new TagList(span, {
          tags: tags
        });
        span.classList.add('tag-list');
      } else {
        this.tagListAPI.updated({
          tags: tags
        });
      }

      this.tagListAPI.element.classList[this.selectedOptions.length ? 'remove' : 'add']('empty');

      if (!isNaN(this.settings.tagListMaxHeight)) {
        span.classList.add('scrollable');
        span.style.maxHeight = tags.length ? "".concat(this.settings.tagListMaxHeight, "px") : '';
      } // Detect scrollbar, if applicable, to push the dropdown icon away from the scrollbar.


      var hasScrollbar = span.scrollHeight > span.clientHeight;
      this.pseudoElem[0].classList[hasScrollbar ? 'add' : 'remove']('has-scrollbar');

      if (this.isOpen()) {
        this.position();
      }
    },

    /**
     * Used for preventing menus from popping open/closed when they shouldn't.
     * Gets around the need for timeouts everywhere
     * @private
     * @returns {boolean} If the timeout should be cancelled.
      */
    inputTimer: function inputTimer() {
      if (this.inputTimeout) {
        return false;
      }

      var self = this;
      this.inputTimeout = setTimeout(function () {
        clearTimeout(self.inputTimeout);
        self.inputTimeout = null;
      }, 100);
      return true;
    },

    /**
     * Set Width on the field
     * @private
     */
    setWidth: function setWidth() {
      var style = this.element[0].style;

      if (style.width) {
        this.pseudoElem[0].style.width = style.width;
      }

      if (style.position === 'absolute') {
        this.pseudoElem[0].style.position = 'absolute';
        this.pseudoElem[0].style.left = style.left;
        this.pseudoElem[0].style.top = style.top;
        this.pseudoElem[0].style.bottom = style.bottom;
        this.pseudoElem[0].style.right = style.right;
      }
    },

    /**
     * Set list item icon
     * @private
     * @param  {object} listIconItem The icon info to use on the list.
     */
    setItemIcon: function setItemIcon(listIconItem) {
      var self = this;
      var specColor = null;

      if (!listIconItem.icon) {
        listIconItem.isIcon = false;
        listIconItem.html = '';
        self.listIcon.items.push(listIconItem);
        return;
      } // Set icon properties


      if (_typeof(listIconItem.icon) === 'object') {
        listIconItem.obj = listIconItem.icon;
        listIconItem.icon = listIconItem.icon.icon; // Color

        if (listIconItem.obj.color) {
          specColor = listIconItem.obj.color.indexOf('#') === 0;

          if (specColor) {
            listIconItem.specColor = listIconItem.obj.color;
          } else {
            listIconItem.classList = " ".concat(listIconItem.obj.color);
          }
        } else if (listIconItem.obj.class) {
          specColor = listIconItem.obj.class.indexOf('#') === 0;

          if (specColor) {
            listIconItem.specColor = listIconItem.obj.class;
          } else {
            listIconItem.classList = " ".concat(listIconItem.obj.class);
          }
        } // Color Over


        if (listIconItem.obj.colorOver) {
          specColor = listIconItem.obj.colorOver.indexOf('#') === 0;

          if (specColor) {
            listIconItem.specColorOver = listIconItem.obj.colorOver;
          } else {
            listIconItem.classListOver = " ".concat(listIconItem.obj.colorOver);
          }
        } else if (listIconItem.obj.classOver) {
          specColor = listIconItem.obj.classOver.indexOf('#') === 0;

          if (specColor) {
            listIconItem.specColorOver = listIconItem.obj.classOver;
          } else {
            listIconItem.classListOver = " ".concat(listIconItem.obj.classOver);
          }
        }
      } // Set flags


      listIconItem.isIcon = listIconItem.icon && listIconItem.icon.length;

      if (listIconItem.classList && listIconItem.classList.length) {
        listIconItem.isClassList = true;
      }

      if (listIconItem.classListOver && listIconItem.classListOver.length) {
        listIconItem.isClassListOver = true;
      } // Build icon


      listIconItem.html = $.createIcon({
        icon: listIconItem.isIcon ? listIconItem.icon : '',
        class: "listoption-icon".concat(listIconItem.isClassList ? " ".concat(listIconItem.classList) : '')
      });

      if (listIconItem.icon === 'swatch') {
        listIconItem.isSwatch = true;
        listIconItem.html = "<span class=\"swatch ".concat(listIconItem.isClassList ? listIconItem.classList : '', "\"></span>");
      }

      self.listIcon.items.push(listIconItem);
    },

    /**
     * Set all icons on the list.
     * @private
     */
    setListIcon: function setListIcon() {
      var self = this;
      var hasIcons = self.settings.multiple ? false : self.element.find('[data-icon]').length > 0;
      var opts = hasIcons ? this.element.find('option') : [];
      self.listIcon = {
        hasIcons: hasIcons,
        items: []
      };

      if (hasIcons) {
        var count = 0;
        opts.each(function (i) {
          var iconAttr = $(this).attr('data-icon');
          var icon = null;

          if (typeof iconAttr !== 'string' || !iconAttr.length) {
            return;
          }

          if (iconAttr.indexOf('{') !== 0) {
            icon = iconAttr;
          } else {
            icon = $.fn.parseOptions(this, 'data-icon');
          }

          self.setItemIcon({
            html: '',
            icon: icon
          });

          if (self.listIcon.items[i] && self.listIcon.items[i].isIcon) {
            count++;
          }
        });
        hasIcons = count > 0;
      }

      if (hasIcons) {
        self.pseudoElem.prepend($.createIcon({
          icon: '',
          class: 'listoption-icon'
        }));
        self.listIcon.pseudoElemIcon = self.pseudoElem.find('> .listoption-icon');
        self.listIcon.idx = -1;
      }

      self.listIcon.hasIcons = hasIcons;
    },

    /**
     * Toggle toooltip (add if text over flowed)
     * @private
     * @returns {void}
     */
    toggleTooltip: function toggleTooltip() {
      if (this.overflowed) {
        this.setTooltip();
      } else if (this.tooltipApi) {
        this.removeTooltip();
      }
    },

    /**
     * Triggers tooltip in multiselect
     * @returns {void}
     */
    setTooltip: function setTooltip() {
      var _this2 = this;

      var opts = $(this.element[0].selectedOptions);
      var optText = this.getOptionText(opts);
      this.tooltipApi = this.pseudoElem.find('span').tooltip({
        content: xssUtils.escapeHTML(optText),
        parentElement: this.pseudoElem,
        trigger: this.isMobile() ? 'immediate' : 'hover'
      }).on('blur.dropdowntooltip', function () {
        _this2.removeTooltip();
      }).data('tooltip');
    },

    /**
     * Removes a tooltip
     * @returns {void}
     */
    removeTooltip: function removeTooltip() {
      if (this.tooltipApi) {
        this.tooltipApi.element.off('blur.dropdowntooltip');
        this.tooltipApi.destroy();
        this.tooltipApi = null;
      }
    },

    /**
     * Set over color for list item icon,
     * if run without pram {target}, it will make on only
     * @private
     * @param  {object} target The dom target.
     */
    setItemIconOverColor: function setItemIconOverColor(target) {
      var self = this;

      if (self.listIcon.hasIcons) {
        var targetIcon = target ? target.find('.listoption-icon') : null;
        self.list.find('li').each(function (i) {
          var li = $(this);
          var icon = li.find('.listoption-icon');
          var iconRef = self.listIcon.items[i];

          if (!iconRef) {
            return;
          } // make it on


          if (li.is('.is-focused')) {
            if (iconRef.isClassListOver) {
              icon.removeClass(iconRef.classListOver).addClass(iconRef.classList);
            }
          } // make it over


          if (targetIcon && li.is(target)) {
            if (iconRef.isClassListOver) {
              targetIcon.removeClass(iconRef.classList);
              targetIcon.addClass(iconRef.classListOver);
            }
          }
        });
      }
    },

    /**
     * Update the icon.
     * @private
     * @param {object} opt The dom target.
     */
    updateItemIcon: function updateItemIcon(opt) {
      var self = this;

      if (self.listIcon.hasIcons) {
        var target = self.listIcon.pseudoElemIcon;
        var i = opt.index();
        var idx = self.listIcon.idx;
        var iconRef = self.listIcon.items[i];
        var icon = iconRef && iconRef.isIcon ? iconRef.icon : ''; // Return out if this item has no icon

        if (!iconRef) {
          return;
        } // Reset class and color


        if (idx > -1) {
          var iconAtIndex = self.listIcon.items[idx];

          if (iconAtIndex) {
            target.removeClass("".concat(iconAtIndex.classList, " ").concat(iconAtIndex.classListOver));
            target[0].style.fill = '';
          }
        } // Update new stuff


        self.listIcon.idx = i;
        target.changeIcon(icon);

        if (iconRef.isClassList) {
          target.addClass(iconRef.classList);
        }
      }
    },

    /**
     * Update the visible list object.
     * @param {string} [term = undefined] an optional search term that will cause highlighting of text
     * @private
     */
    updateList: function updateList(term) {
      var self = this;
      var s = this.settings;
      var isMobile = self.isMobile();
      var listExists = self.list !== undefined && self.list !== null && self.list.length > 0;
      var listContents = '';
      var ulContents = '';
      var upTopOpts = 0;
      var hasOptGroups = this.element.find('optgroup').length;
      var reverseText = '';
      var isMultiselect = this.settings.multiple === true;
      var moveSelected = "".concat(this.settings.moveSelected);
      var showSelectAll = this.settings.showSelectAll === true;
      var headerText = {
        all: Locale.translate('All'),
        selected: Locale.translate('Selected'),
        labelText: self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()
      };
      headerText.all = typeof s.allTextString === 'string' && s.allTextString !== '' ? self.settings.allTextString : "".concat(headerText.all, " ").concat(headerText.labelText);
      headerText.selected = typeof s.selectedTextString === 'string' && s.selectedTextString !== '' ? self.settings.selectedTextString : "".concat(headerText.selected, " ").concat(headerText.labelText);

      if (this.element[0].classList.contains('text-align-reverse')) {
        reverseText = ' text-align-reverse';
      } else if (this.element[0].classList.contains('text-align-center')) {
        reverseText = ' text-align-center';
      }

      if (!listExists) {
        listContents = "<div class=\"dropdown-list".concat(reverseText).concat(isMobile ? ' mobile' : '').concat(this.settings.multiple ? ' multiple' : '', "\" id=\"dropdown-list\" ").concat(this.settings.multiple ? 'aria-multiselectable="true"' : '', ">\n        <label for=\"dropdown-search\" class=\"audible\">").concat(this.settings.noSearch ? Locale.translate('PressDown') : Locale.translate('TypeToFilter'), "</label>\n        <input type=\"text\" class=\"dropdown-search").concat(reverseText, "\" ").concat(this.settings.noSearch ? 'aria-readonly="true"' : '', " id=\"dropdown-search\" autocomplete=\"off\" />\n        <span class=\"trigger\">").concat(isMobile ? $.createIcon({
          icon: 'close',
          classes: ['close']
        }) : $.createIcon('dropdown'), "</span>\n        <ul role=\"listbox\" aria-label=\"").concat(Locale.translate('Dropdown'), "\">");
      } // Get a current list of <option> elements
      // If none are available, simply return out


      var opts = this.element.find('option');
      var groups = this.element.find('optgroup');
      var selectedFilterMethod = ':selected';
      var groupsSelectedOpts = []; // For typeahead reloading, the <option> tags are not used for determining what's already
      // selected.  Use the internal storage of selected values instead.

      if (this.settings.reload === 'typeahead') {
        selectedFilterMethod = function selectedFilterMethod(i, opt) {
          if (!self.selectedValues) {
            return false;
          }

          return self.selectedValues.indexOf(opt.value) > -1;
        };
      }

      var selectedOpts = opts.filter(selectedFilterMethod); // Re-inforce typeahead-reloaded options' `selected` properties

      if (this.settings.reload === 'typeahead') {
        selectedOpts.prop('selected', true);
      }

      function buildLiHeader(textContent) {
        return "<li role=\"presentation\" class=\"group-label\" focusable=\"false\">\n        ".concat(textContent, "\n      </li>");
      }

      function buildLiOption(option, index) {
        var liMarkup = '';
        var text = option.innerHTML;
        var attributes = DOM.getAttributes(option);
        var value = attributes.getNamedItem('value');
        var title = attributes.getNamedItem('title');
        var hasTitle = title ? "\" title=\"".concat(title.value, "\"") : '';
        var badge = attributes.getNamedItem('data-badge');
        var badgeColor = attributes.getNamedItem('data-badge-color');
        var badgeHtml = '';
        var isSelected = option.selected ? ' is-selected' : '';
        var isDisabled = option.disabled ? ' is-disabled' : '';
        var liCssClasses = option.className ? " ".concat(option.className.value) : '';
        var aCssClasses = liCssClasses.indexOf('clear') > -1 ? ' class="clear-selection"' : '';
        var tabIndex = " tabIndex=\"".concat(index && index === 0 ? 0 : -1, "\"");
        var toExclude = ['data-badge', 'data-badge-color', 'data-val', 'data-icon'];
        var copiedDataAttrs = " ".concat(self.getDataAttributes(attributes, toExclude).str);
        var trueValue = (value && 'value' in value ? value.value : text).replace(/"/g, '/quot/');
        var iconHtml = '';

        if (self.listIcon.hasIcons && self.listIcon.items[index]) {
          iconHtml = self.listIcon.items[index].html;
        }

        if (badge) {
          badgeHtml = "<span class=\"badge ".concat(badgeColor ? badgeColor.value : 'azure07', "\">").concat(badge.value, "</span>");
        }

        if (liCssClasses.indexOf('clear') > -1 && text === '') {
          text = Locale.translate('ClearSelection');
        } // Highlight search term


        if (term && term.length > 0) {
          var exp = self.getSearchRegex(term);
          text = text.replace(exp, '<span class="dropdown-highlight">$1</span>').trim();
        }

        if (self.listIcon.hasIcons && self.listIcon.items[index] && self.listIcon.items[index].isSwatch) {
          liCssClasses += ' is-swatch';
        }

        liMarkup += "<li class=\"dropdown-option".concat(isSelected).concat(isDisabled).concat(liCssClasses, "\" ").concat(isSelected ? 'aria-selected="true"' : '', " data-val=\"").concat(trueValue, "\" ").concat(copiedDataAttrs).concat(tabIndex).concat(hasTitle, " role=\"option\">\n        <a id=\"list-option-").concat(index, "\" href=\"#\" ").concat(aCssClasses, " role=\"option\">").concat(iconHtml).concat(text).concat(badgeHtml, "</a></li>");
        return liMarkup;
      } // In multiselect scenarios, shows an option at the top of the list that will
      // select all available options if checked.


      if (isMultiselect && showSelectAll && opts.length) {
        var allSelected = opts.not('[disabled], .hidden').length === selectedOpts.not('[disabled], .hidden').length;
        ulContents += "<li role=\"presentation\" class=\"dropdown-select-all-list-item".concat(allSelected ? ' is-selected' : '', "\">") + "<a role=\"option\" href=\"#\" id=\"dropdown-select-all-anchor\" class=\"dropdown-select-all-anchor\">".concat(Locale.translate('SelectAll'), "</a>") + '</li>';
      } // Move selected options in each group to just underneath their corresponding group headers.


      if (moveSelected === 'group') {
        // If no optgroups exist, change to "all" and skip this part.
        if (!groups || !groups.length) {
          moveSelected = 'all';
        } else {
          // Break apart selectedOpts into groups.
          // These selected items are applied when the header is generated.
          groups.each(function (i, g) {
            var els = selectedOpts.filter(function () {
              return $.contains(g, this);
            });
            groupsSelectedOpts.push(els);
          });
        }
      } // Move all selected options to the top of the list if the setting is true.
      // Also adds a group heading if other option groups are found in the <select> element.


      if (moveSelected === 'all') {
        opts = opts.not(selectedOpts); // Show a "selected" header if there are selected options

        if (selectedOpts.length > 0) {
          ulContents += buildLiHeader(headerText.selected);
        }

        selectedOpts.each(function (i) {
          ulContents += buildLiOption(this, i);
          upTopOpts++;
        }); // Only show the "all" header beneath the selected options if there
        // are no other optgroups present

        if (!hasOptGroups && opts.length > 0) {
          ulContents += buildLiHeader(headerText.all);
        }
      }

      opts.each(function (i) {
        var count = i + upTopOpts;
        var option = $(this);
        var parent = option.parent();
        var optgroupIsNotDrawn;
        var optgroupIndex; // Add Group Header if this is an <optgroup>
        // Remove the group header from the queue.

        if (parent.is('optgroup') && groups.length) {
          optgroupIndex = parent.index();
          optgroupIsNotDrawn = groups.index(parent) > -1;

          if (optgroupIsNotDrawn) {
            groups = groups.not(parent);
            ulContents += buildLiHeader("".concat(parent.attr('label'))); // Add all selected items for this group

            if (moveSelected === 'group') {
              groupsSelectedOpts[optgroupIndex].each(function (j) {
                ulContents += buildLiOption(this, j);
                upTopOpts++;
              });
            }
          }
        }

        if (moveSelected !== 'none' && option.is(':selected')) {
          return;
        }

        ulContents += buildLiOption(this, count);
      }); // Render the new list contents to the page.
      // Build the entire thing and set references if this is the first opening.
      // Otherwise, simply replace the elements inside the <ul>.

      if (!listExists) {
        listContents += "".concat(ulContents, "</ul>") + '</div>'; // Append markup to the DOM

        this.list = $(listContents); // Get references

        this.listUl = this.list.find('ul');
        this.searchInput = this.list.find('#dropdown-search');
      } else {
        this.listUl.html(ulContents);
      }

      if (this.listIcon.hasIcons) {
        this.list.addClass('has-icons');
        this.listIcon.pseudoElemIcon.clone().appendTo(this.list);
      }

      if (hasOptGroups) {
        this.listUl.addClass('has-groups');
      }

      this.hasTooltips = this.listUl.find('[title]').length > 0;

      if (this.isOpen()) {
        this.position();
        this.highlightOption(this.listUl.find('li:visible:not(.separator):not(.group-label):not(.is-disabled)').first());
      }
    },

    /**
     * Sets the displayed value of the Pseudo-Element based on currently-selected options.
     * @private
     */
    setDisplayedValues: function setDisplayedValues() {
      var opts = $(this.element[0].selectedOptions);
      var text = this.getOptionText(opts); // Clear Text

      if (opts.hasClass('clear')) {
        text = '';
      } // Displays the tags/text on the pseudo-element


      if (this.settings.showTags && this.tagListAPI) {
        // Render tags
        this.renderTagList();
      } else {
        // If empty, render an accessibility message
        if (this.settings.empty && opts.length === 0) {
          var _span = this.pseudoElem.find('span').first();

          DOM.html(_span, "<span class=\"audible\">".concat(this.label.text(), " </span>"), '<div><p><span><ul><li><a><abbr><b><i><kbd><small><strong><sub><svg><use><br>');
          _span = $("#".concat(this.element.attr('id'))).next().find('span').first();
          DOM.html(_span, "<span class=\"audible\">".concat(this.label.text(), " </span>"), '<div><p><span><ul><li><a><abbr><b><i><kbd><small><strong><sub><svg><use><br>');
          this.setPlaceholder(text);
          return;
        } // Render text


        var maxlength = this.element.attr('maxlength');

        if (maxlength) {
          text = text.substr(0, maxlength);
        }

        text = text.trim();
        var span = this.pseudoElem.find('span');

        if (span.length > 0) {
          span[0].innerHTML = "<span class=\"audible\">".concat(this.label.text(), " </span>").concat(xssUtils.escapeHTML(text));
        }

        if (!this.settings.showSearchUnderSelected) {
          this.setPlaceholder(text);
        }
      } // Set the "previousActiveDescendant" to the first of the items


      this.previousActiveDescendant = opts.first().val();
      this.updateItemIcon(opts);
      this.setBadge(opts);
    },

    /**
     * Copy classes from the two objects
     * @private
     * @param  {object} from The from element
     * @param  {object} to  The to element
     * @param  {string} prop The property to set
     */
    copyClass: function copyClass(from, to, prop) {
      if (from.hasClass(prop)) {
        to.addClass(prop);
      }
    },

    /**
     * Copy initial stuff from the drop down to the pseudo element.
     * @private
     */
    setInitial: function setInitial() {
      if (this.element.is(':disabled')) {
        this.disable();
      }

      if (this.element.is('[readonly]')) {
        this.readonly();
      }

      if (this.isHidden) {
        this.pseudoElem.hide().prev('label').hide();
        this.pseudoElem.next('svg').hide();
      }
    },

    /**
     * Set placeholder text, if value empty
     * @private
     * @param  {string} text The selected text value.
     * @returns {void}
     */
    setPlaceholder: function setPlaceholder(text) {
      this.placeholder = this.placeholder || {
        text: this.element.attr('placeholder')
      };

      if (this.placeholder.text) {
        var isEmpty = typeof text !== 'string' || typeof text === 'string' && text === '';
        this.placeholder.elem = this.placeholder.elem || this.pseudoElem.find('span:not(.audible)');
        this.placeholder.elem.attr('data-placeholder-text', isEmpty ? this.placeholder.text : '');
      } else {
        delete this.placeholder;
      }
    },

    /**
     * Figure out which keys to ignore on typehead.
     * @private
     * @param  {element} input The input element.
     * @param  {object} e  The event.
     * @returns {boolean} False if the key should be ignored.
     */
    ignoreKeys: function ignoreKeys(input, e) {
      var charCode = e.which; // Needed for browsers that use keypress events to manipulate the window.

      if (e.altKey && charCode === 38) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      if (input.is(':disabled') || input.hasClass('is-readonly')) {
        return; // eslint-disable-line
      }

      if (e.ctrlKey) {
        if (this.settings.onKeyDown) {
          var ret = this.settings.onKeyDown(e);

          if (ret === false) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        }
      }

      return true;
    },

    /**
     * Handle events while search is focus'd
     * @private
     * @returns {void}
     */
    handleSearchEvents: function handleSearchEvents() {
      var _this3 = this;

      // Used to determine how spacebar should function.
      // False means space will select/deselect.  True means
      // Space will add a space inside the search input.
      if (!this.filterTerm) {
        this.searchKeyMode = false;
      }

      var searchInputVal = this.searchInput[0].value;
      var isIE11 = Environment.browser.name === 'ie' && Environment.browser.version === '11';
      var rectStr;

      if (!isIE11) {
        /* eslint-disable */
        rectStr = String.fromCodePoint(8);
        /* eslint-enable no-alert, no-console */
      }

      if (searchInputVal === '.' || searchInputVal === rectStr) {
        this.searchInput[0].value = '';
      }

      this.searchInput.on("keydown.".concat(COMPONENT_NAME$v), function (e) {
        var searchInput = $(_this3);
        return _this3.handleKeyDown(searchInput, e);
      }).on("input.".concat(COMPONENT_NAME$v), function (e) {
        _this3.isFiltering = true;

        _this3.handleAutoComplete(e);
      });
    },

    /**
     * Filter the list elements by term.
     * @private
     * @param  {string} term The search term
     */
    filterList: function filterList(term) {
      var typeahead = false; // 'typeahead' reloading skips client-side filtering in favor of server-side

      if (this.settings.source && this.settings.reload === 'typeahead') {
        typeahead = true;
        this.callSource();
      }

      var self = this;
      var selected = false;
      var list = $('.dropdown-option', this.listUl);
      var headers = $('.group-label', this.listUl);
      var results;

      if (!list.length || !this.list || this.list && !this.list.length) {
        return;
      }

      if (!term) {
        term = '';
      }

      if (!typeahead && term && term.length) {
        results = this.listfilter.filter(list, term);
      } else {
        results = list;
      }

      this.list.addClass('search-mode');
      this.list.find('.trigger').find('.icon').attr('class', 'icon search').changeIcon('search');
      this.searchInput.removeAttr('aria-activedescendant');
      this.unhighlightOptions();

      if (!results || !results.length && !term) {
        this.resetList();
        return;
      }

      results.removeClass('hidden');
      list.not(results).add(headers).addClass('hidden');
      this.filteredItems = list.filter(results);
      this.filteredItems.each(function (i) {
        var li = $(this);
        var a = li.children('a');
        li.attr('tabindex', i === 0 ? '0' : '-1');

        if (!selected) {
          self.highlightOption(li);
          selected = true;
        } // Highlight Term


        var exp = self.getSearchRegex(term);
        var text = li.text();
        text = xssUtils.escapeHTML(text);
        text = text.replace(/&lt;/g, '&#16;');
        text = text.replace(/&gt;/g, '&#17;');
        text = text.replace(/&apos;/g, '&#18;');
        text = text.replace(/&quot;/g, '&#19;');
        text = text.replace(/&amp;/g, '&');
        text = text.replace(exp, '<span class="dropdown-highlight">$1</span>').trim();
        text = text.replace(/&#16;/g, '&lt;');
        text = text.replace(/&#17;/g, '&gt;');
        text = text.replace(/&#18;/g, '&apos;');
        text = text.replace(/&#19;/g, '&quot;');
        var icon = li.children('a').find('svg').length !== 0 ? new XMLSerializer().serializeToString(li.children('a').find('svg')[0]) : '';
        var swatch = li.children('a').find('.swatch');
        var swatchHtml = swatch.length !== 0 ? swatch[0].outerHTML : '';

        if (a[0]) {
          a[0].innerHTML = swatchHtml + icon + text;
        }
      });
      headers.each(function () {
        var children = $(this).nextUntil('.group-label, .selector').not('.hidden');

        if (self.settings.showEmptyGroupHeaders || children.length) {
          $(this).removeClass('hidden');
        }
      });
      term = '';
      this.position();
    },

    /**
     * Removes filtering from an open Dropdown list and turns off "search mode"
     * @private
     */
    resetList: function resetList() {
      // 'typeahead' reloading skips client-side filtering in favor of server-side
      if (this.settings.source && this.settings.reload === 'typeahead') {
        this.filterTerm = '';
        this.searchKeyMode = false;
        this.callSource(null, true);
        return;
      }

      if (!this.list || this.list && !this.list.length) {
        return;
      }

      this.list.removeClass('search-mode');
      var lis = this.listUl.find('li');
      lis.removeAttr('style').each(function () {
        var a = $(this).children('a');
        var li = $(this);
        var text = xssUtils.escapeHTML(a.text());
        var icon = li.children('a').find('svg').length !== 0 ? new XMLSerializer().serializeToString(li.children('a').find('svg')[0]) : '';
        var swatch = li.children('a').find('.swatch');
        var swatchHtml = swatch.length !== 0 ? swatch[0].outerHTML : '';

        if (a[0]) {
          a[0].innerHTML = swatchHtml + icon + text;
        }
      }); // Adjust height / top position

      if (this.list.hasClass('is-ontop')) {
        this.list[0].style.top = "".concat(this.pseudoElem.offset().top - this.list.height() + this.pseudoElem.outerHeight() - 2, "px");
      } else {
        this.list[0].style.top = '';
      }

      delete this.filteredItems;

      if (this.settings.multiple) {
        this.updateList();
      }

      lis.removeClass('hidden');
      this.position();

      if (this.list.find('svg').length === 2) {
        this.list.find('svg').last().remove();
      }
    },

    /**
     * Select the blank item (if present)
     * @private
     */
    selectBlank: function selectBlank() {
      var blank = this.element.find('option').filter(function () {
        return !this.value || $.trim(this.value).length === 0;
      });

      if (!blank.length) {
        return;
      } // TODO: Refactor this in v4.9.0 to call `selectOption` instead.  Can't currently
      // do that because `selectOption` depends on the list being open.


      blank[0].selected = true;
      blank[0].setAttribute('selected', true);
      this.element.triggerHandler('updated');
      this.element.triggerHandler('change');
    },

    /**
     * Handle the key down event actions.
     * @private
     * @param  {object} input The dom element.
     * @param  {object} e The event element.
     * @returns {boolean} Returns the event in some situations.
     */
    handleKeyDown: function handleKeyDown(input, e) {
      var selectedIndex = this.element[0].selectedIndex || -1;
      var options = this.element[0].options;
      var key = e.which;
      var self = this;
      var excludes = 'li:visible:not(.separator):not(.group-label):not(.is-disabled)';
      var next;

      if (!this.ignoreKeys(input, e)) {
        return false;
      }

      if (this.isLoading()) {
        return;
      }

      if (self.settings.onKeyDown) {
        var ret = self.settings.onKeyDown(e);

        if (ret === false) {
          e.stopPropagation();
          e.preventDefault();
          return false; //eslint-disable-line
        }
      }

      if (self.isOpen()) {
        options = this.listUl.find(excludes);
        selectedIndex = -1;
        $(options).each(function (index) {
          if ($(this).is('.is-focused')) {
            selectedIndex = index;
          }
        });
      }

      switch (key) {
        //eslint-disable-line
        case 37: // backspace

        case 8: // del & backspace

        case 46:
          {
            // del
            if (!self.isOpen()) {
              self.selectBlank(); // Prevent Backspace from returning to the previous page.

              e.stopPropagation();
              e.preventDefault();
              return false; //eslint-disable-line
            }

            break;
          }

        case 9:
          {
            // tab - save the current selection
            // If "search mode" is currently off, Tab should turn this mode on and place focus back
            // into the SearchInput.
            // If search mode is on, Tab should 'select' the currently highlighted
            // option in the list, update the SearchInput and close the list.
            if (self.isOpen()) {
              if (!this.settings.multiple && options.length && selectedIndex > -1) {
                // store the current selection
                // selectValue
                self.selectOption(this.correctValue($(options[selectedIndex])));
              }

              self.closeList('tab');
              this.activate();
            } // allow tab to propagate otherwise


            return true; //eslint-disable-line
          }

        case 27:
          {
            // Esc - Close the Combo and Do not change value
            if (self.isOpen()) {
              // Close the option list
              self.element.closest('.modal.is-visible').data('listclosed', true);
              var tdContainer = self.pseudoElem ? self.pseudoElem.parents('td') : null;
              self.closeList('cancel');
              self.activate();

              if (tdContainer) {
                tdContainer.focus();
              }

              e.stopPropagation();
              return false; //eslint-disable-line
            } // Allow Esc to propagate if the menu was closed, since some other Controls
            // that rely on dropdown may need to trigger routines when the Esc key is pressed.


            break;
          }

        case 32: // Spacebar

        case 13:
          {
            // enter
            if (self.isOpen()) {
              if (key === 32 && self.searchKeyMode === true) {
                break;
              }

              e.preventDefault();

              if (options.length && selectedIndex > -1) {
                // store the current selection
                var li = $(options[selectedIndex]);
                self.selectListItem(li);
              }
            }

            e.stopPropagation();
            return false; //eslint-disable-line
          }

        case 38:
          {
            // up
            if (e.shiftKey) {
              return;
            }

            this.searchKeyMode = false;

            if (selectedIndex > 0) {
              next = $(options[selectedIndex - 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next); // NOTE: Do not also remove the ".is-selected" class here!
              // It's not the same as ".is-focused"!
              // Talk to ed coyle if you need to know why.

              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false; //eslint-disable-line
          }

        case 40:
          {
            // down
            if (e.shiftKey) {
              return;
            }

            this.searchKeyMode = false;

            if (selectedIndex < options.length - 1) {
              next = $(options[selectedIndex + 1]);
              this.highlightOption(next);
              self.setItemIconOverColor(next); // NOTE: Do not also remove the ".is-selected" class here!
              //  It's not the same as ".is-focused"!
              // Talk to ed coyle if you need to know why.

              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false; //eslint-disable-line
          }

        case 35:
          {
            // end
            this.searchKeyMode = false;
            var last = $(options[options.length - 1]);
            this.highlightOption(last);
            e.stopPropagation();
            return false; //eslint-disable-line
          }

        case 36:
          {
            // home
            this.searchKeyMode = false;
            var first = $(options[0]);
            this.highlightOption(first);
            e.stopPropagation();
            return false; //eslint-disable-line
          }
      }

      if (!self.isOpen()) {
        if (!self.isControl(key) && !this.settings.source && !this.settings.noSearch) {
          // Make this into Auto Complete
          self.isFiltering = true;
          self.filterTerm = $.actualChar(e);

          if (self.searchInput && self.searchInput.length) {
            self.searchInput.val($.actualChar(e));
          }

          self.toggle();
        }
      }

      this.searchKeyMode = true;

      if (self.searchInput) {
        self.searchInput.attr('aria-activedescendant', '');
      }

      return true; // eslint-disable-line
    },

    /**
     * @private
     * @param {jQuery.Event} e incoming keydown event
     * @returns {boolean} whether or not the keydown event is allowed to continue
     */
    handlePseudoElemKeydown: function handlePseudoElemKeydown(e) {
      var target = $(e.target);
      var key = e.key; // No need to execute if readonly

      if (target.is('.is-readonly')) {
        return true;
      } // "Esc" is used by IE11


      var isEscapeKey = key === 'Esc' || key === 'Escape'; // Control Keydowns are ignored

      var controlKeys = ['Alt', 'Shift', 'Control', 'Meta'];

      if (controlKeys.indexOf(key) > -1) {
        return false;
      }

      if (!this.ignoreKeys(target, e)) {
        return false;
      }

      if (this.settings.onKeyDown) {
        var ret = this.settings.onKeyDown(e);

        if (ret === false) {
          e.stopPropagation();
          e.preventDefault();
          return false; //eslint-disable-line
        }
      } // Down arrow opens the list.
      // Down/Up are for IE/Edge.
      // ArrowDown/ArrowUp are for all others.


      var openKeys = ['ArrowDown', 'ArrowUp', 'Down', 'Up', 'Enter', 'Spacebar', ' '];

      if (openKeys.indexOf(key) > -1) {
        if (!this.isOpen()) {
          this.open();
        } // TODO: refactor this out so that `handleKeyDown` is no longer necessary.
        // This is necessary here because in `noSearch` mode, there is no actionable searchInput.


        if (this.settings.noSearch && !e.ctrlKey) {
          this.handleKeyDown(target, e);
        }

        return false;
      } // Mac OSX: "backspace" delete key
      // Everything else: DEL key (numpad, control keys)


      var isOSX = Environment.os.name === 'Mac OS X';

      if (!isOSX && key === 'Delete' || isOSX && key === 'Backspace') {
        this.selectBlank(); // Stop the backspace key from navigating back a page

        if (key === 'Backspace') {
          e.stopPropagation();
          e.preventDefault();
        }

        return true;
      }

      if (isEscapeKey || key === 'Tab') {
        // In nosearch mode, bypass the typeahead autocomplete and pass keydown events
        // along to the list elements
        if (this.settings.noSearch && this.isOpen()) {
          return this.handleKeyDown(target, e);
        } // Allow some keys to pass through with no changes in functionality


        return true;
      }

      this.handleAutoComplete(e);
      return true;
    },

    /**
     * Handle the typeahead.
     * @private
     * @param {object} e The event object
     */
    handleAutoComplete: function handleAutoComplete(e) {
      var _this4 = this;

      if (this.isLoading()) {
        return;
      }

      var self = this;

      if (this.timer) {
        clearTimeout(this.timer);
      }

      if (e.type === 'input') {
        this.filterTerm = this.searchInput.val();
      } else {
        this.filterTerm += $.actualChar(e).toLowerCase();

        if (this.filterTerm === '') {
          return;
        }

        if (e.key !== this.filterTerm && e.key.toLowerCase() === this.filterTerm && !self.settings.noSearch) {
          this.filterTerm = e.key;
        }
      } // if called by `open()`, runs in the context of this Dropdown's API


      function filter() {
        if (self.filterTerm === '') {
          self.resetList();
        } else {
          self.filterList(self.filterTerm.toLowerCase());
        }
      }

      this.timer = setTimeout(function () {
        if (self.settings.noSearch) {
          if (self.isOpen()) {
            self.highlightStartsWith(self.filterTerm);
          } else {
            self.selectStartsWith(self.filterTerm);
          }

          return;
        }

        _this4.searchKeyMode = true;

        if (!self.isOpen()) {
          self.open(filter);
          return;
        }

        if (_this4.list.find('ul li.hidden').length === 0) {
          _this4.list.find(' > svg.listoption-icon:not(.swatch)').changeIcon('icon-empty-circle');
        }

        filter();
      }, self.settings.delay);
    },

    /**
     * Determine if the key is a control key
     * @private
     * @param  {number} keycode The keycode to check.
     * @returns {boolean} true if the key is a control key.
     */
    isControl: function isControl(keycode) {
      var valid = keycode > 7 && keycode < 48 || // control chars
      keycode > 90 && keycode < 94 || // windows keys
      keycode > 111 && keycode < 146; // function keys

      return valid;
    },

    /**
     * Focus the input element. Since the select is hidden this is needed over normal focus()
     * @private
     * @param  {boolean} [useSearchInput] If true the search is used.
     * @returns {void}
     */
    activate: function activate(useSearchInput) {
      var self = this;
      var input = this.pseudoElem;

      if (useSearchInput || self.isMobile()) {
        input = this.searchInput;
      }

      if (this.currentlyScrolledPos) {
        this.listUl.scrollTop(this.currentlyScrolledPos);
        delete this.currentlyScrolledPos;
      }

      if (useSearchInput && input && (input.hasClass('is-readonly') || input.prop('readonly') === true)) {
        return;
      }

      function selectText() {
        if (self.isMobile() || self.filterTerm || !input) {
          return;
        }

        if (input[0].setSelectionRange) {
          input[0].setSelectionRange(0, input[0].value.length); // scroll to left
        } else if (input[0].tagName === 'INPUT') {
          // using Search Input instead of Pseudo Div
          input[0].select();
        }
      }

      selectText(); // Set focus back to the element

      if (input) {
        input[0].focus();
      }
    },

    /**
     * @private
     * @param {string} term incoming search term
     * @returns {RegExp} a valid regex object used to filter search results
     */
    getSearchRegex: function getSearchRegex(term) {
      var regex;

      try {
        regex = new RegExp("(".concat(stringUtils.escapeRegExp(term), ")"), 'i');
      } catch (e) {
        // create a "matches all" regex if we can't create a regex from the search term
        regex = /[\s\S]*/i;
      }

      return regex;
    },

    /**
     * Retrieves a string containing all text for currently selected options.
     * @private
     * @param  {array} opts The current option elements.
     * @returns {string} The selection options in a string  delimited by commas.
     */
    getOptionText: function getOptionText(opts) {
      var text = '';

      if (!opts) {
        opts = this.element.find('option:selected');
      }

      opts.each(function () {
        if (text.length > 0) {
          text += ', ';
        }

        text += $(this).text().trim();
      });
      return text;
    },

    /**
     * Open the dropdown list of options
     * @param {function} callback additional items that can be run after the opening process completes
     * @returns {void}
     */
    open: function open(callback) {
      var self = this;

      if (!this.inputTimer()) {
        return;
      }

      if (this.element.is(':disabled') || this.pseudoElem.hasClass('is-disabled') || this.pseudoElem.hasClass('is-readonly')) {
        return;
      }

      function completeOpen() {
        if (self.isMobile()) {
          $('.tooltip:not(.is-hidden)').hide();
        }

        self.updateList();
        self.openList();

        if (callback && typeof callback === 'function') {
          callback.call(this);
        }
      }

      if (!self.callSource(completeOpen)) {
        completeOpen();
      }
    },

    /**
     * Popup the list of options for selection.
     * @private
     */
    openList: function openList() {
      var current = this.previousActiveDescendant ? this.list.find(".dropdown-option[data-val=\"".concat(this.previousActiveDescendant.replace(/"/g, '/quot/'), "\"]")) : this.list.find('.is-selected');
      var self = this;
      var threshold = 10;
      var pos;
      this.touchPrevented = false; // Close any other drop downs.

      $('select').each(function () {
        var data = $(this).data();

        if (data.dropdown) {
          data.dropdown.closeList('cancel');
        }
      }); // Close any open popup menus

      var otherMenus = $('.popupmenu.is-open').filter(function () {
        return $(this).parents('.popupmenu').length === 0;
      }); // close others.

      otherMenus.each(function () {
        var trigger = $(this).data('trigger');

        if (!trigger || !trigger.length) {
          return;
        }

        var api = $(this).data('trigger').data('popupmenu');

        if (api && typeof api.close === 'function') {
          api.close();
        }
      });

      if (!this.isOpen()) {
        this.list.appendTo('body');
      }

      this.list.show(); // Persist the "short" input field

      if (this.isShortField) {
        this.list[0].classList.add('dropdown-short');
      }

      this.pseudoElem.attr('aria-expanded', 'true').addClass('is-open');

      if (self.settings.attributes) {
        // Add test automation ids
        utils.addAttributes(this.list.find('input'), this, this.settings.attributes, 'search', true);
        this.list.find('label').attr('for', this.list.find('input').attr('id'));
        utils.addAttributes(this.list.find('label'), this, this.settings.attributes, 'search-label');
        utils.addAttributes(this.list.find('.trigger svg'), this, this.settings.attributes, 'trigger', true);
        utils.addAttributes(this.list.find('ul'), this, this.settings.attributes, 'listbox', true);
        utils.addAttributes(this.list, this, this.settings.attributes, 'list');
        var options = this.list.find('.dropdown-option a');
        options.each(function (i) {
          var opt = $(this);
          utils.addAttributes(opt, self, self.settings.attributes, "option-".concat(i), true);
        });
      }

      this.searchInput.attr('aria-activedescendant', current.children('a').attr('id'));

      if (this.settings.showSearchUnderSelected) {
        this.list.find('.trigger').find('.icon').attr('class', 'icon search').changeIcon('search');
      } // In a grid cell


      this.isInGrid = this.pseudoElem.closest('.datagrid-row').length === 1;

      if (this.pseudoElem.parent().hasClass('is-inline')) {
        this.isInGrid = false;
      }

      if (this.isInGrid) {
        var rowHeight = this.pseudoElem.closest('.datagrid').attr('class').replace('datagrid', '');
        this.list.addClass("datagrid-dropdown-list ".concat(rowHeight));
      }

      if (this.pseudoElem.closest('.datagrid-filter-wrapper').length === 1) {
        this.list.addClass('datagrid-filter-dropdown');
      }

      var cssClass = this.settings.cssClass;

      if (cssClass && typeof cssClass === 'string') {
        this.list.addClass(cssClass);
      }

      this.position(); // Limit the width

      if (this.settings.maxWidth) {
        this.list.css('max-width', "".concat(this.settings.maxWidth, "px"));
      } // Set the contents of the search input.
      // If we've got a stored typeahead


      if (typeof this.filterTerm === 'string' && this.filterTerm.length > 0) {
        this.searchInput.val(this.filterTerm);
      } else if (!this.settings.showSearchUnderSelected) {
        var selectedOpts = $(this.selectedOptions);
        var text = this.getOptionText(selectedOpts);
        this.searchInput.val(text);
      }

      var noScroll = this.settings.multiple;
      this.highlightOption(current, noScroll);

      if (this.settings.multiple && this.listUl.find('.is-selected').length > 0) {
        this.highlightOption(this.listUl.find('.dropdown-option').eq(0));
        setTimeout(function () {
          self.listUl.scrollTop(0);
        }, 0);
      }

      this.handleSearchEvents();
      this.activate(true); // Focus the Search Input

      /**
      *  Fires as the dropdown list is opened.
      *
      * @event listopened
      * @memberof Dropdown
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */

      this.element.trigger('listopened');

      if (this.isMobile()) {
        // iOS-specific keypress event that listens for when you click the "done" button
        self.searchInput.on('keypress.dropdown', function (e) {
          if (e.which === 13) {
            self.closeList('select');
          }
        });
      }

      self.list.removeClass('dropdown-tall').on('touchend.list click.list', 'li', function (e) {
        if (self.touchPrevented) {
          return;
        }

        var itemSelected = self.selectListItem($(this));
        e.preventDefault();

        if (!itemSelected) {
          return;
        }

        e.stopPropagation();
      }).on('mouseenter.list', 'li', function () {
        self.highlightOption($(this), true);
      });

      if (this.hasTooltips) {
        var clearTimer = function clearTimer() {
          if (_self.timer && _self.timer.destroy) {
            _self.timer.destroy(true);
          }
        };

        var showTooltip = function showTooltip(target, title) {
          $(target).tooltip({
            trigger: 'immediate',
            content: title
          });
          $(target).focus();
        };

        var hideTooltip = function hideTooltip(target) {
          var _$$data;

          $('#tooltip').hide();
          (_$$data = $('#tooltip').data('tooltip')) === null || _$$data === void 0 ? void 0 : _$$data == null ? void 0 : _$$data.destroy();
        };

        var showOnTimer = function showOnTimer(target) {
          clearTimer();
          _self.timer = new RenderLoopItem({
            duration: 500 / 10,
            timeoutCallback: function timeoutCallback() {
              var title = target.getAttribute('title');

              if (!title) {
                title = target.getAttribute('data-title');
                showTooltip(target, title);
                return;
              }

              target.setAttribute('data-title', title);
              target.removeAttribute('title');
              showTooltip(target, title);
            }
          });
          renderLoop.register(_self.timer);
        };

        var hideImmediately = function hideImmediately(target) {
          clearTimer();
          hideTooltip(target);
        };

        var _self = this;

        _self.list.on('mouseover.tooltip', 'li[title], li[data-title]', function (e) {
          showOnTimer(e.currentTarget);
        }).on('mouseleave.tooltip, click.tooltip', 'li[title], li[data-title]', function (e) {
          hideImmediately(e.currentTarget);
        });
      } // Some list-closing events are on a timer to prevent immediate list close
      // There would be several things to check with a setTimeout, so this is done with a CSS
      // class to keep things a bit cleaner


      setTimeout(function () {
        self.list.addClass('is-closable');
      }, 100); // Is the jQuery Element a component of the current Dropdown list?

      function isDropdownElement(target) {
        return target.closest('.dropdown, .multiselect').length > 0 || target.closest('.dropdown-list').length > 0 || self.touchmove === true;
      } // Triggered when the user scrolls the page.
      // Ignores Scrolling on Mobile, and will not close the list if accessing an item within the list


      function scrollDocument(e) {
        var focus = $('*:focus'); // dont close on timepicker arrow down and up

        if (self.touchPrevented || isDropdownElement($(e.target)) || focus.is('.timepicker')) {
          self.touchPrevented = false;
          return;
        }

        self.closeList('cancel');
      } // Triggered when the user clicks anywhere in the document
      // Will not close the list if the clicked target is anywhere inside the dropdown list.


      function clickDocument(e) {
        var target = $(e.target);

        if (self.touchPrevented || isDropdownElement(target) && !target.is('.icon')) {
          e.preventDefault();
          self.touchPrevented = false;
          return;
        }

        self.closeList('cancel');
      }

      function touchStartCallback(e) {
        self.touchPrevented = false;
        pos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };
        $(document).on('touchmove.dropdown', function (evt) {
          var newPos = {
            x: evt.originalEvent.touches[0].pageX,
            y: evt.originalEvent.touches[0].pageY
          };

          if (newPos.x >= pos.x + threshold || newPos.x <= pos.x - threshold || newPos.y >= pos.y + threshold || newPos.y <= pos.y - threshold) {
            self.touchPrevented = true;
          }
        });
      }

      function touchEndCallback(e) {
        //eslint-disable-line
        $(document).off('touchmove.dropdown');
        e.preventDefault();

        if (self.touchPrevented) {
          e.stopPropagation();
          return false;
        }

        clickDocument(e);
      } // Need to detect whether or not scrolling is happening on a touch-capable device
      // The dropdown list should not close on mobile if scrolling is occuring, but should close
      // if the user is simply tapping outside the list.


      $(document).on('touchstart.dropdown', touchStartCallback).on('touchend.dropdown touchcancel.dropdown', touchEndCallback).on('click.dropdown', clickDocument); // When the Dropdown is located within a scrollable section,
      // the dropdown must close if that section is scrolled.

      var parentScrollableArea = $('.modal.is-visible .modal-body-wrapper');
      var subScrollableSection = self.element.parents('.scrollable, .scrollable-x, .scrollable-y, .card-content');

      if (subScrollableSection.length) {
        parentScrollableArea = subScrollableSection;
      }

      if (parentScrollableArea.length) {
        this.parentScrollableArea = parentScrollableArea;
        this.parentScrollableArea.on('scroll.dropdown', scrollDocument);
      }

      $('body').on('resize.dropdown', function () {
        self.position(); // in desktop environments, close the list on viewport resize

        if (window.orientation === undefined) {
          self.closeList('cancel');
        }
      }); // In mobile environments, close the list on an orientation change.
      // Don't do this on mobile against a resize because of the software keyboard's potential
      // to cause a "resize" event to fire.

      if (window.orientation !== undefined) {
        $(window).on('orientationchange.dropdown', function () {
          self.closeList('cancel');
        });
      }
    },

    /**
     * Set size and positioning of the list
     * @private
     */
    position: function position() {
      var self = this;
      var positionOpts = {
        parentXAlignment: 'left',
        placement: 'bottom',
        strategies: ['flip', 'shrink-y']
      };

      function dropdownAfterPlaceCallback(e, placementObj) {
        // Turn upside-down if flipped to the top of the pseudoElem
        self.list[placementObj.wasFlipped === true ? 'addClass' : 'removeClass']('is-ontop');
        self.listUl[placementObj.wasFlipped === true ? 'prependTo' : 'appendTo'](self.list);
        var listStyle = window.getComputedStyle(self.list[0]);
        var listStyleTop = listStyle.top ? parseInt(listStyle.top, 10) : 0; // Firefox has different alignments without an adjustment:

        var browserOffset = 0;

        if (Environment.browser.name === 'firefox') {
          browserOffset = 4;
        } // Set the <UL> height to 100% of the `.dropdown-list` minus the size of the search input


        var ulHeight = parseInt(self.listUl[0].offsetHeight, 10);
        var listHeight = parseInt(self.list[0].offsetHeight, 10) + 5;
        var searchInputHeight = parseInt(self.searchInput[0].offsetHeight, 10);
        var isToBottom = parseInt(self.list[0].offsetTop, 10) + parseInt(self.list[0].offsetHeight, 10) >= window.innerHeight;
        var isSmaller = searchInputHeight < listHeight - searchInputHeight * 2 && ulHeight + searchInputHeight >= listHeight;
        var adjustedUlHeight;

        if (isSmaller) {
          adjustedUlHeight = "".concat(listHeight - searchInputHeight - 5, "px");

          if (isToBottom) {
            self.list[0].style.height = "".concat(parseInt(listHeight, 10) - 10, "px");
          }
        }

        if (placementObj.wasFlipped) {
          adjustedUlHeight = "".concat(listHeight - searchInputHeight - browserOffset - 5, "px");

          if (!self.isShortField) {
            self.list[0].style.top = "".concat(listStyleTop, "px");
          }
        }

        if (adjustedUlHeight) {
          self.listUl[0].style.height = adjustedUlHeight;
        }

        if (adjustedUlHeight === undefined && self.list[0].classList.contains('is-ontop')) {
          adjustedUlHeight = "".concat(listHeight - searchInputHeight - browserOffset - 7);
          self.list[0].style.top = "".concat(listStyleTop - adjustedUlHeight, "px");
        }

        return placementObj;
      } // Reset styles that may have been appended to the list


      this.list[0].removeAttribute('style');
      this.listUl[0].removeAttribute('style');
      var parentElement = this.pseudoElem;

      if (this.isInGrid) {
        parentElement = this.element.closest('.datagrid-cell-wrapper');
      } // If the list would end up being wider parent,
      // use the list's width instead of the parent's width


      var parentElementStyle = window.getComputedStyle(parentElement[0]);
      var parentElementBorderWidth = parseInt(parentElementStyle.borderLeftWidth, 10) * 2;
      var parentElementWidth = Math.round(parseInt(parentElement[0].clientWidth, 10) + parentElementBorderWidth); // Temporarily shrink the value of the search input, and compare the size of the list to
      // the parent element.

      this.searchInput[0].style.cssText = "width: ".concat(parentElementWidth, "px !important");
      var listDefaultWidth = Math.round(this.list.width());
      var useParentWidth = listDefaultWidth <= parentElementWidth;
      this.searchInput[0].style.width = ''; // Add parent info to positionOpts

      positionOpts.parent = parentElement;
      positionOpts.useParentWidth = useParentWidth; // Use negative height of the pseudoElem to get the Dropdown list to overlap the input.
      // This is used when rendering a tag list, or if the Dropdown is explicitly configured for placing the Search outside the pseudo-element.
      // Otherwise, always position below/above the field.

      if (!this.settings.showSearchUnderSelected) {
        var isRetina = window.devicePixelRatio > 1;
        var isChrome = Environment.browser.name === 'chrome';
        positionOpts.y = -(parseInt(parentElement[0].clientHeight, 10) + parseInt(parentElementStyle.borderTopWidth, 10) + parseInt(parentElementStyle.borderBottomWidth, 10) - (!isChrome && isRetina ? 1 : 0));
        positionOpts.x = 0;
      }

      if (self.settings.placementOpts && self.settings.placementOpts.x) {
        positionOpts.x = self.settings.placementOpts.x;
      }

      this.list.one('afterplace.dropdown', dropdownAfterPlaceCallback).place(positionOpts);
      this.list.data('place').place(positionOpts);
    },

    /**
     * @param {jQuery[]} target a jQuery-wrapped <option> or <li> tag representing an option.
     * @returns {boolean} whether or not the item was successfully selected.
     */
    selectListItem: function selectListItem(target) {
      var ddOption = target.closest('li');

      if (ddOption.length) {
        target = ddOption;
      }

      if (target.is('.separator, .group-label')) {
        return false;
      }

      if (target.is('.dropdown-select-all-anchor')) {
        target = target.parent();
      } // If this is the Select All option, select/deselect all.


      if (this.settings.multiple && target[0].classList.contains('dropdown-select-all-list-item')) {
        var doSelectAll = !target[0].classList.contains('is-selected');
        target[0].classList[doSelectAll ? 'add' : 'remove']('is-selected');

        if (doSelectAll) {
          target[0].setAttribute('aria-selected', 'true');
        } else {
          target[0].removeAttribute('aria-selected');
        }

        this.selectAll(doSelectAll);
        return true; //eslint-disable-line
      }

      var cur = this.correctValue(target);

      if (cur.is(':disabled')) {
        return false; //eslint-disable-line
      }

      this.selectOption(cur);

      if (this.settings.closeOnSelect) {
        this.closeList('select');
      }

      if (this.isMobile()) {
        return true; //eslint-disable-line
      }

      this.activate(!this.settings.closeOnSelect); // Check/uncheck select all depending on no. of selected items

      if (this.settings.showSelectAll && this.list) {
        var opts = this.element.find('option');
        var selectedOpts = opts.filter(':selected');

        if (opts.length > selectedOpts.length) {
          this.list.find('.dropdown-select-all-list-item').removeClass('is-selected').removeAttr('aria-selected');
        } else {
          this.list.find('.dropdown-select-all-list-item').addClass('is-selected').attr('aria-selected', 'true');
        }
      }

      return true; //eslint-disable-line
    },

    /**
     * Try matching the option's text if 'cur' comes back empty or overpopulated.
     * Supports options that don't have a 'value' attribute, And also some special &quote handling.
     * @private
     * @param  {object} option The object to correct.
     * @returns {object} The corrected object
     */
    correctValue: function correctValue(option) {
      var val = option.attr('data-val').replace(/"/g, '/quot/');
      var cur = this.element.find("option[value=\"".concat(val, "\"]"));

      if (cur.length === 0 || cur.length > 1) {
        cur = this.element.find('option').filter(function () {
          var elem = $(this);
          var attr = elem.attr('value');
          return elem.text() === val || attr && attr.replace(/"/g, '/quot/') === val;
        });
      }

      return cur;
    },

    /**
    * Close the list of options if open.
    * @returns {void}
    */
    close: function close() {
      return this.closeList('cancel'); // See "js/lifecycle.js"
    },

    /**
     * Close the list of options if open.
     * @private
     * @param  {string} [action] The action that trigger the closing (cancel fx) this
     * is passed to the events.
     * @returns {void}
     */
    closeList: function closeList(action) {
      //  Also see "js/lifecycle.js" alias that works with the global "closeChildren" method.
      if (!this.list || !this.list.is(':visible') || !this.isListClosable()) {
        return;
      }

      if (!this.inputTimer()) {
        return;
      }

      if (this.touchmove) {
        this.touchmove = false;
      } // Rendering-related resets


      this.filterTerm = '';
      this.searchKeyMode = false;
      this.setDisplayedValues();
      delete this.filteredItems; // Scroll TagList to the top

      if (this.tagListAPI) {
        this.scrollTagList();
      }

      this.searchInput.off(["input.".concat(COMPONENT_NAME$v), "keydown.".concat(COMPONENT_NAME$v)].join(' '));
      this.list.off(["click.".concat(COMPONENT_NAME$v), "touchmove.".concat(COMPONENT_NAME$v), "touchend.".concat(COMPONENT_NAME$v), "touchcancel.".concat(COMPONENT_NAME$v), "mousewheel.".concat(COMPONENT_NAME$v), "mouseenter.".concat(COMPONENT_NAME$v)].join(' ')).remove();
      this.pseudoElem.removeClass('is-open').removeAttr('aria-expanded');
      this.searchInput.removeAttr('aria-activedescendant');
      $(document).off(["click.".concat(COMPONENT_NAME$v), "scroll.".concat(COMPONENT_NAME$v), "touchstart.".concat(COMPONENT_NAME$v), "touchmove.".concat(COMPONENT_NAME$v), "touchend.".concat(COMPONENT_NAME$v), "touchcancel.".concat(COMPONENT_NAME$v)].join(' '));

      if (this.parentScrollableArea) {
        this.parentScrollableArea.off('scroll.dropdown');
        delete this.parentScrollableArea;
      }

      $('body').off('resize.dropdown');
      $(window).off('orientationchange.dropdown');
      /**
      * Fires as the dropdown list is closed
      *
      * @event listclosed
      * @memberof Dropdown
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */

      this.element.trigger('listclosed', action);
      this.activate();
      this.toggleTooltip();
      this.list = null;
      this.searchInput = null;
      this.listUl = null;
    },

    /**
    * Scroll to a particular option and make it in view.
    * @private
    * @param  {object} current The option element to scroll to.
    * @returns {void}
    */
    scrollToOption: function scrollToOption(current) {
      var self = this;

      if (!current) {
        return;
      }

      if (current.length === 0) {
        return;
      } // scroll to the currently selected option


      self.listUl.scrollTop(0);
      self.listUl.scrollTop(current.offset().top - self.listUl.offset().top - self.listUl.scrollTop() - 40);
    },

    /**
     * Scrolls an overflowed Tag List
     * @private
     * @returns {void}
     */
    scrollTagList: function scrollTagList() {
      var _this5 = this;

      if (!this.tagListAPI) {
        return;
      }

      setTimeout(function () {
        if (!_this5.isFocused) {
          _this5.tagListAPI.element.scrollTop = 0;
        }
      }, 5);
    },

    /**
    * Blur and Close List
    * @private
    * @returns {void}
    */
    handleBlur: function handleBlur() {
      var self = this;
      self.closeList('cancel');
      return true;
    },

    /**
     * Function that is used to check if the field is loading from an ajax call.
     * @returns {void} Returns true if the field is attempting to load via AJAX.
     */
    isLoading: function isLoading() {
      return this.element.is('.is-loading') && this.element.is('.is-blocked');
    },

    /**
     * Return true/false depending on if the list is open.
     * @returns {boolean} The current state (open = true).
     */
    isOpen: function isOpen() {
      return !!this.pseudoElem.hasClass('is-open');
    },

    /**
     * Toggle the current state of the list between open and closed.
     * @private
     */
    toggle: function toggle() {
      if (this.isOpen() || this.isLoading()) {
        this.closeList('cancel');
        return;
      }

      this.open();
    },

    /**
     * Toggle the current state of the list between open and closed.
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @deprecated as of v4.4.0.  Please use `toggle()` instead.
     * @private
     * @returns {void}
     */
    toggleList: function toggleList() {
      return deprecateMethod(this.toggle, this.toggleList).apply(this);
    },

    /**
     * Highlights a Dropdown list option if it's present inside the list.
     * @private
     * @param {object} listOption The option element
     * @param {boolean} noScroll If true will scroll to the option
     * @returns {void}
     */
    highlightOption: function highlightOption(listOption, noScroll) {
      if (!this.isOpen()) {
        return;
      }

      if (!listOption) {
        return;
      }

      if (listOption.length === 0) {
        listOption = this.list.find('.dropdown-option').eq(0);
      }

      if (listOption.is('.separator, .group-label')) {
        return;
      } // Get the corresponding option from the list,
      // or use an `<option>` element directly.


      var option;

      if (listOption.is('option')) {
        option = listOption;
        listOption = this.listUl.find("li[data-val=\"".concat(option.val(), "\"]"));
      } else {
        option = this.element.find('option').filter(function (i, item) {
          return item.value === listOption.attr('data-val');
        });
      } // Unset previous highlight


      this.setItemIconOverColor();
      this.list.find('.is-focused').removeClass('is-focused').attr({
        tabindex: '-1'
      }); // Don't continue if a match hasn't been found, or the match is disabled.

      if (!listOption.length || !option.length || option.hasClass('.is-disabled') || option.is(':disabled')) {
        return;
      } // Set activedescendent for new option


      this.searchInput.attr('aria-activedescendant', listOption.children('a').attr('id'));
      var isEmpty = option.val() === '' || listOption.attr('data-val') === '' || option.hasClass('clear');

      if (!isEmpty) {
        this.setItemIconOverColor(listOption);
        listOption.addClass('is-focused').attr({
          tabindex: '0'
        });

        if (!noScroll || noScroll === false || noScroll === undefined) {
          this.scrollToOption(listOption);
        }
      }
    },

    /**
     * Un Highlight the option that is being typed.
     * @private
     * @param  {object} listOptions The option element
     * @param  {boolean} noScroll If true will scroll to the option
     */
    unhighlightOptions: function unhighlightOptions(listOptions, noScroll) {
      if (!listOptions || !listOptions.length) {
        listOptions = this.list.find('.is-selected');
      }

      this.setItemIconOverColor();
      listOptions.removeClass('is-focused').attr({
        tabindex: '-1'
      });
      this.searchInput.removeAttr('aria-activedescendant');

      if (!noScroll || noScroll === false || noScroll === undefined) {
        this.scrollToOption(listOptions.first());
      }
    },

    /**
     * Renders a Dropdown/Multiselect item based on its corresponding <option> element's state
     * @private
     * @param {HTMLOptionElement} optionEl the option element
     * @returns {void}
     */
    renderListItem: function renderListItem(optionEl) {
      var optionVal = optionEl.value;
      var selected = optionEl.selected;
      var li = this.listUl.find("li[data-val=\"".concat(optionVal, "\"]"));

      if (selected) {
        li[0].classList.add('is-selected');
        li[0].setAttribute('aria-selected', true);
        return;
      }

      li[0].classList.remove('is-selected');
      li[0].removeAttribute('aria-selected');
    },

    /**
     * Toggle all selection for items.
     * @private
     * @param {boolean} doSelectAll true to select and false will clear selection for all items.
     * @returns {void}
     */
    selectAll: function selectAll(doSelectAll) {
      var _this6 = this;

      var selector = {
        options: 'option:not(.is-disabled):not(:disabled)',
        items: 'li.dropdown-option:not(.separator):not(.group-label):not(.is-disabled)'
      };
      var options = utils.getArrayFromList(this.element[0].querySelectorAll(selector.options));
      var items = utils.getArrayFromList(this.listUl[0].querySelectorAll(selector.items));
      var last = options[options.length - 1]; // If the Multiselect should only select from filtered items,
      // filter the full result sets down to the ones that aren't hidden.

      if (this.settings.selectAllFilterOnly && this.filteredItems) {
        options = [];
        items = $.makeArray(this.filteredItems);
        items.forEach(function (item) {
          var val = item.getAttribute('data-val');

          if (!val) {
            return;
          }

          var opt = _this6.element[0].querySelector("option[value=\"".concat(val, "\"]"));

          if (opt) {
            options.push(opt);
          }
        });
      }

      if (doSelectAll) {
        // Select all
        items.forEach(function (node) {
          node.classList.add('is-selected');
          node.setAttribute('aria-selected', true);
        });
        options.forEach(function (node) {
          node.selected = true;
          node.setAttribute('selected', true);
        });
      } else {
        // Clear all
        items.forEach(function (node) {
          node.classList.remove('is-selected');
          node.removeAttribute('aria-selected');
        });
        options.forEach(function (node) {
          // Fix for ie-edge
          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/
          node.selected = false;
          node.setAttribute('selected', false);
          node.removeAttribute('selected');
        });
      }

      this.previousActiveDescendant = last.value || '';
      this.setDisplayedValues();
      this.updateItemIcon(last);

      if (!this.settings.selectAllFilterOnly && this.list[0].classList.contains('search-mode')) {
        this.resetList();
      }

      this.activate(true);
      this.setBadge(last);
      this.toggleTooltip();
      this.element.trigger('change').triggerHandler('selected');
    },

    /**
     * Convenience method for running _selectOption()_ on a set of list options.
     * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
     * @private
     * @param {object} options incoming options
     * @param {boolean} noTrigger if true, causes the 'selected' and 'change' events
     * not to fire on each list item.
     */
    selectOptions: function selectOptions(options, noTrigger) {
      // Use a jQuery selector if the incoming options are inside an array
      if (Array.isArray(options)) {
        options = $(options);
      }

      var self = this;
      options.each(function () {
        self.selectOption($(this), noTrigger);
      });
      self.element.trigger('change').triggerHandler('selected');
    },

    /**
     * Select an option and conditionally trigger events.
     * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
     * @private
     * @param {object} option - the incoming li option
     * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to
     * @returns {void}
     * fire on the list item.
     */
    selectOption: function selectOption(option, noTrigger) {
      if (!option || !option.length) {
        return;
      }

      var li; // Discovers a `<option>` incoming item from its corresponding Dropdown List item's `data-val` attribute.

      if (option.is('li')) {
        li = option;
        option = this.element.find("option[value=\"".concat(option.attr('data-val'), "\"]")); // Try matching the option's text if 'cur' comes back empty.
        // Supports options that don't have a 'value' attribute.

        if (option.length === 0) {
          option = this.element.find('option').filter(function () {
            return $(this).text() === li.attr('data-val');
          });
        }

        if (option.prop('disabled')) {
          return;
        }
      }

      var optionVal = option.val();

      if (typeof option === 'string') {
        li = this.listUl.find("li[data-val=\"".concat(option, "\"]"));
        optionVal = option;
        option = this.element.find("option[value=\"".concat(optionVal, "\"]"));
      } else if (typeof optionVal === 'string') {
        optionVal = optionVal.replace(/"/g, '/quot/');
        li = this.listUl.find("li[data-val=\"".concat(optionVal, "\"]"));
      }

      var isAdded = true;
      var currentValue = this.selectedValues;
      var clearSelection = false;

      if (option.hasClass('clear') || !li) {
        clearSelection = true;
      } // If in single-select mode, or forcing a clear, unset all selections.


      if (clearSelection) {
        this.deselectAll();
      } // In a multi-select setting, it's possible for deselection to happen instead of selection.


      if (this.settings.multiple) {
        if (!Array.isArray(currentValue)) {
          currentValue = [currentValue];
        }

        if (currentValue.indexOf(optionVal) > -1) {
          isAdded = false;
        }
      }

      if (isAdded) {
        this.select(option[0]);
        this.previousActiveDescendant = optionVal;
      } else {
        this.deselect(option[0]);
        this.previousActiveDescendant = undefined;
      }

      var listScrollTop = this.listUl[0].scrollTop;

      if (listScrollTop > 0) {
        this.currentlyScrolledPos = listScrollTop;
      }

      this.renderListItem(option[0]);
      this.setDisplayedValues();
      this.updateItemIcon(option);
      /**
      * Fires after the value in the input is changed by any means.
      * @event change
      * @memberof Dropdown
      * @property {object} event The jquery event object
      */

      if (!noTrigger) {
        // Fire the change event with the new value if the noTrigger flag isn't set
        this.element.trigger('change').triggerHandler('selected', [option, isAdded]);
        this.toggleTooltip();
      } // If multiselect, reset the menu to the unfiltered mode


      if (this.settings.multiple) {
        this.activate(true);
      }

      this.setBadge(option);
      var id = this.element.attr('id');

      if (Environment.browser.isIE11() && id) {
        var ieHtml = $("#".concat(id)).html();
        var ieVal = $("#".concat(id)).val();

        if (ieHtml) {
          this.element.html(ieHtml);
        }

        if (ieVal) {
          this.element.val(ieVal);
        }
      }
    },

    /**
     * Selects an option element directly.
     * @param {HTMLOptionElement} optionEl the option to be deselected
     * @returns {void}
     */
    select: function select(optionEl) {
      if (!optionEl || !(optionEl instanceof HTMLOptionElement)) {
        return;
      } // If this is a multselect, never allow more items to be selected than
      // defined by settings.


      if (this.settings.multiple) {
        if (this.selectedValues.length >= this.settings.maxSelected) {
          return;
        }
      }

      optionEl.selected = true;
    },

    /**
     * Select an option by its value.
     * @param {string} value - A string containing the value to look for. (Case insensitive)
     * @returns {void}
     */
    selectValue: function selectValue(value) {
      if (typeof value !== 'string') {
        return;
      }

      var option = this.element.find("option[value=\"".concat(value, "\"]"));

      if (!option || !option.length) {
        return;
      }

      this.select(option[0]);
      this.updated();
    },

    /**
     * Deselects an option element directly.
     * @param {HTMLOptionElement} optionEl the option to be deselected
     * @returns {void}
     */
    deselect: function deselect(optionEl) {
      if (!optionEl || !(optionEl instanceof HTMLOptionElement)) {
        return;
      }

      optionEl.selected = false;
    },

    /**
     * Deselect an option by its value.
     * @param {string} value - A string containing the value to look for. (Case insensitive)
     * @returns {void}
     */
    deselectValue: function deselectValue(value) {
      if (typeof value !== 'string') {
        return;
      }

      var option = this.element.find("option[value=\"".concat(value, "\"]"));

      if (!option || !option.length) {
        return;
      }

      this.deselect(option[0]);
      this.updated();
    },

    /**
     * Deselects all <select> options.
     * @returns {void}
     */
    deselectAll: function deselectAll() {
      var _this7 = this;

      var allOptions = this.element.find('option');
      allOptions.each(function (i, option) {
        $(option).prop('selected', false);

        _this7.deselectValue(option);
      });
    },

    /**
     * Finds the first HTMLOptionElement inside the select that matches a given search term
     * @param {string} char a single character or filter term that will be matched.
     * @returns {HTMLOptionElement|undefined} representing the first option that matches the filter term. Returns nothing if there's no match.
     */
    firstOptionStartingWith: function firstOptionStartingWith(char) {
      if (typeof char !== 'string') {
        return;
      }

      var elem = this.element[0];
      var newIdx = -1;
      var totalMatches = 0; // Log search matches

      if (!this.searchMatches || !this.searchMatches[char]) {
        this.searchMatches = {};
        this.searchMatches[char] = [];
      }

      for (var i = 0; i < elem.options.length; i++) {
        var option = elem.options[i]; // Check if its a match (Case insensitive)

        var isMatch = option.innerText.toLowerCase().indexOf(char) === 0;

        if (isMatch) {
          if (this.searchMatches[char].indexOf(i) === -1) {
            this.searchMatches[char].push(i);
            newIdx = i;
            break;
          }

          totalMatches++;
          continue;
        }
      }

      if (newIdx === -1) {
        if (!this.searchMatches[char].length) {
          return;
        }

        if (totalMatches === this.searchMatches[char].length) {
          newIdx = this.searchMatches[char][0];
          this.searchMatches[char].length = 1; // reset
        }
      }

      return elem.options[newIdx];
    },

    /**
     * Select the next item that starts with a given string (text of the option).
     * @param {string} char - The starting letter to match for. (Case insensitive)
     * @returns {void}
     */
    selectStartsWith: function selectStartsWith(char) {
      this.filterTerm = '';
      var newOption = this.firstOptionStartingWith(char);
      this.select(newOption);
      this.updated();
      this.element.trigger('change');
    },

    /**
     * Highlights the next item that starts with a given string (text of the option).
     * @param {string} char - The starting letter to match for. (Case insensitive)
     * @returns {void}
     */
    highlightStartsWith: function highlightStartsWith(char) {
      if (!this.isOpen()) {
        return;
      }

      var newOption = this.firstOptionStartingWith(char);
      this.highlightOption($(newOption));
    },

    /**
     * Set the bade on the option from the config.
     * @private
     * @param {string} option - A string containing the value to look for. (Case insensitive)
     */
    setBadge: function setBadge(option) {
      // Badge Support
      if (this.badges) {
        var badge = this.element.parent().find('.badge');

        if (badge.length === 0) {
          this.element.parent().find('.dropdown-wrapper').append('<span class="badge">1</span>');
          badge = this.element.parent().find('.badge');
        }

        badge.attr('class', "badge ".concat(option.attr('data-badge-color') ? option.attr('data-badge-color') : 'azure07')).text(option.attr('data-badge'));
      }
    },

    /**
     * Execute the source ajax option
     * @private
     * @param {function} callback  The function call back.
     * @param {boolean} doReset  if defined, acts as a "reset" source call, where the search term will be ignored.
     * @returns {function} The callback for execution.
     */
    callSource: function callSource(callback, doReset) {
      var self = this;
      var searchTerm = '';

      if (!doReset && this.isOpen() && !this.element.hasClass('search-mode')) {
        searchTerm = this.searchInput.val();
      } // Return false and let the normal display codepath run.


      if (!this.settings.source) {
        return false;
      }

      this.isFiltering = false;

      var sourceType = _typeof(this.settings.source);

      var response = function response(data, isManagedByTemplate) {
        // to do - no results back do not open.
        var list = '';
        var val = self.element.val();

        function replaceDoubleQuotes(content) {
          return content.replace(/"/g, '\'');
        }

        function buildOption(option) {
          if (option === null || option === undefined) {
            return;
          }

          var isString = typeof option === 'string';
          var stringContent = option;
          var id = '';
          var selected = '';
          var textContent = '';

          if (isString) {
            option = {
              value: stringContent
            };
          }

          if (option.value !== undefined) {
            option.value = replaceDoubleQuotes(option.value);
          }

          if (option.id !== undefined) {
            if (!isNaN(option.id)) {
              //eslint-disable-line
              option.id = "".concat(option.id);
            }

            option.id = replaceDoubleQuotes(option.id);
            id = " id=\"".concat(option.id, "\"");
          }

          if (option.label !== undefined && option.label.length) {
            option.label = replaceDoubleQuotes(option.label);
            textContent = option.label;
          } // Detect whether or not the `<option>` should be selected


          var selectedValues = self.selectedValues;
          var hasSelectedValues = selectedValues.indexOf(val) > -1;

          if (self.settings.multiple) {
            val.forEach(function (value) {
              if (value === option.value) {
                option.selected = true;
              }
            });
          } else if (option.value === val || hasSelectedValues) {
            option.selected = true;
          }

          if (option.selected) {
            selected = ' selected';
          } // Make sure that text content is populated.
          // If all else fails, just use the value.


          if (!textContent.length && textContent !== option.value) {
            textContent += option.value;
          } // Render the option element


          list += "<option".concat(id, " value=\"").concat(option.value, "\"").concat(selected, ">\n          ").concat(textContent, "\n        </option>");
        } // If the incoming dataset is different than the one we started with,
        // replace the contents of the list, and rerender it.


        if (!self.isFiltering && !utils.equals(data, self.dataset)) {
          self.dataset = data;

          if (!isManagedByTemplate) {
            self.element.empty();

            for (var i = 0; i < data.length; i++) {
              var opts = void 0;

              if (data[i].group) {
                opts = data[i].options;
                list += "<optgroup label=\"".concat(data[i].group, "\">");

                for (var ii = 0; ii < opts.length; ii++) {
                  buildOption(opts[ii]);
                }

                list += '</optgroup>';
              } else {
                buildOption(data[i]);
              }
            }

            self.element.append(list);
          }
        }

        self.element.triggerHandler('complete'); // For Busy Indicator

        self.element.trigger('requestend', [searchTerm, data]);

        if (typeof callback !== 'function') {
          self.updateList(searchTerm);
          return;
        }

        callback();
      };

      self.element.triggerHandler('start'); // For Busy Indicator

      self.element.trigger('requeststart');

      if (sourceType === 'function') {
        // Call the 'source' setting as a function with the done callback.
        this.settings.source(response, searchTerm, this.settings.sourceArguments);
      } else if (sourceType === 'object') {
        // Use the 'source' setting as pre-existing data.
        // Sanitize accordingly.
        var sourceData = $.isArray(this.settings.source) ? this.settings.source : [this.settings.source];
        response(sourceData);
      } else {
        // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
        var sourceURL = this.settings.source.toString();
        var request = $.getJSON(sourceURL);
        request.done(function (data) {
          response(data);
        }).fail(function () {
          response([]);
        });
      }

      return true;
    },

    /**
     * Get data attributes from passed list of attributes
     * @private
     * @param {array} attr - List of all attributes.
     * @param {array} attrToExclude - List of attributes to be excluded from passed list.
     * @returns {object} It will return an object containing two keys
     * str - string of attributes
     * obj - object of attributes
     */
    getDataAttributes: function getDataAttributes(attr, attrToExclude) {
      if (!attr) {
        return;
      }

      if (typeof attr === 'string') {
        attr = [attr];
      }

      var toExclude = attrToExclude || [];

      if (typeof toExclude === 'string') {
        toExclude = [toExclude];
      }

      var attrToCopy = {
        obj: {},
        str: '',
        isExclude: function isExclude(attrib) {
          return $.inArray(attrib, toExclude) > -1;
        }
      };

      for (var key in attr) {
        //eslint-disable-line
        if (!attr.hasOwnProperty(key)) {
          //eslint-disable-line
          continue; //eslint-disable-line
        }

        attrToCopy.name = "".concat(attr[key].name);
        attrToCopy.isData = attrToCopy.name.substr(0, 5) === 'data-';

        if (attrToCopy.isData && !attrToCopy.isExclude(attrToCopy.name)) {
          attrToCopy.obj[attrToCopy.name] = attr[key].value;
          attrToCopy.str += " ".concat(attrToCopy.name, "=\"").concat(attr[key].value, "\"");
        }
      }

      return {
        str: attrToCopy.str,
        obj: attrToCopy.obj
      }; //eslint-disable-line
    },

    /**
     * Public API for setting the `<select>`'s value.
     * @private
     * @param {string} code - The value to match and set on the value element.
     */
    setCode: function setCode(code) {
      var self = this;

      var doSetting = function doSetting() {
        self.element.val(code);
        self.updated();
      };

      if (!self.callSource(doSetting)) {
        doSetting();
      }
    },

    /**
     * Returns true if the object is a mobile element.
     * @private
     * @returns {boolean} code - True if this is a mobile device
     */
    isMobile: function isMobile() {
      return ['ios', 'android'].indexOf(Environment.os.name) > -1;
    },

    /**
     * Returns true if the element already has the closable class.
     * @private
     * @returns {object} The list
     */
    isListClosable: function isListClosable() {
      return this.list.hasClass('is-closable');
    },

    /**
     * Gets a data-representation of the currently-selected Multiselect items in a format
     * compatible with the TagList component.
     * @returns {array} containing JSON-compatible data representing a collection of tags
     */
    toTagData: function toTagData() {
      var tagData = [];
      var componentID = this.element[0].id;

      if (!componentID) {
        componentID = utils.uniqueId(this.element[0], this.element[0].className);
      }

      this.selectedOptions.forEach(function (opt) {
        tagData.push({
          content: opt.innerText.trim(),
          dismissible: true,
          href: '#',
          id: "".concat(componentID, "-tag-").concat(opt.value),
          style: 'secondary',
          value: opt.value
        });
      });
      return tagData;
    },

    /**
     * Disable the input element.
     */
    disable: function disable() {
      this.element.prop('disabled', true).prop('readonly', false);
      this.pseudoElem.addClass('is-disabled');

      if (this.pseudoElem.is($(document.activeElement))) {
        this.pseudoElem.blur();
      }

      this.pseudoElem.addClass('is-disabled').removeClass('is-readonly').attr('tabindex', '-1').prop('readonly', false).prop('disabled', true);
      this.closeList('cancel');

      if (this.settings.showTags) {
        this.pseudoElem.find('.tag').addClass('is-disabled');
      }
    },

    /**
    * Returns true if the dropdown is disabled.
    * @returns {boolean} True if the element is disabled.
    */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Enable the input element.
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.pseudoElem.prop('disabled', false).prop('readonly', false).attr('tabindex', '0').removeClass('is-disabled').removeClass('is-readonly');

      if (this.settings.showTags) {
        this.pseudoElem.find('.tag').removeClass('is-disabled');
      }
    },

    /**
     * Make the input element readonly.
     */
    readonly: function readonly() {
      this.element.prop('disabled', false).prop('readonly', true);
      this.pseudoElem.removeClass('is-disabled').addClass('is-readonly').attr('tabindex', this.element.attr('tabindex') || '0').prop('disabled', false).prop('readonly', true);
      this.closeList('cancel');
    },

    /**
     * Tear down events and restore to original state.
     * @param  {object} settings The settings object to use.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.closeList('cancel');

      if (this.pseudoElem && this.pseudoElem.hasClass('is-open')) {
        this.pseudoElem.removeClass('is-open').removeAttr('aria-expanded');
      } // Update the 'multiple' property


      if (this.settings.multiple && this.settings.multiple === true) {
        this.element.prop('multiple', true);
      } else {
        this.element.prop('multiple', false);
      } // update "readonly" prop


      if (this.element.prop('readonly') === true) {
        this.readonly();
      } else {
        this.pseudoElem.removeClass('is-readonly');
      } // update "disabled" prop


      this.pseudoElem[this.element.prop('disabled') ? 'addClass' : 'removeClass']('is-disabled'); // update the list and set a new value, if applicable

      this.updateList();
      this.setDisplayedValues();
      this.toggleTooltip();
      this.element.trigger('has-updated');
      return this;
    },

    /**
     * Tear down events and restore to original state.
     */
    destroy: function destroy() {
      if (this.placeholder) {
        delete this.placeholder;
      }

      if (this.currentlyScrolledPos) {
        delete this.currentlyScrolledPos;
      }

      $.removeData(this.element[0], COMPONENT_NAME$v);
      this.closeList('cancel');
      this.pseudoElem.off().remove();
      this.icon.remove();
      this.wrapper.remove();
      this.listfilter.destroy();
      this.element.removeAttr('style');
      this.element.closest('form').off('reset.dropdown');
      this.element.off();
      this.label.off();
      var list = document.body.querySelector('#dropdown-list');

      if (list && this.isOpen()) {
        list.parentNode.removeChild(list);
      }
    },

    /**
     * Setup the internal event handlers.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this8 = this;

      var self = this;

      function isTagEl(e) {
        // If the element clicked is a tag, ignore and let the tag handle it.
        var containedByTag = $(e.target).parents('.tag').length > 0;
        var isTag = false;

        if (e.target instanceof HTMLElement && typeof e.target.className === 'string') {
          isTag = e.target.classList.contains('tag');
        }

        if (isTag || containedByTag) {
          return true;
        }

        return false;
      }

      var isTag = false;
      this.pseudoElem.on('keydown.dropdown', function (e) {
        return _this8.handlePseudoElemKeydown(e);
      }).on('click.dropdown touchstart.dropdown', function (e) {
        // Would like the click event to bubble up if ctrl and shift are pressed
        if (!(e.originalEvent.ctrlKey && e.originalEvent.shiftKey)) {
          e.stopPropagation();
        }

        if (isTag) {
          return;
        }

        self.toggle();
      }).on('mouseup.dropdown touchend.dropdown', function (e) {
        if (e.button === 2) {
          e.stopPropagation();
          return;
        }
      }).on('mousedown.dropdown touchstart.dropdown', function (e) {
        isTag = isTagEl(e);
      }).on('touchcancel.dropdown', function (e) {
        if (isTagEl(e)) {
          return;
        }

        e.stopPropagation();
        self.toggle();
        e.preventDefault();
      }); // If the Dropdown/Multiselect loses focus while tags are showing,
      // the tag list will scroll itself to the top.

      if (this.tagListAPI) {
        this.pseudoElem.on('focusout.dropdown', function () {
          _this8.scrollTagList();
        });
      }

      self.element.on('activated.dropdown', function () {
        self.label.trigger('click');
      }).on('updated.dropdown', function (e) {
        e.stopPropagation();
        self.updated();
      }).on('openlist.dropdown', function () {
        self.toggle();
      }); // for form resets.

      self.element.closest('form').on('reset.dropdown', function () {
        setTimeout(function () {
          self.element.triggerHandler('updated');
        }, 1);
      }); // Handle Label click

      this.label.on('click', function () {
        self.pseudoElem.focus();
      });
    }
  };

  /**
   * jQuery Component Wrapper for the Dropdown
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.dropdown = function (settings) {
    // Keep the Chaining and Init the Controls or Settings
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$v);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$v, new Dropdown(this, settings));
      }
    });
  };

  var COMPONENT_NAME$w = 'colorpicker';
  /**
   * The ColorPicker Component is a trigger field with a listing colors that can be selected.
   * @class ColorPicker
   * @param {jQuery[]|HTMLElement} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {object} [settings.themes={}] Themes available for ColorPicker
   * @param {array} [settings.colors=[]] An array of objects of the form. {label: 'Azure', number: '01', value: 'CBEBF4'}
   * that can be used to populate the color grid.
   * @param {boolean} [settings.showLabel=false]  Show the label if true vs the hex value if false.
   * @param {boolean} [settings.editable=true]  If false, the field is readonly and transparent. I.E. The value
   * cannot be typed only editable by selecting.
   * @param {boolean} [settings.uppercase=true] If false, lower case hex is allowed. If true upper case hex is allowed.
   * If showLabel is true this setting is ignored.
   * @param {boolean} [settings.colorOnly=false] If true the field will be shrunk to only show the color portion.
   * @param {boolean} [settings.clearable=true] If true will add clearable option.
   * @param {string} [settings.clearableText] The text to show in tooltip.
   * @param {object} [settings.popupmenuSettings] optional Popupmenu settings that will supersede the defaults.
   * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  var COLORPICKER_DEFAULTS = {
    // Theme key: MUST match with theme file name (ie: [filename: 'light-theme.css' -> 'light-theme'])
    // BORDERS
    // Use (,) commas to separate themes or single entry for border as:
    // colors[{label: 'Slate', number: '01', value: 'F0F0F0',
    // border: 'light-theme, contrast-theme'}]
    // and assign which swatch theborder should apply ['all' or 'matched-only']
    // themes: { 'contrast-theme': {'border': 'all'} }
    // CHECKMARKS
    // checkmark: {'one': [1, 2], 'two': [3, 10]}
    // will add class as "checkmark-{key}", where current colors number is in range
    // [{value[0]} to {value[1]}]
    // will add class "checkmark-one", where current colors number is in range [1 to 3]
    // and will add class "checkmark-two", where current colors number is in range [3 to 10]
    themes: {
      light: {
        border: 'matched-only',
        checkmark: {
          one: [1, 2],
          two: [3, 10]
        }
      },
      dark: {
        border: 'matched-only',
        checkmark: {
          one: [1, 2],
          two: [3, 10]
        }
      },
      contrast: {
        border: 'all',
        checkmark: {
          one: [1, 3],
          two: [4, 10]
        }
      }
    },
    customColors: false,
    colors: [{
      label: 'Slate',
      number: '10',
      value: '1a1a1a'
    }, {
      label: 'Slate',
      number: '09',
      value: '292929'
    }, {
      label: 'Slate',
      number: '08',
      value: '383838',
      border: 'dark'
    }, {
      label: 'Slate',
      number: '07',
      value: '454545',
      border: 'dark'
    }, {
      label: 'Slate',
      number: '06',
      value: '5C5C5C'
    }, {
      label: 'Slate',
      number: '05',
      value: '737373'
    }, {
      label: 'Slate',
      number: '04',
      value: '999999'
    }, {
      label: 'Slate',
      number: '03',
      value: 'BDBDBD'
    }, {
      label: 'Slate',
      number: '02',
      value: 'D8D8D8'
    }, {
      label: 'Slate',
      number: '01',
      value: 'F0F0F0',
      border: 'light, contrast'
    }, {
      label: 'Amber',
      number: '10',
      value: 'D66221'
    }, {
      label: 'Amber',
      number: '09',
      value: 'DE7223'
    }, {
      label: 'Amber',
      number: '08',
      value: 'E68425'
    }, {
      label: 'Amber',
      number: '07',
      value: 'EB9728'
    }, {
      label: 'Amber',
      number: '06',
      value: 'EFAA30'
    }, {
      label: 'Amber',
      number: '05',
      value: 'F2BC41'
    }, {
      label: 'Amber',
      number: '04',
      value: 'F4C951'
    }, {
      label: 'Amber',
      number: '03',
      value: 'F7D475'
    }, {
      label: 'Amber',
      number: '02',
      value: 'F8E09C'
    }, {
      label: 'Amber',
      number: '01',
      value: 'FBE9BF'
    }, {
      label: 'Ruby',
      number: '10',
      value: '880E0E'
    }, {
      label: 'Ruby',
      number: '09',
      value: '941E1E'
    }, {
      label: 'Ruby',
      number: '08',
      value: 'A13030'
    }, {
      label: 'Ruby',
      number: '07',
      value: 'AD4242'
    }, {
      label: 'Ruby',
      number: '06',
      value: 'B94E4E'
    }, {
      label: 'Ruby',
      number: '05',
      value: 'C65F5F'
    }, {
      label: 'Ruby',
      number: '04',
      value: 'D26D6D'
    }, {
      label: 'Ruby',
      number: '03',
      value: 'DE8181'
    }, {
      label: 'Ruby',
      number: '02',
      value: 'EB9D9D'
    }, {
      label: 'Ruby',
      number: '01',
      value: 'F4BCBC'
    }, {
      label: 'Turquoise',
      number: '10',
      value: '0E5B52'
    }, {
      label: 'Turquoise',
      number: '09',
      value: '206B62'
    }, {
      label: 'Turquoise',
      number: '08',
      value: '317C73'
    }, {
      label: 'Turquoise',
      number: '07',
      value: '448D83'
    }, {
      label: 'Turquoise',
      number: '06',
      value: '579E95'
    }, {
      label: 'Turquoise',
      number: '05',
      value: '69ADA3'
    }, {
      label: 'Turquoise',
      number: '04',
      value: '7BBFB5'
    }, {
      label: 'Turquoise',
      number: '03',
      value: '8ED1C6'
    }, {
      label: 'Turquoise',
      number: '02',
      value: 'A9E1D6'
    }, {
      label: 'Turquoise',
      number: '01',
      value: 'C0EDE3'
    }, {
      label: 'Emerald',
      number: '10',
      value: '397514'
    }, {
      label: 'Emerald',
      number: '09',
      value: '44831F'
    }, {
      label: 'Emerald',
      number: '08',
      value: '56932E'
    }, {
      label: 'Emerald',
      number: '07',
      value: '66A140'
    }, {
      label: 'Emerald',
      number: '06',
      value: '76B051'
    }, {
      label: 'Emerald',
      number: '05',
      value: '89BF65'
    }, {
      label: 'Emerald',
      number: '04',
      value: '9CCE7C'
    }, {
      label: 'Emerald',
      number: '03',
      value: 'AFDC91'
    }, {
      label: 'Emerald',
      number: '02',
      value: 'C3E8AC'
    }, {
      label: 'Emerald',
      number: '01',
      value: 'D5F6C0'
    }, {
      label: 'Amethyst',
      number: '10',
      value: '4B2A5E'
    }, {
      label: 'Amethyst',
      number: '09',
      value: '5A3A6F'
    }, {
      label: 'Amethyst',
      number: '08',
      value: '6C4B81'
    }, {
      label: 'Amethyst',
      number: '07',
      value: '7D5F92'
    }, {
      label: 'Amethyst',
      number: '06',
      value: '8E72A4'
    }, {
      label: 'Amethyst',
      number: '05',
      value: 'A189B8'
    }, {
      label: 'Amethyst',
      number: '04',
      value: 'B59ECA'
    }, {
      label: 'Amethyst',
      number: '03',
      value: 'C7B4DB'
    }, {
      label: 'Amethyst',
      number: '02',
      value: 'DACCEC'
    }, {
      label: 'Amethyst',
      number: '01',
      value: 'EDE3FC'
    }, {
      label: 'Azure',
      number: '10',
      value: '133C59'
    }, {
      label: 'Azure',
      number: '09',
      value: '134D71'
    }, {
      label: 'Azure',
      number: '08',
      value: '1D5F8A'
    }, {
      label: 'Azure',
      number: '07',
      value: '2876A8'
    }, {
      label: 'Azure',
      number: '06',
      value: '2578A9'
    }, {
      label: 'Azure',
      number: '05',
      value: '4EA0D1'
    }, {
      label: 'Azure',
      number: '04',
      value: '69B5DD'
    }, {
      label: 'Azure',
      number: '03',
      value: '8DC9E6'
    }, {
      label: 'Azure',
      number: '02',
      value: 'ADD8EB'
    }, {
      label: 'Azure',
      number: '01',
      value: 'C8E9F4'
    }],
    placeIn: null,
    // null|'editor'
    showLabel: false,
    editable: true,
    disabled: false,
    uppercase: true,
    colorOnly: false,
    clearable: true,
    clearableText: null,
    popupmenuSettings: {}
  };

  function ColorPicker(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COLORPICKER_DEFAULTS); // Merge Settings does deep copy we want to replace here

    if (settings && settings.colors) {
      this.settings.colors = settings.colors;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  ColorPicker.prototype = {
    init: function init() {
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';
      this.isIe11 = this.isIe && Environment.browser.version === '11';
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = this.element.parent().is('.inline'); // Set default clearable text

      if (!this.settings.clearableText) {
        this.settings.clearableText = Locale ? Locale.translate('None') : 'None';
      }

      this.build();
      this.handleEvents();
      this.setCustomWidth();
    },
    // Add the extra markup
    build: function build() {
      this.isEditor = this.settings.placeIn === 'editor';
      var colorpicker = this.element;
      var initialValue = this.isEditor ? this.element.attr('data-value') : this.element.val();
      var classList = "swatch".concat(!initialValue || $.trim(initialValue) === '' ? ' is-empty' : '');

      if (!this.isEditor) {
        // Add Button
        if (this.isInlineLabel) {
          this.inlineLabel.addClass('colorpicker-container');
        } else {
          this.container = $('<span class="colorpicker-container"></span>');
          colorpicker.wrap(this.container);
        }

        this.container = colorpicker.parent();
        this.swatch = $("<span class=\"".concat(classList, "\"></span>")).prependTo(this.container); // Add Masking to show the #.
        // Remove the mask if using the "showLabel" setting

        if (!this.settings.showLabel) {
          var pattern = ['#', /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/];
          colorpicker.mask({
            pattern: pattern
          });
        } else {
          var maskAPI = colorpicker.data('mask');

          if (maskAPI && typeof maskAPI.destroy === 'function') {
            maskAPI.destroy();
          }
        }
      }

      var trigger = this.element.children('.trigger');

      if (this.container && this.container.length) {
        trigger = this.container.children('.trigger');
      }

      if (!trigger || !trigger.length || !trigger.children('.icon').length) {
        this.icon = $.createIconElement('dropdown').appendTo(this.isEditor ? this.element : this.container);
        this.icon.wrap('<span class="trigger"></span>');
      } // Handle initial values


      if (initialValue) {
        this.setColor(initialValue);
      }

      if (this.element.is(':disabled') || this.settings.disabled) {
        this.disable();
      }

      if (this.element.is(':disabled') && this.container) {
        this.container.closest('.field').addClass('is-disabled');
      }

      if (this.element.prop('readonly')) {
        this.readonly();
      }

      if (!this.settings.editable && !this.settings.disabled) {
        this.readonly();
      }

      if (this.settings.colorOnly) {
        this.element.parent().addClass('color-only');
      }

      this.element.attr('autocomplete', 'off');
      this.addAria(); // Add automation Id's

      utils.addAttributes(this.element.parent().find('.trigger'), this, this.settings.attributes, 'trigger');
    },

    /**
    * Get the hex value based on a label. Does not handle duplicates.
    * @param {string} label  The label to search for in the color labels.
    * @returns {void}
    */
    getHexFromLabel: function getHexFromLabel(label) {
      for (var i = 0; i < this.settings.colors.length; i++) {
        var data = this.settings.colors[i];
        var translated = Locale.translate(data.label, true);

        if (label === data.label + data.number || label === translated + data.number) {
          var hex = data.value;

          if (hex.substr(0, 1) !== '#') {
            hex = "#".concat(hex);
          }

          return hex;
        }
      }

      return '';
    },

    /**
    * Get the label value based on a hex. Does not handle duplicates.
    * Can pass with or without the #
    *
    * @param {string} hex The hex to search for in the color set.
    * @returns {void}
    */
    getLabelFromHex: function getLabelFromHex(hex) {
      if (!hex) {
        return '';
      }

      for (var i = 0; i < this.settings.colors.length; i++) {
        var data = this.settings.colors[i];

        if (hex.replace('#', '') === data.value.replace('#', '')) {
          return this.translateColorLabel(data.label) + data.number;
        }
      }

      return '';
    },

    /**
    * Set custom width.
    * @private
    * @returns {void}
    */
    setCustomWidth: function setCustomWidth() {
      if (this.element[0].style && this.element[0].style.width) {
        var w = parseInt(this.element[0].style.width, 10);
        this.container.css({
          width: w
        });
        this.element.css({
          width: w - 4 - this.swatch.width()
        });
      }
    },

    /**
    * Get the currently set hex value.
    * @returns {string} A string containing the hex
    */
    getHexValue: function getHexValue() {
      return this.element.attr('value');
    },

    /**
    * Get the currently set label value.
    * @returns {string} A string containing the hex
    */
    getLabelValue: function getLabelValue() {
      return this.settings.showLabel ? this.element.val() : this.getLabelFromHex(this.element.val());
    },

    /**
    * Add the necessary aria for accessibility.
    * @private
    * @returns {void}
    */
    addAria: function addAria() {
      this.element.attr({
        role: 'combobox',
        'aria-autocomplete': 'list'
      });
      $("label[for=\"".concat(this.element.attr('id'), "\"]")).append("<span class=\"audible\">".concat(Locale.translate('UseArrow'), "</span>"));
    },

    /**
    * Toggle / Open the List of Colors
    * @returns {void}
    */
    toggleList: function toggleList() {
      var _this = this;

      var menu = $('#colorpicker-menu');

      if (this.element.is(':disabled') || this.element.prop('readonly') && this.settings.editable) {
        return;
      }

      if (menu.length && this.isPickerOpen) {
        return;
      } // Append Color Menu


      menu = this.updateColorMenu();
      var popupmenuOpts = utils.extend({}, {
        ariaListbox: true,
        menuId: 'colorpicker-menu',
        trigger: 'immediate',
        attachToBody: true,
        placementOpts: {
          containerOffsetX: 10,
          containerOffsetY: 10,
          parentXAlignment: Locale.isRTL() ? 'right' : 'left',
          strategies: ['flip', 'nudge', 'shrink']
        },
        offset: {
          x: 0,
          y: 10
        }
      }, this.settings.popupmenuSettings); // Show Menu

      this.element.popupmenu(popupmenuOpts).on('open.colorpicker', function () {
        _this.element.parent().addClass('is-open');

        _this.isPickerOpen = true;
      }).on('close.colorpicker', function () {
        var links = [].slice.call(_this.menu[0].querySelectorAll('a'));
        links.forEach(function (link) {
          var tooltipApi = $(link).data('tooltip');

          if (tooltipApi) {
            tooltipApi.hide();
          }
        });
        menu.on('destroy.colorpicker', function () {
          _this.element.off('open.colorpicker selected.colorpicker close.colorpicker');

          _this.menu.off('destroy.colorpicker').remove();
        });

        _this.element.parent().removeClass('is-open');

        _this.isPickerOpen = false;
        /**
        *  Fires after the color picker popup is closed
        * @event listclosed
        * @memberof ColorPicker
        * @property {object} event The jquery event object
        */

        _this.element.trigger('listclosed', 'select');
      }).on('selected.colorpicker', function (e, item) {
        if (!_this.element.is('.colorpicker-editor-button')) {
          _this.itemLabel = item.data('label');
        }

        if (!_this.isEditor) {
          _this.setColor(item.data('value'), _this.itemLabel);
        } // Editor colorpicker


        var cpEditorNotVisible = false;

        if (_this.element.is('.colorpicker-editor-button')) {
          var toolbarItem = _this.element.data('toolbaritem') || _this.element.data('toolbarflexitem');

          var toolbarAPI = toolbarItem ? toolbarItem.toolbarAPI : null;

          if (toolbarAPI) {
            toolbarAPI.overflowedItems.forEach(function (thisItem) {
              if (thisItem.type === 'colorpicker') {
                cpEditorNotVisible = true;
              }
            });
          }
        }

        if (!cpEditorNotVisible) {
          _this.element.focus();
        }
        /**
        *  Fires after the color picker is changed
        * @event change
        * @memberof ColorPicker
        * @property {object} event The jquery event object
        */


        _this.element.trigger('change');
      }); // Append Buttons

      this.menu = $('#colorpicker-menu');
      setTimeout(function () {
        _this.menu.find('.is-selected').focus();
      }, 1);
    },

    /**
    * Set the visible color in the field
    * @param {string} hex The hex value to use (can have the # or not).
    * @param {string} label The text to display
    * @returns {void}
    */
    setColor: function setColor(hex, label) {
      hex = hex || '';
      var s = this.settings;
      var colorHex = hex;
      var colorLabel = label; // Make sure there is always a hash

      if (hex.toString().substr(0, 1) !== '#' && hex !== '') {
        colorHex = "#".concat(colorHex);
      }

      var isValidHex = /(^#[0-9a-fA-F]{6}$)|(^#[0-9a-fA-F]{3}$)/i.test(colorHex); // Simply return out if hex isn't valid

      if (s.showLabel && label === s.clearableText) {
        this.setValueOnField({
          hex: colorHex,
          label: s.clearableText,
          isEmpty: true
        });
        return;
      }

      if (!isValidHex) {
        if (!s.showLabel) {
          colorHex = colorHex !== '#' ? colorHex : '';
          this.setValueOnField({
            hex: colorHex,
            invalid: true
          });
          return;
        }

        colorLabel = hex.replace('#', '');
        colorHex = this.getHexFromLabel(colorLabel);
      }

      if (!colorLabel) {
        colorLabel = this.getLabelFromHex(colorHex);
      }

      this.setValueOnField({
        hex: colorHex,
        label: colorLabel
      });
    },

    /**
     * Set the value on the field
     * @private
     * @param {object} [o] Options
     * @param {string} [o.hex] The hex value to use
     * @param {string} [o.label] The text to display
     * @param {boolean} [o.isEmpty] if true will set empty value for all
     * @param {boolean} [o.invalid] if true will set empty value for swatch only
     * @returns {void}
     */
    setValueOnField: function setValueOnField(o) {
      var s = this.settings;
      var targetAttr = this.isEditor ? 'data-value' : 'value';
      var hex = '';

      if (!o.isEmpty && typeof o.hex === 'string') {
        hex = s.uppercase ? o.hex.toUpperCase() : o.hex.toLowerCase();
      }

      if (this.swatch) {
        if (o.isEmpty || o.invalid) {
          this.swatch.addClass(o.isEmpty ? 'is-empty' : 'is-invalid');
          this.swatch[0].style.backgroundColor = '';
        } else {
          this.swatch.removeClass('is-empty is-invalid');
          this.swatch[0].style.backgroundColor = hex;
        }
      }

      this.element[0].value = s.showLabel ? o.label : hex;
      this.element[0].setAttribute(targetAttr, hex);
      this.element[0].setAttribute('aria-describedby', o.label || '');
    },

    /**
     * @private
     * @param {string} colorText the original text color
     * @returns {string} the translated text color
     */
    translateColorLabel: function translateColorLabel(colorText) {
      if (!colorText) {
        return '';
      }

      var translatedText = Locale.translate(colorText, true);
      return typeof translatedText === 'string' ? Locale.translate(colorText, true) : colorText;
    },

    /**
     * Make basic theme variants backwards/forwards compatible
     * @param {string} activeTheme The active theme to get the variant for
     * @returns {string} The theme variants's border property value
     * @example (i.e. match "theme-uplift-light" with "light" and return "themes.light.border")
     */
    getThemeVariant: function getThemeVariant(activeTheme) {
      var legacyThemes = Object.keys(COLORPICKER_DEFAULTS.themes);
      var res = legacyThemes.filter(function (legacyTheme) {
        return activeTheme.indexOf(legacyTheme) > -1;
      });
      var variant = 'light';

      if (res.length > 0) {
        variant = res[0];
      }

      return variant;
    },

    /**
     * Refresh and Append the Color Menu
     * @private
     * @returns {jQuery} the menu to be appended
     */
    updateColorMenu: function updateColorMenu() {
      var _this2 = this;

      var s = this.settings;
      var isMenu = !!$('#colorpicker-menu').length;
      var menu = $('<ul id="colorpicker-menu" class="popupmenu colorpicker"></ul>');
      var activeTheme = personalization.currentTheme;
      var themeVariant = this.getThemeVariant(activeTheme);
      var isBorderAll = s.themes[themeVariant].border === 'all';
      var checkThemes = s.themes[themeVariant].checkmark;
      var checkmarkClass = ''; // Remove previously opened colorpicker first

      $('#colorpicker-menu').remove();

      var _loop = function _loop(i, l) {
        var li = $('<li></li>');
        var a = $('<a href="#"><span class="swatch"></span></a>').appendTo(li);
        var colorText = (_this2.translateColorLabel(s.colors[i].label) || s.colors[i].label) + (s.colors[i].number || '');
        var colorNum = parseInt(s.colors[i].number, 10);
        var regexp = new RegExp("\\b".concat(activeTheme, "\\b"));
        var colorValue = s.colors[i].value;
        var isBorder = false;
        var elemValue = _this2.isEditor ? _this2.element.attr('data-value') : _this2.element.val();

        if (s.showLabel && !_this2.isEditor) {
          elemValue = _this2.getHexFromLabel(elemValue);
        } // Set border to this swatch


        if (isBorderAll || regexp.test(s.colors[i].border)) {
          isBorder = true;
        }

        if (elemValue && "".concat(elemValue).toLowerCase().replace('#', '') === "".concat(colorValue).toLowerCase()) {
          // Set checkmark color class
          if (checkThemes) {
            /* eslint-disable no-loop-func */
            $.each(checkThemes, function (k, v) {
              // checkmark: {'one': [1, 2], 'two': [3, 10]}
              // will add class "checkmark-one", where current colors number is in range [1 to 3]
              // and will add class "checkmark-two", where current colors number is in range [3 to 10]
              if (colorNum >= v[0] && colorNum <= v[1]) {
                checkmarkClass = " checkmark-".concat(k);
              }
            });
            /* eslint-disable no-loop-func */
          }

          if (colorText === _this2.itemLabel || _this2.itemLabel === undefined) {
            a.addClass("is-selected".concat(checkmarkClass));
          }
        }

        colorValue = s.uppercase ? colorValue.toUpperCase() : colorValue.toLowerCase();
        var swatch = a.find('.swatch');

        if (swatch[0]) {
          swatch[0].style.backgroundColor = "#".concat(colorValue);
        }

        swatch.addClass(isBorder ? 'is-border' : '');
        a[0].setAttribute('data-label', colorText);
        a[0].setAttribute('data-value', colorValue);
        a[0].setAttribute('title', "".concat(colorText, " #").concat(colorValue));
        a.tooltip();
        utils.addAttributes(a, _this2, _this2.settings.attributes, colorText);

        if (!isMenu) {
          menu.append(li);
        }
      };

      for (var i = 0, l = s.colors.length; i < l; i++) {
        _loop(i);
      }

      if (!isMenu) {
        // Add clearable swatch to popupmenu
        if (s.clearable) {
          var li = $('<li></li>');
          var resetColorValue = this.element.attr('data-action') === 'foreColor' ? '000000' : '';
          var a = $("<a href=\"#\" title=\"".concat(s.clearableText, "\"><span class=\"swatch is-empty").concat(isBorderAll ? ' is-border' : '', "\"></span></a>")).appendTo(li);
          a.data('label', s.clearableText).data('value', resetColorValue).tooltip();
          utils.addAttributes(a, this, this.settings.attributes, 'clear');
          menu.append(li);
        }

        $('body').append(menu);
      }

      return menu;
    },

    /**
    * Change the color picker from enabled to disabled.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.prop('readonly', false);
      this.element.parent().removeClass('is-disabled is-readonly');
    },

    /**
    * Make the color picker disabled
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);

      if (!this.settings.placeIn) {
        this.element.parent().addClass('is-disabled');
      }
    },

    /**
    * Make the color picker readonly
    * @returns {void}
    */
    readonly: function readonly() {
      this.enable();
      this.element.prop('readonly', true);
      this.element.parent().addClass('is-readonly');

      if (!this.settings.editable) {
        this.element.parent().addClass('is-not-editable');
      }
    },

    /**
    * Returns true if the color picker is disabled.
    * @returns {void}
    */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
    * Gets the decimal as a rgb value so it can be shown in the editor
    * @private
    * @param {string} n Decimal value to convert to rgb.
    * @returns {void}
    */
    decimal2rgb: function decimal2rgb(n) {
      if (typeof n !== 'number') {
        return n;
      }
      /* eslint-disable no-bitwise */


      return "rgb(".concat(n & 0xFF, ", ").concat((n & 0xFF00) >> 8, ", ").concat((n & 0xFF0000) >> 16, ")");
    },
    rgb2hex: function rgb2hex(rgb) {
      if (!rgb || rgb.search('rgb') === -1) {
        return rgb;
      }

      if (rgb === 'rgba(0, 0, 0, 0)') {
        return 'transparent';
      }

      var hex = function hex(x) {
        return "0".concat(parseInt(x, 10).toString(16)).slice(-2);
      };

      var newRgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
      return "#".concat(hex(newRgb[1])).concat(hex(newRgb[2])).concat(hex(newRgb[3]));
    },

    /**
    * Update the component and optionally apply new settings.
    *
    * @param  {object} settings the settings to update to.
    * @returns {object} The plugin api for chaining.
    */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      return this.init();
    },
    teardown: function teardown() {
      this.element.off(["keypress.".concat(COMPONENT_NAME$w), "keyup.".concat(COMPONENT_NAME$w), "blur.".concat(COMPONENT_NAME$w), "openlist.".concat(COMPONENT_NAME$w), "change.".concat(COMPONENT_NAME$w), "paste.".concat(COMPONENT_NAME$w)].join(' '));

      if (this.swatch && this.swatch.length) {
        this.swatch.off("click.".concat(COMPONENT_NAME$w));
        this.swatch.remove();
        delete this.swatch;
      }

      var maskAPI = this.element.data('mask');

      if (maskAPI) {
        maskAPI.destroy();
      }

      if (this.icon && this.icon.length) {
        var trigger = this.icon.parent('.trigger');
        this.icon.off().remove();
        trigger.off().remove();
        delete this.icon;
      }

      if (this.container && this.container.length) {
        this.container.find('.trigger').remove();
        this.element.unwrap();
        delete this.container;
      }
    },

    /**
    * Detach events and restore DOM to default.
    * @returns {object} The plugin api (this).
    */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$w);
      return this;
    },

    /**
    * Detach events and restore DOM to default.
    * @private
    * @returns {void}
    */
    handleEvents: function handleEvents() {
      var _this3 = this;

      var elem = this.element;
      var elemParent = elem.parent();
      var originalVal;
      this.icon.parent().on('click.colorpicker', function () {
        _this3.toggleList();
      });
      elem.on('focus.colorpicker', function () {
        originalVal = elem.val();
        elemParent.addClass('is-focused');
      }).on('blur.colorpicker', function () {
        elemParent.removeClass('is-focused'); // Fix: Force to change event
        // IE-Edge not firing `change event` after updated input-s values

        if (_this3.isIeEdge && !elem.is('.is-open') && originalVal !== elem.val()) {
          elem.triggerHandler('change');
        }
      }).on('openlist.colorpicker', function () {
        _this3.toggleList();
      });
      var eventStr = 'blur.colorpicker paste.colorpicker change.colorpicker';
      eventStr += this.isIe11 ? 'keypress.colorpicker' : 'keyup.colorpicker';
      elem.on(eventStr, function () {
        var val = _this3.isEditor ? elem.attr('data-value') : elem.val();

        if (_this3.settings.showLabel) {
          _this3.setColor(elem.attr('value'), val);

          return;
        }

        _this3.setColor(val);
      }); // Handle Key Down to open

      elem.on('keydown.colorpicker', function (e) {
        if (e.keyCode === 38 || e.keyCode === 40) {
          _this3.toggleList();
        }

        if (e.keyCode === 13) {
          _this3.setColor(elem.val());
        }
      });
    }
  };

  /**
   * jQuery Component Wrapper for Colorpicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.colorpicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$w);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$w, new ColorPicker(this, settings));
      }
    });
  };

  var COMPONENT_NAME$x = 'toolbarflexitem'; // Filters out buttons located inside of Searchfield wrappers.
  // Only `input` elements should be picked up by the item detector.

  function buttonFilter(elem) {
    var searchfieldWrapper = $(elem).parents('.searchfield-wrapper, .toolbar-searchfield-wrapper');
    return !searchfieldWrapper.length;
  } // Filters out hyperlinks that are part of menu/action button components


  function hyperlinkFilter(elem) {
    if (elem.nodeName !== 'A') {
      throw new Error('Unspecified error occured');
    }

    var wrapped = $(elem);
    return wrapped.parents('.popupmenu').length < 1;
  } // Toolbar Focusable Element Selectors.
  // Any of these element/class types are valid toolbar items.
  // TODO: Designate between "button" and "menu button"


  var TOOLBAR_ELEMENTS = [{
    type: 'button',
    selector: 'button:not(.btn-menu):not(.btn-actions):not(.colorpicker-editor-button), input[type="button"]:not(.btn-menu):not(.btn-actions):not(.colorpicker-editor-button)',
    filter: buttonFilter
  }, {
    type: 'menubutton',
    selector: '.btn-menu'
  }, {
    type: 'actionbutton',
    selector: '.btn-actions'
  }, {
    type: 'colorpicker',
    selector: '.colorpicker-editor-button'
  }, {
    type: 'hyperlink',
    selector: 'a[href]',
    filter: hyperlinkFilter
  }, {
    type: 'checkbox',
    selector: 'input[type="checkbox"]'
  }, {
    type: 'radio',
    selector: 'input[type="radio"]'
  }, {
    type: 'searchfield',
    selector: '.searchfield'
  }, {
    type: 'toolbarsearchfield',
    selector: '.toolbarsearchfield'
  } // temporary
  ]; // Mappings from toolbar item type to component API

  var TOOLBAR_COMPONENT_APIS = {
    button: 'button',
    actionbutton: 'popupmenu',
    colorpicker: 'colorpicker',
    menubutton: 'popupmenu',
    hyperlink: 'hyperlink',
    searchfield: 'searchfield',
    toolbarsearchfield: 'searchfield'
  };
  /**
   * Default Settings
   * @namespace
   */

  var TOOLBAR_FLEX_ITEM_DEFAULTS = {
    disabled: false,
    readOnly: false,
    hidden: false,
    componentSettings: undefined,
    allowTabs: false,
    attributes: null
  };
  /**
   * Gets the type of Toolbar Item that an element represents.
   * @param {HTMLElement} element being checked for a toolbar item.
   * @returns {string} representing the type
   */

  function getToolbarItemType(element) {
    var type = false;
    TOOLBAR_ELEMENTS.forEach(function (elemObj) {
      if (!$(element).is(elemObj.selector)) {
        return;
      }

      if (typeof elemObj.filter === 'function' && !elemObj.filter(element)) {
        return;
      }

      type = elemObj.type;
    });

    if (!type) {
      throw new Error("Element ".concat(element, " is not a valid Toolbar Item Type."));
    }

    return type;
  }
  /**
   * Toolbar Item Wrapper Component
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */


  function ToolbarFlexItem(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, TOOLBAR_FLEX_ITEM_DEFAULTS);
    this.init();
  }

  ToolbarFlexItem.prototype = {
    /**
     * @property {string} type used to determine the type of toolbar item.  Certain toolbar item types
     *  have certain special properties.
     * @property {HTMLElement} section the parent toolbar section that this item is housed in.
     * @property {HTMLElement} toolbar the parent toolbar's base element.
     */
    type: undefined,

    /**
     * @property {boolean} a different type to check if the object is a ToolbarFlexItem.
     */
    isToolbarFlexItem: true,

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      // internal flags
      this.type = getToolbarItemType(this.element);
      this.section = this.element.parentElement;
      this.toolbar = this.section.parentElement;
      this.trueSelected = false;
    },

    /**
     * @returns {boolean} whether or not the toolbar item is currently able to be focused, based
     *  on its `disabled`, `overflowed`, and `visible` properties.
     */
    get focusable() {
      if (this.disabled === true) {
        return false;
      }

      if (this.type === 'searchfield') {
        return true;
      }

      if (this.type === 'actionbutton' && this.hasNoOverflowedItems === true) {
        return false;
      }

      if (this.overflowed === true) {
        return false;
      }

      return this.visible;
    },

    /**
     * @returns {boolean} whether or not the toolbar item is the one that will currently be focused
     */
    get focused() {
      return this.element.tabIndex === 0;
    },

    /**
     * @param {boolean} boolean, if provided, sets a focused state on the toolbar item.
     * @returns {void}
     */
    set focused(boolean) {
      if (boolean) {
        this.element.tabIndex = 0;
        return;
      }

      this.element.tabIndex = -1;
    },

    /**
     * @returns {boolean} whether or not the Toolbar item is selected.
     */
    get selected() {
      return this.trueSelected;
    },

    /**
     * @param {boolean} boolean, if provided, sets a selected state on the toolbar item.
     * @returns {void}
     */
    set selected(boolean) {
      if (boolean) {
        this.trueSelected = true;
        this.element.classList.add('is-selected');
        this.triggerSelectedEvent();

        if (this.selectedAnchor) {
          delete this.selectedAnchor;
        }

        return;
      }

      this.trueSelected = false;
      this.element.classList.remove('is-selected');
    },

    /**
     * Retrieves an item's main Soho Component instance.
     * @returns {object} Soho Component instance, if applicable
     */
    get componentAPI() {
      var $element = $(this.element);
      var componentType = TOOLBAR_COMPONENT_APIS[this.type];

      if (!componentType) {
        return undefined;
      }

      return $element.data(componentType);
    },

    /**
     * @returns {ToolbarFlex} the parent toolbar API
     */
    get toolbarAPI() {
      if (this.settings.toolbarAPI) {
        return this.settings.toolbarAPI;
      }

      return $(this.toolbar).data('toolbar-flex');
    },

    /**
     * @fires selected
     * @returns {void}
     */
    triggerSelectedEvent: function triggerSelectedEvent() {
      // Searchfields and Colorpickers aren't "selectable" in the same way actionable
      // items are, so they shouldn't fire the "selected" event.
      var disallowedTypes = ['searchfield', 'toolbarsearchfield'];

      if (disallowedTypes.indexOf(this.type) > -1) {
        return;
      }

      var eventArgs = [this]; // MenuButton types pass the currently-selected anchor

      var selectedAnchorTypes = ['menubutton', 'actionbutton'];

      if (selectedAnchorTypes.indexOf(this.type) > -1 && this.selectedAnchor) {
        eventArgs.push(this.selectedAnchor);
      }

      $(this.element).trigger('selected', eventArgs, eventArgs[1]);
    },

    /**
     * Causes the toolbar item to become visible.
     * @returns {void}
     */
    show: function show() {
      this.visible = true;
    },

    /**
     * Causes the toolbar item to become hidden.
     * @returns {void}
     */
    hide: function hide() {
      this.visible = false;
    },

    /**
     * Toggles the Toolbar item's visiblity.
     * @param {boolean} boolean whether or not the `hidden` class should be set.
     */
    set visible(boolean) {
      // NOTE: Temporary until Searchfield handles this better internally.
      var isSearchfield = this.type === 'searchfield' || this.type === 'toolbarsearchfield';

      if (boolean) {
        if (isSearchfield) {
          this.element.parentNode.classList.remove('hidden');
        }

        this.element.classList.remove('hidden');
        return;
      }

      if (isSearchfield) {
        this.element.parentNode.classList.add('hidden');
      }

      this.element.classList.add('hidden');
    },

    /**
     * @returns {boolean} whether or not the Toolbar Item is visible.
     */
    get visible() {
      return this.element.className.indexOf('hidden') === -1;
    },

    /**
     * @returns {void}
     */
    enable: function enable() {
      this.disabled = false;

      if (this.hasReadOnly) {
        this.readOnly = false;
      }
    },

    /**
     * @returns {boolean} whether or not the element is disabled
     */
    get disabled() {
      return this.element.disabled;
    },

    /**
     * @param {boolean} boolean, if provided, sets a disabled state on the toolbar item.
     * @returns {void}
     */
    set disabled(boolean) {
      if (boolean) {
        this.element.disabled = true;
        this.element.setAttribute('aria-disabled', true);
        this.element.readOnly = false;
        return;
      }

      this.element.disabled = false;
      this.element.removeAttribute('aria-disabled');
    },

    /**
     * @returns {boolean} whether or not `readOnly` as a property exists on this HTMLElement type.
     */
    get hasReadOnly() {
      return 'readOnly' in this.element;
    },

    /**
     * @returns {boolean} element's readOnly prop
     */
    get readOnly() {
      if (!this.hasReadOnly) {
        return false;
      }

      return this.element.readOnly;
    },

    /**
     * @param {boolean} boolean, if provided, sets a readOnly state on the toolbar item, if possible.
     * @returns {void}
     */
    set readOnly(boolean) {
      if (!this.hasReadOnly) {
        return;
      }

      if (boolean) {
        this.disabled = false;
        this.element.disabled = false;
        this.element.readOnly = true;
        return;
      }

      this.element.readOnly = false;
    },

    /**
     * @returns {boolean} whether or not the item is pushed into overflow by the boundaries
     *  of its container element.
     */
    get overflowed() {
      var isRTL = Environment.rtl;
      var elemRect = this.element.getBoundingClientRect();
      var sectionRect = this.section.getBoundingClientRect();

      if (isRTL) {
        return elemRect.left < sectionRect.left;
      }

      return elemRect.right > sectionRect.right;
    },

    /**
     * @param {boolean} isTrue whether or not the more actions menu has overflowed items, causing it to become displayed
     * @returns {void}
     */
    set hasNoOverflowedItems(isTrue) {
      if (this.type !== 'actionbutton' || !this.componentAPI) {
        return;
      }

      var popupmenuLength = this.componentAPI.toData({
        noMenuWrap: true
      }).length;
      var menuIsEmpty = popupmenuLength - this.predefinedItems.length < 1;

      if (isTrue && menuIsEmpty) {
        this.element.classList.add('no-overflowed-items');
        this.trueHasNoOverflowedItems = true;

        if (this.focused) {
          this.toolbarAPI.focusedItem = this;
          this.toolbarAPI.navigate(-1, undefined);
        }

        return;
      }

      this.trueHasNoOverflowedItems = false;
      this.element.classList.remove('no-overflowed-items');
    },

    /**
     *
     */
    get hasNoOverflowedItems() {
      if (!this.componentAPI) {
        return true;
      }

      return this.trueHasNoOverflowedItems;
    },

    /**
     * @returns {number} representing the index of this Toolbar Item within its current section.
     */
    get index() {
      return this.toolbarAPI.items.indexOf(this);
    },

    /**
     * Sets up all event listeners for this element.
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var $element = $(this.element);
      var popupmenuConsumers = ['menubutton', 'actionbutton', 'colorpicker'];

      if (popupmenuConsumers.indexOf(this.type) > -1) {
        // Listen to the Popupmenu's selected event
        $element.on("selected.".concat(COMPONENT_NAME$x), function (e, anchor) {
          if (_this.selectedAnchor) {
            return;
          }

          e.stopPropagation();

          if (_this.type === 'actionbutton') {
            var li = $(anchor).parent();
            var itemLink = li.data('originalButton');
            var itemLinkAPI = $(itemLink).data('toolbarflexitem');
            var elementLink;

            if (li.parents('ul').length > 1) {
              elementLink = li.data('original-menu-element');
              itemLink = li.parents('li').last().data('originalButton');
              itemLinkAPI = $(itemLink).data('toolbarflexitem');
            } // If this item is linked to another toolbar item, trigger its `selected` event instead
            // of the one on the item in this menu.


            if (itemLinkAPI) {
              if (elementLink) {
                e.preventDefault();
                itemLinkAPI.selectedAnchor = $(elementLink).children('a');
              } else {
                // case of a menu button overflowed into more actions
                itemLinkAPI.selectedAnchor = anchor;
              }

              itemLinkAPI.selected = true;
              return;
            }
          }

          self.selectedAnchor = anchor;
          self.selected = true;
        });
      }

      if (this.type === 'actionbutton') {
        $element.on("beforeopen.".concat(COMPONENT_NAME$x), this.handleActionButtonBeforeOpen.bind(this));
        $('body').off("resize.".concat(COMPONENT_NAME$x)).on("resize.".concat(COMPONENT_NAME$x), this.handleActionButtonResize.bind(this));
      }

      if (!this.settings.allowTabs) {
        $element.on("focus.".concat(COMPONENT_NAME$x), this.handleFocus.bind(this));
      }
    },

    /**
     * If this element is an Action Button, this listener runs before its popupmenu is opened
     * To determine which elements need to be shown/hidden.
     * @private
     * @returns {void}
     */
    handleActionButtonBeforeOpen: function handleActionButtonBeforeOpen() {
      this.refreshMoreActionsMenu();
    },

    /**
     * If this element is an Action Button, this listener runs whenever Soho's custom resize event
     * on the `<body>` tag fires, to determine which elements need to be shown/hidden.
     * @private
     * @returns {void}
     */
    handleActionButtonResize: function handleActionButtonResize() {
      this.refreshMoreActionsMenu();
    },

    /**
     * @private
     * @param {FocusEvent} e `focus`
     * @returns {void}
     */
    handleFocus: function handleFocus(e) {
      if (e.target && e.target === this.element) {
        this.toolbarAPI.focusedItem = this;
      }
    },

    /**
     * Renders extra markup or anything else needed on the toolbar item
     * @returns {void}
     */
    render: function render() {
      var _this2 = this;

      // eslint-disable-next-line
      this.disabled = this.disabled;

      if (this.hasReadOnly) {
        // eslint-disable-next-line
        this.readonly = this.readonly;
      } // In some cases we need to concatenate attributes together.
      // The main Flex Toolbar API will pass on its attributes as an `attributes` setting on each Item.
      // If an attribute is provided by the Toolbar API, but a component instance is already configured
      // to have these attributes, we don't want to change the ones on the component instance.
      // However, we want any unset attributes at the component level to pass on from the Toolbar.


      if (Array.isArray(this.settings.attributes)) {
        if (!this.settings.componentSettings) {
          this.settings.componentSettings = {};
        }

        var attrs;

        if (!this.settings.componentSettings.attributes) {
          attrs = this.settings.attributes.map(function (obj) {
            return {
              name: obj.name,
              value: "".concat(obj.value, "-").concat(_this2.type, "-").concat(_this2.index)
            };
          });
        } else {
          // If an item attribute is not defined, but a toolbar attribute is,
          // Make a custom one by concatenating properties of these two together.
          attrs = [];
          this.settings.attributes.forEach(function (topLevelAttr) {
            var itemAttr = _this2.settings.componentSettings.attributes.find(function (toolbarAttrs) {
              return toolbarAttrs.name === topLevelAttr.name;
            });

            if (itemAttr) {
              // Simply push the existing one if it finds it
              attrs.push(itemAttr);
            } else {
              attrs.push({
                name: topLevelAttr.name,
                value: "".concat(topLevelAttr.value, "-").concat(_this2.type, "-").concat(_this2.index)
              });
            }
          });
        }

        this.settings.componentSettings.attributes = attrs;
      } // Setup component APIs, if applicable.
      // NOTE: Soho Initializer doesn't invoke these automatically, by nature of the
      // base elements existing inside the Flex Toolbar.


      var $element = $(this.element);
      var componentType = TOOLBAR_COMPONENT_APIS[this.type];
      var api;

      if (componentType) {
        api = $element.data(componentType);

        if (!api) {
          $element[componentType](this.settings.componentSettings);
        } else {
          api.updated(this.settings.componentSettings);
        }
      } // Action Buttons need more stuff


      if (this.type === 'actionbutton') {
        this.renderMoreActionsMenu();
        this.refreshMoreActionsMenu();
      }

      this.handleEvents();
    },

    /**
     * Uses data from Toolbar Items to build Toolbar-linked, pre-defined items for the More Actions menu.
     * NOTE: This method only runs when this toolbar item is a "More Actions" button
     * @private
     * @returns {void}
     */
    renderMoreActionsMenu: function renderMoreActionsMenu() {
      var menuAPI = this.componentAPI;

      if (!menuAPI || !this.toolbarAPI) {
        return;
      } // If the menu doesn't already exist, pre-define it.


      var $menu = menuAPI.menu;

      if (!$menu || !$menu.length) {
        $menu = $('<ul class="popupmenu"></ul>').insertAfter(this.element);
      }

      this.teardownPredefinedItems(); // Get Popupmenu data equivalent of the current set of Toolbar items.
      // Menu item data is scrubbed for IDs that would otherwise be duplicated

      function removeMenuIds(item, isSubmenu) {
        if (item.menuId) {
          delete item.menuId;
        }

        var menuTarget = isSubmenu ? 'submenu' : 'menu';

        if (Array.isArray(item[menuTarget])) {
          item[menuTarget].forEach(function (subitem) {
            removeMenuIds(subitem, true);
          });
        }
      }

      var data = this.toolbarAPI.toPopupmenuData();
      removeMenuIds(data); // Add Toolbar Items as predefined items to the Popupmenu.

      var menuItems = $(menuAPI.renderItem(data));
      this.predefinedItems = menuItems;
      this.linkToolbarItems(data); // Notify the Popupmenu of predefined items

      $menu.prepend(this.predefinedItems);
      menuAPI.updated({
        menu: $menu,
        predefined: menuItems
      });
      this.menuRendered = true;
    },

    /**
     * Refreshes the state of menu items in a "More Actions" menu that were constructed by the Flex Toolbar.
     * @private
     * @returns {void}
     */
    refreshMoreActionsMenu: function refreshMoreActionsMenu() {
      if (this.type !== 'actionbutton') {
        return;
      }

      var menuAPI = this.componentAPI;

      if (!menuAPI || !this.toolbarAPI || menuAPI.isOpen) {
        return;
      } // If there are toolbar items, but no predefined items, render the more-actions menu


      if (!menuAPI.settings.beforeOpen && (!this.predefinedItems || !this.predefinedItems.length) && this.toolbarAPI.items.length) {
        this.renderMoreActionsMenu();
      }

      var hasNoOverflowedItems = true; // Called at the end of the item refresh.
      // Uses the Popupmenu's API to add overflow information.

      function itemRefreshCallback(menuItem, data) {
        if (data.isSubmenuItem) {
          return;
        }

        if (data.overflowed === true) {
          menuItem.classList.add('is-overflowed');

          if (data.visible) {
            menuItem.classList.remove('hidden');
          }

          hasNoOverflowedItems = false;
          return;
        }

        menuItem.classList.remove('is-overflowed');
        menuItem.classList.add('hidden');
      } // Each Linked Toolbar Item will be refreshed by the Popupmenu API


      this.toolbarAPI.items.forEach(function (item) {
        if (!item.actionButtonLink) {
          return;
        }

        var itemData = item.toPopupmenuData();
        itemData.overflowed = item.overflowed;

        if (itemData.id) {
          delete itemData.id;
        }

        menuAPI.refreshMenuItem(item.actionButtonLink, itemData, itemRefreshCallback);
      }); // Set a record for display

      this.hasNoOverflowedItems = hasNoOverflowedItems;
    },

    /**
     * Removes links between the current set of Toolbar Items to `More Actions` menu items.
     * @private
     * @returns {void}
     */
    unlinkToolbarItems: function unlinkToolbarItems() {
      if (this.type !== 'actionbutton' || !this.menuRendered || !this.predefinedItems || !this.predefinedItems.length) {
        return;
      }

      function doUnlinkSubmenuItem(actionMenuElement) {
        var $originalMenuElement = $($(actionMenuElement).data('original-menu-element'));
        $originalMenuElement.removeData('action-button-link');
        $(actionMenuElement).removeData('original-menu-element');

        if ($originalMenuElement.hasClass('submenu')) {
          var submenuItems = actionMenuElement.querySelector('.popupmenu').children;

          for (var j = 0; j < submenuItems.length; j++) {
            doUnlinkSubmenuItem(submenuItems[j]);
          }
        }
      }

      function doUnlinkToolbarItems(i, itemElement) {
        var originalButton = $(itemElement).data('originalButton');
        var originalButtonAPI = $(originalButton).data('toolbarflexitem');
        originalButtonAPI.actionButtonLink = null;
        $(itemElement).removeData('original-button');

        if (originalButtonAPI.type === 'menubutton') {
          var submenuItems = itemElement.querySelector('.popupmenu').children;

          for (var j = 0; j < submenuItems.length; j++) {
            doUnlinkSubmenuItem(submenuItems[j]);
          }
        }
      }

      this.predefinedItems.each(doUnlinkToolbarItems);
    },

    /**
     * Links the current set of Toolbar Items to the `More Actions` menu items.
     * @private
     * @param {object} popupmenuData incoming popupmenu data
     * @returns {void}
     */
    linkToolbarItems: function linkToolbarItems(popupmenuData) {
      if (this.type !== 'actionbutton' || !popupmenuData) {
        return;
      }

      if (!Array.isArray(popupmenuData)) {
        popupmenuData = popupmenuData.menu;
      }

      function doLinkSubmenuItem(menuItemData, actionMenuElement) {
        var originalMenuElement = menuItemData.elementLink;
        $(originalMenuElement).data('action-button-link', actionMenuElement);
        $(actionMenuElement).data('original-menu-element', originalMenuElement);
        var submenu = menuItemData.submenu;

        if (submenu && submenu.length) {
          var submenuItems = actionMenuElement.querySelector('.popupmenu').children;

          for (var j = 0; j < submenuItems.length; j++) {
            doLinkSubmenuItem(submenu[j], submenuItems[j]);
          }
        }
      }

      function doLinkToolbarItems(i, itemElement) {
        var originalButtonAPI = popupmenuData[i].itemLink;
        originalButtonAPI.actionButtonLink = itemElement;
        $(itemElement).data('original-button', originalButtonAPI.element);
        var submenu = popupmenuData[i].submenu;

        if (submenu && submenu.length) {
          var submenuItems = itemElement.querySelector('.popupmenu').children;

          for (var j = 0; j < submenuItems.length; j++) {
            doLinkSubmenuItem(submenu[j], submenuItems[j]);
          }
        }
      }

      this.predefinedItems.each(doLinkToolbarItems);
    },

    /**
     * Converts the contents of the Toolbar Item to a data structure that's compatible with a Popupmenu component.
     * This data structure can be used to populate the contents of a "More Actions" menu.
     * @returns {object} an object representation of the Toolbar Item as a Popupmenu Item.
     */
    toPopupmenuData: function toPopupmenuData() {
      if (this.type === 'searchfield' || this.type === 'toolbarsearchfield' || this.type === 'actionbutton') {
        return undefined;
      }

      var itemData = {
        itemLink: this,
        disabled: this.disabled,
        visible: this.visible
      };
      var icon = this.element.querySelector('.icon:not(.close):not(.icon-dropdown) > use');

      if (icon && icon.getAttribute('href')) {
        itemData.icon = icon.getAttribute('href').replace('#icon-', '');
      }

      if (icon && icon.getAttribute('xlink:href')) {
        itemData.icon = icon.getAttribute('xlink:href').replace('#icon-', '');
      }

      if (/\b(button|menubutton|colorpicker)\b/g.test(this.type)) {
        itemData.text = this.element.textContent.trim();
      }

      function addMenuElementLinks(menu, data) {
        var elems = menu.querySelectorAll('li:not(.heading)');
        data.forEach(function (item, i) {
          item.elementLink = elems[i];

          if (item.submenu) {
            var submenu = elems[i].querySelector('.popupmenu');
            item.submenu = addMenuElementLinks(submenu, item.submenu);
          }
        });
        return data;
      } // Add links to the menubutton's menu item elements to the Popupmenu data


      if (this.type === 'menubutton') {
        var menuElem = this.componentAPI.menu;

        if (!menuElem.length) {
          // Act as if this menubutton is simply empty.
          itemData.submenu = [];
        } else {
          // Get a data representation of the existing menu content
          var originalSubmenuData = this.componentAPI.toData({
            noMenuWrap: true
          });
          var targetId = this.componentAPI.element[0].id;

          if (targetId) {
            // NOTE: don't pass the same ID here, which would cause duplicates
            itemData.id = "".concat(this.toolbarAPI.uniqueId, "-").concat(targetId);
          }

          itemData.submenu = addMenuElementLinks(menuElem[0], originalSubmenuData);
        }
      }

      return itemData;
    },

    /**
     * Converts the current state of the toolbar item to an object structure that can be
     * easily passed back/forth and tested.
     * @returns {object} containing the current Toolbar Item state.
     */
    toData: function toData() {
      var itemData = {
        type: this.type,
        disabled: this.disabled,
        focused: this.focused,
        selected: this.selected,
        overflowed: this.overflowed,
        visible: this.visible
      };

      if (this.hasReadOnly) {
        itemData.readOnly = this.readOnly;
      }

      if (this.actionButtonLink) {
        itemData.actionButtonLink = this.actionButtonLink;
      }

      if (this.componentAPI) {
        itemData.componentAPI = this.componentAPI;
      }

      var icon = this.element.querySelector('.icon:not(.close):not(.icon-dropdown) > use');

      if (icon && icon.getAttribute('href')) {
        itemData.icon = icon.getAttribute('href').replace('#icon-', '');
      }

      if (icon && icon.getAttribute('xlink:href')) {
        itemData.icon = icon.getAttribute('xlink:href').replace('#icon-', '');
      }

      if (/\b(button|menubutton|colorpicker)\b/g.test(this.type)) {
        itemData.text = this.element.textContent.trim();
      }

      if (this.type === 'actionbutton') {
        itemData.predefinedItems = this.predefinedItems;
      }

      if (this.type === 'menubutton' || this.type === 'actionbutton') {
        // TODO: Need to convert a Popupmenu's contents to the object format with this method
        itemData.submenu = this.componentAPI.toData({
          noMenuWrap: true
        });
      }

      return itemData;
    },

    /**
     * Completely updates this component with (optional) new settings.
     * @param {object} [settings] incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },

    /**
     * @private
     * @returns {void}
     */
    teardownPredefinedItems: function teardownPredefinedItems() {
      if (this.type !== 'actionbutton') {
        return;
      }

      this.unlinkToolbarItems();

      if (this.predefinedItems && this.predefinedItems.length) {
        this.predefinedItems.remove();
      }
    },

    /**
     * Unbinds events and removes preset internal flags for this component.
     * @returns {void}
     */
    teardown: function teardown() {
      $(this.element).off("selected.".concat(COMPONENT_NAME$x)).off("beforeopen.".concat(COMPONENT_NAME$x)).off("focus.".concat(COMPONENT_NAME$x));
      $('body').off("resize.".concat(COMPONENT_NAME$x));
      this.teardownPredefinedItems();
      delete this.type;
      delete this.selected;
      delete this.focusable;
      delete this.visible;
      delete this.disabled;
      delete this.readOnly;
      delete this.section;
      delete this.toolbar;
      delete this.trueSelected;
      delete this.menuRendered;
    },

    /**
     * Destroy the item and any popup menus
     * @returns {void}
     */
    destroy: function destroy() {
      var popupmenu = $(this.element).data('popupmenu');

      if (popupmenu && popupmenu.destroy) {
        popupmenu.destroy();
      }

      this.teardown();
    }
  };

  /**
   * jQuery component wrapper for Toolbar Flex Item Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.toolbarflexitem = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$x);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$x, new ToolbarFlexItem(this, settings)); // Remove the jQuery Component reference from $.data

        var oldDestroy = instance.destroy;

        instance.destroy = function () {
          if (typeof oldDestroy === 'function') {
            oldDestroy.call(this);
          }

          $.removeData(this, COMPONENT_NAME$x);
        };
      }
    });
  };

  var COMPONENT_NAME$y = 'toolbar-flex';
  /**
   * Component Default Settings
   * @namespace
   */

  var TOOLBAR_FLEX_DEFAULTS = {
    allowTabs: false,
    attributes: null,
    beforeMoreMenuOpen: null,
    moreMenuSettings: {}
  };
  /**
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.beforeMoreMenuOpen=null] Ajax function to be called before the more menu is opened
   * @param {boolean} [settings.allowTabs] Allows tab to navigate the toolbar
   * @param {object} [settings.moreMenuSettings] if defined on a toolbar containing a More Actions menu, this will pass settings into this toolbar's More Actions menu
   */

  function ToolbarFlex(element, settings) {
    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, TOOLBAR_FLEX_DEFAULTS);
    this.init();
  }

  ToolbarFlex.prototype = {
    /**
     * @private
     */
    trueFocusedItem: undefined,
    sections: [],
    items: [],

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      this.uniqueId = utils.uniqueId(this.element);
      this.sections = utils.getArrayFromList(this.element.querySelectorAll('.toolbar-section'));
      this.items = this.getElements().map(function (item) {
        var itemComponentSettings = {};
        var isActionButton = $(item).hasClass('btn-actions');

        if (isActionButton) {
          itemComponentSettings = _this.settings.moreMenuSettings || itemComponentSettings;

          if (_this.settings.beforeMoreMenuOpen) {
            warnAboutDeprecation('settings.moreMenuSettings.beforeOpen', 'settings.beforeMoreMenuOpen', 'Flex Toolbar');
            itemComponentSettings.beforeOpen = _this.settings.beforeMoreMenuOpen;
          }
        }

        $(item).toolbarflexitem({
          toolbarAPI: _this,
          componentSettings: itemComponentSettings,
          allowTabs: _this.settings.allowTabs,
          attributes: _this.settings.attributes
        });
        return $(item).data('toolbarflexitem');
      });

      if (!this.items) {
        return;
      } // Check for a focused item


      if (!this.settings.allowTabs) {
        this.items.forEach(function (item) {
          if (item.focused) {
            if (_this.focusedItem === undefined) {
              _this.focusedItem = item;
            } else {
              item.focused = false;
            }
          }
        });

        if (!this.focusedItem) {
          this.focusedItem = this.items[0];
        }

        if (this.focusedItem) {
          this.focusedItem.focused = true;
        }
      }

      this.render();
      this.handleEvents();
    },

    /**
     * @returns {void}
     */
    render: function render() {
      this.element.setAttribute('role', 'toolbar');

      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes($(this.element), this, this.settings.attributes);
      }

      this.items.forEach(function (item) {
        item.render();
      });
    },

    /**
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      if (!this.settings.allowTabs) {
        this.keydownListener = this.handleKeydown.bind(this);
        this.element.addEventListener('keydown', this.keydownListener);
        this.keyupListener = this.handleKeyup.bind(this);
        this.element.addEventListener('keyup', this.keyupListener);
        this.clickListener = this.handleClick.bind(this);
        this.element.addEventListener('click', this.clickListener);
      }

      $(this.element).on("selected.".concat(COMPONENT_NAME$y), function (e) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
      }); // Inlined Searchfields can cause navigation requiring a focus change to occur on collapse.

      $(this.element).on("collapsed-responsive.".concat(COMPONENT_NAME$y), function (e, direction) {
        e.stopPropagation();

        _this2.navigate(direction, null, true);
      });
    },

    /**
     * Event Handler for internal `keydown` events.
     * @private
     * @param {KeyboardEvent} e `keydown`
     * @returns {void}
     */
    handleKeydown: function handleKeydown(e) {
      var target = e.target; // Toolbar Items get handled separately.

      if ($(target).data('toolbarflexitem')) {
        this.handleItemKeydown(e);
      }
    },

    /**
     * Event Handler for internal `keydown` events, specifically on Toolbar Items.
     * @private
     * @param {KeyboardEvent} e `keydown`
     * @returns {void}
     */
    handleItemKeydown: function handleItemKeydown(e) {
      var isRTL = Locale.isRTL();
      var key = e.key;
      var item = this.getItemFromElement(e.target);

      function preventScrolling() {
        e.preventDefault();
      } // NOTE: 'Enter' and 'SpaceBar' are purposely not handled on keydown, since
      // a `click` event will be fired on Toolbar items while pressing either of these keys.


      if (key === 'Enter') {
        this.clickByEnterKey = true;
        return;
      }

      if (key === ' ') {
        // SpaceBar
        if (item.type === 'hyperlink') {
          this.select(e.target);
        }

        return;
      } // Left Navigation


      var leftNavKeys = ['ArrowLeft', 'Left', 'ArrowUp', 'Up'];

      if (leftNavKeys.indexOf(key) > -1) {
        if (item.type === 'searchfield' && (key === 'ArrowLeft' || key === 'Left')) {
          return;
        }

        this.navigate(isRTL ? 1 : -1, undefined, true);
        preventScrolling();
        return;
      } // Right Navigation


      var rightNavKeys = ['ArrowRight', 'Right', 'ArrowDown', 'Down'];

      if (rightNavKeys.indexOf(key) > -1) {
        if (item.type === 'searchfield' && (key === 'ArrowRight' || key === 'Right')) {
          return;
        }

        this.navigate(isRTL ? -1 : 1, undefined, true);
        preventScrolling();
      }
    },

    /**
     * Event Handler for internal `keyup` events
     * @private
     * @param {KeyboardEvent} e `keyup`
     * @returns {void}
     */
    handleKeyup: function handleKeyup(e) {
      this.clearClickByEnter(e);
    },

    /**
     * Event Handler for internal `click` events
     * @private
     * @param {MouseEvent} e `click`
     * @returns {void}
     */
    handleClick: function handleClick(e) {
      var target = e.target; // Toolbar Items get handled separately.

      if ($(target).data('toolbarflexitem')) {
        this.handleItemClick(e);
      }

      this.clearClickByEnter();
    },

    /**
     * Event Handler for internal `click` events, specifically on Toolbar Items.
     * @private
     * @param {MouseEvent} e `click`
     * @returns {void}
     */
    handleItemClick: function handleItemClick(e) {
      var item = this.getItemFromElement(e.target);
      this.select(item);
      this.focusedItem = item;
    },

    /**
     * @private
     * @param {Event} e incoming event of multiple types
     * @returns {void}
     */
    clearClickByEnter: function clearClickByEnter(e) {
      // Gets set in `this.handleItemKeydown` by pressing 'Enter'.
      if (this.clickByEnterKey) {
        // Prevents the enter key from triggering a `selected` event on the menu button.
        if (this.type === 'menubutton' || this.type === 'actionbutton') {
          e.preventDefault();
        }

        delete this.clickByEnterKey;
      }
    },

    /**
     * Gets all the elements currently inside the Toolbar Markup.
     * The array of items produced is ordered by Toolbar Section.
     * @returns {array} of Toolbar Items
     */
    getElements: function getElements() {
      var items = [];
      var allSelectors = []; // Build a really big selector containing all possible matches

      TOOLBAR_ELEMENTS.forEach(function (elemObj) {
        allSelectors.push(elemObj.selector);
      });
      allSelectors = allSelectors.join(', '); // Get all possible Toolbar Element matches
      // NOTE: Important that the toolbar items are picked up by the querySelector
      // in their actual, physical DOM order.

      var thisElems = utils.getArrayFromList(this.element.querySelectorAll(allSelectors)); // Check each element for each type of toolbar item.
      // If there's a match, push to the item array.

      thisElems.forEach(function (elem) {
        var defined = false;
        TOOLBAR_ELEMENTS.forEach(function (elemObj) {
          if (defined || !$(elem).is(elemObj.selector)) {
            return;
          }

          if (typeof elemObj.filter === 'function') {
            if (!elemObj.filter(elem)) {
              return;
            }
          }

          defined = true;
          items.push(elem);
        });
      });
      return items;
    },

    /**
     * @param {HTMLElement|ToolbarFlexItem} element the element to be checked
     * @returns {ToolbarFlexItem} an instance of a Toolbar item
     */
    getItemFromElement: function getItemFromElement(element) {
      if (element instanceof ToolbarFlexItem || element.isToolbarFlexItem) {
        return element;
      }

      var item;

      for (var i = 0; i < this.items.length; i++) {
        // Simple comparison of innerHTML to figure out if the elements match up
        if (this.items[i].element.innerHTML === element.innerHTML) {
          item = this.items[i];
        }
      }

      if (!item) {
        throw new Error("No Toolbar Item instance available for element ".concat(element, "."));
      }

      return item;
    },

    /**
     * If this toolbar contains a searchfield, this alias returns a reference to its ComponentAPI property.
     * If no searchfield exists, it returns `undefined`
     * @returns {Searchfield|undefined} a reference to the componentAPI of the searchfield item.
     */
    get searchfieldAPI() {
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].type === 'searchfield') {
          return this.items[i].componentAPI;
        }
      }

      return undefined;
    },

    /**
     * @returns {ToolbarFlexItem|undefined} either a toolbar item, or undefined if one
     *  wasn't previously focused.
     */
    get focusedItem() {
      if (this.trueFocusedItem) {
        return this.trueFocusedItem;
      }

      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].focused === true) {
          return this.items[i];
        }
      }

      return undefined;
    },

    /**
     * Sets the currently focused item
     * @param {ToolbarFlexItem} item the item to be focused
     */
    set focusedItem(item) {
      if (this.items.length === 0) {
        return;
      }

      for (var i = 0; i < this.items.length; i++) {
        this.items[i].focused = false;
      }

      item.focused = true;
      this.trueFocusedItem = item;
    },

    // Flag for figuring out if a Toolbar's items are all completely unavailable for keyboard focus.
    get hasFocusableItems() {
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].focusable === true) {
          return true;
        }
      }

      return false;
    },

    /**
     * @returns {boolean} determining whether or not the Flex Toolbar has the authority to currently control focus
     */
    get canManageFocus() {
      var activeElement = document.activeElement;

      if (this.element.contains(activeElement)) {
        return true;
      } // If the searchfield currently has focus, return true


      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].type === 'searchfield' && this.items[i].componentAPI.isFocused) {
          return true;
        }
      }

      if (activeElement.tagName === 'BODY') {
        return true;
      }

      return false;
    },

    /**
     * @returns {ToolbarFlexItem[]} all overflowed items in the toolbar
     */
    get overflowedItems() {
      var overflowed = [];

      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].overflowed === true) {
          overflowed.push(this.items[i]);
        }
      }

      return overflowed;
    },

    /**
     * Navigates among toolbar items and gets a reference to a potential target for focus.
     * @param {number} direction positive/negative value representing how many spaces to move
     * @param {number} [currentIndex] the index to start checking from
     *  the current focus either right/left respectively.
     * @param {boolean} [doSetFocus=false] if set to true, will cause navigation to also set focus.
     */
    navigate: function navigate(direction, currentIndex, doSetFocus) {
      if (this.hasFocusableItems === false) {
        return;
      } // reference the original direction for later, if placement fails.


      var originalDirection = 0 + direction;

      if (currentIndex === undefined || currentIndex === null) {
        currentIndex = this.items.indexOf(this.focusedItem);
      }

      while (direction !== 0) {
        if (direction > 0) {
          if (currentIndex === this.items.length - 1) {
            currentIndex = 0;
          } else {
            currentIndex++;
          }

          --direction;
        }

        if (direction < 0) {
          if (currentIndex === 0) {
            currentIndex = this.items.length - 1;
          } else {
            --currentIndex;
          }

          direction++;
        }
      }

      var targetItem = this.items[currentIndex];

      if (targetItem.focusable === false) {
        this.navigate(originalDirection > 0 ? 1 : -1, currentIndex, doSetFocus);
        return;
      } // Retain a reference to the focused item and set focus, if applicable.


      this.focusedItem = targetItem;

      if (doSetFocus && this.canManageFocus) {
        this.focusedItem.element.focus();
      }
    },

    /**
     * @param {HTMLElement|ToolbarFlexItem} element an HTMLElement representing a
     *  Toolbar Item, or an actual ToolbarFlexItem API to use.
     * @returns {void}
     */
    select: function select(element) {
      var item = this.getItemFromElement(element);

      switch (item.type) {
        case 'searchfield':
        case 'actionbutton':
        case 'menubutton':
          {
            if (this.clickByEnterKey) {
              return;
            }

            item.selected = true;
            break;
          }

        default:
          item.selected = true;
          break;
      }
    },

    /**
     * Exports everything in the current `items` array as Popupmenu-friendly data to be
     * converted to menu items.
     * NOTE: Searchfields and other Action Buttons are ignored
     * @returns {object} containing JSON-friendly Popupmenu data
     */
    toPopupmenuData: function toPopupmenuData() {
      var data = {
        noMenuWrap: true
      };

      function getItemData(item) {
        var itemData = item.toPopupmenuData();

        if (itemData) {
          // Pass along some properties to the top level data object
          if (itemData.icon) {
            data.hasIcons = true;
          }

          if (itemData.selectable) {
            data.selectable = itemData.selectable;
          }
        }

        return itemData;
      }

      data.menu = this.items.filter(function (item) {
        if (item.type === 'actionbutton' || item.type === 'searchfield') {
          return false;
        }

        return true;
      }).map(function (item) {
        return getItemData(item);
      });
      return data;
    },

    /**
     * Exports everything in the current `items` array as a Flex Toolbar object structure
     * @returns {object} containing JSON-friendly Flex Toolbar data
     */
    toData: function toData() {
      var data = {};
      data.items = this.items.map(function (item) {
        return item.toData();
      });
      return data;
    },

    get disabled() {
      return this.trueDisabled;
    },

    set disabled(bool) {
      this.trueDisabled = bool;

      if (bool === true) {
        this.element.classList.add('is-disabled');
        return;
      }

      this.element.classList.remove('is-disabled');
    },

    /**
     * Detects whether or not a toolbar item is currently overflowed.
     * @param {ToolbarFlexItem|jQuery[]|HTMLElement} item the Toolbar Item or Element to check for overlflow.
     * @returns {boolean} whether or not the item is overflowed.
     */
    isItemOverflowed: function isItemOverflowed(item) {
      if (!item) {
        return false;
      } // If we get an HTMLElement or jQuery object, rzesolve the ToolbarFlex Item
      // from either of those, if applicable. Otherwise, it's not overflowed.


      var targetItem;

      if (item instanceof HTMLElement || item instanceof $) {
        targetItem = $(item).data('toolbarflexitem');

        if (!targetItem) {
          return false;
        }

        item = targetItem;
      } // If this item isn't inside this toolbar, it's definitely not overflowed.


      if (this.items.indexOf(item) < 0) {
        return false;
      }

      return item.overflowed;
    },

    /**
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (_typeof(settings) === 'object') {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },

    /**
     * @returns {void}
     */
    teardown: function teardown() {
      if (!this.settings.allowTabs) {
        this.element.removeEventListener('keydown', this.keydownListener);
        this.element.removeEventListener('keyup', this.keyupListener);
        this.element.removeEventListener('click', this.clickListener);
      }

      $(this.element).off("selected.".concat(COMPONENT_NAME$y));
      $(this.element).off("collapsed-responsive.".concat(COMPONENT_NAME$y));
      this.items.forEach(function (item) {
        item.teardown();
      });
      delete this.items;
      delete this.sections;
    },

    /**
     * Do full destroy and remove children popup menus
     * @returns {void}
     */
    destroy: function destroy() {
      this.items.forEach(function (item) {
        item.destroy();
      });
      this.teardown();
    }
  };

  /**
   * jQuery component wrapper for Toolbar Flex Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.toolbarflex = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$y);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$y, new ToolbarFlex(this, settings)); // Remove the jQuery Component reference from $.data

        var oldDestroy = instance.destroy;

        instance.destroy = function () {
          if (typeof oldDestroy === 'function') {
            oldDestroy.call(this);
          }

          $.removeData(this, COMPONENT_NAME$y);
        };
      }
    });
  };

  var COMPONENT_NAME$z = 'calendartoolbar';
  /**
   * The Calendar Toolbar Displays a toolbar above calendars and week views.
   * @class CalendarToolbar
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.language] The name of the language to use for this instance. If not set the current locale's language will be used.
   * @param {number} [settings.month] The month to show.
   * @param {number} [settings.year] The year to show.
   * @param {boolean} [settings.showToday=true] If true the today button is shown on the header.
   * @param {function} [settings.onOpenCalendar] Call back for when the calendar is open on the toolbar datepicker, allows you to set the date.
   * @param {function} [settings.onChangeView] Call back for when the view changer is changed.
   * @param {boolean} [settings.isAlternate] Alternate style for the datepicker popup.
   * @param {boolean} [settings.isMenuButton] Show the month/year as a menu button object, works if isAlternate is true.
   * @param {boolean} [settings.isMonthPicker] Indicates this is a month picker on the month and week view. Has some slight different behavior.
   * @param {boolean} [settings.showViewChanger=false] If false the dropdown to change views will not be shown.
   * @param {string} [settings.viewChangerValue='month'] The value to show selected in the view changer. Can be month, week, day or schedule.
   * @param {string} [settings.attributes] Add extra attributes like id's to the element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var COMPONENT_DEFAULTS = {
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    locale: null,
    showToday: true,
    onOpenCalendar: null,
    onChangeView: null,
    isAlternate: false,
    isMenuButton: true,
    showViewChanger: false,
    viewChangerValue: 'month',
    isMonthPicker: false
  };

  function CalendarToolbar(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, COMPONENT_DEFAULTS);
    this.init();
  } // CalendarToolbar Methods


  CalendarToolbar.prototype = {
    init: function init() {
      this.setLocale().build().handleEvents();
    },

    /**
     * Set up the toolbar to the settings.
     * @private
     * @returns {void}
     */
    build: function build() {
      this.element[0].classList.add('flex-toolbar');
      this.element[0].setAttribute('data-init', 'false');

      if (this.settings.isAlternate) {
        this.element[0].classList.add('is-alternate');
        var monthYearPaneButton = "<button type=\"button\" class=\"btn btn-monthyear-pane expandable-area-trigger\" id=\"btn-monthyear-pane\">\n        <span class=\"month\">november</span>\n        <span class=\"year\">2019</span>\n        <svg class=\"icon icon-closed\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n          <use href=\"#icon-dropdown\"></use>\n        </svg>\n        <svg class=\"icon icon-opened\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n          <use href=\"#icon-dropdown\"></use>\n        </svg>\n      </button>";
        this.element[0].innerHTML = "\n        <div class=\"toolbar-section\">\n          ".concat(this.settings.isMenuButton ? monthYearPaneButton : '<span class="month">november</span><span class="year">2015</span>', "\n        </div>\n        <div class=\"toolbar-section buttonset l-align-").concat(this.isRTL ? 'left' : 'right', "\">\n          ").concat(this.settings.showToday ? "<a class=\"hyperlink today\" href=\"#\">".concat(Locale.translate('Today', {
          locale: this.locale.name,
          language: this.language
        }), "</a>") : '', "\n          <button type=\"button\" class=\"btn-icon prev\">\n            <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-left\"></use></svg>\n            <span>").concat(Locale.translate('PreviousMonth', {
          locale: this.locale.name,
          language: this.language
        }), "</span>\n            </button>\n          <button type=\"button\" class=\"btn-icon next\">\n              <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-right\"></use></svg>\n              <span>").concat(Locale.translate('NextMonth', {
          locale: this.locale.name,
          language: this.language
        }), "</span>\n          </button>\n        </div>\n      ");
      } else {
        this.element[0].innerHTML = "\n        <div class=\"toolbar-section\">\n          <button type=\"button\" class=\"btn-icon prev\">\n            <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-left\"></use></svg>\n            <span>".concat(Locale.translate('PreviousMonth', {
          locale: this.locale.name,
          language: this.language
        }), "</span>\n            </button>\n          <button type=\"button\" class=\"btn-icon next\">\n              <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-right\"></use></svg>\n              <span>").concat(Locale.translate('NextMonth', {
          locale: this.locale.name,
          language: this.language
        }), "</span>\n          </button>\n          <span class=\"monthview-datepicker\">\n            <span class=\"hidden month\" data-month=\"9\">9</span>\n            <span class=\"hidden year\">2019</span>\n            <span class=\"audible\">").concat(Locale.translate('SelectDay'), "</span>\n            <span tabindex=\"0\" aria-label=\"").concat(Locale.translate('Today', {
          locale: this.locale.name,
          language: this.language
        }), "\" id=\"monthview-datepicker-field\" class=\"datepicker input-auto\" data-validation=\"\">October 2019</span>\n          </span>\n          ").concat(this.settings.showToday ? "<a class=\"hyperlink today\" href=\"#\">".concat(Locale.translate('Today', {
          locale: this.locale.name,
          language: this.language
        }), "</a>") : '', "\n        </div>\n        <div class=\"toolbar-section buttonset l-align-right\">\n          ").concat(!this.settings.showViewChanger ? '' : "<label for=\"".concat(this.settings.viewChangerValue, "-calendar-view-changer\" class=\"label audible\">").concat(Locale.translate('ChangeView', {
          locale: this.locale.name,
          language: this.language
        }), "</label>\n            <select id=\"").concat(this.settings.viewChangerValue, "-calendar-view-changer\" name=\"").concat(this.settings.viewChangerValue, "-calendar-view-changer\" class=\"dropdown\">\n              <option value=\"month\"").concat(this.settings.viewChangerValue === 'month' ? ' selected' : '', ">").concat(Locale.translate('Month', {
          locale: this.locale.name,
          language: this.language
        }), "</option>\n              <option value=\"week\"").concat(this.settings.viewChangerValue === 'week' ? ' selected' : '', ">").concat(Locale.translate('Week', {
          locale: this.locale.name,
          language: this.language
        }), "</option>\n              <option value=\"day\" ").concat(this.settings.viewChangerValue === 'day' ? ' selected' : '', ">").concat(Locale.translate('Day', {
          locale: this.locale.name,
          language: this.language
        }), "</option>\n            </select>\n          </div>"), "\n        </div>\n      ");
      } // Invoke the toolbar


      this.element.toolbarflex({
        allowTabs: true
      }); // Setup the datepicker

      this.monthPicker = this.element.find('#monthview-datepicker-field').datepicker({
        dateFormat: Locale.calendar(this.locale.name, this.settings.language, this.settings.calendarName).dateFormat.year,
        locale: this.settings.locale,
        language: this.settings.language,
        onOpenCalendar: this.settings.onOpenCalendar,
        isMonthPicker: this.settings.isMonthPicker,
        showToday: this.settings.showToday
      });

      if (this.settings.showViewChanger) {
        this.viewChanger = this.element.find("#".concat(this.settings.viewChangerValue, "-calendar-view-changer")).dropdown();
      }

      this.todayLink = this.element.find('.hyperlink.today');
      this.monthPickerApi = this.monthPicker.data('datepicker'); // Hide focus on buttons

      this.element.find('button, a').hideFocus();
      this.setInternalDate(this.isIslamic ? [this.settings.year, this.settings.month, 1] : new Date(this.settings.year, this.settings.month, 1));
      utils.addAttributes(this.element.find('.next'), this, this.settings.attributes, "".concat(this.settings.viewChangerValue, "-view-btn-next"));
      utils.addAttributes(this.element.find('.prev'), this, this.settings.attributes, "".concat(this.settings.viewChangerValue, "-view-btn-prev"));
      utils.addAttributes(this.element.find('.today'), this, this.settings.attributes, "".concat(this.settings.viewChangerValue, "-view-today"));
      utils.addAttributes(this.element.find('#monthview-datepicker-field + .icon'), this, this.settings.attributes, "".concat(this.settings.viewChangerValue, "-view-datepicker-trigger"), true);
      utils.addAttributes(this.element.find('#monthview-datepicker-field'), this, this.settings.attributes, "".concat(this.settings.viewChangerValue, "-view-datepicker"), true);
      utils.addAttributes($('.monthview-header #month-calendar-view-changer [value="month"]'), this, this.settings.attributes, 'month-view-changer-month');
      utils.addAttributes($('.monthview-header #month-calendar-view-changer [value="week"]'), this, this.settings.attributes, 'month-view-changer-week');
      utils.addAttributes($('.monthview-header #month-calendar-view-changer [value="day"]'), this, this.settings.attributes, 'month-view-changer-day');
      utils.addAttributes($('.monthview-header #month-calendar-view-changer'), this, this.settings.attributes, 'month-view-changer');
      utils.addAttributes($('.week-view-header #week-calendar-view-changer [value="month"]'), this, this.settings.attributes, 'week-view-changer-month');
      utils.addAttributes($('.week-view-header #week-calendar-view-changer [value="week"]'), this, this.settings.attributes, 'week-view-changer-week');
      utils.addAttributes($('.week-view-header #week-calendar-view-changer [value="day"]'), this, this.settings.attributes, 'week-view-changer-day');
      utils.addAttributes($('.week-view-header #week-calendar-view-changer'), this, this.settings.attributes, 'week-view-changer');
      return this;
    },

    /**
     * Set the internal date state.
     * @private
     * @param {date} date The date to set.
     * @returns {void}
     */
    setInternalDate: function setInternalDate(date) {
      if (Locale.isIslamic(this.locale.name)) {
        this.currentYear = date[0];
        this.currentMonth = date[1];
        this.currentDay = date[2];
        this.currentDateIslamic = date;
      } else {
        this.currentYear = date.getFullYear();
        this.currentMonth = date.getMonth();
        this.currentDay = date.getDate();
        this.currentDate = date;
      }

      this.monthPicker.text(Locale.formatDate(new Date(this.currentYear, this.currentMonth, this.currentDay), {
        date: 'year',
        locale: this.locale.name,
        language: this.settings.language
      }));

      if (!this.currentCalendar || !this.currentCalendar.months) {
        this.currentCalendar = Locale.calendar(this.locale.name, this.settings.language, this.settings.calendarName);
      }

      var monthName = this.currentCalendar.months ? this.currentCalendar.months.wide[this.currentMonth] : '';
      this.element.find('span.month').attr('data-month', this.currentMonth).text(monthName);
      this.element.find('span.year').text(" ".concat(this.currentYear)); // Some locales set the year first

      var yearFirst = this.currentCalendar.dateFormat.year && this.currentCalendar.dateFormat.year.substr(1, 1) === 'y';

      if (yearFirst) {
        var translation = Locale.formatDate(this.currentDate, {
          date: 'year',
          locale: this.locale.name
        });
        var split = translation.split(' ');
        var justYear = split[0];

        if (split.length === 3) {
          this.element.find('span.month').attr('data-month', this.currentMonth).text("".concat(split[1], " ").concat(split[2]));
        }

        this.element.find('span.year').text("".concat(justYear, " "));
        this.element.find('span.year').insertBefore(this.element.find('span.month'));
      }

      return this;
    },

    /**
     * Set current calendar
     * @private
     * @returns {this} Rhe object for chaining
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.settings.language, this.settings.calendarName);
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.isRTL = (this.locale.direction || this.locale.data.direction) === 'right-to-left';
      return this;
    },

    /**
     * Set current locale to be used if different than the set locale.
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      if (this.settings.language) {
        Locale.getLocale(this.settings.language);
        this.language = this.settings.language;
      } else {
        this.language = Locale.currentLanguage.name;
      }

      if (this.settings.locale && (!this.locale || this.locale.name !== this.settings.locale)) {
        Locale.getLocale(this.settings.locale).done(function (locale) {
          _this.locale = Locale.cultures[locale];
          _this.language = _this.settings.language || _this.locale.language;

          _this.setCurrentCalendar();
        });
      } else if (!this.settings.locale) {
        this.locale = Locale.currentLocale;
        this.setCurrentCalendar();
      }

      return this;
    },

    /**
     * Set the view changer dropdown value
     * @private
     * @param {string} viewChangerValue The view changer value to use (month, day or week)
     * @returns {void}
     */
    setViewChangerValue: function setViewChangerValue(viewChangerValue) {
      this.settings.viewChangerValue = viewChangerValue;
      this.viewChanger.val(viewChangerValue).trigger('updated');
    },

    /**
     * Attach Events used by the Component.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      this.monthPicker.off('change.calendar-toolbar-p').on('change.calendar-toolbar-p', function () {
        var picker = $(this).data('datepicker');
        self.setInternalDate(picker.isIslamic ? picker.currentDateIslamic : picker.currentDate);
        self.element.trigger('change-date', {
          selectedDate: picker.currentDate,
          isToday: false
        });
      });
      this.todayLink.off('click.calendar-toolbar-t').on('click.calendar-toolbar-t', function (e) {
        _this2.element.trigger('change-date', {
          selectedDate: _this2.currentDate,
          isToday: true
        });

        e.preventDefault();
      });
      this.element.find('.prev').off('click.calendar-toolbar-b').on('click.calendar-toolbar-b', function () {
        _this2.element.trigger('change-prev', {
          selectedDate: _this2.currentDate,
          isToday: false
        });
      });
      this.element.find('.next').off('click.calendar-toolbar-b').on('click.calendar-toolbar-b', function () {
        _this2.element.trigger('change-next', {
          selectedDate: _this2.currentDate,
          isToday: false
        });
      });

      if (this.settings.onChangeView && this.viewChanger) {
        this.viewChanger.off('change.calendar-toolbar-v').on('change.calendar-toolbar-v', function (e) {
          _this2.settings.onChangeView({
            viewName: e.currentTarget.value,
            elem: e.currentTarget,
            api: _this2
          });
        });
      }

      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, COMPONENT_DEFAULTS);
      }

      return this.teardown().init();
    },

    /**
     * Teardown all event handles.
     * @returns {void}
     */
    teardown: function teardown() {
      this.element.off();
      this.monthPicker.off();
      this.todayLink.off();
      this.element.find('.prev .next').off();
      return this;
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$z);
    }
  };

  var COMPONENT_NAME$A = 'monthview';
  var COMPONENT_NAME_DEFAULTS = {
    locale: null,
    language: null,
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    day: new Date().getDate(),
    activeDate: null,
    activeDateIslamic: null,
    isPopup: false,
    headerStyle: 'full',
    firstDayOfWeek: null,
    disable: {
      callback: null,
      dates: [],
      years: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    legend: [{
      name: 'Public Holiday',
      color: 'azure06',
      dates: []
    }, {
      name: 'Weekends',
      color: 'turquoise06',
      dayOfWeek: []
    }],
    hideDays: false,
    // TODO
    showMonthYearPicker: true,
    yearsAhead: 5,
    yearsBack: 4,
    range: {
      useRange: false,
      // true - if datepicker using range dates
      start: '',
      // Start date '03/05/2018'
      end: '',
      // End date '03/21/2018'
      separator: ' - ',
      // separator string between two dates
      minDays: 0,
      // Minimum days
      maxDays: 0,
      // Maximum days
      selectForward: false,
      // Only in forward direction
      selectBackward: false,
      // Only in backward direction
      includeDisabled: false // if true range will include disable dates in it

    },
    selectable: true,
    onSelected: null,
    onKeyDown: null,
    showToday: true,
    onChangeView: null,
    isMonthPicker: false
  };
  /**
   * MonthView - Renders a Month calendar
   * @class MonthView
   * @param {string} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.language] The name of the language to use for this instance. If not set the current locale will be used or the passed locale will be used.
   * @param {number} [settings.month] The month to show.
   * @param {number} [settings.year] The year to show.
   * @param {number} [settings.day] The initial selected day to show.
   * @param {number} [settings.activeDate] The date to highlight as selected/today.
   * @param {number} [settings.activeDateIslamic] The date to highlight as selected/today (as an array for islamic)
   * @param {number} [settings.isPopup] Is it in a popup (datepicker using it)
   * @param {number} [settings.headerStyle] Configure the header, this can be 'simple' or 'full'. Full adds a picker and today link.
   * @param {boolean} [settings.isMonthPicker] Indicates this is a month picker on the month and week view. Has some slight different behavior.
   * @param {number} [settings.firstDayOfWeek=null] Set first day of the week. '1' would be Monday.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {function} [settings.disable.callback] return true to disable passed dates.
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019']}`.
   * @param {array} [settings.disable.years] Disable specific years.
   * Example `{years: [2018, 2019]}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {object} [settings.range] Range between two dates with various options.
   * @param {boolean} [settings.range.useRange=false] Use range of two dates options.
   * @param {string|date} [settings.range.start] Start date in range.
   * @param {string|date} [settings.range.end] End date in range.
   * @param {string} [settings.range.separator=' - '] Visual separator between two dates.
   * @param {number} [settings.range.minDays=0] Minimum days to be in range.
   * @param {number} [settings.range.maxDays=0] Maximum days to be in range.
   * @param {boolean} [settings.range.selectForward=false] Range only in forward direction.
   * @param {boolean} [settings.range.selectBackward=false] Range only in backward direction.
   * @param {boolean} [settings.range.includeDisabled=false] Include disable dates in range of dates.
   * @param {boolean} [settings.hideDays=false] If true the days portion of the calendar will be hidden. Usefull for Month/Year only formats.
   * @param {boolean} [settings.showMonthYearPicker=true] If false the year and month switcher will be disabled.
   * @param {number} [settings.yearsAhead=5] The number of years ahead to show in the month/year picker should total 9 with yearsBack.
   * @param {number} [settings.yearsBack=4] The number of years back to show in the month/year picker should total 9 with yearsAhead.
   * @param {array} [settings.legend]  Legend Build up
   * for example `[{name: 'Public Holiday', color: '#76B051', dates: []},
   * {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
   * @param {boolean} [settings.selectable=false] If true the month days can be clicked to select
   * @param {boolean} [settings.onSelected=false] Callback that fires when a month day is clicked.
   * @param {boolean} [settings.onKeyDown=false] Callback that fires when a key is pressed down.
   * @param {boolean} [settings.showToday=true] If true the today button is shown on the header.
   * @param {function} [settings.onChangeView] Call back for when the view changer is changed.
   * @param {string} [settings.attributes] Add extra attributes like id's to the element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function MonthView(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  MonthView.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      return this.setLocaleThenBuild();
    },

    /**
     * Set current locale to be used
     * @private
     * @returns {void}
     */
    setLocaleThenBuild: function setLocaleThenBuild() {
      var _this = this;

      var languageDf = Locale.getLocale(this.settings.language);
      var localeDf = Locale.getLocale(this.settings.locale);
      $.when(localeDf, languageDf).done(function (locale, lang) {
        _this.locale = Locale.cultures[locale] || Locale.currentLocale;
        _this.language = lang || _this.settings.language || _this.locale.language;
        _this.settings.language = _this.language;

        _this.setCurrentCalendar();

        _this.build().handleEvents();
      });
    },

    /**
     * Add any needed markup to the component.
     * @private
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    build: function build() {
      var _this2 = this;

      if (this.settings.showMonthYearPicker === 'false') {
        this.settings.showMonthYearPicker = false;
      }

      this.setCurrentCalendar(); // Calendar Html in Popups

      this.prevButton = '' + "<button type=\"button\" class=\"btn-icon prev\">\n        ".concat($.createIcon('caret-left'), "\n        <span>").concat(Locale.translate('PreviousMonth', {
        locale: this.locale.name,
        language: this.language
      }), "</span>\n      </button>");
      this.nextButton = '' + "<button type=\"button\" class=\"btn-icon next\">\n        ".concat($.createIcon('caret-right'), "\n        <span>").concat(Locale.translate('NextMonth', {
        locale: this.locale.name,
        language: this.language
      }), "</span>\n      </button>");
      this.table = $("<table class=\"monthview-table\" aria-label=\"".concat(Locale.translate('Calendar', {
        locale: this.locale.name
      }), "\" role=\"application\"></table>"));
      this.dayNames = $('' + "<thead>\n        <tr>\n          <th>SU</th>\n          <th>MO</th>\n          <th>TU</th>\n          <th>WE</th>\n          <th>TH</th>\n          <th>FR</th>\n          <th>SA</th>\n        </tr>\n      </thead>").appendTo(this.table);
      this.days = $('' + "<tbody>\n        <tr>\n          <td class=\"alternate\">26</td>\n          <td class=\"alternate\">27</td>\n          <td class=\"alternate\">28</td>\n          <td class=\"alternate\">29</td>\n          <td class=\"alternate\" >30</td>\n          <td class=\"alternate\">31</td>\n          <td>1</td>\n        </tr><tr>\n          <td>2</td>\n          <td>3</td>\n          <td>4</td>\n          <td>5</td>\n          <td>6</td>\n          <td>7</td>\n          <td>8</td>\n        </tr><tr>\n          <td>9</td>\n          <td>10</td>\n          <td>11</td>\n          <td>12</td>\n          <td>13</td>\n          <td>14</td>\n          <td>15</td>\n        </tr><tr>\n          <td>16</td>\n          <td>17</td>\n          <td>18</td>\n          <td>19</td>\n          <td class=\"is-today\">20</td>\n          <td>21</td>\n          <td>22</td>\n        </tr><tr>\n          <td>23</td>\n          <td>24</td>\n          <td>25</td>\n          <td>26</td>\n          <td>27</td>\n          <td>28</td>\n          <td class=\"alternate\">1</td>\n        </tr><tr>\n          <td class=\"alternate\">2</td>\n          <td class=\"alternate\">3</td>\n          <td class=\"alternate\">4</td>\n          <td class=\"alternate\">5</td>\n          <td class=\"alternate\">6</td>\n          <td class=\"alternate\">7</td>\n          <td class=\"alternate\">8</td>\n        </tr>\n      </tbody>").appendTo(this.table);
      this.monthYearPane = $('');

      if (this.settings.showMonthYearPicker && this.settings.isPopup) {
        this.monthYearPane = $("<div class=\"monthview-monthyear-pane expandable-area ".concat(this.settings.hideDays ? ' is-expanded' : '', "\">\n        <div class=\"expandable-pane\">\n          <div class=\"content\"><div class=\"picklist-section is-month\"></div><div class=\"picklist-section is-year\"></div></div>\n        </div>\n      </div>"));
      }

      if (this.settings.hideDays) {
        this.table = '';
      } // Reconfigure the header


      this.header = $('<div class="monthview-header"><div class="calendar-toolbar"></div></div>');

      if (this.settings.headerStyle === 'full') {
        this.monthPicker = this.header.find('#monthview-datepicker-field');
      } else if (this.settings.showToday) {
        this.header.find('.btn-icon.prev').before("<a class=\"hyperlink today\" href=\"#\">".concat(Locale.translate('Today', {
          locale: this.locale.name,
          language: this.language
        }), "</a>"));
      }

      this.showMonth(this.settings.month, this.settings.year);
      this.calendar = this.element.addClass('monthview').append(this.header, this.monthYearPane, this.table);

      if (!this.settings.isPopup) {
        this.element.addClass('is-fullsize');
      } // Add Legend


      this.addLegend(); // Invoke the toolbar

      this.calendarToolbarEl = this.header.find('.calendar-toolbar');
      this.calendarToolbarAPI = new CalendarToolbar(this.calendarToolbarEl[0], {
        onOpenCalendar: function onOpenCalendar() {
          return _this2.currentDate;
        },
        locale: this.settings.locale,
        language: this.settings.language,
        year: this.currentYear,
        month: this.currentMonth,
        showToday: this.settings.showToday,
        isMonthPicker: this.settings.headerStyle === 'full',
        isAlternate: this.settings.headerStyle !== 'full',
        isMenuButton: this.settings.headerStyle !== 'full' ? this.settings.showMonthYearPicker : false,
        showViewChanger: this.settings.showViewChanger,
        onChangeView: this.settings.onChangeView,
        attributes: this.settings.attributes
      });
      this.handleEvents();
      utils.addAttributes(this.element, this, this.settings.attributes);
      return this;
    },

    /**
     * Set current calendar
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.language, this.settings.calendarName);
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.isRTL = (this.locale.direction || this.locale.data.direction) === 'right-to-left';
      this.conversions = this.currentCalendar.conversions;
    },

    /**
     * Update the calendar to show the given month and year
     * @param {number} month The zero based month to display
     * @param {number} year The year to display
     * @returns {void}
     */
    showMonth: function showMonth(month, year) {
      var _this3 = this;

      var self = this;
      var s = this.settings;
      var now = new Date();
      now.setHours(0);
      now.setMinutes(0);
      now.setSeconds(0);
      var elementDate;

      if (this.isIslamic) {
        elementDate = s.activeDate || Locale.gregorianToUmalqura(now);
      } else {
        elementDate = s.activeDate && s.activeDate.getDate() ? s.activeDate : now;
      }

      this.setCurrentCalendar();

      if (this.isIslamic) {
        if (!s.activeDateIslamic) {
          var gregorianDate = new Date(year, month, this.currentDay || this.settings.day);
          var islamicDate = Locale.gregorianToUmalqura(gregorianDate);
          this.todayDateIslamic = Locale.gregorianToUmalqura(now);
          s.activeDateIslamic = [];
          s.activeDateIslamic[0] = islamicDate[0];
          s.activeDateIslamic[1] = islamicDate[1];
          s.activeDateIslamic[2] = islamicDate[2];
          year = islamicDate[0];
          month = islamicDate[1];
          elementDate = islamicDate;
          this.currentDay = islamicDate[2];
        } else {
          elementDate = s.activeDateIslamic;
        }
      }

      if (year.toString().length < 4) {
        year = new Date().getFullYear();
      }

      if (month === 12) {
        year++;
        month = 0;
        this.currentMonth = month;
        this.currentYear = year;
        this.currentDate.setFullYear(year);
        this.currentDate.setMonth(month);
      }

      if (month < 0) {
        year--;
        month = 11;
        this.currentMonth = month;
        this.currentYear = year;
        this.currentDate.setFullYear(year);
        this.currentDate.setMonth(month);
      }

      this.currentDay = this.currentDay || this.settings.day;

      if (!this.currentCalendar || !this.currentCalendar.days) {
        this.currentCalendar = Locale.calendar(this.locale.name, this.language, this.settings.calendarName);
      }

      var days = this.currentCalendar.days.narrow;
      days = days || this.currentCalendar.days.abbreviated;

      if (!s.isPopup) {
        days = this.currentCalendar.days.abbreviated;
      }

      var monthName = this.currentCalendar.months.wide[month];
      this.currentMonth = month;
      this.currentYear = year; // Set the Days of the week

      var firstDayofWeek = this.currentCalendar.firstDayofWeek || 0;

      if (s.firstDayOfWeek) {
        firstDayofWeek = s.firstDayOfWeek;
      }

      this.dayNames.find('th').each(function (i) {
        $(this).text(days[(i + firstDayofWeek) % 7]);
      }); // Localize Month Name

      this.yearFirst = this.currentCalendar.dateFormat.year && this.currentCalendar.dateFormat.year.substr(1, 1) === 'y';
      this.header.find('.month').attr('data-month', month).text("".concat(xssUtils.stripTags(monthName), " "));
      this.header.find('.year').text(" ".concat(year));

      if (this.yearFirst && !this.isIslamic && !this.isRTL) {
        elementDate.setFullYear(year);
        var translation = Locale.formatDate(elementDate, {
          date: 'year',
          locale: this.locale.name
        });
        var justYear = translation.split(' ')[0];
        this.header.find('.year').text("".concat(justYear, " "));
        this.header.find('.year').insertBefore(this.header.find('.month'));
      }

      if (s.headerStyle === 'full' && this.calendarToolbarAPI) {
        this.calendarToolbarAPI.setInternalDate(this.isIslamic ? [year, month, 1] : new Date(year, month, 1));
      }

      this.appendMonthYearPicker(month, year); // Adjust days of the week
      // lead days

      var firstDayOfMonth = this.firstDayOfMonth(year, month);
      var leadDays = (firstDayOfMonth - firstDayofWeek + 7) % 7;
      var lastMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 1 : 0));
      var thisMonthDays = this.daysInMonth(year, month + (this.isIslamic ? 0 : 1));
      var nextMonthDayCnt = 1;
      var dayCnt = 1;
      var exYear;
      var exMonth;
      var exDay;
      var foundSelected = false; // Set selected state

      var setSelected = function setSelected(el, isFound) {
        foundSelected = isFound;
        el.addClass("is-selected".concat(s.range.useRange ? ' range' : '')).attr('aria-selected', 'true').attr('tabindex', '0');
      };

      this.dayMap = [];
      this.days.find('td').each(function (i) {
        var th = $(this).removeClass('alternate prev-month next-month is-selected range is-today');
        th.removeAttr('aria-selected');
        th.removeAttr('tabindex');

        if (i < leadDays) {
          exDay = lastMonthDays - leadDays + 1 + i;
          exMonth = month === 0 ? 11 : month - 1;
          exYear = month === 0 ? year - 1 : year;
          self.setDisabled(th, exYear, exMonth, exDay);
          self.setLegendColor(th, exYear, exMonth, exDay);
          self.dayMap.push({
            key: stringUtils.padDate(exYear, exMonth, exDay),
            elem: th
          });
          th.addClass('alternate prev-month').html("<span class=\"day-container\"><span aria-hidden=\"true\" class=\"day-text\">".concat(xssUtils.stripTags(exDay), "</span></span>"));
          th.attr('data-key', stringUtils.padDate(exYear, exMonth, exDay));
        }

        if (i >= leadDays && dayCnt <= thisMonthDays) {
          self.dayMap.push({
            key: stringUtils.padDate(year, month, dayCnt),
            elem: th
          });
          th.html("<span class=\"day-container\"><span aria-hidden=\"true\" class=\"day-text\">".concat(xssUtils.stripTags(dayCnt), "</span></span>"));
          th.attr('data-key', stringUtils.padDate(year, month, dayCnt)); // Add Selected Class to Selected Date

          if (self.isIslamic) {
            if (dayCnt === elementDate[2]) {
              setSelected(th, true);
            }
          } else {
            var tHours = elementDate.getHours();
            var tMinutes = elementDate.getMinutes();
            var tSeconds = self.isSeconds ? elementDate.getSeconds() : 0;

            var setHours = function setHours(el) {
              return el ? el.setHours(tHours, tMinutes, tSeconds, 0) : 0;
            };

            var newDate = setHours(new Date(year, month, dayCnt));
            var comparisonDate = self.currentDate || elementDate;

            if (newDate === setHours(comparisonDate)) {
              setSelected(th, true);
            }
          }

          if (dayCnt === self.todayDay && self.currentMonth === self.todayMonth && self.currentYear === self.todayYear) {
            th.addClass('is-today');
          }

          th.attr('aria-label', Locale.formatDate(new Date(self.currentYear, self.currentMonth, dayCnt), {
            date: 'full',
            locale: self.locale.name
          }));
          var startKey = stringUtils.padDate(self.currentYear, self.currentMonth, dayCnt);
          th.attr('data-key', startKey);
          self.setDisabled(th, year, month, dayCnt);
          self.setLegendColor(th, year, month, dayCnt);
          th.attr('role', 'link');
          dayCnt++;
          return;
        }

        if (dayCnt >= thisMonthDays + 1) {
          exDay = nextMonthDayCnt;
          exMonth = month === 11 ? 0 : month + 1;
          exYear = month === 11 ? year + 1 : year;
          self.dayMap.push({
            key: stringUtils.padDate(exYear, exMonth, exDay),
            elem: th
          });
          self.setDisabled(th, exYear, exMonth, exDay);
          self.setLegendColor(th, exYear, exMonth, exDay);
          th.addClass('alternate next-month').html("<span class=\"day-container\"><span aria-hidden=\"true\" class=\"day-text\">".concat(nextMonthDayCnt, "</span></span>"));
          th.attr('data-key', stringUtils.padDate(exYear, exMonth, exDay));
          nextMonthDayCnt++;
        }
      });

      if (!foundSelected && !s.range.useRange) {
        var firstDay = self.dayMap.filter(function (d) {
          return d.key === stringUtils.padDate(year, month, _this3.settings.day);
        });

        if (firstDay.length) {
          setSelected(firstDay[0].elem, false);
        }
      } // Hide 6th Row if all disabled


      var row = this.days.find('tr').eq(5);

      if (row.find('td.alternate').length === 7) {
        row.hide();
      } else {
        row.show();
      }

      if (!this.currentDate) {
        if (this.isIslamic) {
          this.currentDateIslamic = [this.currentYear, this.currentMonth, this.currentDay];
          this.currentDate = Locale.umalquraToGregorian(this.currentYear, this.currentMonth, this.currentDay);
        } else {
          this.currentDate = new Date(this.currentYear, this.currentMonth, this.currentDay);
        }
      }

      this.setRangeSelection();
      this.validatePrevNext(); // Allow focus on the same day as last month

      if (!s.range.useRange && this.element.find('td.is-selected').length === 0) {
        this.element.find('td[tabindex]').removeAttr('tabindex');
        this.element.find('td:not(.alternate) .day-text').first().closest('td').attr('tabindex', '0');
      }
      /**
      * Fires as the calendar popup is opened.
      * @event monthrendered
      * @memberof MonthView
      * @property {object} event - The jquery event object
      * @property {object} args - The event arguments
      * @property {number} args.year - The rendered year
      * @property {object} args.elem - The DOM object
      * @property {object} args.api - The MonthView api
      */


      this.element.trigger('monthrendered', {
        year: year,
        month: month,
        elem: this.element,
        api: this
      });
    },

    /**
      * Get a unqiue and comparable time from the date.
      * @param  {date|Array} date The arabic array or date
      * @param  {boolean} zeroMinutes set the minutes part to zero
      * @returns {string} comparable time string
      */
    getTime: function getTime(date, zeroMinutes) {
      if (this.isIslamic) {
        return date[0] + "0".concat(date[1]).slice(-2) + "0".concat(date[2]).slice(-2);
      }

      if (zeroMinutes) {
        var d = new Date(date);
        d.setHours(0, 0, 0);
        return d.getTime();
      }

      return date.getTime();
    },

    /**
     * Set range selection
     * @private
     * @returns {void}
     */
    setRangeSelection: function setRangeSelection() {
      if (this.settings.range.useRange) {
        var range = {};
        range.date = new Date(this.currentYear, this.currentMonth, 1);
        range.date.setDate(range.date.getDate() - (this.days.find('.prev-month:visible').length + 1));
        var key = stringUtils.padDate(range.date.year || range.date[0], range.date.month || range.date[1], range.date.day || range.date[2]);
        range.cell = this.days.find("[data-key=\"".concat(key, "\"]"));
        this.setRangeOnCell(this.settings.range.second ? false : range.cell);
      }
    },

    /**
     * Append month year picker
     * @private
     * @param {number} month The month to show in the picker
     * @param {number} year The year to show in the picker
     * @returns {void}
     */
    appendMonthYearPicker: function appendMonthYearPicker(month, year) {
      var self = this;

      if (!this.settings.showMonthYearPicker) {
        return;
      }

      var monthList = '<ul class="picklist is-month">';
      var wideMonths = this.currentCalendar.months.wide;
      wideMonths.map(function (monthMap, i) {
        // eslint-disable-line
        monthList += "<li class=\"picklist-item".concat(i === month ? ' is-selected ' : '', "\"><a href=\"#\" ").concat(i === month ? 'tabindex="0" ' : 'tabindex="-1" ', "data-month=\"").concat(i, "\">").concat(monthMap, "</a></li>");
      });
      monthList += '</ul>';
      this.monthYearPane.find('.picklist-section.is-month').empty().append(monthList);
      var years = [];
      var yearList = '<ul class="picklist is-year">';
      yearList += "<li class=\"picklist-item up\"><a href=\"#\" tabindex=\"0\"><span class=\"audible\">".concat(Locale.translate('PreviousYear'), "</span><svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-up\"></use></svg></a></li>");

      for (var i = this.settings.yearsBack; i >= 1; i--) {
        years.push(parseInt(year, 10) - i);
      }

      years.push(year);

      for (var j = 1; j <= this.settings.yearsAhead; j++) {
        years.push(parseInt(year, 10) + j);
      } // eslint-disable-next-line


      years.map(function (yearMap) {
        yearList += "<li class=\"picklist-item".concat(year === yearMap ? ' is-selected ' : '', "\"><a href=\"#\" ").concat(year === yearMap ? 'tabindex="0" ' : 'tabindex="-1" ', "data-year=\"").concat(yearMap, "\">").concat(yearMap, "</a></li>");
      });
      yearList += "<li class=\"picklist-item down\"><a tabindex=\"0\"><span class=\"audible\">".concat(Locale.translate('NextYear'), "</span><svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-down\"></use></svg></a></li>");
      yearList += '</ul>';
      this.monthYearPane.find('.picklist-section.is-year').empty().append(yearList);

      if (this.yearFirst) {
        this.monthYearPane.addClass('is-yearfirst');
      }

      utils.addAttributes(this.monthYearPane.find('.picklist-item.up a'), this, this.settings.attributes, 'btn-picklist-up');
      utils.addAttributes(this.monthYearPane.find('.picklist-item.down a'), this, this.settings.attributes, 'btn-picklist-down');
      this.monthYearPane.find('.is-year .picklist-item').not('.up, .down').each(function () {
        var elem = $(this).find('a');
        utils.addAttributes(elem, self, self.settings.attributes, "btn-picklist-".concat(elem.text().toLowerCase()));
      });
      this.monthYearPane.find('.is-month .picklist-item').not('.up, .down').each(function (i) {
        utils.addAttributes($(this).find('a'), self, self.settings.attributes, "btn-picklist-".concat(i));
      });
    },

    /**
     * Find first day of the week for a given month
     * @private
     * @param {number} year The year to use with the month
     * @param {number} month The month to find the first day for
     * @returns {number} day
     */
    firstDayOfMonth: function firstDayOfMonth(year, month) {
      if (this.isIslamic) {
        var firstDay = Locale.umalquraToGregorian(year, month, 1);
        return firstDay === null ? 1 : firstDay.getDay();
      }

      return new Date(year, month, 1).getDay();
    },

    /**
     * Find the date of the Month (29, 30, 31 ect)
     * @private
     * @param {number} year The year to use with the month
     * @param {number} month The month to find the days in month for
     * @returns {number} date
     */
    daysInMonth: function daysInMonth(year, month) {
      if (this.isIslamic) {
        var monthLengthBitmap = this.conversions.yearInfo[this.islamicYearIndex(year)][0];
        var monthDayCount = 0;

        for (var M = 0; M <= month; M++) {
          // eslint-disable-next-line
          monthDayCount = 29 + (monthLengthBitmap & 1);

          if (M === month) {
            return monthDayCount;
          } // eslint-disable-next-line


          monthLengthBitmap = monthLengthBitmap >> 1;
        }

        return 0;
      }

      return new Date(year, month, 0).getDate();
    },

    /**
     * Get the islamic year index
     * @private
     * @param {number} islamicYear Year to test.
     * @returns {number} index
     */
    islamicYearIndex: function islamicYearIndex(islamicYear) {
      var yearIdx = islamicYear - 1318;

      if (yearIdx < 0 || yearIdx >= this.conversions.yearInfo.length) {
        return 0; // for an out-of-range year, simply returns 0
      }

      return yearIdx;
    },

    /**
     * Set disable Date
     * @private
     * @param {object} elem Node element to set.
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {void}
     */
    setDisabled: function setDisabled(elem, year, month, date) {
      var s = this.settings;

      function makeDisable() {
        elem.addClass('is-disabled').attr('aria-disabled', 'true').removeClass('is-selected range').removeAttr('aria-selected');
      } // Reset


      elem.removeClass('is-disabled').removeAttr('aria-disabled');

      if (typeof s.disable.callback === 'function') {
        $.when(this.isDateDisabled(year, month, date)).then(function (dateIsDisabled) {
          if (dateIsDisabled) {
            makeDisable();
          }
        });
      } else {
        var dateIsDisabled = this.isDateDisabled(year, month, date);

        if (dateIsDisabled && !s.disable.isEnable || !dateIsDisabled && s.disable.isEnable) {
          makeDisable();
        }
      }
    },

    /**
     * Check through the options to see if the date is disabled
     * @private
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {boolean} true if the date is disabled
     */
    isDateDisabled: function isDateDisabled(year, month, date) {
      var s = this.settings;

      if (typeof s.disable.callback === 'function') {
        var deferred = $.Deferred();
        $.when(s.disable.callback(year, month, date)).then(function (results) {
          deferred.resolve(results);
        });
        return deferred.promise();
      }

      var min = new Date(s.disable.minDate).setHours(0, 0, 0, 0);
      var max = new Date(s.disable.maxDate).setHours(0, 0, 0, 0);
      var d2 = this.isIslamic ? Locale.umalquraToGregorian(year, month, date) : new Date(year, month, date);

      if (!d2) {
        return false;
      } // dayOfWeek


      if (s.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
        return true;
      }

      var thisYear = d2.getFullYear();
      d2 = d2.setHours(0, 0, 0, 0); // min and max

      if (d2 <= min || d2 >= max) {
        return true;
      } // years


      if (/string|number/.test(_typeof(s.disable.years))) {
        s.disable.years = [s.disable.years];
      }

      for (var i = 0, l = s.disable.years.length; i < l; i++) {
        if (thisYear === Number(s.disable.years[i])) {
          return true;
        }
      } // dates


      if (s.disable.dates.length && typeof s.disable.dates === 'string') {
        s.disable.dates = [s.disable.dates];
      }

      for (var _i = 0, _l = s.disable.dates.length; _i < _l; _i++) {
        var d = new Date(s.disable.dates[_i]);

        if (d2 === d.setHours(0, 0, 0, 0)) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get array of dates between two dates
     * @private
     * @param {object} startDate .
     * @param {object} endDate .
     * @param {boolean} includeDisabled .
     * @returns {array} dates between two dates
     */
    getDateRange: function getDateRange(startDate, endDate, includeDisabled) {
      var dates = [];
      var current = this.isIslamic ? _toConsumableArray(startDate) : new Date(startDate);
      includeDisabled = typeof includeDisabled !== 'undefined' ? includeDisabled : this.settings.range.includeDisabled;

      while (this.getTime(endDate) >= this.getTime(current)) {
        if (includeDisabled || !includeDisabled && !this.isDateDisabled(this.isIslamic ? current[0] : current.getFullYear(), this.isIslamic ? current[1] : current.getMonth(), this.isIslamic ? current[2] : current.getDate())) {
          if (this.isIslamic) {
            dates.push(current);
          } else {
            dates.push(new Date(current));
          }
        }

        if (this.isIslamic) {
          current[2] += 1;
        } else {
          current.setDate(current.getDate() + 1);
        }
      }

      return dates;
    },

    /**
     * Set Color for the Legend settings
     * @private
     * @param {object} elem to set.
     * @param {string} year to check.
     * @param {string} month to check.
     * @param {string} date to check.
     * @returns {void}
     */
    setLegendColor: function setLegendColor(elem, year, month, date) {
      if (!this.settings.showLegend || !elem[0]) {
        return;
      }

      var hex = this.getLegendColor(year, month, date);
      elem[0].style.backgroundColor = '';
      elem.off('mouseenter.legend mouseleave.legend');

      if (hex) {
        if (hex.indexOf('#') === -1) {
          var name = hex.replace(/[0-9]/g, '');
          var number = hex.substr(hex.length - 2, 2) * 10;
          hex = theme.themeColors().palette[name][number].value;
        } // set color on elem at .3 of provided color as per design


        elem.addClass('is-colored');
        elem[0].style.backgroundColor = colorUtils.hexToRgba(hex, 0.3);
        var normalColor = colorUtils.hexToRgba(hex, 0.3);
        var hoverColor = colorUtils.hexToRgba(hex, 0.7); // handle hover states

        elem.on('mouseenter.legend', function () {
          var thisElem = $(this);
          thisElem[0].style.backgroundColor = hoverColor;
          thisElem.find('span')[0].style.backgroundColor = 'transparent';
          thisElem.find('.day-text')[0].style.backgroundColor = 'transparent';
        }).on('mouseleave.legend', function () {
          var thisElem = $(this);
          thisElem[0].style.backgroundColor = normalColor;
          thisElem.find('span')[0].style.backgroundColor = '';
          thisElem.find('.day-text')[0].style.backgroundColor = '';
        });
      }
    },

    /**
     * Process Color Options to get the date color
     * @private
     * @param {string} year .
     * @param {string} month .
     * @param {string} date .
     * @returns {string} date color
     */

    /* eslint-disable consistent-return */
    getLegendColor: function getLegendColor(year, month, date) {
      var s = this.settings;

      if (!s.showLegend) {
        return;
      }

      var checkDate = new Date(year, month, date);
      var checkHours = checkDate.setHours(0, 0, 0, 0);

      for (var i = 0; i < s.legend.length; i++) {
        var series = s.legend[i]; // Check Day of week

        if (series.dayOfWeek && series.dayOfWeek.indexOf(checkDate.getDay()) !== -1) {
          return series.color;
        } // Check for dates that match


        if (series.dates) {
          for (var j = 0; j < series.dates.length; j++) {
            var d = new Date(series.dates[j]);

            if (checkHours === d.setHours(0, 0, 0, 0)) {
              return series.color;
            }
          }
        }
      }

      return '';
    },

    /* eslint-enable consistent-return */

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this4 = this;

      var self = this;
      var s = this.settings;
      this.element.off("updated.".concat(COMPONENT_NAME$A)).on("updated.".concat(COMPONENT_NAME$A), function () {
        _this4.updated();
      }); // Change Month Events

      this.header.off('click.monthview').on('click.monthview', '.btn-icon', function () {
        var isNext = $(this).is('.next');
        var range = {};
        var d = {
          month: self.currentMonth,
          year: self.currentYear
        };

        if (s.range.useRange) {
          if (isNext) {
            range.date = new Date(d.year, d.month + 1, self.element.find('.next-month:visible').length + 1);
          } else {
            range.date = new Date(d.year, d.month, 1);
            range.date.setDate(range.date.getDate() - (self.days.find('.prev-month:visible').length + 1));
          }

          d.month += isNext ? 1 : -1;
        } else {
          self.currentMonth += isNext ? 1 : -1;
          self.currentDate.setMonth(self.currentMonth);
          self.currentYear = parseInt(self.element[0].querySelector('span.year').innerText, 10);
          self.currentDate.setFullYear(self.currentYear);
          d.month = self.currentMonth;
          d.year = self.currentYear;
        }

        self.showMonth(d.month, d.year);

        if (s.range.useRange) {
          range.formatedDate = Locale.formatDate(range.date, {
            date: 'full',
            locale: self.locale.name
          });
          range.cell = self.days.find("[aria-label=\"".concat(range.formatedDate, "\"]"));
          self.setRangeOnCell(s.range.second ? false : range.cell);
        }
      });

      if (s.range.useRange) {
        this.header.off('mouseover.datepicker').on('mouseover.datepicker', 'button', function () {
          if (s.range.extra) {
            self.setRangeOnCell($(this).is('.next') ? s.range.extra.maxCell : s.range.extra.minCell);
          }
        }).off('focus.datepicker').on('focus.datepicker', 'button:not(.hide-focus)', function () {
          if (s.range.extra) {
            self.setRangeOnCell($(this).is('.next') ? s.range.extra.maxCell : s.range.extra.minCell);
          }
        });
        this.days.off('mouseover.datepicker').on('mouseover.datepicker', 'td', function () {
          self.setRangeOnCell(this);
        });
      }

      if (this.calendarToolbarEl) {
        this.calendarToolbarEl.off('change-date.monthview').on('change-date.monthview', function (e, args) {
          if (args.isToday && _this4.settings.isPopup) {
            return;
          }

          if (args.isToday) {
            _this4.setToday();

            return;
          }

          _this4.selectDay(args.selectedDate, false, true);
        });
      } // Allow dates to be selected


      if (s.selectable) {
        this.element.addClass('is-selectable').off('click.monthview-day').on('click.monthview-day', 'td', function (e) {
          var key = e.currentTarget.getAttribute('data-key');
          _this4.lastClickedKey = key;

          if (e.currentTarget.classList.contains('is-disabled')) {
            return;
          }

          _this4.selectDay(key, false, true);
        });
      }

      this.handleMonthYearPane().handleKeys();
      return this;
    },

    /**
     * Handle events and keys on the month year pane
     * @private
     * @returns {object} The component for chaining.
     */
    handleMonthYearPane: function handleMonthYearPane() {
      var _this5 = this;

      var s = this.settings;

      var appendYear = function appendYear(upDown) {
        var yearContainer = _this5.monthYearPane[0].querySelector('.picklist.is-year');

        var yearList = yearContainer.children;
        var year = yearList[upDown === 'up' ? 1 : yearList.length - 2].querySelector('a').getAttribute('data-year');
        DOM.remove(yearList[upDown === 'up' ? yearList.length - 2 : 1]);
        $(yearContainer).find('.picklist-item').not('.up, .down').remove();

        if (upDown === 'up') {
          for (var i = 10; i > 0; i--) {
            var nextYear = parseInt(year, 10) - i;
            var a = $("<a href=\"#\" tabindex=\"-1\" data-year=\"".concat(nextYear, "\">").concat(nextYear, "</a>"));
            var li = $('<li class="picklist-item"></li>');
            li.append(a);
            $(yearContainer).find('.picklist-item.down').before(li);
            utils.addAttributes(a, _this5, s.attributes, "btn-picklist-".concat(nextYear));
          }
        }

        if (upDown === 'down') {
          for (var _i2 = 1; _i2 < 11; _i2++) {
            var _nextYear = parseInt(year, 10) + _i2;

            var _a = $("<a href=\"#\" tabindex=\"-1\" data-year=\"".concat(_nextYear, "\">").concat(_nextYear, "</a>"));

            var _li = $('<li class="picklist-item"></li>');

            _li.append(_a);

            $(yearContainer).find('.picklist-item.down').before(_li);
            utils.addAttributes(_a, _this5, s.attributes, "btn-picklist-".concat(_nextYear));
          }
        }

        $(yearContainer).find('.picklist-item').eq(5).addClass('is-selected').attr('tabindex', '0');
      }; // Handle Long Press


      var intervalId = null;
      this.monthYearPane.off('touchstart.monthviewpane mousedown.monthviewpane').on('touchstart.monthviewpane mousedown.monthviewpane', '.picklist.is-year li', function (e) {
        intervalId = setInterval(function () {
          if (e.currentTarget.classList.contains('up')) {
            appendYear('up');
          }

          if (e.currentTarget.classList.contains('down')) {
            appendYear('down');
          }

          e.stopImmediatePropagation();
          e.stopPropagation();
          return false;
        }, 200);
        return true;
      }).off('touchend.monthviewpane touchcancel.monthviewpane mouseup.monthviewpane mouseout.monthviewpane').on('touchend.monthviewpane touchcancel.monthviewpane mouseup.monthviewpane mouseout.monthviewpane', '.picklist.is-year li', function () {
        clearInterval(intervalId);
        return true;
      });

      var selectPicklistItem = function selectPicklistItem(target, cssClass) {
        var selectedElem = _this5.monthYearPane[0].querySelector(".picklist.".concat(cssClass, " .is-selected"));

        DOM.removeClass(selectedElem, 'is-selected');

        if (selectedElem) {
          selectedElem.querySelector('a').setAttribute('tabindex', '-1');
        }

        DOM.addClass(target.parentNode, 'is-selected');
        target.setAttribute('tabindex', '0');
      }; // Set selecting the month or year
      // by click, keyboard from `monthYearPane`
      // target: clicked or keyed element
      // cssClass: target option `is-month` or `is-year`


      var setMonthYearPane = function setMonthYearPane(target, cssClass) {
        var elem = function elem(sel) {
          return _this5.monthYearPane[0].querySelector(".is-".concat(sel, " .is-selected a"));
        };

        var d = cssClass === 'is-month' ? {
          month: parseInt(target.getAttribute('data-month'), 10),
          year: parseInt(elem('year').getAttribute('data-year'), 10)
        } : {
          month: parseInt(elem('month').getAttribute('data-month'), 10),
          year: parseInt(target.getAttribute('data-year'), 10)
        };

        if (!s.range.useRange) {
          _this5.currentMonth = d.month;

          _this5.currentDate.setMonth(_this5.currentMonth);

          _this5.currentYear = d.year;

          _this5.currentDate.setFullYear(_this5.currentYear);

          d.month = _this5.currentMonth;
          d.year = _this5.currentYear;
        }

        selectPicklistItem(target, cssClass);

        if (_this5.element.hasClass("".concat(cssClass, "only"))) {
          _this5.monthYearPane.parent().find('button.is-select-month').click();
        }
      }; // Handle selecting a year, or month


      this.monthYearPane.off('click.picklist-month').on('click.picklist-month', '.picklist.is-month li', function (e) {
        setMonthYearPane(e.target, 'is-month');
        e.preventDefault();
      });
      this.monthYearPane.off('click.picklist-month-a').on('click.picklist-month-a', '.picklist.is-month li a', function (e) {
        e.preventDefault();
      });
      this.monthYearPane.off('click.picklist-year').on('click.picklist-year', '.picklist.is-year li', function (e) {
        if (e.currentTarget.classList.contains('up')) {
          appendYear('up');
          return;
        }

        if (e.currentTarget.classList.contains('down')) {
          appendYear('down');
          return;
        }

        setMonthYearPane(e.target, 'is-year');
        e.preventDefault();
      });
      this.monthYearPane.off('click.picklist-year-a').on('click.picklist-year-a', '.picklist.is-year li a', function (e) {
        e.preventDefault();
      }); // Handle behaviors when expanding and collapsing like disabling buttons and setting height

      this.monthYearPane.on('expand.monthviewpane', function () {
        // Disable the main page buttons for tabbing
        if (!s.hideDays) {
          _this5.element.find('.btn-icon, td.is-selected').attr('disabled', 'true');

          _this5.element.find('td.is-selected').removeAttr('tabindex'); // Set the height


          _this5.monthYearPane.find('.content').css('height', _this5.header.parent().height() - _this5.header.height() - 55); // 45 is the footer height
          // Rename some buttons


          _this5.element.find('.hyperlink.today').hide();

          _this5.element.find('.is-select').removeClass('is-select').addClass('is-select-month-pane');

          _this5.element.find('.is-cancel').removeClass('is-cancel').addClass('is-cancel-month-pane').text(Locale.translate('Cancel', {
            locale: _this5.locale.name,
            language: _this5.language
          }));
        } // Focus the month


        setTimeout(function () {
          var selectedMonth = _this5.monthYearPane.find('.is-month .is-selected a');

          selectedMonth.focus();

          if (_this5.monthYearPane.parent().hasClass('is-yearonly')) {
            _this5.monthYearPane.find('.is-year .is-selected a').focus();
          }
        });
      }).on('collapse.monthviewpane', function () {
        // Enable it all again
        if (!s.hideDays) {
          _this5.element.find('.btn-icon').removeAttr('disabled');

          _this5.element.find('td.is-selected').attr('tabindex', '0');

          _this5.element.find('.hyperlink.today').show();

          _this5.element.find('.is-select-month-pane').addClass('is-select').removeClass('is-select-month-pane');

          _this5.element.find('.is-cancel-month-pane').addClass('is-cancel').removeClass('is-cancel-month-pane').text(Locale.translate('Clear', {
            locale: _this5.locale.name,
            language: _this5.language
          }));
        }
      }); // Handle keyboard on the month year pane

      var moveToItem = function moveToItem(e, nextPrev) {
        var a = e.currentTarget;
        var li = e.currentTarget.parentNode;
        var adjacentLi = nextPrev === 'prev' ? li.previousSibling : li.nextSibling;

        if (!adjacentLi) {
          adjacentLi = li.parentNode.children[nextPrev === 'prev' ? li.parentNode.children.length - 1 : 0];
        }

        var adjacentA = adjacentLi.querySelector('a');
        a.setAttribute('tabindex', '-1');
        li.parentNode.querySelector('.is-selected').classList.remove('is-selected');
        DOM.addClass(adjacentLi, 'is-selected');
        adjacentA.setAttribute('tabindex', '0');
        adjacentA.focus();
      };

      this.monthYearPane.off('keydown.monthviewpane').on('keydown.monthviewpane', '.picklist-item a', function (e) {
        var isUp = e.currentTarget.parentNode.classList.contains('up');
        var isDown = e.currentTarget.parentNode.classList.contains('down');
        var isYear = e.currentTarget.parentNode.parentNode.classList.contains('is-year');
        var isMonth = e.currentTarget.parentNode.parentNode.classList.contains('is-month');
        var handle = false;

        if (e.key === 'ArrowUp' && (isYear || isMonth)) {
          moveToItem(e, 'prev');
          handle = true;
        } else if (e.key === 'ArrowDown' && (isYear || isMonth)) {
          moveToItem(e, 'next');
          handle = true;
        } else if (e.key === 'Enter') {
          if (isUp || isDown) {
            appendYear(isUp ? 'up' : 'down');
            handle = true;
          } else if (isYear || isMonth) {
            setMonthYearPane(e.target, isYear ? 'is-year' : 'is-month');
            handle = true;
          }
        }

        if (handle) {
          e.preventDefault();
        }
      });
      return this;
    },

    /**
     * Select a specific date visually.
     * @private
     * @param {date | string} date specific date or a date key (hash string of the date)
     * @param {boolean} closePopup Send a flag to close the popup
     * @param {boolean} insertDate Send a flag to insert the date in the field
    */
    selectDay: function selectDay(date, closePopup, insertDate) {
      if (this.isIslamic && typeof date !== 'string') {
        this.currentDateIslamic = Locale.gregorianToUmalqura(date);
        date = stringUtils.padDate(this.currentDateIslamic[0], this.currentDateIslamic[1], this.currentDateIslamic[2]);
      }

      if (!this.isIslamic && typeof date !== 'string') {
        date = stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
      }

      var dayObj = this.dayMap.filter(function (dayFilter) {
        return dayFilter.key === date;
      });
      var year = parseInt(date.substr(0, 4), 10);
      var month = parseInt(date.substr(4, 2), 10) - 1;
      var day = parseInt(date.substr(6, 2), 10);

      if (this.isIslamic) {
        this.currentDateIslamic = date;
        this.currentDate = Locale.umalquraToGregorian(year, month, day);
      } else {
        this.currentDate = new Date(year, month, day);
      }

      this.currentYear = year;
      this.currentMonth = month;
      this.currentDay = day;

      if (dayObj.length === 0 || dayObj[0].elem.hasClass('alternate')) {
        // Show month
        this.showMonth(month, year);
        dayObj = this.dayMap.filter(function (dayFilter) {
          return dayFilter.key === date;
        });
      } // Error - date not found


      if (!dayObj.length === 0) {
        return;
      }

      var node = dayObj[0].elem[0];
      var args = {
        node: node,
        key: date,
        day: day,
        month: month,
        year: year,
        close: closePopup
      };
      delete this.isKeyClick;
      this.element.find('td.is-selected').removeClass('is-selected').removeAttr('tabindex');
      $(node).addClass('is-selected').attr('tabindex', '0').focus();
      insertDate = this.settings.headerStyle === 'full' ? true : insertDate;

      if (insertDate && this.settings.onSelected) {
        this.settings.onSelected(node, args);
      }

      if (insertDate) {
        this.element.trigger('selected', args);
      }
    },

    /**
     * Select todays date visually.
     */
    setToday: function setToday() {
      this.selectDay(new Date(), false, true);
    },

    /**
     * Attach keyboard events for the calendar.
     * @private
     */
    handleKeys: function handleKeys() {
      var _this6 = this;

      var s = this.settings;
      this.element.off('keydown.monthview').on('keydown.monthview', '.monthview-table', function (e) {
        var key = e.keyCode || e.charCode || 0;
        var cell = $(e.target);

        var allCell = _this6.days.find('td:visible');

        var allCellLength = allCell.length;
        var idx = null;
        var selector = null;
        var handled = false;
        var minDate = new Date(s.disable.minDate);
        var maxDate = new Date(s.disable.maxDate);

        var resetRange = function resetRange() {
          if (_this6.datepickerApi && s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
            _this6.datepickerApi.resetRange({
              isData: true
            });
          }
        };

        if (_this6.settings.onKeyDown) {
          var callbackResult = _this6.settings.onKeyDown({
            e: e,
            key: key,
            cell: cell,
            node: _this6.element
          });

          if (callbackResult === false) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        } // Arrow Down: select same day of the week in the next week


        if (key === 40) {
          handled = true;

          if (s.range.useRange) {
            idx = allCell.index(e.target) + 7;
            selector = allCell.eq(idx);

            if (idx < allCellLength) {
              resetRange();

              _this6.setRangeOnCell(selector.is('.is-selected') ? null : selector);

              _this6.setRangeSelBeforeFirstSel(selector);

              _this6.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this6.currentDate.getMonth() < maxDate.getMonth()) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() + 7);
            } else if (maxDate.getDate() - 1 >= _this6.currentDate.getDate() + 7) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() + 7);
            }

            _this6.selectDay(_this6.currentDate, false, false);
          } else {
            _this6.currentDate.setDate(_this6.currentDate.getDate() + 7);

            _this6.selectDay(_this6.currentDate, false, false);
          }
        } // Arrow Up: select same day of the week in the previous week


        if (key === 38) {
          handled = true;

          if (s.range.useRange) {
            idx = allCell.index(e.target) - 7;
            selector = allCell.eq(idx);

            if (idx > -1) {
              resetRange();

              _this6.setRangeOnCell(selector.is('.is-selected') ? null : selector);

              _this6.setRangeSelBeforeFirstSel(selector);

              _this6.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this6.currentDate.getMonth() > minDate.getMonth()) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() - 7);
            } else if (minDate.getDate() + 1 <= _this6.currentDate.getDate() - 7) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() - 7);
            }

            _this6.selectDay(_this6.currentDate, false, false);
          } else {
            _this6.currentDate.setDate(_this6.currentDate.getDate() - 7);

            _this6.selectDay(_this6.currentDate, false, false);
          }
        } // Arrow Left or - key


        if (key === 37 || key === 189 && !e.shiftKey) {
          handled = true;

          if (s.range.useRange) {
            idx = allCell.index(e.target) - 1;
            selector = allCell.eq(idx);

            if (idx > -1) {
              resetRange();

              _this6.setRangeOnCell(selector.is('.is-selected') ? null : selector);

              _this6.setRangeSelBeforeFirstSel(selector);

              _this6.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this6.currentDate.getMonth() > minDate.getMonth()) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() - 1);
            } else if (minDate.getDate() + 1 !== _this6.currentDate.getDate()) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() - 1);
            }

            _this6.selectDay(_this6.currentDate, false, false);
          } else {
            _this6.currentDate.setDate(_this6.currentDate.getDate() - 1);

            _this6.selectDay(_this6.currentDate, false, false);
          }
        } // Arrow Right or + key


        if (key === 39 || key === 187 && e.shiftKey) {
          handled = true;

          if (s.range.useRange) {
            idx = allCell.index(e.target) + 1;
            selector = allCell.eq(idx);

            if (idx < allCellLength) {
              resetRange();

              _this6.setRangeOnCell(selector.is('.is-selected') ? null : selector);

              _this6.setRangeSelBeforeFirstSel(selector);

              _this6.activeTabindex(selector, true);
            }
          } else if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this6.currentDate.getMonth() < maxDate.getMonth()) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() + 1);
            } else if (maxDate.getDate() - 1 !== _this6.currentDate.getDate()) {
              _this6.currentDate.setDate(_this6.currentDate.getDate() + 1);
            }

            _this6.selectDay(_this6.currentDate, false, false);
          } else {
            _this6.currentDate.setDate(_this6.currentDate.getDate() + 1);

            _this6.selectDay(_this6.currentDate, false, false);
          }
        } // Page Up Selects Same Day Prev Month


        if (key === 33 && !e.altKey) {
          handled = true;
          resetRange();

          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (minDate.getMonth() !== _this6.currentDate.getMonth()) {
              _this6.currentDate.setMonth(_this6.currentDate.getMonth() - 1);

              _this6.selectDay(_this6.currentDate, false, false);
            }
          } else {
            _this6.currentDate.setMonth(_this6.currentDate.getMonth() - 1);

            _this6.selectDay(_this6.currentDate, false, false);
          }
        } // Page Down Selects Same Day Next Month


        if (key === 34 && !e.altKey) {
          handled = true;
          resetRange();

          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this6.currentDate.getMonth() !== maxDate.getMonth()) {
              _this6.currentDate.setMonth(_this6.currentDate.getMonth() + 1);

              _this6.selectDay(_this6.currentDate, false, false);
            }
          } else {
            _this6.currentDate.setMonth(_this6.currentDate.getMonth() + 1);

            _this6.selectDay(_this6.currentDate, false, false);
          }
        } // ctrl + Page Up Selects Same Day previous Year


        if (key === 33 && e.ctrlKey) {
          handled = true;
          resetRange();

          _this6.currentDate.setFullYear(_this6.currentDate.getFullYear() - 1);

          _this6.selectDay(_this6.currentDate, false, false);
        } // ctrl + Page Down Selects Same Day next Year


        if (key === 34 && e.ctrlKey) {
          handled = true;
          resetRange();

          _this6.currentDate.setFullYear(_this6.currentDate.getFullYear() + 1);

          _this6.selectDay(_this6.currentDate, false, false);
        } // Home Moves to Start of the month


        if (key === 36) {
          handled = true;
          var d = _this6.currentDate;
          var firstDay;
          resetRange();

          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (minDate.getMonth() !== _this6.currentDate.getMonth()) {
              firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
            } else {
              firstDay = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
              firstDay.setDate(firstDay.getDate() + 1);
            }
          } else {
            firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
          }

          _this6.currentDate = firstDay;

          if (_this6.isIslamic) {
            _this6.currentDateIslamic = Locale.gregorianToUmalqura(_this6.currentDate);
          }

          _this6.selectDay(_this6.currentDate, false, false);
        } // End Moves to End of the month


        if (key === 35) {
          handled = true;
          var _d = _this6.currentDate;
          var lastDay;
          resetRange();

          if (s.disable.restrictMonths && s.disable.minDate && s.disable.maxDate) {
            if (_this6.currentDate.getMonth() !== maxDate.getMonth()) {
              lastDay = new Date(_d.getFullYear(), _d.getMonth() + 1, 0);
            } else {
              lastDay = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
              lastDay.setDate(lastDay.getDate() - 1);
            }
          } else {
            lastDay = new Date(_d.getFullYear(), _d.getMonth() + 1, 0);
          }

          _this6.currentDate = lastDay;

          if (_this6.isIslamic) {
            _this6.currentDateIslamic = Locale.gregorianToUmalqura(_this6.currentDate);
          }

          _this6.selectDay(_this6.currentDate, false, false);
        } // 't' selects today


        if (key === 84) {
          if (s.range.useRange && _this6.datepickerApi) {
            resetRange();
            var keepFocus = !(s.range.first && s.range.first.date && (!s.range.second || s.range.second && !s.range.second.date));

            _this6.datepickerApi.setToday(keepFocus);

            if (!keepFocus && _this6.datepickerApi && typeof _this6.datepickerApi.closeCalendar === 'function') {
              _this6.datepickerApi.closeCalendar();
            }
          } else {
            _this6.setToday();
          }

          handled = true;
        } // Space or Enter closes Date Picker, selecting the Date


        if (key === 32 || key === 13) {
          handled = true;

          if (s.range.useRange) {
            if (!s.range.first || s.range.first && !s.range.first.date) {
              allCell.removeClass('is-selected');
            }

            cell.focus().trigger('click');
            return false;
          }

          var _d2 = _this6.getCellDate(cell);

          if (_this6.isIslamic) {
            _this6.currentDateIslamic = [_d2.year, _d2.month, _d2.day];
            _this6.currentDate = Locale.umalquraToGregorian(_this6.currentDateIslamic[0], _this6.currentDateIslamic[1], _this6.currentDateIslamic[2]);
          } else {
            _this6.currentDate = new Date(_d2.year, _d2.month, _d2.day);
          }

          _this6.selectDay(_this6.currentDate, true, true);
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        return true;
      });
    },

    /**
     * Validate the Previous and Next Button availability.
     * @private
     */
    validatePrevNext: function validatePrevNext() {
      if (!this.settings.disable.restrictMonths || !this.settings.disable.minDate || !this.settings.disable.maxDate) {
        return;
      }

      var minDate = new Date(this.settings.disable.minDate);
      var maxDate = new Date(this.settings.disable.maxDate);
      this.element.find('.prev').prop('disabled', false);
      this.element.find('.next').prop('disabled', false); // Wierd edge case, the user probably should use validation.

      if (minDate.getFullYear() > this.currentYear || this.currentYear > maxDate.getFullYear()) {
        this.element.find('.prev').prop('disabled', true);
        this.element.find('.next').prop('disabled', true);
        return;
      }

      if (this.currentMonth - 1 < minDate.getMonth()) {
        this.element.find('.prev').prop('disabled', true);
      }

      if (this.currentMonth + 1 > maxDate.getMonth()) {
        this.element.find('.next').prop('disabled', true);
      }
    },

    /**
     * Add a Legend below the table
     * @private
     * @returns {void}
     */
    addLegend: function addLegend() {
      var s = this.settings;

      if (!s.showLegend) {
        return;
      } // Remove Legend


      if (this.legend && this.legend.length) {
        this.legend.remove();
      }

      this.legend = $('<div class="monthview-legend"></div>');

      for (var i = 0; i < s.legend.length; i++) {
        var series = s.legend[i];
        var hex = series.color;

        if (hex.indexOf('#') === -1) {
          var name = hex.replace(/[0-9]/g, '');
          var number = hex.substr(hex.length - 2, 2) * 10;
          hex = theme.themeColors().palette[name][number].value;
        }

        var item = '' + "<div class=\"monthview-legend-item\">\n          <span class=\"monthview-legend-swatch\" style=\"background-color: ".concat(colorUtils.hexToRgba(hex, 0.3), "\"></span>\n          <span class=\"monthview-legend-text\">").concat(series.name, "</span>\n        </div>");
        this.legend.append(item);
      }

      this.table.after(this.legend);
    },

    /**
     * Set range on given cell -or- current month/year.
     * @private
     * @param {object} cell to set range.
     * @returns {void}
     */
    setRangeOnCell: function setRangeOnCell(cell) {
      var self = this;
      var s = this.settings;

      if (s.range.useRange && s.range.first && !s.range.second) {
        var first = s.range.first;
        var extra = s.range.extra;
        var len = extra.cellLength - 1;
        var firstCell = first.rowIdx + first.cellIdx + len * first.rowIdx;
        cell = $(cell); // First date selected cell element

        if (cell.length && !cell.is('.is-disabled, .is-selected')) {
          var row = cell.closest('tr');
          var cellIdx = cell.index();
          var rowIdx = row.index();
          var thisCell = rowIdx + cellIdx + len * rowIdx;
          var d = self.getCellDate(cell);
          var cellDate = this.getTime(this.isIslamic ? [d.year, d.month, d.day] : new Date(d.year, d.month, d.day));
          var max = this.getDifferenceToDate(s.range.first.date, s.range.maxDays);
          self.days.find('td:visible').each(function (i) {
            var thisTd = $(this);

            if (cellDate > self.getTime(s.range.first.date) && !s.range.selectBackward && (!s.range.maxDays || s.range.maxDays > 0 && cellDate <= max.aftertime) && (i > firstCell && i <= thisCell || cellDate > self.getTime(extra.max) && i <= thisCell)) {
              thisTd.addClass('range-next');
            } else if (cellDate < self.getTime(s.range.first.date) && !s.range.selectForward && (!s.range.maxDays || s.range.maxDays > 0 && cellDate >= max.beforetime) && (i < firstCell && i >= thisCell || cellDate < self.getTime(extra.min) && i >= thisCell)) {
              thisTd.addClass('range-prev');
            } else {
              thisTd.removeClass('range-next range-prev');
            }
          });
        } else if (!cell.length) {
          self.days.find('td').removeClass('range-next range-prev');
        }
      }

      if (!cell && s.range.second) {
        self.setRangeSelected();
      }
    },

    /**
     * Get Dates with in the min and max range for the range picker.
     * @private
     * @param {object} date Date to focus around
     * @param {number} days Number of days +/-
     * @param {boolean} includeDisabled Use the disabled setting.
     * @returns {object} Dates/and difference before/afterto given date
     */
    getDifferenceToDate: function getDifferenceToDate(date, days, includeDisabled) {
      var _this7 = this;

      var difference = {};

      var move = function move(d, daystomove, isNext) {
        d = _this7.isIslamic ? Locale.umalquraToGregorian(d) : new Date(d);

        while (daystomove > 0) {
          d.setDate(d.getDate() + (isNext ? 1 : -1));

          if (includeDisabled || !includeDisabled && !_this7.isDateDisabled(d.getFullYear(), d.getMonth(), d.getDate())) {
            daystomove--;
            difference[isNext ? 'after' : 'before'] = _this7.isIslamic ? Locale.gregorianToUmalqura(new Date(d)) : new Date(d);
          }
        }

        if (isNext && difference.after) {
          difference.aftertime = _this7.getTime(difference.after);
        } else if (difference.before) {
          difference.beforetime = _this7.getTime(difference.before);
        }
      };

      includeDisabled = typeof includeDisabled !== 'undefined' ? includeDisabled : this.settings.range.includeDisabled;
      move(date, days); // previous

      move(date, days, true); // next

      return difference;
    },

    /**
     * Set range selected value
     * @private
     * @returns {void}
     */
    setRangeSelected: function setRangeSelected() {
      var _this8 = this;

      var self = this;
      var s = this.settings;

      var dateObj = function dateObj(d) {
        return _this8.isIslamic ? [d.year, d.month, d.day] : new Date(d.year, d.month, d.day);
      };

      if (s.range.useRange && s.range.second && s.range.second.date && this.days && this.days.length) {
        this.days.find('td').removeClass('range range-next range-prev range-selection end-date is-selected');
        this.days.find('td:visible').each(function () {
          var cell = $(this);
          var isDisabled = cell.is('.is-disabled') && !s.range.includeDisabled;
          var includeDisabled = cell.is('.is-disabled') && s.range.includeDisabled;
          var includeDisableClass = includeDisabled ? ' include-disabled' : '';
          var date = self.getTime(dateObj(self.getCellDate(cell)));
          var d1 = self.getTime(s.range.first.date, true);
          var d2 = self.getTime(s.range.second.date, true);

          if ((date === d1 || date === d2) && !isDisabled) {
            cell.addClass("is-selected".concat(includeDisableClass).concat(d1 !== d2 ? " range-selection".concat(date === d2 && !self.isIslamic ? ' end-date' : '') : ''));
          } else if (!self.isIslamic && date > d1 && date < d2 && !isDisabled) {
            cell.addClass("range-selection".concat(includeDisableClass));
          } else if (self.isIslamic && (d1 > date && d2 < date || d1 < date && d2 > date) && !isDisabled) {
            cell.addClass("range-selection".concat(includeDisableClass));
          }
        });
      }
    },

    /**
     * Set range selection to active cell with click.
     * @private
     * @returns {number} status
     */
    setRangeSelByClick: function setRangeSelByClick() {
      // 0: cell did not found
      // 1: cell found but not changed and not clicked
      // 2: cell found and changed but not clicked
      // 3: cell found and clicked
      var status = 0;
      var s = this.settings;

      if (s.range.useRange) {
        if (s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
          if (s.showTime && this.datepickerApi) {
            var d = {
              time1: this.getTime(s.range.first.date),
              time2: this.getTime(s.range.second.date),
              first: this.datepickerApi.setTime(s.range.first.date),
              second: this.datepickerApi.setTime(s.range.second.date)
            };

            if (d.time1 !== this.getTime(d.first)) {
              this.datepickerApi.setRangeToElem(d.first, true);
              this.datepickerApi.setRangeToElem(d.second, false);
              status = 2; // 2: cell found and changed but not clicked
            }
          } // 1: cell found but not changed and not clicked


          status = status === 0 ? 1 : status;
        } else {
          var cell;

          if (!s.range.first || s.range.first && !s.range.first.date) {
            cell = this.dayMap.filter(function (d) {
              return d.elem.is('.is-selected');
            });

            if (cell && cell.length) {
              this.days.find('td:visible').removeClass('is-selected').removeAttr('aria-selected');
              cell[0].elem.focus().trigger('click');
              status = 3; // 3: cell found and clicked
            }
          } else if (!s.range.second || s.range.second && !s.range.second.date) {
            cell = this.days.find('td.range-prev:visible').first();

            if (!cell.length) {
              cell = this.days.find('td.range-next:visible').last();
            }

            if (!cell.length) {
              cell = this.dayMap.filter(function (d) {
                return d.elem.is('.is-selected');
              });
            }

            if (cell && cell.length) {
              var elem = cell[0].elem || cell;
              elem.focus().trigger('click');
              status = 3; // 3: cell found and clicked
            }
          }
        }
      }

      return status;
    },

    /**
     * Get date from given cell.
     * @private
     * @param {object} cell to get date.
     * @returns {object} as: year, month, day
     */
    getCellDate: function getCellDate(cell) {
      var day = parseInt(cell.text(), 10);
      var month = parseInt(this.header.find('.month').attr('data-month'), 10);
      var year = parseInt(this.header.find('.year').text(), 10);

      if (cell.hasClass('prev-month')) {
        if (month === 0) {
          month = 11;
          year--;
        } else {
          month--;
        }
      } else if (cell.hasClass('next-month')) {
        if (month === 11) {
          month = 0;
          year++;
        } else {
          month++;
        }
      }

      return {
        year: year,
        month: month,
        day: day
      };
    },

    /**
     * Set range selection before first date selected
     * @private
     * @param {object} elem to set selection
     * @returns {void}
     */
    setRangeSelBeforeFirstSel: function setRangeSelBeforeFirstSel(elem) {
      var s = this.settings;

      if (s.range.useRange && $('#monthview-popup:visible')) {
        if (!s.range.first) {
          $('td', this.element).removeClass('is-selected');
          elem.addClass('is-selected');
        }
      }
    },

    /**
     * Check if file type allowed
     * @private
     * @param {object} elem to set fouus
     * @param {boolean} isFocus true if need to set foucs
     * @returns {object} element passed in
     */
    activeTabindex: function activeTabindex(elem, isFocus) {
      $('td', this.element).removeAttr('tabindex');
      elem.attr('tabindex', 0);

      if (isFocus) {
        elem.focus();
      }

      return elem;
    },

    /**
     * Handle updated settings and values.
     * @returns {object} [description]
     */
    updated: function updated() {
      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.header.off();
      this.days.off();
      this.element.off();

      if (this.monthYearPane) {
        this.monthYearPane.off();
        this.monthYearPane = null;
      }

      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @private
     * @returns {object} The prototype.
     */
    destroy: function destroy() {
      this.teardown();

      if (this.element) {
        this.element.empty();
      }

      if (this.element && this.element[0]) {
        try {
          $.removeData(this.element[0], COMPONENT_NAME$A);
        } catch (error) {} //eslint-disable-line

      }

      return this;
    }
  };

  var COMPONENT_NAME$B = 'weekview';
  var COMPONENT_NAME_DEFAULTS$1 = {
    eventTypes: [{
      id: 'example',
      label: 'Example',
      color: 'emerald07',
      checked: true,
      click: function click() {}
    }],
    filteredTypes: [],
    events: [],
    locale: null,
    language: null,
    firstDayOfWeek: 0,
    startDate: null,
    endDate: null,
    showAllDay: true,
    showTimeLine: true,
    startHour: 7,
    endHour: 19,
    showToday: true,
    showViewChanger: true,
    onChangeView: null,
    onChangeWeek: null,
    onRenderWeek: null,
    eventTooltip: 'overflow',
    iconTooltip: 'overflow'
  };
  /**
   * WeekView - Renders a Week View Calendar
   * @class WeekView
   * @param {string} element The plugin element for the constuctor
   * @param {object} [settings] The settings element.
   * @param {array} [settings.eventTypes] An array of objects with data for the event types.
   * @param {array} [settings.events] An array of objects with data for the events.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.language] The name of the language to use for this instance. If not set the current locale will be used or the passed locale will be used.
   * @param {date} [settings.startDate] Start of the week to show.
   * @param {date} [settings.endDate] End of the week to show.
   * @param {boolean} [settings.firstDayOfWeek=0] Set first day of the week. '1' would be Monday.
   * @param {boolean} [settings.showAllDay=true] Detemines if the all day events row should be shown.
   * @param {boolean} [settings.showTimeLine=true] Shows a bar across the current time.
   * @param {number} [settings.startHour=7] The hour (0-24) to end on each day.
   * @param {number} [settings.endHour=19] The hour (0-24) to end on each day.
   * @param {boolean} [settings.showToday=true] Deterimines if the today button should be shown.
   * @param {boolean} [settings.showViewChanger] If false the dropdown to change views will not be shown.
   * @param {function} [settings.onChangeView] Call back for when the view changer is changed.
   * @param {function} [settings.onChangeWeek] Call back for when the week is changed.
   * @param {function} [settings.onRenderMonth] Fires when a week is rendered, allowing you to pass back events or event types to show.
   * @param {string | function} [settings.eventTooltip] The content of event tooltip. Default value is 'overflow'
   * @param {string | function} [settings.iconTooltip] The content of event icon tooltip. Default value is 'overflow'
   * @param {string} [settings.attributes] Add extra attributes like id's to the element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function WeekView(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS$1);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  WeekView.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      // Do initialization. Build or Events ect
      if (!this.settings.startDate) {
        this.settings.startDate = dateUtils.firstDayOfWeek(new Date(), this.settings.firstDayOfWeek);
      }

      if (!this.settings.endDate) {
        this.settings.endDate = dateUtils.lastDayOfWeek(new Date(), this.settings.firstDayOfWeek);
      }

      return this.setLocaleThenBuild();
    },

    /**
     * Set current locale to be used
     * @private
     * @returns {void}
     */
    setLocaleThenBuild: function setLocaleThenBuild() {
      var _this = this;

      var languageDf = Locale.getLocale(this.settings.language);
      var localeDf = Locale.getLocale(this.settings.locale);
      $.when(localeDf, languageDf).done(function (locale, lang) {
        _this.locale = Locale.cultures[locale] || Locale.currentLocale;
        _this.language = lang || _this.settings.language || _this.locale.language;
        _this.settings.language = _this.language;

        _this.setCurrentCalendar();

        _this.build();
      });
      return this;
    },

    /**
     * Set current calendar
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.settings.language, this.settings.calendarName);
      this.isRTL = (this.locale.direction || this.locale.data.direction) === 'right-to-left';
      this.conversions = this.currentCalendar.conversions;
      return this;
    },

    /**
     * Add any needed markup to the component.
     * @private
     * @returns {object} The WeekView prototype, useful for chaining.
     */
    build: function build() {
      this.addToolbar();
      this.showWeek(this.settings.startDate, this.settings.endDate);
      this.handleEvents();
      utils.addAttributes(this.element, this, this.settings.attributes);
      return this;
    },

    /**
     * Render all the events in the current view.
     * @param {boolean} isCallback Will be set to true when a callback occurs
     * @private
     */
    renderAllEvents: function renderAllEvents(isCallback) {
      if (this.settings.onRenderWeek && !isCallback) {
        this.callOnRenderWeek();
        return;
      } // Clone and sort the array


      var eventsSorted = this.settings.events.slice(0);
      eventsSorted.sort(function (a, b) {
        return a.starts < b.starts ? -1 : a.starts > b.starts ? 1 : 0;
      }); // eslint-disable-line

      this.removeAllEvents();

      for (var i = 0; i < eventsSorted.length; i++) {
        var event = eventsSorted[i];

        if (this.settings.filteredTypes.indexOf(event.type) > -1) {
          continue;
        }

        this.renderEvent(event);
      }
    },

    /**
     * Execute onRenderWeek and handle the call back.
     * @private
     */
    callOnRenderWeek: function callOnRenderWeek() {
      var self = this;

      function response(events, eventTypes) {
        if (eventTypes && eventTypes.length > 0) {
          self.settings.eventTypes = eventTypes;
        }

        if (events && events.length > 0) {
          self.settings.events = events;
          self.renderAllEvents(true);
        }
      }

      this.settings.onRenderWeek(this.element, response, {
        api: self,
        settings: this.settings
      });
    },

    /**
     * Remove all events from the month.
     * @private
     */
    removeAllEvents: function removeAllEvents() {
      var events = this.element[0].querySelectorAll('.calendar-event');

      for (var i = 0; i < events.length; i++) {
        events[i].parentNode.removeChild(events[i]);
      }

      for (var _i = 0; _i < this.dayMap.length; _i++) {
        this.dayMap[_i].events = [];
      }
    },

    /**
     * Render a single event on the ui, use in the loop and other functions.
     * @private
     * @param  {object} event The event object.
     */
    renderEvent: function renderEvent(event) {
      var startDate = new Date(event.starts);
      var startKey = stringUtils.padDate(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());

      if (Locale.isIslamic(this.locale.name)) {
        var startDateIslamic = Locale.gregorianToUmalqura(startDate);
        startKey = stringUtils.padDate(startDateIslamic[0], startDateIslamic[1], startDateIslamic[2]);
      }

      var endDate = new Date(event.ends);
      var endKey = stringUtils.padDate(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

      if (Locale.isIslamic(this.locale.name)) {
        var endDateIslamic = Locale.gregorianToUmalqura(endDate);
        endKey = stringUtils.padDate(endDateIslamic[0], endDateIslamic[1], endDateIslamic[2]);
      }

      var days = this.dayMap.filter(function (day) {
        return day.key >= startKey && day.key <= endKey;
      });
      event.endKey = endKey;
      event.startKey = startKey;
      event = calendarShared.addCalculatedFields(event, this.locale, this.language, this.settings.eventTypes); // Event is only on this day

      if (days.length === 1 && !event.isAllDay) {
        this.appendEventToHours(days[0].elem, event);
      }

      if (days.length === 1 && event.isAllDay) {
        this.appendEventToAllDay(days[0].elem, event);
      } // Event extends multiple days or is all day


      if (days.length > 1) {
        // TODO
        for (var i = 0; i < days.length; i++) {
          var cssClass = i === 0 ? 'calendar-event-start' : 'calendar-event-continue';

          if (i === days.length - 1) {
            cssClass = 'calendar-event-ends';
          }

          this.appendEventToAllDay(days[i].elem, event, cssClass);
        }
      }
    },

    /*
     * Add the ui event to the container event day
     * @private
     * @param {object} container The container to append to
     * @param {object} event The event data object.
     * @param {string} cssClass An extra css class
     */
    appendEventToAllDay: function appendEventToAllDay(container, event, cssClass) {
      var allDayContainer = container.querySelector('.week-view-all-day-wrapper');

      if (!allDayContainer) {
        return;
      }

      var node = document.createElement('a');
      DOM.addClass(node, 'calendar-event', event.color, cssClass);
      node.setAttribute('data-id', event.id);
      node.setAttribute('data-key', event.startKey);
      node.setAttribute('href', '#');

      if (cssClass === 'calendar-event-continue' || cssClass === 'calendar-event-ends') {
        node.setAttribute('tabindex', '-1');
      }

      node.innerHTML = "<div class=\"calendar-event-content\">\n      ".concat(event.icon ? "<span class=\"calendar-event-icon\"><svg class=\"icon ".concat(event.icon, "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\" data-status=\"").concat(event.status, "\"><use href=\"#").concat(event.icon, "\"></use></svg></span>") : '', "\n      <span class=\"calendar-event-title\">").concat(event.shortSubject || event.subject, "</span>\n    </div>");
      var containerEvents = allDayContainer.querySelectorAll('.calendar-event');
      var eventCount = containerEvents.length;

      if (eventCount >= 1) {
        node.style.top = "".concat(22 * eventCount, "px");
      }

      if (eventCount > 2) {
        var nodes = this.element[0].querySelectorAll('.week-view-all-day-wrapper');

        for (var i = 0; i < nodes.length; i++) {
          nodes[i].style.height = "".concat(44 + (eventCount - 1) * 23, "px");
        }
      }

      allDayContainer.appendChild(node);
      utils.addAttributes($(node), this, this.settings.attributes, "week-view-event-".concat(event.id));
      this.attachTooltip(node, event);
    },

    /**
     * Add the ui event to the container spanning hours
     * @private
     * @param {object} container The container to append to
     * @param {object} event The event data object.
     */
    appendEventToHours: function appendEventToHours(container, event) {
      var dayHourContainers = this.element[0].querySelectorAll("td:nth-child(".concat(container.cellIndex + 1, ")"));

      for (var i = 0; i < dayHourContainers.length; i++) {
        var tdEl = dayHourContainers[i];
        var hour = parseFloat(tdEl.parentNode.getAttribute('data-hour'), 10);
        var rStartsHour = Math.round(event.startsHour);
        var isUp = rStartsHour > event.startsHour;
        var startsHere = isUp ? hour === rStartsHour - 0.5 : hour === rStartsHour;

        if (startsHere) {
          var duration = event.endsHour - event.startsHour;
          var displayedTime = '';
          var node = document.createElement('a');
          DOM.addClass(node, 'calendar-event', event.color);
          node.setAttribute('data-id', event.id);
          node.setAttribute('data-key', event.startKey);
          node.setAttribute('href', '#');

          if (duration < 0.5) {
            DOM.addClass(node, 'reduced-padding', event.color);
          }

          if (duration < 1.5) {
            DOM.addClass(node, 'is-ellipsis');
          }

          if (duration > 2) {
            displayedTime = " ".concat(Locale.formatHourRange(event.startsHour, event.endsHour, {
              locale: this.locale
            }));
          } // Max out at the bottom and show the time


          if (event.startsHour + duration > this.settings.endHour) {
            DOM.addClass(node, 'is-cutoff', event.color);
            duration = this.settings.endHour + 1 - event.startsHour;
          }

          if (duration < 0.25) {
            duration = 0.25;
          } // Set css top property if there extra starting time


          if (event.startsHour > hour) {
            var unit = 0.016666666666666784; // unit for one minute

            var extra = event.startsHour - hour; // extract extra minutes

            var height = tdEl.parentNode.offsetHeight; // container height
            // calculate top value

            node.style.top = "".concat(extra / unit * (height / 30), "px"); // 30-minutes each row
          } // Add one per half hour + 1 px for each border crossed


          node.style.height = "".concat(25 * (duration * 2) + 1.5 * duration, "px");
          node.innerHTML = "<div class=\"calendar-event-content\">\n          ".concat(event.icon ? "<span class=\"calendar-event-icon\"><svg class=\"icon ".concat(event.icon, "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\" data-status=\"").concat(event.status, "\"><use href=\"#").concat(event.icon, "\"></use></svg></span>") : '', "\n          <span class=\"calendar-event-title\">").concat(event.shortSubject || event.subject).concat(displayedTime, "</span>\n        </div>");
          var containerWrapper = tdEl.querySelector('.week-view-cell-wrapper');
          var containerEvents = tdEl.querySelectorAll('.calendar-event');
          var eventCount = containerEvents.length;

          if (eventCount > 0) {
            var width = 100 / (eventCount + 1);
            var j = 0;

            for (j = 0; j < eventCount; j++) {
              containerEvents[j].style.width = "".concat(width, "%");

              if (j > 0 && this.isRTL) {
                containerEvents[j].style.right = "".concat(width * j, "%");
              }

              if (j > 0 && !this.isRTL) {
                containerEvents[j].style.left = "".concat(width * j, "%");
              }
            }

            node.style.width = "".concat(width, "%");

            if (this.isRTL) {
              node.style.right = "".concat(width * j, "%");
            } else {
              node.style.left = "".concat(width * j, "%");
            }
          }

          containerWrapper.appendChild(node);
          utils.addAttributes($(node), this, this.settings.attributes, "week-view-event-".concat(event.id));
          this.attachTooltip(node, event);
        }
      }
    },

    /**
     * Add the tooltip functionality.
     * @private
     * @param {object} node The dom element.
     * @param {object} event The event data object.
     */
    attachTooltip: function attachTooltip(node, event) {
      var _this2 = this;

      if (this.settings.iconTooltip !== 'overflow') {
        var icon = node.querySelector('.calendar-event-icon');

        if (icon) {
          if (typeof this.settings.iconTooltip === 'function') {
            this.settings.iconTooltip({
              settings: this.settings,
              event: event
            });
          } else if (event[this.settings.iconTooltip]) {
            icon.setAttribute('title', event[this.settings.iconTooltip]);
            $(icon).tooltip({
              content: icon.innerText
            });
          }
        }
      }

      if (this.settings.eventTooltip !== 'overflow') {
        if (typeof this.settings.eventTooltip === 'function') {
          this.settings.eventTooltip({
            settings: this.settings,
            event: event
          });
        } else if (event[this.settings.eventTooltip]) {
          node.setAttribute('title', event[this.settings.eventTooltip]);
          $(node).tooltip({
            content: node.innerText
          });
        }
      }

      if (!event.shortSubject && (this.settings.eventTooltip === 'overflow' || this.settings.iconToolTip === 'overflow')) {
        // Show the full text if cut off
        node.setAttribute('title', event.subject);
        $(node).tooltip({
          beforeShow: function beforeShow(response, ui) {
            var title = ui[0].querySelector('.calendar-event-title');
            var icon = ui[0].querySelector('.calendar-event-icon');
            var iconStatus = icon ? icon.querySelector('.icon').getAttribute('data-status') : '';

            if (title.offsetWidth > ui[0].scrollWidth - (icon ? icon.offsetWidth : 0)) {
              response("".concat(title.innerText).concat(iconStatus ? " (".concat(Locale.translate(iconStatus, {
                locale: _this2.locale.name
              }, false), ")") : ''));
              return;
            }

            response(false);
          }
        });
      }
    },

    /**
     * Update the weekview to show the given range of days.
     * @param {date} startDate The start of the week or range.
     * @param {date} endDate The end of the week or range.
     * @returns {void}
     */
    showWeek: function showWeek(startDate, endDate) {
      var _this3 = this;

      this.numberOfDays = Math.round((endDate - startDate) / (1000 * 60 * 60 * 24));
      var gregStartDate = new Date(startDate.getTime());
      var gregEndDate = new Date(endDate.getTime());

      if (Locale.isIslamic(this.locale.name)) {
        startDate = Locale.gregorianToUmalqura(startDate);
        startDate = new Date(startDate[0], startDate[1], startDate[2], startDate[3], startDate[4], startDate[5], startDate[6]);
        endDate = Locale.gregorianToUmalqura(endDate);
        endDate = new Date(endDate[0], endDate[1], endDate[2], endDate[3], endDate[4], endDate[5], endDate[6]);
      }

      this.dayMap = [];
      this.isDayView = false;
      this.element.removeClass('is-day-view');

      if (this.numberOfDays === 0 || this.numberOfDays === 1) {
        this.element.addClass('is-day-view');
        this.isDayView = true;
        this.element.find('#calendar-view-changer').val('day').trigger('updated');
      }

      this.hasIrregularDays = this.numberOfDays !== 7; // Create the header consisting of days in the range

      this.weekHeader = "<thead class=\"week-view-table-header\"><tr><th><div class=\"week-view-header-wrapper\"><span class=\"audible\">".concat(Locale.translate('Hour'), "</span></div>");

      if (this.settings.showAllDay) {
        this.weekHeader += "<div class=\"week-view-all-day-wrapper\">".concat(Locale.translate('AllDay', this.locale.name), "</div>");
      }

      this.weekHeader += '</th>';

      for (var day = new Date(startDate.getTime()); day <= endDate; day.setDate(day.getDate() + 1)) {
        // TODO if this is 'dd EEEE' has wierd overflow
        var dayValue = Locale.formatDate(day, {
          pattern: 'd',
          locale: this.locale.name
        });
        var dayNameValue = Locale.formatDate(day, {
          pattern: 'EEE',
          locale: this.locale.name
        });
        var dayOfWeekSetting = this.currentCalendar.dateFormat.dayOfWeek;
        var emphasis = dayOfWeekSetting ? dayOfWeekSetting.split(' ')[0] === 'EEE' : 'd EEE';
        this.weekHeader += "<th data-key=\"".concat(stringUtils.padDate(day.getFullYear(), day.getMonth(), day.getDate()), "\"><div class=\"week-view-header-wrapper").concat(dateUtils.isToday(day) ? ' is-today' : '', "\"><span class=\"week-view-header-day-of-week").concat(emphasis ? '' : ' is-emphasis', "\">").concat(emphasis ? dayNameValue : dayValue, "</span><span class=\"week-view-header-day-of-week").concat(emphasis ? ' is-emphasis' : '', "\">").concat(emphasis ? dayValue : dayNameValue, "</span></div>");

        if (this.settings.showAllDay) {
          this.weekHeader += '<div class="week-view-all-day-wrapper"></div>';
        }

        this.weekHeader += '</th>';
      }

      this.weekHeader += '</tr></thead>'; // Show the hours in the days

      this.weekBody = '<tbody>';

      for (var hour = this.settings.startHour; hour <= this.settings.endHour; hour++) {
        var weekRow = "<tr class=\"week-view-hour-row\" data-hour=\"".concat(hour, "\"><td><div class=\"week-view-cell-wrapper\">").concat(Locale.formatHour(hour, {
          locale: this.locale
        }), "</div></td>");
        var halfHourRow = "<tr class=\"week-view-half-hour-row\" data-hour=\"".concat(hour, ".5\"><td><div class=\"week-view-cell-wrapper\"></div></td>");

        for (var _day = new Date(startDate.getTime()); _day <= endDate; _day.setDate(_day.getDate() + 1)) {
          //eslint-disable-line
          weekRow += '<td><div class="week-view-cell-wrapper"></div></td>';
          halfHourRow += '<td><div class="week-view-cell-wrapper"></div></td>';
        }

        weekRow += '</tr>';
        halfHourRow += '</tr>';
        this.weekBody += weekRow + halfHourRow;
      }

      this.weekBody += '</tbody>'; // Render the table and show the event

      this.weekContainer = "<div class=\"week-view-container\"><table class=\"week-view-table\">".concat(this.weekHeader).concat(this.weekBody, "</table></div>");
      this.element.find('.week-view-container').remove();
      var args = {
        isDayView: this.isDayView,
        startDate: Locale.isIslamic(this.locale.name) ? gregStartDate : startDate,
        endDate: Locale.isIslamic(this.locale.name) ? gregEndDate : endDate,
        elem: this.element,
        api: this
      };
      /**
      * Fires as the calendar popup is opened.
      * @event weekrendered
      * @memberof WeekView
      * @property {object} event - The jquery event object
      * @property {object} args - The event arguments
      * @property {boolean} args.isDayView - True if one day is showing.
      * @property {object} args.startDate - The start date of the event
      * @property {object} args.endDate - The start date of the event
      * @property {object} args.elem - The current element.
      * @property {object} args.api - The WeekView api
      */

      this.element.append(this.weekContainer).trigger('weekrendered', args);

      if (this.settings.onChangeWeek) {
        this.settings.onChangeWeek(args);
      }

      this.element.find('th').each(function (i, elem) {
        var key = elem.getAttribute('data-key');

        if (key) {
          _this3.dayMap.push({
            key: key,
            elem: elem
          });
        }
      }); // Add the time line and update the text on the month

      this.addTimeLine();
      this.showToolbarMonth(startDate, endDate);
      this.renderAllEvents(); // Update currently set start and end date

      this.settings.startDate = Locale.isIslamic(this.locale.name) ? gregStartDate : startDate;
      this.settings.endDate = Locale.isIslamic(this.locale.name) ? gregEndDate : endDate;
    },

    /**
     * Update the weekview toolbar to show month(s) being show.
     * @private
     * @param {date} startDate The start of the week or range.
     * @param {date} endDate The end of the week or range.
     * @returns {void}
     */
    showToolbarMonth: function showToolbarMonth(startDate, endDate) {
      var startMonth = Locale.formatDate(startDate, {
        pattern: 'MMMM',
        locale: this.locale.name
      });
      var endMonth = Locale.formatDate(endDate, {
        pattern: 'MMMM',
        locale: this.locale.name
      });
      var startYear = Locale.formatDate(startDate, {
        pattern: 'yyyy',
        locale: this.locale.name
      });
      var endYear = Locale.formatDate(endDate, {
        pattern: 'yyyy',
        locale: this.locale.name
      });
      var monthStr = Locale.formatDate(endDate, {
        date: 'year',
        locale: this.locale.name
      });

      if (endMonth !== startMonth) {
        monthStr = "".concat(Locale.formatDate(startDate, {
          pattern: 'MMM',
          locale: this.locale.name
        }), " - ").concat(Locale.formatDate(endDate, {
          pattern: 'MMMM yyyy',
          locale: this.locale.name
        }));
      }

      if (endYear !== startYear) {
        monthStr = "".concat(Locale.formatDate(startDate, {
          pattern: 'MMM yyyy',
          locale: this.locale.name
        }), " - ").concat(Locale.formatDate(endDate, {
          pattern: 'MMM yyyy',
          locale: this.locale.name
        }));
      }

      this.monthField.text(monthStr);
    },

    /**
     * Add a time line on the weekview which moves.
     * @private
     */
    addTimeLine: function addTimeLine() {
      var _this4 = this;

      if (!this.settings.showTimeLine) {
        return;
      }

      var setTime = function setTime() {
        var now = new Date();
        var hours = now.getHours();
        var mins = now.getMinutes();
        var diff = hours - _this4.settings.startHour + mins / 60; // 53 is the size of one whole hour (25 + two borders)

        _this4.markers.css('top', diff * 52);
      };

      if (!this.timeMarker) {
        this.element.find('.week-view-hour-row:nth-child(1) td').prepend('<div class="week-view-time-marker"></div>');
        this.markers = $('.week-view-time-marker');
        setTime();
        this.timer = setInterval(function () {
          setTime();
        }, 30 * 1000);
      }
    },

    /**
     * Add and invoke the toolbar
     * @private
     */
    addToolbar: function addToolbar() {
      var _this5 = this;

      // Invoke the toolbar
      this.header = $('<div class="week-view-header"><div class="calendar-toolbar"></div></div>').appendTo(this.element);
      this.calendarToolbarEl = this.header.find('.calendar-toolbar');
      this.calendarToolbarAPI = new CalendarToolbar(this.calendarToolbarEl[0], {
        onOpenCalendar: function onOpenCalendar() {
          return _this5.settings.startDate;
        },
        locale: this.settings.locale,
        language: this.settings.language,
        year: this.currentYear,
        month: this.currentMonth,
        showToday: this.settings.showToday,
        isAlternate: false,
        isMenuButton: true,
        showViewChanger: this.settings.showViewChanger,
        onChangeView: this.settings.onChangeView,
        viewChangerValue: !this.isDayView ? 'week' : 'day',
        attributes: this.settings.attributes
      });
      this.monthField = this.header.find('#monthview-datepicker-field');
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this6 = this;

      this.element.off("updated.".concat(COMPONENT_NAME$B)).on("updated.".concat(COMPONENT_NAME$B), function () {
        _this6.updated();
      });
      this.element.off("change-date.".concat(COMPONENT_NAME$B)).on("change-date.".concat(COMPONENT_NAME$B), function (e, args) {
        var startDate = args.isToday ? new Date() : args.selectedDate;

        if (_this6.isDayView) {
          _this6.settings.startDate = startDate;
          _this6.settings.endDate = startDate;
        } else {
          _this6.settings.startDate = _this6.hasIrregularDays ? startDate : dateUtils.firstDayOfWeek(startDate, _this6.settings.firstDayOfWeek);

          _this6.settings.startDate.setHours(0, 0, 0, 0);

          _this6.settings.endDate = new Date(_this6.settings.startDate);

          _this6.settings.endDate.setDate(_this6.settings.endDate.getDate() + _this6.numberOfDays - 1);

          _this6.settings.endDate.setHours(23, 59, 59, 59);
        }

        _this6.showWeek(_this6.settings.startDate, _this6.settings.endDate);
      });
      this.element.off("change-next.".concat(COMPONENT_NAME$B)).on("change-next.".concat(COMPONENT_NAME$B), function () {
        _this6.advanceDays(true);
      });
      this.element.off("change-prev.".concat(COMPONENT_NAME$B)).on("change-prev.".concat(COMPONENT_NAME$B), function () {
        _this6.advanceDays(false);
      });

      var fireEvent = function fireEvent(target, eventName) {
        var eventId = target.getAttribute('data-id');

        var eventData = _this6.settings.events.filter(function (event) {
          return event.id === eventId;
        });

        if (!eventData || eventData.length === 0) {
          return;
        }
        /**
        * Fires as the calendar popup is opened.
        * @event eventclick
        * @memberof WeekView
        * @property {object} event - The jquery event object
        * @property {object} args - The event arguments
        * @property {object} args.settings - The current settings including start and end date.
        * @property {object} args.event - The event data.
        */

        /**
        * Fires as the calendar popup is opened.
        * @event eventdblclick
        * @memberof WeekView
        * @property {object} event - The jquery event object
        * @property {object} args - The event arguments
        * @property {object} args.settings - The current settings including start and end date.
        * @property {object} args.event - The event data.
        */


        _this6.element.trigger(eventName, {
          settings: _this6.settings,
          event: eventData[0]
        });
      };

      this.element.off("click.".concat(COMPONENT_NAME$B)).on("click.".concat(COMPONENT_NAME$B), '.calendar-event', function (e) {
        fireEvent(e.currentTarget, 'eventclick');
        e.preventDefault();
      });
      this.element.off("dblclick.".concat(COMPONENT_NAME$B)).on("dblclick.".concat(COMPONENT_NAME$B), '.calendar-event', function (e) {
        fireEvent(e.currentTarget, 'eventdblclick');
      });
      return this;
    },

    /**
     * Handle updated settings and values.
     * @param {boolean} advance Whether to go up or down in days.
     */
    advanceDays: function advanceDays(advance) {
      var diff = this.isDayView ? 1 : this.numberOfDays;

      if (!advance) {
        diff = -diff;
      }

      this.settings.startDate.setDate(this.settings.startDate.getDate() + diff);

      if (this.isDayView) {
        this.settings.endDate = new Date(this.settings.startDate);
        this.settings.startDate.setHours(0, 0, 0, 0);
        this.settings.endDate.setHours(23, 59, 59, 999);
      } else {
        this.settings.endDate.setDate(this.settings.endDate.getDate() + diff);
      }

      this.showWeek(this.settings.startDate, this.settings.endDate);
    },

    /**
     * Add a new event via the event object and show it if it should be visible in the calendar.
     * @param {object} event The event object with common event properties.
     */
    addEvent: function addEvent(event) {
      if (!event.startsLocale) {
        event = calendarShared.addCalculatedFields(event, this.locale, this.language, this.settings.eventTypes);
      }

      calendarShared.cleanEventData(event, true, this.settings.startDate, this.locale, this.language, this.settings.events, this.settings.eventTypes);
      this.settings.events.push(event);
      this.renderEvent(event);
    },

    /**
     * Select header for given date
     * @private
     * @param {object|string} d The date or key use for attribute in header `data-kay`.
     * @returns {void}
     */
    selectHeader: function selectHeader(d) {
      var key = d instanceof Date ? stringUtils.padDate(d.getFullYear(), d.getMonth(), d.getDate()) : d;
      var selector = {
        all: '.week-view-table-header th'
      };
      selector.current = "".concat(selector.all, "[data-key=\"").concat(key, "\"]");
      var headers = [].slice.call(this.element[0].querySelectorAll(selector.all));
      headers.forEach(function (header) {
        header.classList.remove('is-selected');
      });
      var thisHeader = this.element[0].querySelector(selector.current);

      if (thisHeader) {
        thisHeader.classList.add('is-selected');
      }
    },

    /**
     * Remove all events from the calendar
     */
    clearEvents: function clearEvents() {
      this.settings.events = [];
      this.renderAllEvents();
    },

    /**
     * Update an event via the event object and show it if it should be visible in the calendar.
     * It uses the event id to do this.
     * @param {object} event The event object with common event properties.
     */
    updateEvent: function updateEvent(event) {
      var eventId = event.id;

      for (var i = this.settings.events.length - 1; i >= 0; i--) {
        if (this.settings.events[i].id === eventId) {
          this.settings.events[i] = utils.extend(true, this.settings.events[i], event);
          calendarShared.cleanEventData(this.settings.events[i], true, this.settings.startDate, this.locale, this.language, this.settings.events, this.settings.eventTypes);
        }
      }

      this.renderAllEvents();
    },

    /**
     * Remove an event from the dataset and page. It uses the id property.
     * @param {object} event The event object with common event properties.
     */
    deleteEvent: function deleteEvent(event) {
      var eventId = event.id;

      for (var i = this.settings.events.length - 1; i >= 0; i--) {
        if (this.settings.events[i].id === eventId) {
          this.settings.events.splice(i, 1);
        }
      }

      this.renderAllEvents();
    },

    /**
     * Handle updated settings and values.
     * @param {object} settings The new settings object to use.
     * @returns {object} [description]
     */
    updated: function updated(settings) {
      if (!settings) {
        settings = {};
      }

      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (settings.locale) {
        this.destroy().init();
        return this;
      }

      this.renderAllEvents();
      return this;
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    teardown: function teardown() {
      this.element.off();
      clearInterval(this.timer);
      this.timer = null;
      return this;
    },

    /**
     * Destroy - Remove added markup and events.
     * @returns {object} The prototype.
     */
    destroy: function destroy() {
      this.teardown();
      this.element.empty();
      $.removeData(this.element[0], COMPONENT_NAME$B);
      return this;
    }
  };

  var COMPONENT_NAME$C = 'calendar';
  var COMPONENT_NAME_DEFAULTS$2 = {
    eventTypes: [{
      id: 'example',
      label: 'Example',
      color: 'emerald07',
      checked: true,
      click: function click() {}
    }],
    events: [],
    locale: null,
    language: null,
    month: new Date().getMonth(),
    year: new Date().getFullYear(),
    day: new Date().getDate(),
    showViewChanger: true,
    onRenderMonth: null,
    template: null,
    mobileTemplate: null,
    upcomingEventDays: 14,
    modalTemplate: null,
    menuId: null,
    menuSelected: null,
    eventTooltip: 'overflow',
    iconTooltip: 'overflow',
    newEventDefaults: {
      title: 'NewEvent',
      subject: '',
      isAllDay: true,
      comments: ''
    },
    onChangeView: null,
    showToday: true,
    weekViewSettings: {
      firstDayOfWeek: 0,
      startHour: 7,
      endHour: 19,
      showAllDay: true,
      showTimeLine: true
    },
    disable: {
      callback: null,
      dates: [],
      years: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    dayLegend: null
  };
  /**
   * Calendar - Full eventing calendar.
   * @class Calendar
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {array} [settings.eventTypes] An array of objects with data for the event types.
   * @param {array} [settings.events] An array of objects with data for the events.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.language] The name of the language to use for this instance. If not set the current locale will be used or the passed locale will be used.
   * @param {array} [settings.year] Initial year to show.
   * @param {array} [settings.month] Initial month to show.
   * @param {number} [settings.day] The initial selected day to show.
   * @param {array} [settings.upcomingEventDays=14] How many days in advance should we show in the upcoming events pane.
   * @param {boolean} [settings.showViewChanger] If false the dropdown to change views will not be shown.
   * @param {function} [settings.onRenderMonth] Fires when a month is rendered, allowing you to pass back events or event types to show.
   * @param {function} [settings.onSelected] Fires when a month day is clicked. Allowing you to do something.
   * @param {function} [settings.onChangeView] Call back for when the view changer is changed.
   * @param {string} [settings.template] The ID of the template used for the events.
   * @param {string} [settings.mobileTemplate] The ID of the template on mobile responsive used for the events.
   * @param {string} [settings.modalTemplate] The ID of the template used for the modal dialog on events.
   * @param {string} [settings.menuId=null] ID of the menu to use for an event right click context menu
   * @param {string} [settings.menuSelected=null] Callback for the  right click context menu
   * @param {string} [settings.newEventDefaults] Initial event properties for the new events dialog.
   * @param {string | function} [settings.eventTooltip] The content of event tooltip. Default value is 'overflow'
   * @param {string | function} [settings.iconTooltip] The content of event icon tooltip. Default value is 'overflow'
   * @param {boolean} [settings.showToday=true] Deterimines if the today button should be shown.
   * @param {object} [settings.weekViewSettings = {}] an object containing settings for the internal weekview component.
   * @param {boolean} [settings.weekViewSettings.firstDayOfWeek=0] Set first day of the week. '1' would be Monday.
   * @param {number} [settings.weekViewSettings.startHour=7] The hour (0-24) to end on each day.
   * @param {number} [settings.weekViewSettings.endHour=19] The hour (0-24) to end on each day.
   * @param {boolean} [settings.weekViewSettings.showAllDay=true] Detemines if the all day events row should be shown.
   * @param {boolean} [settings.weekViewSettings.showTimeLine=true] Shows a bar across the current time.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {function} [settings.disable.callback] return true to disable passed dates.
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019']}`.
   * @param {array} [settings.disable.years] Disable specific years.
   * Example `{years: [2018, 2019]}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {array} [settings.dayLegend] Allows you to set legend for days. This is passed to the legend option in Monthview but only the colors and dates part are used since the calendar already has a legend.
   * @param {string} [settings.attributes] Add extra attributes like id's to the element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function Calendar(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPONENT_NAME_DEFAULTS$2);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  Calendar.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      return this.setLocaleThenBuild();
    },

    /**
     * Add any needed markup to the component.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    build: function build() {
      this.setCurrentCalendar().renderEventTypes().renderMonthView().renderWeekView().handleEvents().addEventLegend();
      return this;
    },

    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocaleThenBuild: function setLocaleThenBuild() {
      var _this = this;

      var languageDf = Locale.getLocale(this.settings.language);
      var localeDf = Locale.getLocale(this.settings.locale);
      $.when(localeDf, languageDf).done(function (locale, lang) {
        _this.locale = Locale.cultures[locale] || Locale.currentLocale;
        _this.language = lang || _this.settings.language || _this.locale.language;
        _this.settings.language = _this.language;

        _this.setCurrentCalendar();

        _this.build().handleEvents();
      });
      return this;
    },

    /**
     * Set current calendar data to to be used.
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.isRTL = (this.locale.direction || this.locale.data.direction) === 'right-to-left';
      return this;
    },

    /**
     * Display event legends below the calendar table on mobile view.
     * @private
     * @returns {void}
     */
    addEventLegend: function addEventLegend() {
      var s = this.settings;
      this.eventLegend = $('<div class="calendar-event-legend"></div>');
      this.monthviewTable = $('.monthview-table');

      for (var i = 0; i < s.eventTypes.length; i++) {
        var event = s.eventTypes[i];
        var color = event.color;
        var legend = $('<div class="calendar-event-legend-item"></div>');
        legend.append("<span class=\"calendar-event-legend-swatch ".concat(color, "\"></span>\n          <span class=\"calendar-event-legend-text\">").concat(event.label, "</span>"));
        this.eventLegend.append(legend);
        utils.addAttributes(legend, this, this.settings.attributes, "legend-mobile-".concat(event.id), true);
      }

      this.monthviewTable.after(this.eventLegend);
    },

    /**
     * Render the eventType Section
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderEventTypes: function renderEventTypes() {
      this.eventTypeContainer = document.querySelector('.calendar-event-types');

      if (!this.eventTypeContainer) {
        return this;
      }

      for (var i = 0; i < this.settings.eventTypes.length; i++) {
        var eventType = this.settings.eventTypes[i];
        var eventTypeMarkup = "<input type=\"checkbox\" class=\"checkbox ".concat(eventType.color, "07\" name=\"").concat(eventType.id, "\" id=\"").concat(eventType.id, "\" ").concat(eventType.checked ? 'checked="true"' : '', " ").concat(eventType.disabled ? 'disabled="true"' : '', " />\n        <label for=\"").concat(eventType.id, "\" class=\"checkbox-label\">").concat(eventType.translationKey ? Locale.translate(eventType.translationKey, {
          locale: this.locale.name,
          language: this.language
        }) : eventType.label, "</label><br/>");
        this.eventTypeContainer.insertAdjacentHTML('beforeend', eventTypeMarkup); // Add attributes to the checkbox, copy the ID to its label's [for] attribute.

        var checkboxEl = $(this.eventTypeContainer).find("#".concat(eventType.id));
        utils.addAttributes($(this.eventTypeContainer).find("#".concat(eventType.id)), this, this.settings.attributes, "legend-".concat(eventType.id), true);
        checkboxEl.next('label').attr('for', checkboxEl[0].id);
      }

      return this;
    },

    /**
     * Render the monthview calendar
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderMonthView: function renderMonthView() {
      var _this2 = this;

      this.monthViewContainer = document.querySelector('.calendar .calendar-monthview'); // Handle changing view

      this.activeView = 'month';

      this.onChangeToMonth = function (args) {
        if (_this2.settings.onChangeView) {
          _this2.settings.onChangeView(args);

          return;
        }

        _this2.changeView(args.viewName);
      };

      this.monthView = new MonthView(this.monthViewContainer, {
        onRenderMonth: this.settings.onRenderMonth,
        onSelected: this.settings.onSelected,
        selectable: true,
        locale: this.settings.locale,
        language: this.settings.language,
        month: this.settings.month,
        year: this.settings.year,
        day: this.settings.day,
        eventTooltip: this.eventTooltip,
        iconTooltip: this.iconTooltip,
        showToday: this.settings.showToday,
        showViewChanger: this.settings.showViewChanger,
        onChangeView: this.onChangeToMonth,
        disable: this.settings.disable,
        showLegend: this.settings.dayLegend !== null,
        legend: this.settings.dayLegend,
        attributes: this.settings.attributes
      });
      this.monthViewHeader = document.querySelector('.calendar .monthview-header');
      this.renderAllEvents();
      utils.addAttributes($('.calendar'), this, this.settings.attributes);
      utils.addAttributes($('.calendar-monthview'), this, this.settings.attributes, 'monthview');
      return this;
    },

    /**
     * Render the weekview calendar
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    renderWeekView: function renderWeekView() {
      var _this3 = this;

      this.weekViewContainer = document.querySelector('.calendar .calendar-weekview');

      if (!this.weekViewContainer) {
        return this;
      } // Handle changing view


      this.weekViewContainer.classList.add('week-view');
      this.weekViewContainer.classList.add('hidden');

      this.onChangeToWeekDay = function (args) {
        if (_this3.settings.onChangeView) {
          _this3.settings.onChangeView(args);

          return;
        }

        _this3.changeView(args.viewName);
      };

      var startDate = dateUtils.firstDayOfWeek(new Date(this.currentDate()), this.settings.weekViewSettings.firstDayOfWeek);
      var endDate = dateUtils.lastDayOfWeek(new Date(this.currentDate()), this.settings.weekViewSettings.firstDayOfWeek);
      startDate.setHours(0, 0, 0, 0);
      endDate.setHours(23, 59, 59, 999);
      this.weekView = new WeekView(this.weekViewContainer, {
        locale: this.settings.locale,
        language: this.settings.language,
        startDate: startDate,
        endDate: endDate,
        eventTypes: this.settings.eventTypes,
        events: this.settings.events,
        firstDayOfWeek: this.settings.weekViewSettings.firstDayOfWeek,
        showAllDay: this.settings.weekViewSettings.showAllDay,
        showTimeLine: this.settings.weekViewSettings.showTimeLine,
        startHour: this.settings.weekViewSettings.startHour,
        endHour: this.settings.weekViewSettings.endHour,
        showToday: this.settings.showToday,
        showViewChanger: this.settings.showViewChanger,
        onChangeView: this.onChangeToWeekDay,
        eventTooltip: this.settings.eventTooltip,
        iconTooltip: this.settings.iconTooltip,
        attributes: this.settings.attributes
      });
      this.weekViewHeader = document.querySelector('.calendar .calendar-weekview .monthview-header');
      this.weekView.settings.filteredTypes = this.filterEventTypes();

      this.weekView.settings.onChangeWeek = function (args) {
        _this3.monthView.selectDay(args.startDate, false, true);
      };

      this.weekView.renderAllEvents();
      utils.addAttributes($('.calendar-weekview'), this, this.settings.attributes, 'weekview');
      return this;
    },

    /**
     * Set the current view (day, week or month)
     * @param {string} viewName to set selection
     * @returns {void}
     */
    changeView: function changeView(viewName) {
      if (viewName === this.activeView || !this.weekViewContainer) {
        return;
      }

      var currentDate = this.currentDate();
      var startDate = new Date(currentDate);
      var endDate = new Date(currentDate);
      startDate.setHours(0, 0, 0, 0);
      endDate.setHours(23, 59, 59, 999);

      switch (viewName) {
        case 'day':
          this.monthViewContainer.classList.add('hidden');
          this.weekViewContainer.classList.remove('hidden');
          this.activeView = 'day';
          this.weekView.settings.filteredTypes = this.filterEventTypes();
          this.weekView.showWeek(startDate, endDate);
          this.clearEventDetails();
          this.weekView.calendarToolbarAPI.setViewChangerValue(this.activeView);
          break;

        case 'week':
          this.monthViewContainer.classList.add('hidden');
          this.weekViewContainer.classList.remove('hidden');
          this.activeView = 'week';
          startDate = dateUtils.firstDayOfWeek(startDate, this.settings.firstDayOfWeek);
          endDate = dateUtils.lastDayOfWeek(startDate, this.settings.firstDayOfWeek);
          this.weekView.settings.filteredTypes = this.filterEventTypes();
          this.weekView.showWeek(startDate, endDate);
          this.weekView.calendarToolbarAPI.setViewChangerValue(this.activeView);
          this.clearEventDetails();
          this.monthView.selectDay(currentDate, false, true);
          this.weekView.selectHeader(currentDate);
          break;

        case 'month':
          this.monthViewContainer.classList.remove('hidden');
          this.weekViewContainer.classList.add('hidden');
          this.activeView = 'month';
          this.monthView.showMonth(this.settings.month, this.settings.year);
          this.monthView.calendarToolbarAPI.setViewChangerValue(this.activeView);
          this.monthView.selectDay(currentDate, false, true);
          break;
      }
    },

    /**
     * Render the upcoming events view
     * @param {object} event The Calendar event to show.
     * @private
     */
    appendUpcomingEvent: function appendUpcomingEvent(event) {
      this.upcomingEventsContainer = document.querySelector('.calendar-upcoming-events');

      if (!this.upcomingEventsContainer || event.daysUntil > 0) {
        return;
      }

      var daysUntil = Math.abs(event.daysUntil);

      if (daysUntil < 0 || daysUntil > this.settings.upcomingEventDays) {
        return;
      }

      var upcomingEvent = document.createElement('a');
      upcomingEvent.setAttribute('href', '#');
      upcomingEvent.setAttribute('data-key', event.startKey);
      DOM.addClass(upcomingEvent, 'calendar-upcoming-event');
      var upcomingEventsMarkup = '';
      var startDay = Locale.formatDate(event.starts, {
        pattern: 'd',
        locale: this.locale.name
      });
      var endDay = Locale.formatDate(event.ends, {
        pattern: 'd',
        locale: this.locale.name
      });
      var dateRange = "".concat(Locale.formatDate(event.starts, {
        pattern: 'MMMM',
        locale: this.locale.name
      }), " ").concat(startDay === endDay ? startDay : "".concat(startDay, "-").concat(endDay), ", ").concat(Locale.formatDate(event.starts, {
        pattern: 'yyyy',
        locale: this.locale.name
      }));

      if (parseInt(endDay, 10) < parseInt(startDay, 10)) {
        var nextMonth = new Date(event.starts);
        nextMonth.setDate(1);
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        var endYear = nextMonth.getFullYear();
        dateRange = "".concat(Locale.formatDate(event.starts, {
          pattern: 'MMMM',
          locale: this.locale.name
        }), " ").concat(startDay, " - ").concat(Locale.formatDate(nextMonth, {
          pattern: 'MMMM',
          locale: this.locale.name
        }), " ").concat(endDay, ", ").concat(endYear);
      }

      upcomingEventsMarkup += "\n      <span class=\"calendar-upcoming-date\">".concat(dateRange, "</span>\n      <span class=\"calendar-upcoming-event-color ").concat(event.color || '', "\">").concat(event.color || '', "</span>\n      <span class=\"calendar-upcoming-description\">").concat(event.subject || '', "</span>\n      <span class=\"calendar-upcoming-status-text\">").concat(event.status || '', "</span>\n      <span class=\"calendar-upcoming-duration\">").concat(event.isDays ? event.duration : event.durationHours, " ").concat(event.durationUnits || '', "</span>");
      upcomingEvent.innerHTML = upcomingEventsMarkup;
      this.upcomingEventsContainer.appendChild(upcomingEvent);
      utils.addAttributes($(upcomingEvent), this, this.settings.attributes, "upcoming-event-".concat(event.id));
    },

    /**
     * Render or re-render the events details section, using on the readonly or default eventTemplate
     * @param {string} eventId The event id
     * @param {number} count The event count
     * @private
     */
    renderEventDetails: function renderEventDetails(eventId, count) {
      if (!this.settings.events || this.activeView !== 'month') {
        return;
      } // Find the event data


      var eventData = this.settings.events.filter(function (event) {
        return event.id === eventId;
      });

      if (!eventData || eventData.length === 0) {
        return;
      }

      this.eventDetailsContainer = document.querySelector('.calendar-event-details');

      if (!this.eventDetailsContainer) {
        return;
      }

      var thisEvent = $.extend(true, {}, eventData[0]);

      if (thisEvent.durationHours && !thisEvent.isDays) {
        calendarShared.formateTimeString(thisEvent, this.locale, this.language);
      }

      this.renderTmpl(thisEvent, this.settings.template, this.eventDetailsContainer, count > 1);
      this.eventDetailsMobileContainer = document.querySelector('.calendar-event-details-mobile.listview');

      if (this.eventDetailsMobileContainer) {
        this.renderTmpl(thisEvent, this.settings.mobileTemplate, this.eventDetailsMobileContainer, count > 1);
      }

      var api = $(this.eventDetailsContainer).data('accordion');

      if (api) {
        api.destroy();
      }

      if (this.eventDetailsMobileContainer) {
        this.translate(this.eventDetailsMobileContainer);
      }

      this.translate(this.eventDetailsContainer);
    },

    /**
     * Translate elements in a DOM object
     * @private
     * @param  {object} elem The DOM Element
     */
    translate: function translate(elem) {
      var _this4 = this;

      $(elem).find('[data-translate="text"]').each(function (i, item) {
        var obj = $(item);
        obj.text(Locale.translate(obj.attr('data-translate-key') || obj.text(), {
          showAsUndefined: false,
          showBrackets: false,
          language: _this4.settings.language,
          locale: _this4.settings.locale
        }));
      });
    },

    /**
     * Render each of the events for the currently selected node
     * @private
     */
    renderSelectedEventDetails: function renderSelectedEventDetails() {
      var dayObj = this.getDayEvents();
      this.clearEventDetails();

      if (!dayObj.events || dayObj.events.length === 0) {
        return;
      }

      for (var i = 0; i < dayObj.events.length; i++) {
        this.renderEventDetails(dayObj.events[i].id, dayObj.events.length);
      }

      $('.calendar .list-detail', this.element).css('display', 'block');
      $(this.eventDetailsContainer).accordion();

      if (this.eventDetailsMobileContainer) {
        $(this.eventDetailsMobileContainer).addClass('listview').listview({
          selectable: false,
          hoverable: false
        });
      }

      if (DOM.hasClass(this.eventDetailsContainer, 'has-only-one')) {
        $(this.eventDetailsContainer).find('.accordion-header, .accordion-header a').off('click');
      }

      $('.accordion-pane.no-transition', this.element).removeClass('no-transition');
    },

    /**
     * If a upcomming day is clicked render that day/year.
     * @private
     * @param {string} key The date as an index key.
     */
    renderDay: function renderDay(key) {
      this.monthView.selectDay(key);
      var startDate = new Date(this.currentDate());
      var endDate = new Date(this.currentDate());
      startDate.setHours(0, 0, 0, 0);
      endDate.setHours(23, 59, 59, 999);

      if (this.activeView === 'day') {
        this.weekView.showWeek(startDate, endDate);
      }

      if (this.activeView === 'week') {
        startDate = dateUtils.firstDayOfWeek(startDate, this.settings.firstDayOfWeek);
        endDate = dateUtils.lastDayOfWeek(startDate, this.settings.firstDayOfWeek);
        this.weekView.showWeek(startDate, endDate);
      }
    },

    /**
     * Clear all contents from the event details area.
     * @private
     */
    clearEventDetails: function clearEventDetails() {
      this.eventDetailsContainer = document.querySelector('.calendar-event-details');
      this.eventDetailsMobileContainer = document.querySelector('.calendar-event-details-mobile.listview');

      if (this.eventDetailsContainer) {
        this.eventDetailsContainer.innerHTML = '';
      }

      if (this.eventDetailsMobileContainer) {
        this.eventDetailsMobileContainer.innerHTML = '';
      }
    },

    /**
     * Clear all contents from the upcoming events area.
     * @private
     */
    clearUpcomingEvents: function clearUpcomingEvents() {
      if (this.upcomingEventsContainer) {
        this.upcomingEventsContainer.innerHTML = '';
      }
    },

    /**
     * Get the currently unchecked filter types
     * @returns {array} The active types.
     * @private
     */
    filterEventTypes: function filterEventTypes() {
      var types = [];

      if (!this.eventTypeContainer) {
        return types;
      }

      var checkboxes = this.eventTypeContainer.querySelectorAll('.checkbox');

      for (var i = 0; i < checkboxes.length; i++) {
        var input = checkboxes[i];

        if (!input.checked) {
          types.push(input.getAttribute('name'));
        }
      }

      return types;
    },

    /**
     * Render/ReRender the events attached to the settings.
     * @private
     * @param {boolean} isCallback Will be set to true when a callback occurs
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    renderAllEvents: function renderAllEvents(isCallback) {
      if (this.settings.onRenderMonth && !isCallback) {
        this.callOnRenderMonth();
        return this;
      }

      var self = this;
      var filters = this.filterEventTypes(); // Cleanup from previous renders

      this.removeAllEvents();
      this.clearUpcomingEvents();
      this.clearEventDetails(); // Clone and sort the array.

      var eventsSorted = this.settings.events.slice(0);
      eventsSorted.sort(function (a, b) {
        return a.starts < b.starts ? -1 : a.starts > b.starts ? 1 : 0;
      });

      for (var i = 0; i < eventsSorted.length; i++) {
        var event = eventsSorted[i];

        if (filters.indexOf(event.type) > -1) {
          continue;
        }

        self.renderEvent(event);
      }

      this.renderSelectedEventDetails();

      if (this.weekView) {
        this.weekView.settings.filteredTypes = filters;
        this.weekView.renderAllEvents();
      }

      return this;
    },

    /**
     * Render a single event on the ui, use in the loop and other functions.
     * @param  {object} event The event object.
     */
    renderEvent: function renderEvent(event) {
      var self = this; // Check for events starting on this day , or only on this day.

      var startDate = Locale.newDateObj(event.starts);
      var isIslamic = Locale.isIslamic(this.locale.name);
      var startKey = stringUtils.padDate(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());

      if (isIslamic) {
        var startDateIslamic = Locale.gregorianToUmalqura(startDate);
        startKey = stringUtils.padDate(startDateIslamic[0], startDateIslamic[1], startDateIslamic[2]);
      } // Check for events extending onto this day


      var endDate = Locale.newDateObj(event.ends);
      var endKey = stringUtils.padDate(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

      if (isIslamic) {
        var endDateIslamic = Locale.gregorianToUmalqura(endDate);
        endKey = stringUtils.padDate(endDateIslamic[0], endDateIslamic[1], endDateIslamic[2]);
      }

      var days = self.monthView.dayMap.filter(function (day) {
        return day.key >= startKey && day.key <= endKey;
      });
      event.endKey = endKey;
      event.startKey = startKey;
      event = calendarShared.addCalculatedFields(event, this.locale, this.language, this.settings.eventTypes);
      var idx = -1;

      for (var i = 0; i < self.monthView.dayMap.length; ++i) {
        if (self.monthView.dayMap[i].key >= startKey && self.monthView.dayMap[i].key <= endKey) {
          idx = i;
          break;
        }
      } // Event is only on this day


      if (days.length === 1) {
        self.appendEvent(days[0].elem[0], event, 'event-day-start-end', idx);
      } // Event extends multiple days


      if (days.length > 1) {
        for (var l = 0; l < days.length; l++) {
          var cssClass = l === 0 ? 'event-day-start' : 'event-day-span';

          if (days.length - 1 === l) {
            cssClass = 'event-day-end';
          }

          self.appendEvent(days[l].elem[0], event, cssClass, idx + l);
        }
      } // Event extends multiple days


      this.appendUpcomingEvent(event, days, idx);
    },

    /**
     * Remove all events from the month.
     */
    removeAllEvents: function removeAllEvents() {
      var moreEvents = this.monthViewContainer.querySelectorAll('.calendar-event-more');

      for (var i = 0; i < moreEvents.length; i++) {
        moreEvents[i].parentNode.removeChild(moreEvents[i]);
      }

      var calendarEvents = this.monthViewContainer.querySelectorAll('.calendar-event');

      for (var _i = 0; _i < calendarEvents.length; _i++) {
        calendarEvents[_i].parentNode.removeChild(calendarEvents[_i]);
      }

      var calendarEventSpacers = this.monthViewContainer.querySelectorAll('.calendar-event-spacer');

      for (var _i2 = 0; _i2 < calendarEventSpacers.length; _i2++) {
        calendarEventSpacers[_i2].parentNode.removeChild(calendarEventSpacers[_i2]);
      }

      for (var _i3 = 0; _i3 < this.monthView.dayMap.length; _i3++) {
        this.monthView.dayMap[_i3].events = [];
      }
    },

    /**
     * Add the ui event to the container.
     * @private
     * @param {object} container The container to append to
     * @param {object} event The event data object.
     * @param {string} type Type of event, can be event-day-start, event-day-start-end, event-day-span, event-day-end
     * @param {number} idx The dayMap index
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    appendEvent: function appendEvent(container, event, type, idx) {
      var _this5 = this,
          _event$color,
          _event$borderColor;

      var node;
      var eventCnt = container.querySelectorAll('.calendar-event').length;

      if (idx > -1) {
        if (!this.monthView.dayMap[idx].events) {
          this.monthView.dayMap[idx].events = [];
        }

        this.monthView.dayMap[idx].events.push(event);
      }

      if (eventCnt >= 3) {
        var moreSpan = container.querySelector('.calendar-event-more');

        var setMoreSpan = function setMoreSpan(elem, count) {
          elem.setAttribute('data-count', count); // Wrap text in extra span here, so link should not expand more than text, because `more span` is styled as block level element

          elem.innerHTML = "<span>+ ".concat(count, " ").concat(Locale.translate('More', {
            locale: _this5.locale.name,
            language: _this5.language
          }).replace('...', ''), "</span>");
        };

        if (!moreSpan) {
          node = document.createElement('span');
          DOM.addClass(node, 'calendar-event-more');
          setMoreSpan(node, 1);
          container.querySelector('.day-container').appendChild(node); // Switch to day view on click

          $(container).off("click.".concat(COMPONENT_NAME$C)).on("click.".concat(COMPONENT_NAME$C), '.calendar-event-more span', function () {
            var thisDate = _this5.monthView.dayMap[idx].key;

            _this5.monthView.selectDay(thisDate, false, true);

            _this5.changeView('day');
          });
        } else {
          setMoreSpan(moreSpan, parseInt(moreSpan.getAttribute('data-count'), 10) + 1);
        }

        return this;
      }

      node = document.createElement('a');
      DOM.addClass(node, 'calendar-event', event.color, type);
      node.setAttribute('data-id', event.id);
      node.setAttribute('data-key', event.startKey); // Let the border color / color be overriden

      if (((_event$color = event.color) === null || _event$color === void 0 ? void 0 : _event$color == null ? void 0 : _event$color.substr(0, 1)) === '#') {
        node.style.backgroundColor = event.color;
        node.classList.remove(event.color);
      }

      if (((_event$borderColor = event.borderColor) === null || _event$borderColor === void 0 ? void 0 : _event$borderColor == null ? void 0 : _event$borderColor.substr(0, 1)) === '#') {
        node.style.borderLeftColor = event.borderColor;
      }

      node.innerHTML = "<div class=\"calendar-event-content\">\n      ".concat(event.icon ? "<span class=\"calendar-event-icon\"><svg class=\"icon ".concat(event.icon, "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\" data-status=\"").concat(event.status, "\"><use href=\"#").concat(event.icon, "\"></use></svg></span>") : '', "\n      <span class=\"calendar-event-title\">").concat(event.shortSubject || event.subject, "</span>\n    </div>"); // Make sure we are on the same "level", when events overlap

      var eventHead = this.monthViewContainer.querySelectorAll(".calendar-event.event-day-start[data-id=\"".concat(event.id, "\"]"));

      if (eventHead[0]) {
        var children = eventHead[0].parentNode.children;

        for (var i = container.querySelector('.day-container').children.length; i < children.length; i++) {
          var dataid = children[i].getAttribute('data-id');

          if (dataid === event.id) {
            break;
          }

          if (!children[i].classList.contains('day-text')) {
            var spacer = document.createElement('span');
            spacer.classList.add('calendar-event-spacer');
            container.querySelector('.day-container').appendChild(spacer);
          }
        }
      }

      container.querySelector('.day-container').appendChild(node);
      utils.addAttributes($(node), this, this.settings.attributes, "event-".concat(event.id));

      if (this.settings.iconTooltip !== 'overflow') {
        var icon = node.querySelector('.calendar-event-icon');

        if (icon) {
          if (typeof this.settings.iconTooltip === 'function') {
            this.settings.iconTooltip({
              month: this.settings.month,
              year: this.settings.year,
              event: event
            });
          } else if (event[this.settings.iconTooltip]) {
            icon.setAttribute('title', event[this.settings.iconTooltip]);
            $(icon).tooltip({
              content: icon.innerText
            });
          }
        }
      }

      if (this.settings.eventTooltip !== 'overflow') {
        if (typeof this.settings.eventTooltip === 'function') {
          this.settings.eventTooltip({
            month: this.settings.month,
            year: this.settings.year,
            event: event
          });
        } else if (event[this.settings.eventTooltip]) {
          node.setAttribute('title', event[this.settings.eventTooltip]);
          $(node).tooltip({
            content: node.innerText
          });
        }
      }

      if (!event.shortSubject && (this.settings.eventTooltip === 'overflow' || this.settings.iconToolTip === 'overflow')) {
        // Show the full text if cut off
        node.setAttribute('title', event.subject);
        $(node).tooltip({
          beforeShow: function beforeShow(response, ui) {
            var title = ui[0].querySelector('.calendar-event-title');
            var icon = ui[0].querySelector('.calendar-event-icon');
            var iconStatus = icon ? icon.querySelector('.icon').getAttribute('data-status') : '';

            if (title.offsetWidth > ui[0].scrollWidth - (icon ? icon.offsetWidth : 0)) {
              response("".concat(title.innerText).concat(iconStatus ? " (".concat(Locale.translate(iconStatus, {
                locale: _this5.locale.name,
                language: _this5.language
              }, false), ")") : ''));
              return;
            }

            response(false);
          }
        });
      }

      return this;
    },

    /**
     * Find the matching type and get the color.
     * @param {object} id The eventType id to find.
     * @param {object} event The event data object.
     * @returns {object} The Calendar prototype, useful for chaining.
     */
    getEventTypeLabel: function getEventTypeLabel(id) {
      var type = '';

      if (!id) {
        return type;
      }

      var eventInfo = this.settings.eventTypes.filter(function (eventType) {
        return eventType.id === id;
      });

      if (eventInfo.length === 1) {
        type = eventInfo[0].label;
      }

      return type;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Calendar prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this6 = this;

      var self = this;
      this.element.off("updated.".concat(COMPONENT_NAME$C)).on("updated.".concat(COMPONENT_NAME$C), function () {
        _this6.updated();
      });
      this.isSwitchingMonth = false;
      this.element.off("monthrendered.".concat(COMPONENT_NAME$C)).on("monthrendered.".concat(COMPONENT_NAME$C), function (e, args) {
        _this6.isSwitchingMonth = true;

        if (_this6.modalVisible()) {
          _this6.removeModal();
        }

        _this6.settings.year = args.year;
        _this6.settings.month = args.month;

        _this6.renderAllEvents();

        setTimeout(function () {
          _this6.isSwitchingMonth = false;
        }, 500);
      });
      this.element.off("change.".concat(COMPONENT_NAME$C)).on("change.".concat(COMPONENT_NAME$C), '.checkbox', function () {
        _this6.renderAllEvents(true);
      });
      $(this.monthViewContainer).off("selected.".concat(COMPONENT_NAME$C)).on("selected.".concat(COMPONENT_NAME$C), function () {
        _this6.renderSelectedEventDetails();
      });
      this.element.off("click.".concat(COMPONENT_NAME$C, "-upcoming")).on("click.".concat(COMPONENT_NAME$C, "-upcoming"), '.calendar-upcoming-event', function (e) {
        var key = e.currentTarget.getAttribute('data-key');

        _this6.renderDay(key);
      });
      this.element.off("contextmenu.".concat(COMPONENT_NAME$C)).on("contextmenu.".concat(COMPONENT_NAME$C), '.calendar-event', function (e) {
        e.stopPropagation();

        var hasMenu = function hasMenu() {
          return self.settings.menuId && $("#".concat(self.settings.menuId)).length > 0;
        };

        var eventId = e.currentTarget.getAttribute('data-id');

        var eventData = _this6.settings.events.filter(function (event) {
          return event.id === eventId;
        });

        _this6.element.triggerHandler('contextmenu', {
          originalEvent: e,
          month: _this6.settings.month,
          year: _this6.settings.year,
          event: eventData[0]
        });

        if (!utils.isSubscribedTo(self.element[0], e, 'contextmenu', 'calendar') && !hasMenu()) {
          return true;
        }

        e.preventDefault();
        self.closePrevPopupmenu();

        if (!hasMenu()) {
          return true;
        }

        var event = $(e.currentTarget);
        event.popupmenu({
          attachToBody: true,
          menuId: _this6.settings.menuId,
          eventObj: e,
          trigger: 'immediate',
          offset: {
            y: 5
          }
        });
        event.off('selected.calendar').on('selected.calendar', function (evt, elem) {
          // const eventId = this.getAttribute('data-id');
          if (self.settings.menuSelected) {
            self.settings.menuSelected(evt, elem, eventId);
          }

          if (elem.attr('data-action') === 'delete-event') {
            self.deleteEvent({
              id: eventId
            });
          }

          if (elem.attr('data-action') === 'show-event') {
            var key = this.getAttribute('data-key');
            self.monthView.selectDay(key);
          }
        });
        return false;
      });
      var timer = 0;
      var delay = 100;
      var prevent = false;
      this.element.off("click.".concat(COMPONENT_NAME$C, "-event")).on("click.".concat(COMPONENT_NAME$C, "-event"), '.calendar-event', function (e) {
        timer = setTimeout(function () {
          if (!prevent) {
            var eventId = e.currentTarget.getAttribute('data-id');

            var eventData = _this6.settings.events.filter(function (event) {
              return event.id === eventId;
            });

            if (!eventData || eventData.length === 0) {
              return;
            }

            var target = $(e.currentTarget);
            var eventTarget = target.find('.calendar-event-title');

            if (e.currentTarget.classList.contains('event-day-span') || e.currentTarget.classList.contains('event-day-end')) {
              eventTarget = self.element.find(".event-day-start[data-id=\"".concat(target.attr('data-id'), "\"] .calendar-event-title"));
            }

            _this6.showModalWithCallback(eventData[0], false, eventTarget);
            /**
             * Fires when an event in the calendar is clicked.
             * @event eventclick
             * @memberof Calendar
             * @property {number} args.month - The zero based month number.
             * @property {number} args.year - The year currently rendered in the calendar.
             * @property {object} args.event - The data for the event.
             */


            _this6.element.triggerHandler('eventclick', {
              month: _this6.settings.month,
              year: _this6.settings.year,
              event: eventData[0]
            });
          }

          prevent = false;
        }, delay);
      });
      this.element.off("dblclick.".concat(COMPONENT_NAME$C, "-event")).on("dblclick.".concat(COMPONENT_NAME$C, "-event"), '.calendar-event', function (e) {
        clearTimeout(timer);
        prevent = true;
        var eventId = e.currentTarget.getAttribute('data-id');

        var eventData = _this6.settings.events.filter(function (event) {
          return event.id === eventId;
        });

        if (!eventData || eventData.length === 0) {
          return;
        }
        /**
         * Fires when an event in the calendar is double clicked.
         * @event eventdblclick
         * @memberof Calendar
         * @property {number} args.month - The zero based month number.
         * @property {number} args.year - The year currently rendered in the calendar.
         * @property {object} args.event - The data for the event.
         */


        _this6.element.trigger('eventdblclick', {
          month: _this6.settings.month,
          year: _this6.settings.year,
          event: eventData[0]
        });
      });
      this.element.off("dblclick.".concat(COMPONENT_NAME$C)).on("dblclick.".concat(COMPONENT_NAME$C), 'td', function (e) {
        var key = e.currentTarget.getAttribute('data-key');

        if (!key || _this6.isSwitchingMonth) {
          return;
        }

        var day = new Date(key.substr(0, 4), key.substr(4, 2) - 1, key.substr(6, 2));
        var eventData = utils.extend({}, _this6.settings.newEventDefaults);
        eventData.startKey = key;
        eventData.endKey = key;
        eventData.starts = day;
        eventData.ends = day;
        e.stopPropagation();
        calendarShared.cleanEventData(eventData, false, _this6.currentDate(), _this6.locale, _this6.language, _this6.settings.events, _this6.settings.eventTypes);

        _this6.showModalWithCallback(eventData, true);
        /**
         * Fires when the calendar day is double clicked.
         * @event dblclick
         * @memberof Calendar
         * @param {object} eventData - Information about the calendar date double clicked.
         * @param {object} api - Access to the Calendar API
         */


        _this6.element.triggerHandler('dblclick', {
          eventData: eventData,
          api: _this6
        });
      }); // Set up mobile list view events

      this.element.find('.listview').off("click.".concat(COMPONENT_NAME$C, "-mobile")).on("click.".concat(COMPONENT_NAME$C, "-mobile"), function (e) {
        var target = $(e.target).closest('li');
        var mobileEventId = target.attr('data-id');

        var mobileEventData = _this6.settings.events.filter(function (event) {
          return event.id === mobileEventId;
        });

        if (!mobileEventData || mobileEventData.length === 0) {
          return;
        }

        _this6.showModalWithCallback(mobileEventData[0], false, target);

        _this6.element.triggerHandler('eventclick', {
          month: _this6.settings.month,
          year: _this6.settings.year,
          event: mobileEventData[0]
        });
      });
      return this;
    },

    /**
     * Close any previous opened popupmenus.
     * @private
     * @returns {void}
     */
    closePrevPopupmenu: function closePrevPopupmenu() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('.is-open:not(.popupmenu)'));
      nodes.forEach(function (node) {
        var elem = $(node);

        if (elem.data('popupmenu')) {
          elem.trigger('close');
        }
      });
    },

    /**
     * Execute onRenderMonth and handle the call back.
     * @private
     */
    callOnRenderMonth: function callOnRenderMonth() {
      var self = this;

      function response(events, eventTypes) {
        if (eventTypes && eventTypes.length > 0) {
          self.settings.eventTypes = eventTypes;

          if (self.weekView) {
            self.weekView.settings.eventTypes = eventTypes;
          }

          self.renderEventTypes();
        }

        if (events && events.length > 0) {
          self.settings.events = events;
          self.renderAllEvents(true);

          if (self.weekView) {
            self.weekView.settings.events = events;
            self.weekView.renderAllEvents(true);
          }
        }
      }

      this.settings.onRenderMonth(this.element, response, {
        api: self,
        month: this.settings.month,
        year: this.settings.year
      });
    },

    /**
     * Get the current selected date on the calendar.
     * @returns {date} the currently selected date on the control.
     */
    currentDate: function currentDate() {
      var ret = this.isIslamic ? this.monthView.currentDateIslamic : this.monthView.currentDate;

      if (!Locale.isValidDate(ret)) {
        return new Date();
      }

      return ret;
    },

    /**
     * Get the events and date for the currently selected calendar day.
     * @param {date} date The date to find the events for.
     * @returns {object} dayEvents An object with all the events and the event date.
     */
    getDayEvents: function getDayEvents(date) {
      if (!date) {
        date = this.currentDate();
      }

      if (typeof date !== 'string' && !this.isRTL) {
        date = stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
      }

      if (Locale.isIslamic(this.locale.name)) {
        var dateIslamic = Locale.gregorianToUmalqura(date);
        date = stringUtils.padDate(dateIslamic[0], dateIslamic[1], dateIslamic[2]);
      }

      var dayObj = this.monthView.dayMap.filter(function (dayFilter) {
        return dayFilter.key === date;
      });

      if (this.activeView !== 'month') {
        dayObj = this.weekView.dayMap.filter(function (dayFilter) {
          return dayFilter.key === date;
        });
      }

      var dayEvents = {
        date: this.monthView.currentDate,
        events: []
      };

      if (dayObj.length === 0) {
        return [];
      }

      dayEvents.events = dayObj[0].events;
      dayEvents.elem = dayObj[0].elem;
      return dayEvents;
    },

    /**
     * Render the template into the container.
     * @param {object} event The event object with common event properties.
     * @param {object} template The template id.
     * @param {object} container The container to put it in.
     * @param {boolean} append If true we append the template into the container.
    */
    renderTmpl: function renderTmpl(event, template, container, append) {
      if (_typeof(Tmpl) !== 'object' || !template) {
        return;
      } // create a copy of the template


      if (template instanceof $) {
        template = "".concat(template.html());
      } else if (typeof template === 'string') {
        // If a string doesn't contain HTML elments,
        // assume it's an element ID string and attempt to select with jQuery
        if (!stringUtils.containsHTML(template)) {
          template = $("#".concat(template)).html();
        }
      }

      event.color = calendarShared.getEventTypeColor(event, this.settings.eventTypes);
      event.startsLong = Locale.formatDate(event.starts, {
        date: 'long',
        locale: this.locale.name
      });
      event.endsLong = Locale.formatDate(event.ends, {
        date: 'long',
        locale: this.locale.name
      });
      event.startsHoursLong = "".concat(Locale.formatDate(event.starts, {
        date: 'long',
        locale: this.locale.name
      }), " ").concat(Locale.formatDate(event.starts, {
        date: 'hour',
        locale: this.locale.name
      }));
      event.endsHoursLong = "".concat(Locale.formatDate(event.ends, {
        date: 'long',
        locale: this.locale.name
      }), " ").concat(Locale.formatDate(event.ends, {
        date: 'hour',
        locale: this.locale.name
      }));

      if (Locale.isIslamic(this.locale.name)) {
        var startsIslamic = Locale.gregorianToUmalqura(new Date(event.starts));
        var endsIslamic = Locale.gregorianToUmalqura(new Date(event.ends));
        event.startsLong = Locale.formatDate(startsIslamic, {
          date: 'long',
          locale: this.locale.name
        });
        event.endsLong = Locale.formatDate(endsIslamic, {
          date: 'long',
          locale: this.locale.name
        });
        event.startsHoursLong = "".concat(Locale.formatDate(startsIslamic, {
          date: 'long',
          locale: this.locale.name
        }), " ").concat(Locale.formatDate(startsIslamic, {
          date: 'hour',
          locale: this.locale.name
        }));
        event.endsHoursLong = "".concat(Locale.formatDate(endsIslamic, {
          date: 'long',
          locale: this.locale.name
        }), " ").concat(Locale.formatDate(endsIslamic, {
          date: 'hour',
          locale: this.locale.name
        }));
      }

      event.typeLabel = this.getEventTypeLabel(event.type);
      var renderedTmpl = Tmpl.compile(template, {
        event: event
      });
      container.classList.remove('has-only-one');

      if (append) {
        DOM.append(container, renderedTmpl, '*');
        return;
      }

      container.innerHTML = renderedTmpl;
      container.classList.add('has-only-one');
    },

    /**
     * Add a new event via the event object and show it if it should be visible in the calendar.
     * @param {object} event The event object with common event properties.
     */
    addEvent: function addEvent(event) {
      calendarShared.cleanEventData(event, true, this.currentDate(), this.locale, this.language, this.settings.events, this.settings.eventTypes);
      this.settings.events.push(event);
      this.renderEvent(event);
      this.renderSelectedEventDetails();

      if (this.weekView) {
        this.weekView.addEvent(event);
      }
    },

    /**
     * Update an event via the event object and show it if it should be visible in the calendar.
     * It uses the event id to do this.
     * @param {object} event The event object with common event properties.
     */
    updateEvent: function updateEvent(event) {
      var eventId = event.id;

      for (var i = this.settings.events.length - 1; i >= 0; i--) {
        if (this.settings.events[i].id === eventId) {
          this.settings.events[i] = utils.extend(true, this.settings.events[i], event);
          calendarShared.cleanEventData(this.settings.events[i], true, this.currentDate(), this.locale, this.language, this.settings.events, this.settings.eventTypes);
        }
      }

      this.renderAllEvents();

      if (this.weekView) {
        this.weekView.updateEvent(event);
      }
    },

    /**
     * Remove an event from the dataset and page. It uses the id property.
     * @param {object} event The event object with common event properties.
     */
    deleteEvent: function deleteEvent(event) {
      var eventId = event.id;

      for (var i = this.settings.events.length - 1; i >= 0; i--) {
        if (this.settings.events[i].id === eventId) {
          this.settings.events.splice(i, 1);
        }
      }

      this.renderAllEvents();

      if (this.weekView) {
        this.weekView.deleteEvent(event);
      }
    },

    /**
     * Remove all events from the calendar
     */
    clearEvents: function clearEvents() {
      this.settings.events = [];
      this.renderAllEvents();

      if (this.weekView) {
        this.weekView.clearEvents();
      }
    },

    /**
     * Show a modal used to add/edit events. This uses the modalTemplate setting for the modal contents.
     * @param {object} event The event object with common event properties for defaulting fields in the template.
     * @param {function} done The callback for when the modal closes.
     * @param {object} eventTarget The target element for the popup.
     */
    showEventModal: function showEventModal(event, done, eventTarget) {
      var _this7 = this;

      if (!this.settings.modalTemplate) {
        return;
      }

      if (this.modalVisible()) {
        this.removeModal();
      }

      this.modalContents = document.createElement('div');
      DOM.addClass(this.modalContents, 'calendar-event-modal', 'hidden');
      document.getElementsByTagName('body')[0].appendChild(this.modalContents);
      event = calendarShared.addCalculatedFields(event, this.locale, this.language, this.settings.eventTypes);
      this.renderTmpl(event || {}, this.settings.modalTemplate, this.modalContents);
      var dayObj = this.getDayEvents();
      var isCancel = true;
      dayObj.elem = $(dayObj.elem);
      var placementArgs = dayObj.elem.index() === 6 ? this.isRTL ? 'right' : 'left' : this.isRTL ? 'left' : 'right';

      if (!eventTarget && this.activeView === 'day') {
        eventTarget = $('.week-view-header-wrapper');
        placementArgs = this.isRTL ? 'left' : 'right';
      }

      if (!eventTarget) {
        eventTarget = dayObj.elem;
      }

      var modalOptions = this.settings.modalOptions || {
        content: $(this.modalContents),
        closebutton: true,
        popover: true,
        placementOpts: {
          parent: eventTarget,
          strategies: ['flip', 'nudge', 'shrink-y'],
          parentXAlignment: 'center',
          parentYAlignment: 'center',
          placement: placementArgs
        },
        title: event.title || event.subject,
        trigger: 'immediate',
        keepOpen: true,
        extraClass: 'calendar-popup calendar-popup-mobile',
        tooltipElement: '#calendar-popup',
        headerClass: event.color,
        initializeContent: false
      };
      eventTarget.off('hide.calendar').on('hide.calendar', function () {
        if (isCancel) {
          _this7.removeModal();

          return;
        }

        done(_this7.modalContents, event);

        _this7.element.trigger('hidemodal', {
          elem: _this7.modalContents,
          event: event
        });

        _this7.removeModal();

        isCancel = true;
      }).popover(modalOptions).off('show.calendar').on('show.calendar', function (evt, elem) {
        _this7.element.trigger('showmodal', {
          elem: _this7.modalContents,
          event: event
        }); // Wire the click on isAllDay to disable spinbox.


        elem.find('#isAllDay').off().on('click.calendar', function (e) {
          var isDisabled = $(e.currentTarget).prop('checked');

          if (isDisabled) {
            elem.find('#durationHours').prop('disabled', true);
            elem.find('#endsHourLocale').prop('disabled', true);
            elem.find('#startsHourLocale').prop('disabled', true);
          } else {
            elem.find('#durationHours').prop('disabled', false);
            elem.find('#endsHourLocale').prop('disabled', false);
            elem.find('#startsHourLocale').prop('disabled', false);
          }
        }); // Wire the correct type selector

        elem.find('#type').val(event.type).dropdown(); // Wire the correct comments

        elem.find('#comments').val(event.comments);
        elem.find('#subject').focus(); // Wire the buttons

        elem.find('button').on('click', function (e) {
          var popupApi = eventTarget.data('tooltip');
          var action = e.currentTarget.getAttribute('data-action');
          isCancel = action !== 'submit';

          if (popupApi) {
            popupApi.hide(true);
          }
        }); // Init the contents

        elem.find('.datepicker').datepicker({
          locale: _this7.settings.locale,
          language: _this7.settings.language
        });
        elem.find('.timepicker').timepicker({
          locale: _this7.settings.locale,
          language: _this7.settings.language
        });

        _this7.translate(elem);
      });
      $('#calendar-popup').one('tooltipafterplace.calendar', function (e, args) {
        var arrow = args.element.find('.arrow');
        var topValue = parseInt(arrow.css('margin-top'), 10);

        if (dayObj.elem.parent().index() >= 3) {
          var offsetTop = parseInt(args.element.offset().top, 10);
          var diff = offsetTop + args.element.height();
          var height = $('html').height() + 10;

          if (diff > height) {
            var adjustment = offsetTop - (diff - height) - 25;
            args.element.css('top', "".concat(adjustment, "px"));
            arrow.css('margin-top', "".concat(topValue + (offsetTop - adjustment) - 18, "px"));
          }
        } else if (args.element.height() > 580) {
          arrow.css('margin-top', "".concat(topValue - 18, "px"));
        }
      });
      this.activeElem = eventTarget;
    },

    /**
     * Show the event modal and run a callback.
     * @private
     * @param {object} eventData Data from the event object
     * @param {boolean} isAdd Open the modal in readnly mode vs edit mode
     * @param {object} eventTarget The element to point the dialog at
     * @returns {void}
     */
    showModalWithCallback: function showModalWithCallback(eventData, isAdd, eventTarget) {
      var _this8 = this;

      this.showEventModal(eventData, function (elem, event) {
        // Collect the data and popuplate the event object
        var inputs = elem.querySelectorAll('input, textarea, select');

        for (var i = 0; i < inputs.length; i++) {
          event[inputs[i].id] = inputs[i].getAttribute('type') === 'checkbox' ? inputs[i].checked : inputs[i].value;
        }

        if (isAdd) {
          _this8.addEvent(event);
        } else {
          _this8.updateEvent(event);
        }
      }, eventTarget);
    },

    /**
     * Used to check if a Modal is currently visible.
     * @returns {boolean} whether or not the Modal is currently being displayed
     */
    modalVisible: function modalVisible() {
      return document.querySelector('.calendar-event-modal') !== null;
    },

    /**
     * Remove and destroy the modal.
     * @private
     */
    removeModal: function removeModal() {
      this.modalContents = null;

      if (this.activeElem) {
        this.activeElem.off();

        if (this.activeElem.data('tooltip')) {
          this.activeElem.data('tooltip').destroy();
        }
      }

      DOM.remove(document.getElementById('calendar-popup'));
      DOM.remove(document.querySelector('.calendar-event-modal'));
      $('#timepicker-popup').hide();
    },

    /**
     * Handle updated settings and values.
     * @param {object} settings The new settings object to use.
     * @returns {object} [description]
     */
    updated: function updated() {
      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!settings) {
        settings = {};
      }

      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (settings.locale || settings.template || settings.upcomingEventDays || settings.mobileTemplate) {
        this.destroy().init();
        return this;
      } // Update weekview mapped settings.


      if (this.weekView && settings.events) {
        this.weekView.settings.events = settings.events;
      }

      if (this.weekView && settings.eventTypes) {
        this.weekView.settings.events = settings.events;
      }

      if (this.weekView && settings.weekViewSettings) {
        this.weekView.settings = utils.mergeSettings(this.element[0], settings.weekViewSettings, this.weekViews.settings);
      }

      this.monthView.showMonth(this.settings.month, this.settings.year);
      this.renderAllEvents();

      if (this.weekView && settings.weekViewSettings) {
        this.weekView.renderAllEvents();
      }

      return this;
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      if (this.element) {
        this.element.off();
      }

      $(this.monthViewContainer).off();

      if (this.monthView) {
        this.monthView.destroy();
      }

      if (this.weekView) {
        this.weekView.destroy();
      }

      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    destroy: function destroy() {
      if (this.eventTypeContainer) {
        this.eventTypeContainer.innerHTML = '';
      }

      if (this.monthViewContainer) {
        this.monthViewContainer.innerHTML = '';
      }

      if (this.upcomingEventsContainer) {
        this.upcomingEventsContainer.innerHTML = '';
      }

      if (this.eventDetailsContainer) {
        this.eventDetailsContainer.innerHTML = '';
      }

      if (this.eventDetailsMobileContainer) {
        this.eventDetailsMobileContainer.innerHTML = '';
      }

      this.removeModal();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$C);
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Calendar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.calendar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$C);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$C, new Calendar(this, settings));
      }
    });
  };

  var COMPONENT_NAME$D = 'circlepager';
  /**
   * The Circle Pager Displays content in a sliding carousel and has paging buttons.
   * @class CirclePager
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {Integer} [settings.slidesToShow=1] The number of slides to show in one view / pane
   * @param {Integer} [settings.startingSlide] First showing slide/group, an 0-based integer
   * @param {boolean} [settings.loop=false] Setting loop: true will loop back after next/previous reached to end
   * @param {string} [settings.attributes=null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  var CIRCLEPAGER_DEFAULTS = {
    slidesToShow: 1,
    startingSlide: null,
    loop: false,
    attributes: null
  };

  function CirclePager(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, CIRCLEPAGER_DEFAULTS);
    this.init();
  } // CirclePager Methods


  CirclePager.prototype = {
    init: function init() {
      this.setElements();

      if (this.slides.length) {
        this.createControls();
        this.handleEvents();
        this.initActiveSlide();
        this.showCollapsedView();
        this.addAttributes();
      }
    },

    /**
     * Set elements
     * @private
     * @returns {void}
     */
    setElements: function setElements() {
      var s = this.settings;
      this.container = $('.slides', this.element);
      this.slidesJQ = $('.slide', this.element);
      this.slidesToShow = s.slidesToShow;
      this.slides = [];
      this.isVisible = true;

      for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
        this.slides.push({
          node: $(this.slidesJQ[i])
        });
      }

      this.activeIndex = s.startingSlide !== null && s.startingSlide > -1 && s.startingSlide < this.slides.length ? s.startingSlide : 0;
      utils.addAttributes(this.element, this, this.settings.attributes);
    },

    /**
     * Create controls
     * @private
     * @returns {void}
     */
    createControls: function createControls() {
      var len = this.slides.length;
      var html = '<div class="controls">';
      var htmlContent = '';
      var numOfButtons = 0;
      var slide;
      var temp;
      var href;
      var text;
      var buttonText;
      var last;
      var lastIndex;
      var isSingle;
      var isDisabled;

      for (var i = 0, l = len; i < l; i += this.slidesToShow) {
        temp = '';
        numOfButtons++;
        isSingle = this.slidesToShow === 1 || len - i === 1;
        text = Locale.translate(isSingle ? 'SlideOf' : 'SlidesOf'); // Keep href in english language only

        href = isSingle ? '#slide {0} of {1}' : '#slides {0} and {1} of {2}'; // Collect as much bullets need to present

        for (var g = 0; g < this.slidesToShow && i + g < len; g++) {
          temp += "".concat(i + g + 1, ", ");
        }

        text = text.replace(isSingle ? '{1}' : '{2}', len);
        href = href.replace(isSingle ? '{1}' : '{2}', len);
        temp = temp.slice(0, -2);
        lastIndex = temp.lastIndexOf(',');
        last = temp.substr(lastIndex + 2); // Controls for single slide in view

        if (isSingle) {
          isDisabled = '';
          slide = this.slides[i].node; // Set disabled

          if (slide.is('.is-disabled, [disabled]') && !slide.is('[disabled="false"]')) {
            isDisabled = ' disabled tabindex="-1"';
            this.slides[i].isDisabled = true;
          } // Set default starting slide


          if (slide.is('.active') && this.settings.startingSlide === null && isDisabled === '') {
            this.activeIndex = i;
          } // Use custom text if supplied


          buttonText = slide.attr('data-button-text');
          text = buttonText && buttonText.length ? buttonText : text.replace('{0}', temp);
          href = href.replace('{0}', temp);
        } else {
          // Controls for multiple slides in view
          temp = temp.substr(0, lastIndex);
          text = text.replace('{1}', last).replace('{0}', temp);
          href = href.replace('{1}', last).replace('{0}', temp);
        }

        href = href.toLowerCase().replace(/[\s,--]+/g, '-');
        htmlContent += "<a href=\"".concat(href, "\" class=\"control-button hyperlink hide-focus\"").concat(isDisabled, "><span class=\"audible\">").concat(text, "</span></a>");
      }

      html += "".concat(htmlContent, "</div>"); // Previous/Next buttons

      this.isBulletsNav = this.element.width() > numOfButtons * 29;
      var previousButton = $('.btn-previous', this.element);
      var nextButton = $('.btn-next', this.element);

      if (!this.isBulletsNav) {
        if (!previousButton.length) {
          html += '' + "<button class=\"btn-previous\" type=\"button\">\n            ".concat($.createIcon('left-arrow'), "\n            <span class=\"audible\"> ").concat(Locale.translate('Previous'), "</span>\n          </button>");
        }

        if (!nextButton.length) {
          html += '' + "<button class=\"btn-next\" type=\"button\">\n            ".concat($.createIcon('right-arrow'), "\n            <span class=\"audible\">").concat(Locale.translate('Next'), "</span>\n          </button>");
        }
      } else {
        previousButton.add(nextButton).remove();
      }

      if (this.activeIndex > 0 && this.activeIndex > numOfButtons - 1) {
        this.activeIndex = numOfButtons - 1;
      }

      if (numOfButtons > 1) {
        this.element.append(html);
      }
    },

    /**
     * Check if given element is visible in container
     * @private
     * @param {object} element to check.
     * @returns {boolean} -1 if not in container
     */
    isVisibleInContainer: function isVisibleInContainer(element) {
      if (element && element[0]) {
        var eRect = element[0].getBoundingClientRect();
        var cRect = this.element[0].getBoundingClientRect();
        return eRect.left > cRect.left && eRect.left < cRect.left + cRect.width && eRect.top > cRect.top && eRect.top < cRect.top + cRect.height;
      }

      return -1;
    },

    /**
     * Update number of slides to show in view
     * @private
     * @param {object} numOfSlides to show.
     * @returns {object} this api
     */
    updateSlidesToShow: function updateSlidesToShow(numOfSlides) {
      if (!this.isActive) {
        return;
      }

      this.settings.slidesToShow = numOfSlides || 1;
      this.updated();
      return this; // eslint-disable-line
    },

    /**
     * Make sure max number of slides to show in view
     * @private
     * @param {object} numOfSlides to show.
     * @returns {void}
     */
    responsiveSlidesToShow: function responsiveSlidesToShow(numOfSlides) {
      var _this = this;

      if (!this.isActive) {
        return;
      }

      this.slidesToShow = numOfSlides || this.settings.slidesToShow;
      this.unbind().slidesJQ.css('width', '');

      if (this.slides.length) {
        setTimeout(function () {
          _this.createControls();

          _this.handleEvents();

          _this.initActiveSlide();

          _this.showCollapsedView();
        }, 0);
      }
    },

    /**
     * Show a slide to First Slide
     * @private
     * @param {string} index  The index of the slide to show (0 based)
     * @returns {void}
     */
    show: function show(index) {
      if (!this.isActive) {
        return;
      }

      index = typeof index !== 'undefined' ? index : this.activeIndex;
      this.activeIndex = index;
      var left = index > 0 ? "".concat((Locale.isRTL() ? '' : '-') + index * 100, "%") : 0;
      this.controlButtons.removeClass('is-active').eq(index).addClass('is-active');
      this.container[0].style.left = left; // Make sure bullets navigation do not overflow

      if (!this.isBulletsNav) {
        this.element.addClass('is-bullets-nav-hidden');
        this.controlButtons.find('span').addClass('audible').end().eq(index).find('span').removeClass('audible');
      } else {
        this.element.removeClass('is-bullets-nav-hidden');
        this.controlButtons.find('span').addClass('audible');
      } // Set focus


      if (this.isFocus && this.isBulletsNav) {
        this.isFocus = false;
        this.controlButtons.eq(index).focus();
      }
    },

    /**
     * Move to First Slide
     * @private
     * @returns {void}
     */
    first: function first() {
      this.show(0);
    },

    /**
     * Move to Last Slide
     * @private
     * @returns {void}
     */
    last: function last() {
      this.show(Math.round(this.slides.length / this.slidesToShow) - 1);
    },

    /**
     * Move to Previous Slide
     * @private
     * @returns {void}
     */
    prev: function prev() {
      var _this2 = this;

      // eslint-disable-line
      var prev;

      if (this.activeIndex > 0) {
        prev = this.activeIndex - 1;
      } else {
        prev = this.settings.loop ? Math.round(this.slides.length / this.slidesToShow) - 1 : 0;
      }

      if (this.slides[prev].isDisabled) {
        setTimeout(function () {
          _this2.prev();
        }, 0);
        this.activeIndex = prev;
        return false;
      }

      this.show(prev);
    },

    /**
    * Move to Next Slide
    * @private
    * @returns {void}
    */
    next: function next() {
      var _this3 = this;

      // eslint-disable-line
      var next;

      if (this.activeIndex >= Math.round(this.slides.length / this.slidesToShow) - 1) {
        next = this.settings.loop ? 0 : this.activeIndex;
      } else {
        next = this.activeIndex + 1;
      }

      if (this.slides[next].isDisabled) {
        setTimeout(function () {
          _this3.next();
        }, 0);
        this.activeIndex = next;
        return false;
      }

      this.show(next);
    },

    /**
    * Make active
    * @private
    * @returns {void}
    */
    showCollapsedView: function showCollapsedView() {
      this.isActive = true;
      this.element.addClass('is-active');
      this.container[0].style.width = "".concat(100 * this.slides.length, "%");

      if (this.settings.slidesToShow > 1 && this.slidesJQ.eq(0).width() * this.slidesToShow > this.element.width()) {
        this.responsiveSlidesToShow(this.slidesToShow - 1);
        return;
      }

      for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
        this.slidesJQ[i].style.width = "".concat(100 / this.slidesToShow / this.slides.length, "%");
      }

      this.show();
    },

    /** 
     * Add attributes for control buttons
     * @private
     * @returns {void}
     */
    addAttributes: function addAttributes() {
      for (var i = 0, l = this.controlButtons.length; i < l; i++) {
        var ctrlBtns = $(this.controlButtons[i]);
        utils.addAttributes(ctrlBtns, this, this.settings.attributes, "control-".concat(i + 1));
      }
    },

    /**
    * Make un-active
    * @private
    * @returns {void}
    */
    showExpandedView: function showExpandedView() {
      this.isActive = false;
      this.element.removeClass('is-active');

      if (this.element && this.element[0]) {
        this.element[0].style.width = '';
      }

      if (this.container && this.container[0]) {
        this.container[0].style.width = '';
        this.container[0].style.left = '';
      }
    },

    /**
    * Initialize active slide
    * @private
    * @returns {void}
    */
    initActiveSlide: function initActiveSlide() {
      // eslint-disable-line
      if (this.slides[this.activeIndex].isDisabled) {
        this.next();
        return false;
      }

      this.show();
      this.slidesJQ.addClass('is-visible');
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      $('body').off('resize.circlepager');
      this.element.off('focus.circlepager keydown.circlepager', '*');

      if (this.controlButtons) {
        this.controlButtons.off('click.circlepager keydown.circlepager');
      }

      $('.btn-previous, .btn-next', this.element).off('click.circlepager');
      $('.controls', this.element).remove();
      this.showExpandedView();
      var possibleTab = this.element.closest('.tab-panel-container').prev('.tab-container');
      possibleTab.off('activated.circlepager');
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, CIRCLEPAGER_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$D);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this4 = this;

      var self = this; // Previous button

      $('.btn-previous', this.element).on('click.circlepager', function (e) {
        _this4.prev();

        e.stopImmediatePropagation();
      }); // Next button

      $('.btn-next', this.element).on('click.circlepager', function (e) {
        _this4.next();

        e.stopImmediatePropagation();
      });
      this.controlButtons = $('.control-button', this.element);

      var _loop = function _loop(i, l) {
        var btn = $(_this4.controlButtons[i]);
        btn.hideFocus(); // Handle clicks for bottom bullet links

        btn.on('click.circlepager', function (e) {
          e.preventDefault();

          if (_this4.slides[i].isDisabled) {
            return;
          }

          _this4.show(i);
        });
      };

      for (var i = 0, l = this.controlButtons.length; i < l; i++) {
        _loop(i);
      } // Handle keyboard events
      // Prevent hidden slide's content to be get focused
      // on focusable elements in slides content


      this.element.on('focus.circlepager', '*', function (e) {
        // eslint-disable-line
        var handled = false;

        if (!self.isVisibleInContainer($(this))) {
          var canfocus = self.element.find(':focusable');

          for (var _i = 0, _l = canfocus.length; _i < _l; _i++) {
            if (self.isVisibleInContainer(canfocus.eq(_i))) {
              canfocus.eq(_i).focus();
              handled = true;
              break;
            }
          }
        }

        e.stopPropagation();

        if (handled) {
          return false;
        }
      }); // Keydown on focusable elements in slides content to
      // prevent hidden slide's content to be get focused

      this.element.on('keydown.circlepager', '*', function (e) {
        // eslint-disable-line
        var handled = false;
        var key = e.which || e.keyCode || e.charCode || 0;
        var canfocus = $(':focusable');
        var index = canfocus.index(this);

        if (key === 9) {
          // tab
          // Using shift key with tab (going backwards)
          if (e.shiftKey) {
            for (var _i2 = index - 1; _i2 >= 0; _i2--) {
              if (self.element.has(canfocus.eq(_i2)).length < 1 || self.isVisibleInContainer(canfocus.eq(_i2))) {
                canfocus.eq(_i2).focus();
                handled = true;
                break;
              }
            }
          } else if (!self.isVisibleInContainer(canfocus.eq(index + 1))) {
            // Using only tab key (going forward)
            self.controlButtons.first().focus();
            handled = true;
          }
        }

        e.stopPropagation();

        if (handled) {
          return false;
        }
      }); // Control buttons

      this.controlButtons.on('keydown.circlepager', function (e) {
        // eslint-disable-line
        var handled = false;
        var key = e.which || e.keyCode || e.charCode || 0;
        var isRTL = Locale.isRTL(); // Left and Right arrow keys

        if ([37, 39].indexOf(key) !== -1) {
          self.isFocus = true; // Move focus

          if (e.altKey) {
            // [Alt + Left/Right arrow] to move to the first or last
            if (key === 37 && !isRTL || key === 39 && isRTL) {
              self.first();
            } else {
              self.last();
            }
          } else {
            // Left and Right arrow keys to navigate
            if (!isRTL && key === 37 || isRTL && key === 39) {
              self.prev();
            } else {
              self.next();
            }

            handled = true;
          }
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }); // Set max number of slides can view on resize

      $('body').on('resize.circlepager', function () {
        self.responsiveSlidesToShow();
      });
      var possibleTab = self.element.closest('.tab-panel-container').prev('.tab-container');
      possibleTab.off('activated.circlepager').on('activated.circlepager', function () {
        self.responsiveSlidesToShow();
      });
    }
  };

  /**
   * jQuery Component Wrapper for CirclePager
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.circlepager = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$D);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$D, new CirclePager(this, settings));
      }
    });
  };

  /**
   * jQuery Component Wrapper for CalendarToolbar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.calendartoolbar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$z);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$z, new CalendarToolbar(this, settings));
      }
    });
  };

  var COMPONENT_NAME$E = 'compositeform';
  /**
  * CompositeForm is a specialized responsive form component.
  * @class CompositeForm
  * @deprecated as of v4.20.0. This component is no longer supported by the IDS team.
  * @constructor
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [settings.breakpoint = 'phone-to-tablet'] Defines the breakpoint at which the composite form will change into its responsive mode
  * @param {string} [settings.trigger = null] Expandable area trigger selector. Passed to expandable area.
  * @param {string} [settings.expandedText = Locale.translate('ShowLess')] Text to use for the expand button (Default localized)
  * @param {string} [settings.collapsedText = Locale.translate('ShowMore')] Text to use for the collapse button (Default localized)
  */

  var COMPOSITEFORM_DEFAULTS = {
    breakpoint: 'phone-to-tablet',
    trigger: null,
    expandedText: Locale.translate('ShowLess'),
    collapsedText: Locale.translate('ShowMore')
  };

  function CompositeForm(element, settings) {
    this.settings = utils.mergeSettings(element, settings, COMPOSITEFORM_DEFAULTS);
    this.element = $(element);
    this.init();
    warnAboutRemoval('CompositeForm');
  } // Component API


  CompositeForm.prototype = {
    /**
    * Initialize the component
    * @private
    * @returns {object} The component api for chaining.
    */
    init: function init() {
      return this.build().handleEvents();
    },

    /**
    * Adds markup to the control and stores references to some sub-elements
    * @private
    * @returns {object} The component api for chaining.
    */
    build: function build() {
      var componentClassList = this.element[0].classList;

      if (!componentClassList.contains('composite-form')) {
        componentClassList.add('composite-form');
      } // Get expandable area reference, if applicable


      var expandableArea = this.element.find('.expandable-area');

      if (expandableArea.length) {
        this.hasSummary = true;
        this.expandableArea = expandableArea;
        this.expandableAreaAPI = this.expandableArea.data('expandablearea');

        if (!this.expandableAreaAPI) {
          this.expandableArea.expandablearea({
            trigger: this.settings.trigger
          });
          this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        } // Get expandable trigger


        this.expander = this.expandableAreaAPI.expander;
        this.setExpanderText(this.settings.expandedText);
      } else {
        this.hasSummary = false;
      } // Check size and append class, if necessary


      this.checkResponsive();
      return this;
    },

    /**
     * Sets up event handlers for this control and its sub-elements
     * @param {string} expanderText - the text content
     * @returns {undefined}
     */
    handleEvents: function handleEvents() {
      var self = this;
      $('body').off("resize.".concat(COMPONENT_NAME$E)).on("resize.".concat(COMPONENT_NAME$E), function (e) {
        self.checkResponsive(e);
      });
      this.element.on("updated.".concat(COMPONENT_NAME$E), function () {
        self.updated();
      });

      function changeExpanderText() {
        var isExpanded = self.expandableAreaAPI.isExpanded();
        self.setExpanderText(self.settings[isExpanded ? 'expandedText' : 'collapsedText']);
      }

      if (this.hasSummary) {
        this.expandableArea.on("expand.".concat(COMPONENT_NAME$E), changeExpanderText).on("collapse.".concat(COMPONENT_NAME$E), changeExpanderText);
      }

      return this;
    },

    /**
     * Checks if we've passed the breakpoint for switching into Responsive mode.
     * @returns {undefined}
     */
    checkResponsive: function checkResponsive() {
      var cl = this.element[0].classList;

      if (breakpoints.isBelow(this.settings.breakpoint)) {
        cl.add('is-in-responsive-mode');
      } else {
        cl.remove('is-in-responsive-mode');

        if (this.isSideOriented() && !this.expandableAreaAPI.isExpanded()) {
          this.expandableAreaAPI.open();
        }
      }
    },

    /**
     * Sets the text content of the Composite Form's Expandable Area Expander.
     * @param {string} expanderText - the text content
     * @returns {undefined}
     */
    setExpanderText: function setExpanderText(expanderText) {
      if (!this.hasSummary) {
        return;
      }

      if (!(expanderText instanceof String) || !expanderText.length) {
        return;
      }

      var textSpan = this.expander.find('span');

      if (!textSpan) {
        textSpan = this.expander;
      }

      textSpan.text(expanderText);
    },

    /**
     * Determines if this component is configured for "on-side" orientation of the Summary area.
     * @returns {boolean} If the component is currently side oriented.
     */
    isSideOriented: function isSideOriented() {
      return this.element[0].classList.contains('on-side');
    },

    /**
     * Re-invokes the Composite Form
     * @returns {object} The component API for chaining.
     */
    updated: function updated() {
      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The component API for chaining.
     */
    teardown: function teardown() {
      $('body').off("resize.".concat(COMPONENT_NAME$E));
      this.element.off("updated.".concat(COMPONENT_NAME$E));

      if (this.hasSummary) {
        this.expandableArea.off("expand.".concat(COMPONENT_NAME$E, " collapse.").concat(COMPONENT_NAME$E));
      }

      return this;
    },

    /**
     * Destroys the component instance by removing it from its associated element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$E);
    }
  };

  /**
   * jQuery Component Wrapper for Composite Form
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.compositeform = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$E);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$E, new CompositeForm(this, settings));
      }
    });
  };

  var COMPONENT_NAME$F = 'contextualactionpanel';
  /**
  * A more complex modal for complex in page interactions.
  * @class ContextualActionPanel
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  * @param {jQuery|string} [settings.content = null] Pass content through to CAP.
  * @param {boolean} [settings.initializeContent = true] Initialize content before opening with defaults.
  * @param {string} [settings.title = 'Contextual Action Panel'] String that sits in the toolbar's title field.
  * @param {object} [settings.modalSettings = {}] an object containing settings for the internal Modal component.
  * @param {array} [settings.modalSettings.buttons = null] A list of buttons that will sit in the toolbar's Buttonset area.
  * @param {boolean} [settings.modalSettings.centerTitle = false] If true the title will be centered.
  * @param {string} [settings.modalSettings.id = `contextual-action-modal-[number]`] The id to use for the CAP, or defaults to generated.
  * @param {boolean} [settings.modalSettings.showCloseBtn = false] if true, displays a "close (X)" button in the button row that cancels the CAP's Modal action.
  * @param {string} [settings.modalSettings.trigger = 'click'] Can be 'click' or 'immediate'.
  * @param {boolean} [settings.modalSettings.useFlexToolbar = false] If true the new flex toolbar will be used (For CAP)
  * @param {string} [settings.modalSettings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var CONTEXTUALACTIONPANEL_DEFAULTS = {
    content: null,
    initializeContent: true,
    // initialize content before opening
    title: 'Contextual Action Panel',
    modalSettings: {
      buttons: null,
      centerTitle: false,
      id: null,
      showCloseBtn: false,
      trigger: 'click',
      useFlexToolbar: false
    }
  }; // List of settings that used to reside directly underneath the `defaults`, but have
  // been re-located to `settings.modalSettings` as of v4.22.x.
  // See `infor-design/enterprise#2433` for more information.
  // TODO: find a way to normalize CAP's `content` setting with Modal's.  For some reason,
  // they are different and have been that way for some time.

  var CONTEXTUAL_MODAL_SETTINGS = ['buttons', 'centerTitle', 'id', 'showCloseButton', 'trigger', 'useFlexToolbar']; // Handles the conversion of legacy CAP settings to `modalSettings` setting.

  function handleLegacyCAPSettings(settings) {
    // Some settings are renamed to match their Modal counterparts
    var conversionMap = {
      showCloseButton: 'showCloseBtn'
    };
    CONTEXTUAL_MODAL_SETTINGS.forEach(function (setting) {
      if ([null, undefined].indexOf(settings[setting]) === -1) {
        var targetSettingName = setting;

        if (!settings.modalSettings) {
          settings.modalSettings = {};
        }

        if (conversionMap[setting]) {
          // Convert a differently-named setting to the correct name
          targetSettingName = conversionMap[setting];
          settings.modalSettings[targetSettingName] = settings[setting];
        } else {
          // Simply append the actual setting
          settings.modalSettings[setting] = settings[setting];
        }

        delete settings[setting];
        warnAboutDeprecation("settings.modalSettings.".concat(targetSettingName), "settings.".concat(setting));
      }
    });
    return settings;
  }

  function ContextualActionPanel(element, settings) {
    this.settings = utils.mergeSettings(element, settings, CONTEXTUALACTIONPANEL_DEFAULTS);
    this.settings = handleLegacyCAPSettings(this.settings);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  ContextualActionPanel.prototype = {
    /**
     * @returns {Modal|undefined} instance of an IDS modal, or undefined if one doesn't exist
     */
    get modalAPI() {
      var api;

      if (this.panel && this.panel.length) {
        api = this.panel.data('modal');
      }

      return api;
    },

    /**
     * @returns {Toolbar|ToolbarFlex|undefined} instance of an IDS Toolbar, IDS Toolbar Flex, or undefined if one doesn't exist.
     */
    get toolbarAPI() {
      var api;

      if (this.toolbar && this.toolbar.length) {
        if (this.toolbar[0].classList.contains('flex-toolbar')) {
          api = this.toolbar.data('toolbar-flex');
        } else {
          api = this.toolbar.data('toolbar');
        }
      }

      return api;
    },

    /**
    * Initialize the CAP.
    * @private
    */
    init: function init() {
      this.setup().build().handleEvents();
    },

    /**
    * Setup internal variables.
    * NOTE: Does not do any building.
    * @private
    * @returns {object} The Api for chaining.
    */
    setup: function setup() {
      var existingPanel = this.element.next('.contextual-action-panel');
      var modalId = this.id;

      var setPanel = function setPanel(id) {
        var panelFromID = $("#".concat(id));

        if (panelFromID.length) {
          existingPanel = panelFromID;
        }
      };

      if (typeof dataModal === 'string') {
        setPanel(modalId);
      } // Handle case with popup triggered from a menu


      if (this.element.closest('.popupmenu').length === 1) {
        existingPanel = this.element.closest('.popupmenu').next('.contextual-action-panel');
      }

      if (existingPanel[0]) {
        existingPanel[0].style.display = 'none';
        existingPanel.addClass('is-animating');
        this.panel = existingPanel;
      }

      return this;
    },

    /**
    * Add markup to build up the component.
    * @private
    * @returns {object} The Api for chaining.
    */
    build: function build() {
      var _this$settings, _this$settings$modalS, _this$settings2, _this$settings2$modal;

      var self = this;
      var modalContent = this.settings.content;
      this.id = ((_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : (_this$settings$modalS = _this$settings == null ? void 0 : _this$settings.modalSettings) === null || _this$settings$modalS === void 0 ? void 0 : _this$settings$modalS == null ? void 0 : _this$settings$modalS.id) || (modalContent === null || modalContent === void 0 ? void 0 : modalContent == null ? void 0 : modalContent.attr('id')) || utils.uniqueId(this.element, 'contextual-action-modal');

      if (!((_this$settings2 = this.settings) !== null && _this$settings2 !== void 0 && (_this$settings2$modal = _this$settings2 == null ? void 0 : _this$settings2.modalSettings) !== null && _this$settings2$modal !== void 0 && (_this$settings2$modal == null ? void 0 : _this$settings2$modal.id))) {
        this.settings.modalSettings.id = this.id;
      } // Build the Content if it's not present


      if (!this.panel || !this.panel.length) {
        if (modalContent instanceof jQuery) {
          if (modalContent.is('.contextual-action-panel')) {
            this.panel = modalContent;
          } else {
            modalContent.wrap('<div class="contextual-action-panel"></div>');
            this.panel = modalContent.parent();
          }

          this.panel.addClass('modal').appendTo('body');

          if (modalContent.is('iframe')) {
            modalContent.ready(function () {
              self.completeBuild();
              modalContent.show();
            });
            return self;
          }

          modalContent.show();
        } else {
          this.panel = $("<div class=\"contextual-action-panel\">".concat(modalContent, "</div>")).appendTo('body');
          this.panel.addClass('modal').attr('id', this.settings.modalSettings.id);
        }
      }

      this.completeBuild();
      return this;
    },

    /**
    * Finalize build up/
    * @private
    * @returns {object} The Api for chaining.
    */
    completeBuild: function completeBuild() {
      var children;
      var isIframe = false;
      var contents;
      var hasSearchfield = false;
      var predefined = true; // Invoke Icons

      this.panel.find('svg').icon(); // Get a reference to `.modal-content`

      var modalContent = this.panel.find('.modal-content');

      if (modalContent.length === 0) {
        children = this.panel.children();

        if (children.is('iframe')) {
          contents = children.contents();
          this.toolbar = contents.find('.toolbar, .flex-toolbar');
          isIframe = true;
        }

        if (!isIframe) {
          children.wrapAll('<div class="modal-content"></div>').wrapAll('<div class="modal-body"></div>');
          this.panel.addClass('modal');
        }
      } // Build/reference the header


      var modalHeader = this.panel.find('.modal-header');

      if (modalHeader.length === 0) {
        modalHeader = $('<div class="modal-header"></div>');
        modalHeader.insertBefore(this.panel.find('.modal-body'));
      }

      this.header = modalHeader; // Detect existence of buttonset for later

      var buttonset = this.panel.find('.toolbar .buttonset, .flex-toolbar .buttonset'); // Build/reference the CAP header toolbar

      if (!this.toolbar) {
        this.toolbar = this.panel.find('.toolbar, .flex-toolbar');
      }

      if (!this.toolbar.length) {
        predefined = false;

        if (this.settings.modalSettings.buttons) {
          this.settings.modalSettings.buttons.forEach(function (button) {
            if (button.type === 'input') {
              hasSearchfield = true;
            }
          });
        }

        if (this.settings.title && this.settings.modalSettings.centerTitle) {
          var toolbarSearchfieldSection = hasSearchfield ? '<div class="toolbar-section search"></div>' : '';
          var toolbarHTML = "<div class=\"flex-toolbar\">\n          <div class=\"toolbar-section static\"></div>\n          <div class=\"toolbar-section title center-text\">\n            <h2>".concat(this.settings.title, "</h2>\n          </div>\n          ").concat(toolbarSearchfieldSection, "\n          <div class=\"toolbar-section buttonset static\"></div>\n        </div>");
          this.toolbar = $(toolbarHTML);
        } else if (!buttonset.length) {
          var toolbarCSSClass = this.settings.modalSettings.useFlexToolbar ? 'flex-toolbar' : 'toolbar';
          var toolbarTitleSection = this.settings.modalSettings.useFlexToolbar ? "<div class=\"toolbar-section title\"><h2>".concat(this.settings.title, "</h2></div>") : '';
          var toolbarButtonsetCSSClass = this.settings.modalSettings.useFlexToolbar ? 'toolbar-section buttonset' : 'buttonset';
          var toolbarButtonsetSection = "<div class=\"".concat(toolbarButtonsetCSSClass, "\"></div>");

          var _toolbarSearchfieldSection = this.settings.modalSettings.useFlexToolbar && hasSearchfield ? '<div class="toolbar-section search"></div>' : '';

          var _toolbarHTML = "<div class=\"".concat(toolbarCSSClass, "\">\n          ").concat(toolbarTitleSection, "\n          ").concat(_toolbarSearchfieldSection, "\n          ").concat(toolbarButtonsetSection, "\n        </div>");

          var toolbar = $(_toolbarHTML);
          toolbar.appendTo(this.panel.find('.modal-header'));
          this.toolbar = toolbar;
          buttonset = toolbar.children('.buttonset');
        }
      }

      this.toolbar.appendTo(this.header); // Only add certain elements if a Toolbar was generated with JS-options
      // and not by HTML markup.

      if (!predefined) {
        if (!buttonset || !buttonset.length && !this.settings.modalSettings.centerTitle) {
          buttonset = $('<div class="toolbar-section buttonset"></div>');
          buttonset.appendTo(this.toolbar);
        }

        var toolbarTitle = this.toolbar.find('.title');

        if (!toolbarTitle.length) {
          var centerTextCSS = this.settings.modalSettings.centerTitle ? ' center-text' : '';
          toolbarTitle = $("\n          <div class=\"toolbar-section title".concat(centerTextCSS, "\">\n            <h2>").concat(this.settings.title, "</h2>\n          </div>\n        "));

          if (buttonset) {
            toolbarTitle.insertBefore(buttonset);
          } else {
            this.toolbar.prepend(toolbarTitle);
          }
        }

        if (!toolbarTitle.length) {
          toolbarTitle = $("\n          <div class=\"title\">\n            ".concat(this.settings.title, "\n          </div>\n        "));
          this.toolbar.prepend(toolbarTitle);
        }
      } // Move to the body element to break stacking context issues.


      if (!isIframe) {
        this.panel.detach().appendTo('body');
      } // Creates a link to a Modal panel if one isn't present.
      // (Usually needed for linking to a jQuery settings-defined CAP)


      if (!this.element.attr('data-modal')) {
        this.element.attr('data-modal', this.settings.modalSettings.id);
      }

      if (!this.panel.attr('id')) {
        this.panel.attr('id', this.settings.modalSettings.id);
      } // Invoke the underlying Modal API


      this.panel.modal(this.settings.modalSettings);
      this.buttons = this.panel.find('.buttonset').children('button');
      this.closeButton = this.panel.find('.modal-header').find('.btn-close, [name="close"], button.close-button');

      if (this.settings.modalSettings.showCloseBtn && !this.closeButton.length) {
        var closeText = Locale.translate('Close');
        this.closeButton = $("\n        <button class=\"btn-close\" type=\"button\" title=\"".concat(closeText, "\">\n          ").concat($.createIcon('close'), "\n          <span class=\"audible\">").concat(closeText, "</span>\n        </button>\n      "));

        if (!this.settings.modalSettings.useFlexToolbar) {
          buttonset.append(this.closeButton);
        } else {
          var standaloneSection = $('<div class="toolbar-section static"></div>').append(this.closeButton);
          var more = this.toolbar.find('.toolbar-section.more');
          standaloneSection.insertAfter(more.length ? more : buttonset);
        }
      }

      if (this.closeButton.length) {
        this.toolbar.addClass('has-close-button');
      }

      if (this.toolbar.is('.toolbar')) {
        this.toolbar.toolbar();
      }

      if (this.toolbar.is('.flex-toolbar')) {
        this.toolbar.toolbarflex();
      }

      utils.fixSVGIcons(this.element);
      return this;
    },

    /**
    * Attach event handlers.
    * @private
    * @returns {object} The Api for chaining.
    */
    handleEvents: function handleEvents() {
      var self = this; // Convenience method that takes an event from the Modal control's panel element,
      // and triggers any listeners that may be looking at the Contextual Action Panel's
      // trigger instead.

      function passEvent(e) {
        self.element.triggerHandler(e.type);
      }

      this.panel.addClass('is-animating').off('open.contextualactionpanel').on('open.contextualactionpanel', function (e) {
        passEvent(e);
        self.panel.removeClass('is-animating');
      }).off('close.contextualactionpanel').on('close.contextualactionpanel', function (e) {
        passEvent(e);
      }).off('beforeopen.contextualactionpanel').on('beforeopen.contextualactionpanel', function (e) {
        if (self.settings.initializeContent) {
          $(this).initialize();
        }

        passEvent(e);
      }).off('afteropen.contextualactionpanel').on('afteropen.contextualactionpanel', function () {
        if (self.toolbar) {
          self.toolbar.trigger('recalculate-buttons');
        } // Select the proper element on the toolbar


        if (self.toolbar.length) {
          var selected = self.toolbar.find('.buttonset > .is-selected');

          if (!selected.length) {
            selected = self.toolbar.find('.buttonset > *:first-child');

            if (selected.is('.searchfield-wrapper')) {
              selected = selected.children('.searchfield');
            }
          }

          if (!selected.length && self.toolbar.is('.flex-toolbar')) {
            selected = self.toolbar.find('button').first();
            selected.focus();
            return;
          }

          var toolbarData = self.toolbar.data('toolbar');

          if (toolbarData) {
            toolbarData.setActiveButton(selected, true);
          }
        } // Focus the first focusable element inside the Contextual Panel's Body


        self.panel.find('.modal-body-wrapper').find(':focusable').first().focus();
        utils.fixSVGIcons(self.panel);
      });

      if (self.closeButton && self.closeButton.length) {
        self.closeButton.on('click.contextualactionpanel', function () {
          self.handleToolbarSelected();
        });
      }

      return this;
    },

    /**
    * Toolbar select event handler.
    * @private
    * @returns {void}
    */
    handleToolbarSelected: function handleToolbarSelected() {
      this.close(true);
    },

    /**
    * Detach events and restore markup.
    * @private
    * @returns {void}
    */
    teardown: function teardown() {
      var self = this;
      var buttonset = self.toolbar.children('.buttonset');
      this.panel.off('open.contextualactionpanel close.contextualactionpanel ' + 'beforeopen.contextualactionpanel afterclose.contextualactionpanel');
      buttonset.children('*:not(.searchfield)').off('click.contextualactionpanel');
      var menuButtons = buttonset.children('.btn-menu');
      menuButtons.each(function () {
        var popup = $(this).data('popupmenu');

        if (popup) {
          popup.destroy();
        }
      });

      if (self.header) {
        self.header.remove();
      }

      var children = self.panel.find('.modal-body').children();
      children.first().unwrap().unwrap();
      self.element.removeAttr('data-modal');

      if (self.closeButton && self.closeButton.length) {
        self.closeButton.off('click.contextualactionpanel');
        delete self.closeButton;
      } // Trigger an afterclose event on the Contextual Action Panel's trigger element
      // (different from the panel, which is already removed).


      self.element.trigger('afterteardown');
    },

    /**
    * Close the Contextual Action Panel if open and call destroy.
    * @param {boolean} [doForce = false] if true, forces the modal to close.
    * @returns {void}
    */
    close: function close() {
      var doForce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var destroy;

      if (this.settings.modalSettings.trigger === 'immediate') {
        destroy = true;
      }

      if (this.modalAPI) {
        this.modalAPI.close(destroy, false, doForce);
      }
    },

    /**
    * Add a disabled attribute to the main component element.
    * @returns {void}
    */
    disable: function disable() {
      this.element.prop('disabled', true);

      if (this.panel.hasClass('is-visible')) {
        this.close();
      }
    },

    /**
    * Remove disabled attribute from the main component element.
    * @returns {void}
    */
    enable: function enable() {
      this.element.prop('disabled', false);
    },

    /**
     * Update the component and optionally apply new settings.
     *
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.settings = handleLegacyCAPSettings(this.settings);
      this.setup();

      if (this.modalAPI) {
        this.modalAPI.updated(this.settings.modalSettings);
      }

      return this;
    },

    /**
    * Destroy and remove added markup and events
    * @returns {void}
    */
    destroy: function destroy() {
      // ModalAPI calls `capAPI.teardown()` at the correct timing
      if (this.modalAPI && this.modalAPI.isOpen) {
        this.modalAPI.close(true);
      }

      $.removeData(this.element[0], COMPONENT_NAME$F);

      if (this.toolbar && this.toolbar.data('toolbar')) {
        this.toolbar.data('toolbar').destroy();
      }

      if (this.toolbar && this.toolbar.data('toolbarFlex')) {
        this.toolbar.data('toolbarFlex').destroy();
      }
    },

    /**
    * Destroy an and all active cap instances
    * @returns {void}
    */
    destroyAll: function destroyAll() {
      modalManager.destroyAll(true);
    }
  };

  /**
   * jQuery Component Wrapper for Contextual Action Panel
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.contextualactionpanel = function (settings) {
    return this.each(function () {
      var _settings$modalSettin;

      var id = settings === null || settings === void 0 ? void 0 : (_settings$modalSettin = settings == null ? void 0 : settings.modalSettings) === null || _settings$modalSettin === void 0 ? void 0 : _settings$modalSettin == null ? void 0 : _settings$modalSettin.id;

      if (!id && settings !== null && settings !== void 0 && (settings == null ? void 0 : settings.content) && (settings === null || settings === void 0 ? void 0 : settings == null ? void 0 : settings.content) instanceof jQuery) {
        var _settings$content;

        id = settings === null || settings === void 0 ? void 0 : (_settings$content = settings == null ? void 0 : settings.content) === null || _settings$content === void 0 ? void 0 : _settings$content == null ? void 0 : _settings$content.attr('id');
      }

      var instance = modalManager.findById(id);

      if (instance) {
        instance.updated(settings);
        return;
      }

      $.data(this, COMPONENT_NAME$F, new ContextualActionPanel(this, settings));
    });
  };

  // Simply setup the Popover to be the same thing as the Tooltip.

  $.fn.popover = $.fn.tooltip;

  var COMPONENT_NAME$G = 'timepicker'; // Timepicker Modes

  var TIMEPICKER_MODES = ['standard', 'range']; // Timepicker defaults

  var TIMEPICKER_DEFAULTS = function TIMEPICKER_DEFAULTS() {
    return {
      locale: null,
      language: null,
      timeFormat: undefined,
      minuteInterval: 5,
      secondInterval: 5,
      mode: TIMEPICKER_MODES[0],
      roundToInterval: true,
      parentElement: null,
      returnFocus: true,
      attributes: null
    };
  };
  /**
   * The Timepicker Component provides a click/touch user interface for setting a time.
   * @class TimePicker
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.language] The name of the language to use for this instance. If not set the current locale will be used or the passed locale will be used.
   * @param {string} [settings.timeFormat = 'h:mm a'] The time format, defaults to the current locales time format.
   * @param {number} [settings.minuteInterval = 5]  Integer from 1 to 60.  Multiples of this value
   *  are displayed as options in the minutes dropdown.
   * @param {number} [settings.secondInterval = 5]  Integer from 1 to 60.
   * @property {string} [settings.mode = 'standard']  Can be set to 'standard', 'range',
   * @property {boolean} [settings.roundToInterval = true]  if `false`, does not automatically round user-entered values
   * from the pickers to their nearest interval.
   * @param {null|jQuery[]} [settings.parentElement] if defined as a jQuery-wrapped element, will be used as the target element.
   * @property {string} [settings.returnFocus = true]  If set to false, focus will not be returned to
   *  the calling element. It usually should be for accessibility purposes.
   * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
   */


  function TimePicker(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TIMEPICKER_DEFAULTS);
    this.init();
  } // Plugin Methods


  TimePicker.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setLocaleThenBuild();
    },

    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocaleThenBuild: function setLocaleThenBuild() {
      var _this = this;

      var languageDf = Locale.getLocale(this.settings.language);
      var localeDf = Locale.getLocale(this.settings.locale);
      $.when(localeDf, languageDf).done(function (locale, lang) {
        _this.locale = Locale.cultures[locale] || Locale.currentLocale;
        _this.language = lang || _this.settings.language || _this.locale.language || null;
        _this.settings.language = _this.language;

        _this.setCurrentCalendar();

        _this.build().handleEvents().addAttributes();
      });
      return this;
    },

    /**
     * Sets current calendar information.
     * @private
     * @returns {object} The api object for chaining.
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.locale.name, this.settings.language, this.settings.calendarName);

      if (this.settings.timeFormat === undefined) {
        this.settings.timeFormat = this.currentCalendar.timeFormat || 'h:mm a';
      }

      this.isRTL = (this.locale.direction || this.locale.data.direction) === 'right-to-left';
      this.build();
      return this;
    },

    /**
     * Configure any settings for the Timepicker
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      function sanitizeIntervals(value, type) {
        if (!type || ['minute', 'second'].indexOf(type) < 0) {
          type = 'minute';
        }

        var defaultInterval = TIMEPICKER_DEFAULTS()["".concat(type, "Interval")];

        if (value === undefined || isNaN(value)) {
          return defaultInterval;
        }

        var intValue = parseInt(value, 10);
        return intValue > 0 && intValue < 60 ? intValue : defaultInterval;
      }

      function sanitizeTimeFormat(value) {
        if (!value || !value.toUpperCase().match('H') || !value.match('mm')) {
          return TIMEPICKER_DEFAULTS().timeFormat;
        }

        return value;
      }

      function sanitizeRoundToInterval(value) {
        return value === true;
      }

      function sanitizeMode(value) {
        var modes = ['standard', 'range'];
        return $.inArray(value, modes) > -1 ? value : TIMEPICKER_DEFAULTS().mode;
      }

      this.id = "".concat(utils.uniqueId(this.element, 'timepicker'), "-id");
      this.hoursId = "timepicker-hours-".concat(this.id.toString());
      this.minutesId = "timepicker-minutes-".concat(this.id.toString());
      this.secondsId = "timepicker-seconds-".concat(this.id.toString());
      this.periodId = "timepicker-period-".concat(this.id.toString());

      if (this.element.is('[data-round-to-interval]')) {
        this.settings.roundToInterval = sanitizeRoundToInterval(this.element.attr('data-round-to-interval'));
      }

      if (this.element.is('[data-minute-interval]')) {
        this.settings.minuteInterval = sanitizeIntervals(this.element.attr('data-minute-interval'), 'minute');
      }

      this.settings.timeFormat = sanitizeTimeFormat(parseInt(this.element.attr('data-force-hour-mode'), 10) === 24 ? 'HH:mm' : this.settings.timeFormat);
      this.settings.minuteInterval = sanitizeIntervals(this.settings.minuteInterval, 'minute');
      this.settings.secondInterval = sanitizeIntervals(this.settings.secondInterval, 'second');
      this.settings.mode = sanitizeMode(this.settings.mode);
      this.settings.roundToInterval = sanitizeRoundToInterval(this.settings.roundToInterval);
      this.dayPeriods = this.currentCalendar.dayPeriods;
      return this;
    },

    /**
     * Add any markup
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.setup(); // With this option forgoe the input and append the dropdowns/popup to the parent element

      if (this.settings.parentElement) {
        this.settings.parentElement.empty();
        this.trigger = $();
        this.buildStandardPopup();
        this.setupStandardEvents();
        return this;
      } // Append a Button


      this.trigger = this.element.next('svg.icon');

      if (this.trigger.length === 0) {
        this.trigger = $.createIconElement('clock').insertAfter(this.element);
      }

      this.addAria().addMask().handleEvents().roundMinutes();
      return this;
    },

    /**
     * Adds ARIA-related attributes
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      this.element.attr({
        'aria-expanded': 'false',
        role: 'combobox'
      }); // TODO: Confirm this with Accessibility Team

      this.label = $("label[for=\"".concat(this.element.attr('id'), "\"]"));
      this.label.find('.audible').remove();
      this.label.append("<span class=\"audible\">".concat(Locale.translate('UseArrow', {
        locale: this.locale.name,
        language: this.language
      }), "</span>"));
      return this;
    },

    /**
     * Adds an extra attributes
     * @private
     * @returns {void}
     */
    addAttributes: function addAttributes() {
      utils.addAttributes(this.element, this, this.settings.attributes);
      utils.addAttributes(this.trigger, this, this.settings.attributes, 'trigger');
    },

    /**
     * Sets up a `keydown` event listener.
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      var self = this;
      this.element.on('keydown.timepicker', function (e) {
        var handled = false; // Esc closes an open popup with no action

        if (e.which === 27 && self.isOpen()) {
          handled = true;
          self.closeTimePopup();
        } // Arrow Down or Alt first opens the dialog


        if (e.which === 40 && !self.isOpen()) {
          handled = true;
          self.openTimePopup();
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        return true;
      });
    },

    /**
     * Sets up a `blur` event listener.
     * @private
    */
    handleBlur: function handleBlur() {
      var self = this;
      this.element.on('blur.timepicker', function () {
        self.roundMinutes(); // The action of closing the popup menu is set on a timer because technically
        // there are no fields focused on frame 0 of the popup menu's existence, which
        // would cause it to close immediately on open.

        setTimeout(function () {
          if (self.isOpen() && self.popup.find(':focus').length === 0) {
            self.closeTimePopup();
          }
        }, 20);
      });
    },

    /**
     * Checks a time format value to see if it is a Military (24-hour) format.
     * @private
     * @param {string} value - a string value representing a time format.
     * @returns {boolean} whether or not the time format is 24-hour
     */
    is24HourFormat: function is24HourFormat(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }

      if (!value) {
        return false;
      }

      return (value.match('H') || []).length > 0;
    },

    /**
     * @private
     * @param {number} value incoming value
     * @returns {string} the hour text
     */
    hourText: function hourText(value) {
      return ((this.settings.timeFormat.toUpperCase().match('HH') || []).length > 0 && value < 10 ? '0' : '') + value;
    },

    /**
     * Checks a time format value to see if it includes seconds.
     * @private
     * @param {string} value a string value representing a time format.
     * @returns {boolean} whether or not seconds are included in the time format
     */
    hasSeconds: function hasSeconds(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }

      return (value.match('ss') || []).length > 0;
    },

    /**
     * Checks to see if a time format contains a space for presenting the day period.
     * @private
     * @param {string} value a string value representing a time format.
     * @returns {boolean} whther or not the time format has day periods.
     */
    hasDayPeriods: function hasDayPeriods(value) {
      if (!value) {
        value = this.settings.timeFormat;
      }

      return (value.match('a') || []).length > 0;
    },

    /**
     * Gets a Locale-defined version of the time separator.
     * @returns {string} containing the time separator
     */
    getTimeSeparator: function getTimeSeparator() {
      return this.currentCalendar.dateFormat.timeSeparator;
    },

    /**
     * Rounds the current value of the minutes picker to its nearest interval value.
     * @private
     */
    roundMinutes: function roundMinutes() {
      if (!stringUtils.toBoolean(this.settings.roundToInterval)) {
        return;
      } // separate out the minutes value from the rest of the value.


      var val = this.element.val();
      var timeSeparator = this.getTimeSeparator();
      var parts = val ? val.split(timeSeparator) : [];
      var interval = this.settings.minuteInterval;

      if (!parts[1]) {
        return;
      }

      if (!this.is24HourFormat(this.settings.timeFormat)) {
        var periodParts = parts[1].split(' ');
        parts[1] = periodParts[0];

        if (periodParts[1]) {
          parts.push(periodParts[1]);
        }
      }

      parts[1] = parseInt(parts[1], 10);

      if (parts[1] % interval === 0) {
        return;
      }

      parts[1] = Math.round(parts[1] / interval) * interval;
      parts[1] = parts[1].toString();
      parts[1] = (parts[1].length < 2 ? '0' : '') + parts[1];

      if (parts[1] === '60') {
        parts[1] = '00';
        parts[0] = (parseInt(parts[0], 10) + 1).toString();
      }

      var newVal = "".concat(parts[0] + timeSeparator + parts[1], " ").concat(parts[2] ? parts[2] : '');
      this.element.val(newVal);
    },

    /**
     * Adds Masked Input and Validation components to the input field at build time.
     * @private
     * @returns {void}
     */
    addMask: function addMask() {
      if (this.element.data('mask') && _typeof(this.element.data('mask')) === 'object') {
        this.element.data('mask').destroy();
      }

      this.element.data('mask', undefined);
      var maskOptions = {
        keepCharacterPositions: true,
        process: 'date',
        patternOptions: {
          format: this.settings.timeFormat
        }
      };
      var validation = 'time';
      var events = {
        time: 'blur change enter'
      };

      if (!this.element[0].getAttribute('data-validate')) {
        this.element.attr('data-validate', validation).attr('data-validation-events', JSON.stringify(events)).validate();
      }

      if (maskOptions) {
        this.element.mask(maskOptions);
      }

      return this;
    },

    /**
     * Constructs all markup and subcomponents needed to build the standard Timepicker popup.
     * @private
     * @returns {void}
     */
    buildStandardPopup: function buildStandardPopup() {
      var self = this;
      var popupContent = $('<div class="timepicker-popup-content"></div>');
      var timeSeparator = this.getTimeSeparator();
      var textValue = '';
      var selected;
      this.initValues = self.getTimeFromField();
      var timeParts = $('<div class="time-parts"></div>').appendTo(popupContent); // Build the inner-picker HTML

      var is24HourFormat = this.is24HourFormat();
      var hasSeconds = this.hasSeconds();
      var hasDayPeriods = this.hasDayPeriods();
      var hourCounter = is24HourFormat ? 0 : 1;
      var maxHourCount = is24HourFormat ? 24 : 13;
      this.hourSelect = $("<select id=\"".concat(this.hoursId, "\" data-options=\"{'noSearch': 'true'}\" class=\"hours dropdown\"></select>"));

      while (hourCounter < maxHourCount) {
        selected = '';

        if (parseInt(self.initValues.hours, 10) === hourCounter) {
          selected = ' selected';
        }

        self.hourSelect.append($("<option".concat(selected, ">").concat(self.hourText(hourCounter), "</option>")));
        hourCounter++;
      }

      timeParts.append($("<label for=\"".concat(this.hoursId, "\" class=\"audible\">").concat(Locale.translate('Hours', {
        locale: this.locale.name,
        language: this.language
      }), "</label>")));
      timeParts.append(this.hourSelect);
      timeParts.append($("<span class=\"label colons\">".concat(timeSeparator, "</span>"))); // Minutes Picker

      var minuteCounter = 0;
      this.minuteSelect = $("<select id=\"".concat(this.minutesId, "\" data-options=\"{'noSearch': 'true'}\" class=\"minutes dropdown\"></select>"));

      while (minuteCounter <= 59) {
        textValue = minuteCounter < 10 ? "0".concat(minuteCounter) : minuteCounter;
        selected = '';

        if (parseInt(self.initValues.minutes, 10) === minuteCounter) {
          selected = ' selected';
        }

        self.minuteSelect.append($("<option".concat(selected, ">").concat(textValue, "</option>")));
        minuteCounter += self.settings.minuteInterval;
      } // If the value inside the picker doesn't match an interval, add the value
      // as the currently selected option, right at the top


      if (!this.minuteSelect.find('option[selected]').length) {
        this.minuteSelect.prepend($("<option selected>".concat(self.initValues.minutes, "</option>")));
      }

      timeParts.append($("<label for=\"".concat(this.minutesId, "\" class=\"audible\">").concat(Locale.translate('Minutes', {
        locale: this.locale.name,
        language: this.language
      }), "</label>")));
      timeParts.append(this.minuteSelect); // Seconds Picker

      if (hasSeconds) {
        var secondCounter = 0;
        this.secondSelect = $("<select id=\"".concat(this.secondsId, "\" data-options=\"{'noSearch': 'true'}\" class=\"seconds dropdown\"></select>"));

        while (secondCounter <= 59) {
          textValue = secondCounter < 10 ? "0".concat(secondCounter) : secondCounter;
          selected = '';

          if (parseInt(self.initValues.seconds, 10) === secondCounter || !self.initValues.seconds && textValue === '00') {
            selected = ' selected';
          }

          this.secondSelect.append($("<option".concat(selected, ">").concat(textValue, "</option>")));
          secondCounter += self.settings.secondInterval;
        } // If the value inside the picker doesn't match an interval, add the value
        // as the currently selected option, right at the top


        if (!this.secondSelect.find('option[selected]').length) {
          this.secondSelect.prepend($("<option selected>".concat(self.initValues.seconds, "</option>")));
        }

        timeParts.append($("<span class=\"label colons\">".concat(timeSeparator, "</span>")));
        timeParts.append($("<label for=\"".concat(this.secondsId, "\" class=\"audible\">").concat(Locale.translate('Seconds', {
          locale: this.locale.name,
          language: this.language
        }), "</label>")));
        timeParts.append(this.secondSelect);
      }

      if (!is24HourFormat && hasDayPeriods) {
        this.periodSelect = $("<select id=\"".concat(this.periodId, "\" data-options=\"{'noSearch': 'true'}\" class=\"period dropdown\"></select>"));
        timeParts.append($('<span class="label colons"></span>'));
        var localeDays = this.currentCalendar.dayPeriods;
        var localeCount = 0;
        var regexDay = new RegExp(self.initValues.period, 'i');

        while (localeCount < 2) {
          selected = '';

          if (regexDay.test(localeDays[localeCount])) {
            selected = ' selected';
          }

          this.periodSelect.append($("<option value=\"".concat(localeDays[localeCount], "\"").concat(selected, ">").concat(localeDays[localeCount], "</option>")));
          localeCount++;
        }

        timeParts.append($("<label for=\"".concat(this.periodId, "\" class=\"audible\">").concat(Locale.translate('TimePeriod', {
          locale: this.locale.name,
          language: this.language
        }), "</label>")));
        timeParts.append(this.periodSelect);
      }

      if (this.settings.parentElement) {
        this.settings.parentElement.append(popupContent); // self.afterShow(this.settings.parentElement);

        self.popup = this.settings.parentElement.find('.timepicker-popup-content').addClass('timepicker-popup').attr('id', 'timepicker-popup');
      } else {
        popupContent.append("<div class=\"modal-buttonset\"><button type=\"button\" class=\"btn-modal-primary set-time\">".concat(Locale.translate('SetTime', {
          locale: this.locale.name,
          language: this.language
        }), "</button></div>"));
        var placementParent = this.element;
        var placementParentXAlignment = this.isRTL ? 'right' : 'left';
        var parent = this.element.parent();

        if (parent.is('.datagrid-cell-wrapper')) {
          placementParentXAlignment = 'center';
          placementParent = this.element.next('.icon');
        }

        this.trigger.popover({
          content: popupContent,
          trigger: 'immediate',
          placement: 'bottom',
          placementOpts: {
            parent: placementParent,
            parentXAlignment: placementParentXAlignment,
            strategies: ['flip', 'nudge', 'shrink']
          },
          tooltipElement: '#timepicker-popup'
        }).on('show.timepicker', function (e, ui) {
          self.afterShow(ui);
        }).on('hide.timepicker', function () {
          if (self.settings.returnFocus) {
            self.element.focus();
          }
        });
      } // Make adjustments to the popup HTML specific to the timepicker


      if (this.trigger.data('tooltip')) {
        self.popup = this.trigger.data('tooltip').tooltip;
        var tooltip = self.popup;
        tooltip.addClass('timepicker-popup');
      }
    },

    /**
     * Handler for the Timepicker Popover's custom `show` event.
     * @private
     * @param {object} ui timepicker popup element
     * @returns {void}
     */
    afterShow: function afterShow(ui) {
      var self = this;
      ui.find('button').button(); // Set default values based on what's retrieved from the Timepicker's input field.

      this.hourSelect.val(this.initValues.hours);
      this.hourSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.hours);
      this.minuteSelect.val(this.initValues.minutes);
      this.minuteSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.minutes);
      utils.addAttributes(this.hourSelect.data('dropdown').wrapper.find('.dropdown'), this, this.settings.attributes, 'hours');
      utils.addAttributes(this.minuteSelect.data('dropdown').wrapper.find('.dropdown'), this, this.settings.attributes, 'minutes');

      if (this.secondSelect) {
        this.secondSelect.val(this.initValues.seconds);
        this.secondSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.seconds);
        utils.addAttributes(this.secondSelect.data('dropdown').wrapper.find('.dropdown'), this, this.settings.attributes, 'seconds');
      }

      if (self.hasDayPeriods()) {
        this.periodSelect.val(this.initValues.period);
        this.periodSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.period);
        utils.addAttributes(this.periodSelect.data('dropdown').wrapper.find('.dropdown'), this, this.settings.attributes, 'period');
      }

      ui.find('div.dropdown').first().focus();
      ui.find('.set-time').off('click.timepicker').on('click.timepicker', function (e) {
        e.preventDefault();
        self.setTimeOnField();
        self.closeTimePopup();
      });
      utils.addAttributes(ui.find('.set-time'), this, this.settings.attributes, 'btn'); // Handle Tabbing on the dialog

      if (!this.settings.parentElement) {
        ui.on('keydown.timepicker', 'button, div.dropdown', function (e) {
          var key = e.keyCode || e.charCode || 0;

          if (key === 9) {
            self.containFocus(e);
            e.stopPropagation();
            e.preventDefault();
            return false;
          }

          return true;
        });
      }
    },

    /**
     * Focus the next prev focusable element on the popup
     * @private
     * @param {jQuery.Event} e the event object
     * @returns {void}
     */
    containFocus: function containFocus(e) {
      var reverse = e.shiftKey; // Set focus on (opt: next|prev) focusable element

      var focusables = this.popup.find(':focusable');
      var index = focusables.index($(':focus'));
      var next = index + 1 >= focusables.length ? 0 : index + 1;
      var prev = index - 1 < 0 ? focusables.length : index - 1;
      index = !reverse ? next : prev;
      focusables.eq(index).focus();
    },

    /**
     * Sets up events that need to be bound to a standard time picker.
     * @private
     * @returns {void}
     */
    setupStandardEvents: function setupStandardEvents() {
      var self = this;
      self.popup.on('touchend.timepicker touchcancel.timepicker', '.set-time', function (e) {
        e.preventDefault();
        e.target.click();
      }).on('keydown.timepicker', 'input.dropdown', function (e) {
        var handled = false; // Pressing Esc when focused on a closed dropdown menu causes the entire popup to close.

        if (e.which === 27) {
          handled = true;
          self.closeTimePopup();
          self.element.focus();
        } // Pressing Spacebar while the popup is open submits with the new time value.


        if (e.which === 32) {
          handled = true;
          self.popup.find('.set-time').click();
        } // Left & Right Arrows will switch between the available dropdowns


        if (e.which === 37 || e.which === 39) {
          handled = true;
          var inputs = self.popup.find('input[id$="-shdo"]');

          if (e.which === 37) {
            var prev = inputs.eq(inputs.index(this) - 1);

            if (!prev || prev.length === 0) {
              prev = inputs.eq(inputs.length);
            }

            prev.focus();
          }

          if (e.which === 39) {
            var next = inputs.eq(inputs.index(this) + 1);

            if (!next || next.length === 0) {
              next = inputs.eq(0);
            }

            next.focus();
          }
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        return true;
      }); // Listen to the popover/tooltip's "hide" event to properly close out the
      // popover's inner controls.

      self.trigger.on('hide.timepicker', function () {
        self.onPopupHide();
      });
    },

    /**
     * Constructs all markup and subcomponents needed to build a Timepicker popup
     * containing a time range.
     * @private
     * @returns {void}
     */
    buildRangePopup: function buildRangePopup() {// TODO: Build this
    },

    /**
     * Sets up events that need to be bound to a range timepicker.
     * @private
     * @returns {void}
     */
    setupRangeEvents: function setupRangeEvents() {// TODO: Build this
    },

    /**
     * Gets the value of the Timepicker field as an object separated into hours,
     * minutes, (optional) seconds, and (optional) day period.
     * @param {string} [value] this method can optionally be passed
     * a string-based time value to calculate instead of the current field's value.
     * @returns {object} containing key/value pairs representing time parts.
     */
    getTimeFromField: function getTimeFromField(value) {
      var self = this;
      var val = value || this.element.val();
      var sep = this.getTimeSeparator();
      var parts;
      var endParts;
      var timeparts = {};
      val = val.replace(/[T\s:.-]/g, sep).replace(/z/i, '');
      val = val.replace('', "\u5348".concat(sep));
      parts = val.split(sep);
      var aLoc = this.currentCalendar.timeFormat.toLowerCase().indexOf('a');
      var isAmFirst = aLoc !== -1 && aLoc < this.currentCalendar.timeFormat.toLowerCase().indexOf('h'); // If am is before time move it in the array to last

      if (!this.is24HourFormat() && isAmFirst) {
        parts = [parts[1], parts[2], parts[0]];
      } // Fix am/pm


      var periods = this.currentCalendar.dayPeriods;

      if (parts[2] && (periods[0].indexOf('.') > -1 || periods[1].indexOf('.') > -1)) {
        if (periods[0].replace('.', '') === parts[2]) {
          parts[2] = periods[0];
        }

        if (periods[1].replace('.', '') === parts[2]) {
          parts[2] = periods[1];
        }
      } // Check the last element in the array for a time period, and add it as an array
      // member if necessary


      if (!this.is24HourFormat() && !isAmFirst) {
        endParts = parts[parts.length - 1].split(' ');
        parts.pop();
        parts = parts.concat(endParts);
      }

      function isDayPeriod(thisValue) {
        return self.dayPeriods.indexOf(thisValue) > -1;
      }

      function removeLeadingWhitespace(thisValue) {
        return thisValue.replace(/^\s+|\s+$/g, '');
      }

      function addLeadingZero(thisValue) {
        if (!thisValue || isNaN(thisValue)) {
          return '00';
        }

        thisValue = parseInt(thisValue, 10);
        thisValue = thisValue < 10 ? "0".concat(thisValue) : thisValue;
        return thisValue;
      } // Handle Hours


      if (!parts[0] || !parts[0].length || isNaN(parts[0])) {
        parts[0] = '1';
      }

      parts[0] = parseInt(parts[0], 10);

      if (!isNaN(parts[0])) {
        parts[0] = "".concat(parseInt(parts[0], 10));
      }

      timeparts.hours = self.hourText(parts[0]); // Handle Minutes

      if (parts[1]) {
        // remove leading whitespace
        parts[1] = removeLeadingWhitespace(parts[1]);
        parts[1] = addLeadingZero(parts[1]);
        timeparts.minutes = parts[1];
      } else {
        timeparts.minutes = '00';
      } // Handle Seconds/Period (slot 3)


      function handleSlot2(thisValue) {
        // Should not kick off at all if we don't pass it a value, OR if this field
        // is 24-hour display with no seconds
        if (!thisValue) {
          if (self.hasSeconds()) {
            thisValue = '00';
            timeparts.seconds = thisValue;
          }

          if (!self.is24HourFormat()) {
            thisValue = self.translateDayPeriod('AM');
            timeparts.period = thisValue;
          }

          return;
        }

        thisValue = removeLeadingWhitespace(thisValue); // Has seconds

        if (self.hasSeconds()) {
          thisValue = addLeadingZero(thisValue);
          timeparts.seconds = thisValue;
          return;
        } // No seconds, but has a day period


        if (!isDayPeriod(thisValue)) {
          thisValue = self.translateDayPeriod('AM');
        }

        timeparts.period = thisValue;
      }

      handleSlot2(parts[2]); // Handle Period after seconds (slot 4)

      if (parts[3]) {
        parts[3] = removeLeadingWhitespace(parts[3]);
        timeparts.period = parts[3];
      } else if (!this.is24HourFormat() && this.hasSeconds()) {
        timeparts.period = this.translateDayPeriod('AM');
      }

      return timeparts;
    },
    getTimeFromField2: function getTimeFromField2(value) {
      function addLeadingZero(thisValue) {
        if (!thisValue || isNaN(thisValue)) {
          return '00';
        }

        thisValue = parseInt(thisValue, 10);
        thisValue = thisValue < 10 ? "0".concat(thisValue) : thisValue;
        return thisValue;
      }

      var self = this;
      var formatString = self.hasSeconds() ? this.currentCalendar.dateFormat.timestamp : this.currentCalendar.dateFormat.hour;
      var type = self.hasSeconds() ? 'timestamp' : 'hour';
      var tempDate = Locale.parseDate(value || this.element.val(), {
        date: type
      });
      var defaultHours = '1';
      var hours = (tempDate ? tempDate.getHours() : defaultHours).toString();
      var ampm = (hours >= 12 ? this.translateDayPeriod('PM') : this.translateDayPeriod('AM')).toString();

      if (!this.is24HourFormat() && hours > 12) {
        hours = (parseInt(hours, 10) - 12).toString();
      }

      if (!this.is24HourFormat() && hours === '0') {
        hours = '12';
      }

      var period = formatString.indexOf('a') > -1 ? ampm : undefined;
      var minutes = tempDate ? tempDate.getMinutes() : '00';
      var seconds = tempDate ? tempDate.getSeconds() : '00';
      return {
        hours: addLeadingZero(hours),
        minutes: addLeadingZero(minutes),
        seconds: addLeadingZero(seconds),
        period: period
      };
    },

    /**
     * Translate Day Period
     * @private
     * @param {string} period should be "am", "pm", "AM", "PM", or "i"
     * @returns {string} the translated day period.
     */
    translateDayPeriod: function translateDayPeriod(period) {
      if (/am|pm|AM|PM/i.test(period)) {
        var periods = this.currentCalendar.dayPeriods || ['AM', 'PM'];
        return periods[/AM|am/i.test(period) ? 0 : 1];
      }

      return period;
    },

    /**
     * Retrieves the values from the Timepicker popup's pickers and uses those values to set
     * the contents of the Timepicker field.
     * @returns {void}
     */
    setTimeOnField: function setTimeOnField() {
      var _this$hourSelect$, _this$minuteSelect$, _this$secondSelect$, _this$periodSelect$;

      var hours = this.hourSelect ? (_this$hourSelect$ = this.hourSelect[0]) === null || _this$hourSelect$ === void 0 ? void 0 : _this$hourSelect$ == null ? void 0 : _this$hourSelect$.value : '';
      var minutes = this.minuteSelect ? (_this$minuteSelect$ = this.minuteSelect[0]) === null || _this$minuteSelect$ === void 0 ? void 0 : _this$minuteSelect$ == null ? void 0 : _this$minuteSelect$.value : '';
      var seconds = this.secondSelect ? (_this$secondSelect$ = this.secondSelect[0]) === null || _this$secondSelect$ === void 0 ? void 0 : _this$secondSelect$ == null ? void 0 : _this$secondSelect$.value : '';
      var period = (this.periodSelect ? (_this$periodSelect$ = this.periodSelect[0]) === null || _this$periodSelect$ === void 0 ? void 0 : _this$periodSelect$ == null ? void 0 : _this$periodSelect$.value : '').toUpperCase();
      var sep = this.getTimeSeparator();
      var timeString = "".concat(hours).concat(sep).concat(minutes).concat(this.hasSeconds() ? sep + seconds : '');
      period = !this.is24HourFormat() && period === '' ? document.querySelector("#".concat(this.periodId, "-shdo")).value : period;
      timeString += period ? " ".concat(this.translateDayPeriod(period)) : '';
      /**
      * Fires when the value is changed by typing or the picker.
      * @event change
      * @memberof TimePicker
      * @property {object} event - The jquery event object
      */

      this.element.val(timeString).trigger('change');
      this.element.focus();
    },

    /**
     * Return whether or not the Timepicker popup is open.
     * @returns {boolean} whether or not the Timepicker popup is open.
     */
    isOpen: function isOpen() {
      return !!(this.popup && this.popup.is(':visible'));
    },

    /**
     * Opens the Timepicker popup, intializing all the dropdown elements and
     * setting up internal events.
     * @returns {void}
     */
    openTimePopup: function openTimePopup() {
      var self = this; // Get all current settings.

      self.setup();

      if (this.element.is(':disabled') || this.element.attr('readonly')) {
        return;
      }

      if (this.popup && !this.popup.hasClass('is-hidden')) {
        self.closeTimePopup();
      }

      this.element.addClass('is-active is-open'); // Build a different Time Popup based on settings

      if (self.settings.mode === 'range') {
        self.buildRangePopup();
        self.setupRangeEvents();
      } else {
        self.buildStandardPopup();
        self.setupStandardEvents();
      }

      this.element.attr({
        'aria-expanded': 'true'
      });
      this.popup.find('div.dropdown').first().focus();
    },

    /**
     * Triggers the "hide" method on the tooltip plugin.  The Timepicker officially
     * "closes" after the popover's hide event fully completes because certain events
     * need to be turned off and certain markup needs to be removed only AFTER
     * the popover is hidden.
     * @returns {void}
     */
    closeTimePopup: function closeTimePopup() {
      if (this.trigger.data('tooltip')) {
        this.trigger.data('tooltip').hide();
      }
    },

    /**
     * Handles the time popover's "hide" event
     * @private
     * @returns {void}
     */
    onPopupHide: function onPopupHide() {
      if (this.settings.mode === 'standard') {
        var ddHours = this.hourSelect;
        var ddMinutes = this.minuteSelect;
        var ddSeconds = this.secondSelect;
        var ddPeriod = this.periodSelect;

        if (ddHours && ddHours.data('dropdown') && typeof ddHours.data('dropdown').destroy === 'function') {
          ddHours.data('dropdown').destroy();
        }

        if (ddMinutes && ddMinutes.data('dropdown') && typeof ddMinutes.data('dropdown').destroy === 'function') {
          ddMinutes.data('dropdown').destroy();
        }

        if (this.hasSeconds()) {
          if (ddSeconds && ddSeconds.data('dropdown') && typeof ddSeconds.data('dropdown').destroy === 'function') {
            ddSeconds.data('dropdown').destroy();
          }
        }

        if (this.hasDayPeriods()) {
          if (ddPeriod && ddPeriod.data('dropdown') && typeof ddPeriod.data('dropdown').destroy === 'function') {
            ddPeriod.data('dropdown').destroy();
          }
        }

        this.popup.off('click.timepicker touchend.timepicker touchcancel.timepicker keydown.timepicker');
      }

      this.element.attr({
        'aria-expanded': 'false'
      });
      this.trigger.off('hide.timepicker show.timepicker');
      this.trigger.data('tooltip').destroy();
      this.trigger.data('tooltip', undefined);
      $('#timepicker-popup').remove();
      this.element.removeClass('is-active is-open');
    },

    /**
     * Toggles the visibility of the Timepicker popup.
     * @returns {void}
     */
    toggleTimePopup: function toggleTimePopup() {
      if (this.isOpen()) {
        this.closeTimePopup();
      } else {
        this.openTimePopup();
      }
    },

    /**
     * Getter method for retrieving the value of the Timepicker.
     * @param {boolean} removePunctuation Gets rid of all the value's punctuation on return.
     * @returns {string} the current timepicker value
     */
    value: function value(removePunctuation) {
      var val = this.element.val();

      if (!removePunctuation || removePunctuation === false) {
        return val;
      }

      var timeSeparator = this.currentCalendar.dateFormat.timeSeparator;
      var sepRegex = new RegExp(timeSeparator, 'g'); // Remove punctuation

      val = val.replace(sepRegex, ''); // Add leading zero for times without a double digit hour

      var parts = val.split(' ');

      if (parts[0].length < 4) {
        val = "0".concat(parts[0]).concat(parts[1] ? parts[1] : '');
      }

      return val;
    },

    /**
     * Enables the Timepicker
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },

    /**
    * Set input to readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      this.enable();
      this.element.attr('readonly', 'readonly');
    },

    /**
     * Disables the Timepicker
     * @returns {void}
     */
    disable: function disable() {
      this.enable();
      this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
    },

    /**
     * Detects whether or not the component is disabled
     * @returns {boolean} whether or not the component is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Updates the component instance.  Can be used after being passed new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instanceof
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },

    /**
     * Removes all event bindings, subcomponents and unnecessary markup from this component instance.
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.trigger.off('keydown.timepicker');
      this.element.off('focus.timepicker blur.timepicker keydown.timepicker');

      if (this.popup) {
        this.closeTimePopup();
      }

      this.trigger.remove();
      var mask = this.element.data('mask');

      if (mask && typeof mask.destroy === 'function') {
        mask.destroy();
      }

      $.removeData(this.element[0], 'validate');
      $.removeData(this.element[0], 'validationEvents');
      this.element.removeAttr('data-validate').removeData('validate validationEvents');
      this.label.find('.audible').remove();
      $('#timepicker-popup').remove();
      return this;
    },

    /**
     * Destroys the component instance.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$G);
    },

    /**
     * Sets up event listeners for the timepicker instance.
     * @fires TimePicker#events
     * @listens click  &nbsp;-&nbsp;
     * @listens touchstart  &nbsp;-&nbsp;
     * @listens touchmove  &nbsp;-&nbsp;
     * @listens touchend  &nbsp;-&nbsp;
     * @listens blur  &nbsp;-&nbsp;
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.trigger.off('click.timepicker').on('click.timepicker', function () {
        self.toggleTimePopup();
      });
      this.handleKeys();
      this.handleBlur();
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Timepicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} textarea elements being acted on.
   */

  $.fn.timepicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$G);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$G, new TimePicker(this, settings));
      }
    });
  };

  // This contains all base rules for validation that come bundled as part of Soho.
  // These rules can be extended.

  function ValidationRules() {
    var self = this; // define standard validation types

    this.ValidationTypes = [];
    this.ValidationTypes.error = {
      type: 'error',
      titleMessageID: 'Error',
      pagingMessageID: 'ErrorOnPage',
      errorsForm: true
    };
    this.ValidationTypes.alert = {
      type: 'alert',
      titleMessageID: 'Alert',
      pagingMessageID: 'AlertOnPage',
      errorsForm: false
    };
    this.ValidationTypes.success = {
      type: 'success',
      titleMessageID: 'Success',
      pagingMessageID: 'SuccessOnPage',
      errorsForm: false
    }; // TODO: deprecate confirm in favor of success

    this.ValidationTypes.confirm = this.ValidationTypes.success;
    this.ValidationTypes.info = {
      type: 'info',
      titleMessageID: 'Info',
      pagingMessageID: 'InfoOnPage',
      errorsForm: false
    };
    this.ValidationTypes.icon = {
      type: 'icon',
      titleMessageID: 'Icon',
      pagingMessageID: 'IconOnPage',
      errorsForm: false,
      icon: 'user-profile'
    };
    this.rules = {
      required: {
        isNotEmpty: function isNotEmpty(value, field) {
          var supportsPlaceholder = !!('placeholder' in document.createElement('input'));

          if (!supportsPlaceholder && field && (value === field.attr('placeholder') || value === Locale.translate('Required'))) {
            return false;
          }

          if (typeof value === 'string') {
            // strip out any HTML tags and focus only on text content.
            value = $.trim(value.replace(/<\/?[^>]*>/g, ''));

            if ($.trim(value).length === 0) {
              return false;
            }

            return true;
          }

          if (typeof value === 'number') {
            if (isNaN(value)) {
              return false;
            }

            return true;
          }

          if ($.isArray(value)) {
            return value.length > 0;
          }

          return !!value;
        },
        // Check if at least one radio button checked in group
        isRadioChecked: function isRadioChecked(field) {
          var name = field.attr('name');
          return name && name.length && $("input[name=\"".concat(name, "\"]:radio:checked")).length;
        },
        check: function check(value, field) {

          this.message = Locale.translate('Required');
          var valid = true; // Dont show message when opening dialog

          if ($(field).is('.datepicker') && $('#monthview-popup').is(':visible')) {
            return true;
          }

          valid = field.is(':radio') ? this.isRadioChecked(field) : this.isNotEmpty(value, field);
          return valid;
        },
        message: 'Required',
        type: 'error',
        id: 'required'
      },
      // date: Validate date, datetime (24hr or 12hr am/pm)
      date: {
        check: function check(value, field) {
          this.message = Locale.translate('InvalidDate');

          if (value instanceof Date) {
            return value && value.getTime && !isNaN(value.getTime());
          }

          var dateFormat = value.indexOf(':') > -1 ? Locale.calendar().dateFormat.datetime : Locale.calendar().dateFormat.short;
          var dtApi = null;

          if (field && field.data('datepicker')) {
            dtApi = field.data('datepicker');
            dateFormat = dtApi.pattern;
          }

          var isStrict = !(dateFormat === 'MMMM' || dateFormat === 'MMM' || dateFormat === 'MM' || dateFormat === 'MMMM d' || dateFormat === 'd MMMM' || dateFormat === 'yyyy');

          if (dtApi) {
            dateFormat = {
              locale: dtApi.locale.name,
              pattern: dateFormat,
              calendarName: dtApi.currentCalendar.name
            };
          }

          var parsedDate = Locale.parseDate(value, dateFormat, isStrict);
          return !(parsedDate === undefined && value !== '');
        },
        message: 'Invalid Date',
        type: 'error',
        id: 'date'
      },
      // Validate date, disable dates
      availableDate: {
        check: function check(value, field) {
          this.message = Locale.translate('UnavailableDate');
          var check = true;

          if (value === '') {
            return check;
          }

          if (!self.rules.date.check(value, field)) {
            // not a validate date so that will fail instead
            check = false;
            this.message = '';
            return check;
          }

          var datepickerApi = field.data('datepicker');
          var options = datepickerApi ? datepickerApi.settings : {};
          var hasOptions = Object.keys(options).length > 0;
          var d;
          var i;
          var l;
          var min;
          var max;
          var dateObj = value;

          if (typeof dateObj === 'string') {
            var format = options.dateFormat !== 'locale' ? options.dateFormat : Locale.calendar().dateFormat.short;

            if (options.showTime) {
              var timeFormat = options.timeFormat || Locale.calendar().timeFormat;
              format += " ".concat(timeFormat);
            }

            if (datepickerApi && datepickerApi.isIslamic) {
              format = {
                pattern: datepickerApi.pattern,
                locale: datepickerApi.locale.name
              };
            }

            dateObj = Locale.parseDate(dateObj, format);
          }

          if (datepickerApi && datepickerApi.isIslamic && dateObj instanceof Date) {
            dateObj = Locale.umalquraToGregorian(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
          }

          var d2 = options.useUTC ? Locale.dateToUTC(dateObj) : dateObj; // Custom callback

          if (d2 && hasOptions && typeof options.disable.callback === 'function') {
            return !options.disable.callback(d2.getFullYear(), d2.getMonth(), d2.getDate());
          } // TODO: The developer will have to set disabled dates in arabic as arrays,
          // will come back to this for now its not supported in arabic.


          if (d2 instanceof Array) {
            return check;
          }

          if (d2 && hasOptions) {
            min = options.useUTC ? Locale.dateToUTC(new Date(options.disable.minDate)).setHours(0, 0, 0, 0) : new Date(options.disable.minDate).setHours(0, 0, 0, 0);
            max = options.useUTC ? Locale.dateToUTC(new Date(options.disable.maxDate)).setHours(0, 0, 0, 0) : new Date(options.disable.maxDate).setHours(0, 0, 0, 0); // dayOfWeek

            if (options.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
              check = false;
            }

            var thisYear = d2.getFullYear();
            d2 = d2.setHours(0, 0, 0, 0); // min and max

            if (d2 <= min || d2 >= max) {
              check = false;
            } // years


            if (/string|number/.test(_typeof(options.disable.years))) {
              options.disable.years = [options.disable.years];
            }

            for (var i2 = 0, l2 = options.disable.years.length; i2 < l2; i2++) {
              if (thisYear === Number(options.disable.years[i2])) {
                check = false;
                break;
              }
            } // dates


            if (options.disable.dates.length && typeof options.disable.dates === 'string') {
              options.disable.dates = [options.disable.dates];
            }

            for (i = 0, l = options.disable.dates.length; i < l; i++) {
              d = options.useUTC ? Locale.dateToUTC(options.disable.dates[i]) : new Date(options.disable.dates[i]);

              if (d2 === d.setHours(0, 0, 0, 0)) {
                check = false;
                break;
              }
            }
          }

          if (hasOptions) {
            check = !!(check && !options.disable.isEnable || !check && options.disable.isEnable);
          }

          return check;
        },
        message: 'Unavailable Date',
        type: 'error',
        id: 'availableDate'
      },
      // Range date
      rangeDate: {
        check: function check(value, field) {
          var _this = this;

          this.message = Locale.translate('rangeDate');
          var check = true;
          var api = field.data('datepicker');

          if (api) {
            var s = api.settings;
            var parts = value.split(s.range.separator);

            var checkRule = function checkRule(rule, newvalue) {
              field.val(newvalue);
              _this.message = "".concat(self.rules[rule].message, " (").concat(newvalue, ")");

              if (!self.rules[rule].check(newvalue, field)) {
                check = false;
              }
            };

            if (value.indexOf(api.pattern) > -1) {
              if (parts.length === 1) {
                checkRule('date', parts[0]);
              } else if (parts.length === 2) {
                var part = parts[0] === api.pattern ? 1 : 0;
                checkRule('date', parts[part]);

                if (check) {
                  checkRule('availableDate', parts[part]);
                }
              }
            } else if (parts.length === 1) {
              checkRule('date', parts[0]);

              if (check) {
                checkRule('availableDate', parts[0]);
              }
            } else if (parts.length === 2) {
              checkRule('date', parts[0]);

              if (check) {
                checkRule('date', parts[1]);
              }

              if (check) {
                checkRule('availableDate', parts[0]);
              }

              if (check) {
                checkRule('availableDate', parts[1]);
              }
            }
          }

          field.val(value);
          return check;
        },
        message: 'Range Dates',
        type: 'error',
        id: 'rangeDate'
      },
      email: {
        check: function check(value) {
          this.message = Locale.translate('EmailValidation');
          var regex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,16}(?:\.[a-z]{2})?)$/i;
          return value.length ? regex.test(value) : true;
        },
        message: 'EmailValidation',
        type: 'error',
        id: 'email'
      },
      enableSubmit: {
        check: function check(value, field) {
          var submit = field.closest('.signin').find('button[type="submit"]');
          var ok = value.length && (self.rules.email.check(value) || self.rules.passwordConfirm.check(value, field));

          if (ok) {
            submit.enable();
          } else {
            submit.disable();
          }

          return true;
        },
        message: '',
        type: 'error',
        id: 'enableSubmit'
      },
      emailPositive: {
        check: function check(value, field) {
          if ($.trim(value).length && !field.is('[readonly]')) {
            self.rules.emailPositive.positive = true;
            this.message = Locale.translate('EmailValidation');
            var isValid = self.rules.email.check(value, field);

            if (isValid) {
              this.message = '';
            }

            return isValid;
          }

          self.rules.emailPositive.positive = false;
          return true;
        },
        message: 'EmailValidation',
        type: 'error',
        id: 'emailPositive'
      },
      passwordReq: {
        check: function check(value) {
          this.message = Locale.translate('PasswordValidation');
          /* Must be at least 10 characters which contain at least
          ** one lowercase letter,
          ** one uppercase letter,
          ** one numeric digit
          ** and one special character */

          var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{10,}$/;
          return value.length ? value.match(regex) : true;
        },
        message: 'PasswordValidation',
        type: 'error',
        id: 'passwordReq'
      },
      passwordConfirm: {
        check: function check(value, field) {
          this.message = Locale.translate('PasswordConfirmValidation');
          var passwordValue = $("input[type=\"password\"]:not(".concat(field.attr('id'), ")"), field.closest('.signin')).eq(0).val(),
              // eslint-disable-line
          check = value === passwordValue && self.rules.passwordReq.check(passwordValue); // eslint-disable-line

          return value.length ? check : true;
        },
        message: 'PasswordConfirmValidation',
        type: 'error',
        id: 'passwordConfirm'
      },
      time: {
        check: function check(value, field) {
          value = value.replace(/ /g, '');
          this.message = Locale.translate('InvalidTime');
          var timepicker = field && field.data('timepicker');
          var timepickerSettings = timepicker ? field.data('timepicker').settings : {};
          var pattern = timepickerSettings && timepickerSettings.timeFormat ? timepickerSettings.timeFormat : Locale.calendar().timeFormat;

          if (field.attr('data-options') && timepickerSettings && !timepickerSettings.timeFormat) {
            var settings = JSON.parse(field.attr('data-options'));

            if (settings.patternOptions && settings.patternOptions.format) {
              pattern = settings.patternOptions.format;
            }
          }

          var is24Hour = (pattern.match('HH') || pattern.match('H') || []).length > 0;
          var maxHours = is24Hour ? 24 : 12;
          var sep = value.indexOf(Locale.calendar().dateFormat.timeSeparator);
          var valueHours = 0;
          var valueMins = 0;
          var valueSecs = 0;
          var valueM;
          var timeparts;

          if (value === '') {
            return true;
          }

          valueHours = parseInt(value.substring(0, sep), 10);
          valueMins = parseInt(value.substring(sep + 1, sep + 3), 10); // getTimeFromField

          if (timepicker) {
            timeparts = timepicker.getTimeFromField();
            valueHours = timeparts.hours;
            valueMins = timeparts.minutes;

            if (timepicker.hasSeconds()) {
              valueSecs = timeparts.seconds;
            }
          }

          if (valueHours.toString().length < 1 || isNaN(valueHours) || parseInt(valueHours, 10) < 0 || parseInt(valueHours, 10) > maxHours) {
            return false;
          }

          if (valueMins.toString().length < 1 || isNaN(valueMins) || parseInt(valueMins, 10) < 0 || parseInt(valueMins, 10) > 59) {
            return false;
          }

          if (valueSecs.toString().length < 1 || isNaN(valueSecs) || parseInt(valueSecs, 10) < 0 || parseInt(valueSecs, 10) > 59) {
            return false;
          } // AM/PM


          if (!is24Hour) {
            if (parseInt(valueHours, 10) < 1) {
              return false;
            }

            var period0 = new RegExp(Locale.calendar().dayPeriods[0], 'i');
            var period1 = new RegExp(Locale.calendar().dayPeriods[1], 'i');
            valueM = value.match(period0) || value.match(period1) || [];

            if (valueM.length === 0) {
              return false;
            }
          }

          return true;
        },
        message: 'Invalid Time',
        type: 'error',
        id: 'time'
      },
      // Test validation function which always returns false
      test: {
        check: function check(value) {
          return value === '1';
        },
        message: 'Value is not valid (test).',
        type: 'error',
        id: 'test'
      }
    };
  }

  var Validation = new ValidationRules();

  var COMPONENT_NAME$H = 'toast'; // Default Component Settings

  var TOAST_DEFAULTS = {
    title: '(Title)',
    message: '(Content)',
    position: 'top right',
    audibleOnly: false,
    progressBar: true,
    timeout: 6000,
    allowLink: false,
    draggable: false,
    savePosition: false,
    uniqueId: null
  };
  /**
   * Toast Component.  This component produces small, temporary messages in
   *  one of the application's corners.
   * @constructor
   * @param {HTMLElement} element the target location for the Toast message
   * @param {object} [settings] incoming settings
   * @param {string} [settings.title = '(Title)'] Text that is displayed in the Toast's title.
   * @param {string} [settings.message = '(Content)' ] Text that's displayed in the Toast's body.
   * @param {string} [settings.position = 'top right'] Text that propagates into CSS classes that position the Toast in specific places
   * Can be top left, bottom left, bottom rightx
   * @param {boolean} [settings.audibleOnly = false] if true, causes the toast to be invisble on the screen, but still read out lout by screen readers.
   * @param {boolean} [settings.progressBar = true] causes the toast to have a visible progress bar that will be completely
   * disappeared when the toast should be removed.
   * @param {number} [settings.timeout = 6000] the amount of time the toast should be present on-screen.
   * @param {boolean} [settings.allowLink = false] if true, allows user to put links in the toast message.
   * @param {boolean} [settings.draggable = false] if true, allows user to drag/drop the toast container.
   * @param {boolean} [settings.savePosition] Save positon to local storage.
   * @param {string} [settings.uniqueId] A uniqueId to save positon to local storage, so same saved positon can be use for whole app.
   * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  function Toast(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, TOAST_DEFAULTS);
    this.init();
  } // Toast Methods


  Toast.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.show();
    },

    /**
     * Show a Single Toast Message
     * @private
     * @returns {void}
     */
    show: function show() {
      var self = this;
      var s = this.settings;
      var maxHideTime = parseFloat(math.convertDelayToFPS(s.timeout));
      var message = s.allowLink ? xssUtils.stripTags(s.message, '<a><br><p>') : xssUtils.stripHTML(s.message);
      var isPausePlay = false;
      var percentage = 100;
      this.uniqueId = s.uniqueid ? this.generateUniqueId('usersettings-position') : '';
      var container = $("#toast-container".concat(this.uniqueId));
      var toast = $("\n      <div class=\"toast\">\n        <span class=\"toast-title\">".concat(xssUtils.stripHTML(s.title), "</span>\n        <span class=\"toast-message\">").concat(message, "</span>\n      </div>"));
      var closeBtn = $("\n      <button type=\"button\" class=\"btn-icon btn-close\" title=\"".concat(Locale.translate('Close'), "\" aria-hidden=\"true\">\n        ").concat($.createIcon('close'), "\n        <span class=\"audible\">").concat(Locale.translate('Close'), "</span>\n      </button>\n    "));
      var progress = $('<div class="toast-progress"></div>');

      if (!container.length) {
        container = $("<div id=\"toast-container".concat(this.uniqueId, "\" class=\"toast-container\" aria-relevant=\"additions\" aria-live=\"polite\"></div>")).appendTo('body');
      }

      container.removeClass('toast-top-left toast-top-right toast-bottom-right toast-bottom-left').addClass("toast-".concat(s.position.replace(' ', '-')));
      s.timeout = s.audibleOnly ? 100 : s.timeout;

      if (s.progressBar) {
        toast.append(progress);
      }

      container.append(toast);
      toast.addClass(s.audibleOnly ? 'audible' : 'effect-scale');
      toast.append(closeBtn); // Add draggable

      self.createDraggable(toast, container); // Get the number of toasts

      var toastIndex = container.children().length;
      this.toastIndex = toastIndex; // Get the number of unique toast container

      var toastUniqueContainer = this.element.find('.toast-container');

      for (var i = 0, len = toastUniqueContainer.children(); i < len.length; i++) {
        toastIndex = len.length;
      }

      utils.addAttributes(toast, this, this.settings.attributes);
      utils.addAttributes(toast.find('button'), this, this.settings.attributes, 'btn-close'); // Build the RenderLoop integration

      var timer = new RenderLoopItem({
        duration: math.convertDelayToFPS(s.timeout),
        timeoutCallback: function timeoutCallback() {
          self.remove(toast, toastIndex);
        },
        updateCallback: function updateCallback(data) {
          percentage = (data.duration - data.elapsedTime) / maxHideTime * 100;

          if (Locale.isRTL()) {
            percentage = 100 - percentage;
          }

          if (s.progressBar) {
            progress[0].style.width = "".concat(percentage, "%");
          }
        }
      });
      renderLoop.register(timer); // Clears the toast from the container, removing it from renderLoop and tearing down events

      function clearToast(targetToast) {
        timer.destroy(true);
        self.remove(targetToast, toastIndex);
      }

      $(document).on("keydown.toast-".concat(toastIndex, " keyup.toast-").concat(toastIndex), function (e) {
        e = e || window.event;
        var key = e.which || e.keyCode;

        if (e.ctrlKey && key === 80) {
          // [Control + Alt + P] - Pause/Play toggle
          isPausePlay = e.type === 'keydown';
          timer[isPausePlay ? 'pause' : 'resume']();
        }

        if (e.type === 'keydown' && key === 27) {
          // Escape
          e.stopImmediatePropagation();
          e.preventDefault();
          clearToast(toast);
        }
      });
      toast.on('mousedown.toast touchstart.toast mouseup.toast touchend.toast', function (e) {
        isPausePlay = !!/mousedown|touchstart/i.test(e.type);
        timer[isPausePlay ? 'pause' : 'resume']();
      });
      closeBtn.on('click.toast', function () {
        clearToast(toast);
      });
    },

    /**
    * Create draggable
    * @private
    * @param {object} toast the toast element
    * @param {object} container the toast container element
    * @returns {void}
    */
    createDraggable: function createDraggable(toast, container) {
      var _this = this;

      if (!this.settings.draggable || !toast[0] || !container[0]) {
        return;
      }

      var isTouch = Environment.features.touch; // Drop container

      var dropContainer = container.parent(); // Clear inline style

      container.css({
        top: '',
        left: '',
        right: ''
      }); // Create css rules, position from local storage

      var rect = container[0].getBoundingClientRect();
      var lsPosition = this.restorePosition();
      var posEl = rect; // Check for stored postion is in viewport

      if (lsPosition) {
        posEl = {
          top: lsPosition.top,
          left: lsPosition.left,
          width: toast.outerWidth(),
          height: toast.outerHeight()
        };
        posEl.right = posEl.left + posEl.width;
        posEl.bottom = posEl.top + posEl.height; // Set to default, if stored postion not in viewport

        if (!this.isPosInViewport(posEl)) {
          posEl = rect;
        }
      } // Compile css rules


      var rules = {
        top: "".concat(posEl.top, "px"),
        left: "".concat(posEl.left, "px")
      }; // Reset position right rule, if was set in css file

      if (container.is('.toast-bottom-right, .toast-top-right')) {
        rules.right = 'auto';
      } // Apply compiled css rules


      container.css(rules);
      container.addClass('is-draggable'); // Selector for elements need to be exclude

      var excludeEl = 'a, .btn-close'; // Initialize Drag api

      toast.off('mousedown.toast touchstart.toast').on('mousedown.toast touchstart.toast', function (e) {
        if (!isTouch) {
          e.preventDefault();
        } // No need to drag


        if ($(e.target).is(excludeEl)) {
          return;
        } // Initialize drag


        container.drag({
          containment: 'document'
        }) // Start drag
        .off('dragstart.toast').on('dragstart.toast', function () {
          e.stopImmediatePropagation();
          container.attr('aria-grabbed', 'true');
          dropContainer.attr('aria-dropeffect', 'move');
        }) // End drag
        .off('dragend.toast').on('dragend.toast', function () {
          container.removeAttr('aria-grabbed');
          dropContainer.removeAttr('aria-dropeffect');

          _this.savePosition({
            left: parseFloat(container.css('left')),
            top: parseFloat(container.css('top'))
          }); // Unbind drag from header


          var dragApi = container.data('drag');

          if (dragApi && typeof dragApi.destroy === 'function') {
            dragApi.destroy();
          }
        });
      }); // Check if cursor over the toast

      var isToastEl = function isToastEl(_ref) {
        var dragApi = _ref.dragApi,
            x = _ref.x,
            y = _ref.y;
        var underEl = dragApi.getElementsFromPoint(x, y)[0];
        return !$(underEl).closest('.toast').length;
      }; // Resume the toast timer


      var triggerRsume = function triggerRsume(elem) {
        // [Control + Alt + P] - Pause/Play toggle
        var keyupSetting = {
          ctrlKey: true,
          altKey: true,
          keyCode: 80
        };
        var keyup = $.Event('keyup');
        $.extend(keyup, keyupSetting);
        elem.trigger(keyup);
      };

      var doc = $(document);
      doc.off('mouseup.toast').on('mouseup.toast', function (e) {
        if ($("#toast-container".concat(_this.uniqueId, " .toast")).length === 1) {
          var dragApi = container.data('drag');

          if (dragApi && typeof dragApi.getElementsFromPoint === 'function') {
            var args = {
              dragApi: dragApi,
              x: e.pageX,
              y: e.pageY
            };

            if (isToastEl(args)) {
              triggerRsume(doc);
            }
          }
        }
      }).off('touchend.toast').on('touchend.toast', function (e) {
        if ($("#toast-container".concat(_this.uniqueId, " .toast")).length === 1) {
          var dragApi = container.data('drag');

          if (dragApi && typeof dragApi.getElementsFromPoint === 'function') {
            var orig = e.originalEvent; // do now allow two touch points to drag the same element

            if (orig.targetTouches.length > 1) {
              return;
            }

            var t = orig.changedTouches[0];
            var args = {
              dragApi: dragApi,
              x: t.pageX,
              y: t.pageY
            };

            if (isToastEl(args)) {
              triggerRsume(doc);
            }
          }
        }
      });
    },

    /**
     * Save toast container position.
     * @private
     * @param {object} pos the new position to save
     * @returns {void}
     */
    savePosition: function savePosition() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.settings.savePosition || !this.canUseLocalStorage() || $.isEmptyObject(pos)) {
        return;
      } // Save position to local storage


      localStorage[this.uniqueId] = JSON.stringify(pos);
      /**
      * Fires after settings are changed in some way
      * @event settingschanged
      * @memberof Toast
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {string} args.left The current left positon
      * @property {string} args.top The current top positon
      */

      this.element.triggerHandler('settingschanged', [pos]);
    },

    /**
     * Restore the position from local storage
     * @private
     * @returns {object} The left and top position
     */
    restorePosition: function restorePosition() {
      if (!this.settings.savePosition || !this.canUseLocalStorage()) {
        return null;
      }

      var lsPosition = localStorage[this.uniqueId];
      return lsPosition ? JSON.parse(lsPosition) : null;
    },

    /**
     * Returns true if local storage may be used / is available
     * @private
     * @returns {boolean} If it can be used.
     */
    canUseLocalStorage: function canUseLocalStorage() {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }

      return false;
    },

    /**
    * Generate a unique id based on the page and add a suffix.
    * @private
    * @param {object} suffix Add this string to make the id more unique
    * @returns {string} The unique id.
    */
    generateUniqueId: function generateUniqueId(suffix) {
      suffix = suffix === undefined || suffix === null ? '' : suffix;
      var uniqueid = "toast-".concat(this.settings.uniqueid || '', "-").concat(suffix);
      return uniqueid.replace(/--/g, '-').replace(/-$/g, '');
    },

    /**
     * Check if given postion in the viewport
     * @private
     * @param {object} pos The postion to check
     * @param {object} elem The element to check
     * @returns {boolean} true if is in the viewport
     */
    isPosInViewport: function isPosInViewport(pos) {
      return pos.top >= 0 && pos.left >= 0 && pos.bottom <= (window.innerHeight || document.documentElement.clientHeight) && pos.right <= (window.innerWidth || document.documentElement.clientWidth);
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @param {jQuery[]|HTMLElement} toast the toast message to be removed bindings
     * @param {number} [id=undefined] a unique number associated with the toast being removed
     * @returns {this} component instance
     */
    unbind: function unbind(toast, id) {
      var container = toast.closest('.toast-container');
      container.off('dragstart.toast dragend.toast');
      toast.off('mousedown.toast mouseup.toast touchstart.toast touchend.toast');
      toast.find('.btn-close').off('click.toast');

      if (id !== undefined) {
        $(document).off(["keydown.toast-".concat(id), "keyup.toast-".concat(id)].join(' '));
      }

      return this;
    },

    /**
     * Remove the Message and Animate
     * @private
     * @param {jQuery[]|HTMLElement} toast the toast message to be removed
     * @param {number} [id=undefined] a unique number associated with the toast being removed
     * @returns {void}
     */
    remove: function remove(toast, id) {
      var _this2 = this;

      var removeCallback = function removeCallback() {
        toast.remove();
        var canDestroy = !$("#toast-container".concat(_this2.uniqueId, " .toast")).length;

        if (canDestroy) {
          _this2.destroy();
        }
      };

      this.unbind(toast, id);

      if (this.settings.audibleOnly) {
        removeCallback();
        return;
      }

      toast.addClass('effect-scale-hide');
      var closeTimer = new RenderLoopItem({
        duration: 20,
        updateCallback: function updateCallback() {},
        // TODO: make this work without an empty function
        timeoutCallback: function timeoutCallback() {
          removeCallback();
        }
      });
      renderLoop.register(closeTimer);
    },

    /**
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, TOAST_DEFAULTS);
      }

      this.show();
    },

    /**
     * Teardown
     * @returns {void}
     */
    destroy: function destroy() {
      var _this3 = this;

      var container = $("#toast-container".concat(this.uniqueId));

      if (container[0]) {
        var toasts = [].slice.call(container[0].querySelectorAll('.toast'));
        toasts.forEach(function (toast) {
          _this3.settings.audibleOnly = true; // Remove without delay

          _this3.remove($(toast));
        });
      }

      $(document).off(['mouseup.toast', 'touchend.toast'].join(' '));
      container.remove();
      delete this.toastIndex;
      delete this.uniqueId;
      $.removeData(this.element[0], COMPONENT_NAME$H);
    }
  };

  /**
   * jQuery Plugin Wrapper for Toast
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.toast = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$H);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$H, new Toast(this, settings));
      }
    });
  };

  var COMPONENT_NAME$I = 'Validator';
  /**
   * Validation Message Defaults
   * @namespace
   * @property {boolean} inline
   * @property {string} message
   * @property {string} type
   * @property {boolean} showTooltip
   * @property {boolean} isHelpMessage
   */

  var VALIDATION_MESSAGE_DEFAULTS = {
    inline: true,
    message: '',
    type: 'error',
    showTooltip: false,
    isHelpMessage: false
  };
  /**
   * @class Validator
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   */

  function Validator(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, VALIDATION_MESSAGE_DEFAULTS);
    this.init();
  } // Plugin Object


  Validator.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.fields = 'input, textarea, select, div[data-validate], div[data-validation]';
      this.isPlaceholderSupport = !!('placeholder' in document.createElement('input')); // placeholder native support is-exists
      // If we initialize with a form find all inputs

      this.inputs = this.element.find(this.fields); // Or Just use the current input

      if (this.element.is(this.fields)) {
        this.inputs = $().add(this.element);
      }

      this.timeout = null;
      this.attachEvents();
    },

    /**
     * Gets a list of events
     * @private
     * @param {string} events a single event name, or a JSON-representation of several events
     * @returns {void}
     */
    extractEvents: function extractEvents(events) {
      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if (_typeof(events) === 'object') {
        var e = '';

        for (var k in events) {
          // eslint-disable-line
          if (e.indexOf(events[k]) === -1) {
            e += "".concat(events[k], " ");
          }
        }

        e = e.split(' ').join('.validate ');
        events = e;
      }

      return events;
    },

    /**
     * @private
     * @param {string} events a single event name, or a JSON-representation of several events
     * @param {string} type a type of event to filter against
     * @returns {array} of event types in string format
     */
    filterValidations: function filterValidations(events, type) {
      var validations = [];

      if (!events) {
        return [];
      }

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if (_typeof(events) === 'object') {
        for (var k in events) {
          // eslint-disable-line
          if (type && events[k].indexOf(type) > -1) {
            validations.push(k);
          }
        }
      }

      return validations;
    },

    /**
     * Set error icon opacity for tooltip types, to avoid overlap text in the field
     * @private
     * @param {object} field validation element
     * @returns {void}
     */
    setErrorIconOpacity: function setErrorIconOpacity(field) {
      if (field.is(':text') && field.is('[data-error-type="tooltip"]')) {
        var textWidth = this.calculateTextWidth(field.val());
        var fieldWidth = field.outerWidth() - 35; // 35: icon width + padding/margin

        field.closest('.field, .field-short').find('.icon-error')[textWidth > fieldWidth ? 'addClass' : 'removeClass']('lower-opacity');
      }
    },

    /**
     * Calculate the width for given text
     * @param {string} text to calculate the width
     * @param {string} font used with given text (e.g. `14px arial`).
     * @returns {number} the calculated width
     */
    calculateTextWidth: function calculateTextWidth(text, font) {
      // use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = font || '14px arial';
      var metrics = context.measureText(text);
      return metrics.width;
    },

    /**
     * @private
     */
    attachEvents: function attachEvents() {
      var self = this;
      var attribs = '[data-validate],[data-validation]'; // Attach required

      this.inputs.each(function () {
        var field = $(this);
        var attr = field.attr('data-validate') || field.attr('data-validation');

        if (attr && attr.indexOf('required') > -1) {
          field.addClass('required');
        }
      }); // Link on to the current object and perform validation.

      this.inputs.filter('input, textarea, div').filter(attribs).not('input[type=file]').each(function () {
        var field = $(this);
        var eventAttr = field.attr('data-validation-events');
        var events = self.extractEvents(eventAttr || 'blur.validate change.validate keyup.validate'); // Custom enter event

        if (events.indexOf('enter.validate') > -1) {
          field.off('keypress.enter.validate').on('keypress.enter.validate', function (e) {
            var thisField = $(this);

            if (e.which === 13) {
              self.validate(thisField, true, e);
            }
          });
        }

        field.off(events).on(events, function (e) {
          if (e.type === 'keyup') {
            // Skip on Tab
            if (e.keyCode === 9) {
              return;
            }

            self.setErrorIconOpacity(field);
          }

          var thisField = $(this);
          var handleEventData = thisField.data("handleEvent".concat([e.type || '']));

          if (thisField.is('[readonly]') && !thisField.parent().is('.field-fileupload') && !thisField.is('.lookup.is-not-editable')) {
            return;
          }

          if (handleEventData && handleEventData.type === e.type && e.handleObj.namespace === 'validate' && !thisField.is('.lookup') && !thisField.closest('.modal:visible').length) {
            return;
          }

          thisField.data("handleEvent".concat([e.type || '']), e.handleObj);
          setTimeout(function () {
            if (thisField.closest('.modal-engaged').length && !thisField.closest('.modal-body').length) {
              return;
            }

            self.validate(field, true, e);
          }, 300);
        });
      });
      this.inputs.filter('input[type=checkbox]').filter(attribs).off('click.validate').on('click.validate', function (e) {
        self.validate($(this), true, e);
      });
      this.inputs.filter(':radio').off('click.validate').on('click.validate', function (e) {
        var first = $(this).parent().find('.radio').first();
        self.validate(first, true, e);
      });
      var selects = this.inputs.filter('select').filter(attribs);

      if (selects.length) {
        selects.off('change.validate listopened.validate listclosed.validate').on('change.validate', function (e) {
          self.validate($(this), true, e);
        }).on('listopened.validate', function () {
          var thisField = $(this);
          var tooltip = thisField.data('tooltip');

          if (tooltip && document.activeElement === thisField.data('dropdown').searchInput[0]) {
            tooltip.hide();
          }

          $('#validation-tooltip').hide();
        }).on('listclosed.validate', function () {
          var thisField = $(this);
          var tooltip = thisField.data('tooltip');
          var dropdownApi = thisField.data('dropdown');

          if (Environment.features.touch) {
            dropdownApi.pseudoElem.focus();
            setTimeout(function () {
              dropdownApi.pseudoElem.blur();
            }, 100);
          }

          if (dropdownApi && dropdownApi.wrapper) {
            tooltip = dropdownApi.wrapper.find('.icon-error').data('tooltip');
          }

          if (tooltip && document.activeElement !== thisField.data('dropdown').searchInput[0]) {
            tooltip.show();
          }
        });
        selects.filter(function () {
          return $(this).data('dropdown') !== undefined;
        }).each(function () {
          var pseudoElem = $(this).data('dropdown').pseudoElem;
          pseudoElem.off('blur.validate').on('blur.validate', function (e) {
            var select = $(this).closest('.field, .field-short').find('select');
            self.validate(select, true, e);
          });
        });
      } // Attach to Form Submit and Validate


      if (this.element.is('form') && this.element.attr('data-validate-on')) {
        var submitHandler = function submitHandler(e) {
          e.stopPropagation();
          e.preventDefault();
          self.validateForm(function (isValid) {
            self.element.off('submit.validate');
            self.element.triggerHandler('validated', isValid);
            self.element.data('isValid', isValid);
            self.element.on('submit.validate', submitHandler);
          });
        };

        this.element.off('submit.validate').on('submit.validate', submitHandler);
      }
    },

    /**
     * Validates all elements inside of a form
     * @private
     * @param {function} callback method to call when the form's validation completes.
     */
    validateForm: function validateForm(callback) {
      var _$;

      var self = this;
      var deferreds = [];
      self.inputs = this.element.find(self.fields);
      self.inputs.each(function (e) {
        var field = $(this);

        if (field.attr('data-validate')) {
          if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation')) {
            return;
          }

          var dfds = self.validate(field, false, e);

          for (var i = 0; i < dfds.length; i++) {
            deferreds.push(dfds[i]);
          }
        }
      });

      (_$ = $).when.apply(_$, deferreds).then(function () {
        callback(true);
      }, function () {
        callback(false);
      });
    },

    /**
     * Set disable/enable primary button if a container of fields is valid
     * @private
     * @param {jQuery[]|HTMLElement} container to validate.
     * @param {jQuery[]|HTMLElement} modalBtn the button that needs to be set to primary.
     * @returns {void}
     */
    setPrimaryBtn: function setPrimaryBtn(container, modalBtn) {
      var fields = container.find('[data-validate]:visible, select[data-validate], :checkbox[data-validate]');
      var allValid = true;

      if (fields.length > 0) {
        fields.each(function () {
          var field = $(this);

          if (field.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }

          var isVisible = field[0].offsetParent !== null;

          if (field.is('.required')) {
            if (isVisible && field.is('.editor') && !field.html()) {
              allValid = false;
            }

            if ((isVisible || field.is('select, :checkbox')) && !field.val() && !field.is('.editor')) {
              allValid = false;
            }
          }

          if ((isVisible || field.is('select, :checkbox')) && !field.isValid()) {
            allValid = false;
          }
        });
      }

      if (allValid) {
        modalBtn.removeAttr('disabled');
      } else {
        modalBtn.attr('disabled', 'disabled');
      }
    },

    /**
     * Gets the current value of a field
     * @private
     * @param {jQuery[]} field the field being checked.
     * @returns {any} the value of the field.
     */
    value: function value(field) {
      if (field.is('input[type=checkbox]')) {
        return field.prop('checked');
      }

      if (field.is('div')) {
        // contentEditable div (Rich Text)
        return field[0].innerHTML;
      }

      return field.val();
    },

    /**
     * Get the types of validation from a field.
     * @private
     * @param {jQuery[]} field the field being checked
     * @param {jQuery.Event} e the `validate` event
     * @returns {array} an array of types
     */
    getTypes: function getTypes(field, e) {
      var filters = this.filterValidations(field.attr('data-validation-events'), e.type);
      var validations;

      if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validate')) {
        validations = field.prev().prev('select').attr('data-validate').split(' ');
      } else if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validation')) {
        validations = field.prev().prev('select').attr('data-validation').split(' ');
      } else if (field.attr('data-validation')) {
        validations = field.attr('data-validation').split(' ');
      } else if (field.attr('data-validate')) {
        validations = field.attr('data-validate').split(' ');
      } else {
        validations = [];
      } // Filter out not needed events


      if (filters.length > 0) {
        validations = validations.filter(function (n) {
          return filters.indexOf(n) !== -1;
        });
      } // Filter out specific events that should not use keyup


      if (e.type === 'keyup') {
        validations = validations.filter(function (n) {
          return n !== 'date' && n !== 'time';
        });
      }

      return validations;
    },

    /**
     * Set icon on parent tabs/expandable
     * @private
     * @param {jQuery[]} field the field being appended to.
     * @param {string} type the type of icon being appended.
     * @returns {void}
     */
    setIconOnParent: function setIconOnParent(field, type) {
      var errorIcon = $.createIcon({
        classes: ["icon-".concat(type)],
        icon: "".concat(type, "-alert")
      });
      var parent = field.closest('.tab-panel, .expandable-pane');
      var flexRow = field.closest('.row.flex-align-bottom');
      var iconTarget = parent.attr('id');
      var parentContainer = field.closest('.tab-container, .tab-panel-container, .expandable-area');
      var iconContainer;
      var dropdown;
      var dropdownParent; // Flex Row

      if (flexRow && flexRow.length) {
        if ($(".".concat(type), flexRow).length) {
          flexRow.addClass('has-messages');
        } else {
          flexRow.removeClass('has-messages');
        }
      } // Tabs


      if (parentContainer.is('.tab-panel-container')) {
        parentContainer = parentContainer.prev('.tab-container');
      }

      if (parentContainer.is('.tab-container')) {
        // Default Tabs
        iconContainer = $(".tab-list a[href=\"#".concat(iconTarget, "\"]"), parentContainer).closest('.tab'); // Tabs with Counts

        if (iconContainer.length) {
          if ($('.count', iconContainer).length) {
            iconContainer = $('.count', iconContainer);
          }
        } else {
          // Dropdown Tabs (with popupmenu)
          iconTarget = $("a[href=\"#".concat(iconTarget, "\"]"), '.popupmenu').closest('.popupmenu').attr('id');
          iconContainer = $(".tab-list .tab[aria-controls=\"".concat(iconTarget, "\"]"), parentContainer);
          dropdown = iconTarget;
        }
      } else if (parentContainer.is('.expandable-area')) {
        // Expandable
        iconContainer = $(".expandable-header[aria-controls=\"".concat(iconTarget, "\"] .title"), parentContainer);
      } else {
        // No action
        return;
      } // if Dropdown Tabs set each menu item to check


      if (dropdown && dropdown.length) {
        dropdownParent = parent.add($($(dropdown).attr('href')));
        $('a[role="menuitem"]', "#".concat(dropdown)).each(function () {
          dropdownParent = dropdownParent.add($($(this).attr('href')));
        });
      }

      var menuitem = $("a[href=\"#".concat(parent.attr('id'), "\"]"), "#".concat(iconTarget)); // Add icon

      if (!!parent && $(".".concat(type), parent).length || !!dropdownParent && $(".".concat(type), dropdownParent).length) {
        // if Dropdown Tabs and current menu item has no error remove icon
        if (!$(".".concat(type), parent).length) {
          menuitem.removeClass("is-".concat(type));
          $(".icon-".concat(type), menuitem).remove();
        } // if Dropdown Tabs and current menu item has error add icon


        if ($(".".concat(type), parent).length && $(".".concat(type), dropdownParent).length && !$(".icon-".concat(type), menuitem).length) {
          menuitem.addClass("is-".concat(type)).append(errorIcon);
        } // Add icon to main tab area


        if (!$(".icon-".concat(type), iconContainer).length) {
          iconContainer.addClass("is-".concat(type)).append(errorIcon);
        }

        var tabsAPI = parentContainer.data('tabs');

        if (tabsAPI) {
          tabsAPI.sizeBar();
        }
      } else {
        // Remove icon
        iconContainer = iconContainer.add(menuitem);
        iconContainer.removeClass("is-".concat(type));
        $(".icon-".concat(type), iconContainer).remove();
      }
    },

    /**
     * @private
     * @param {jQuery[]} field the field being validated
     * @param {boolean} showTooltip whether or not this field should display its validation message in a tooltip
     * @param {jQuery.Event} e the `validate` event
     * @returns {array} of jQuery deferred objects
     */
    validate: function validate(field, showTooltip, e) {
      field.data("handleEvent".concat([e.type || '']), null);

      if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation') || field.is(':disabled')) {
        return [];
      } // call the validation function inline on the element


      var self = this;
      var types = self.getTypes(field, e) || [];
      var rule;
      var dfd;
      var dfds = [];
      var results = [];
      var i;
      var l;
      var validationType;
      var value = self.value(field);
      var placeholder = field.attr('placeholder');

      function manageResult(result, showResultTooltip, type, dfrd) {
        rule = Validation.rules[type]; // Only remove if "false", not any other value ie.. undefined

        if (rule.positive === false) {
          self.removePositive(field);
        }

        validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;
        var isInline = field.attr("data-".concat(validationType.type, "-type")) !== 'tooltip';

        if (!result) {
          if (!self.isPlaceholderSupport && value === placeholder && rule.message !== Locale.translate('Required')) {
            return;
          }

          self.addMessage(field, rule, isInline, showResultTooltip);
          results.push(rule.type);

          if (validationType.errorsForm) {
            dfrd.reject();
          } else {
            dfrd.resolve();
          }
        } else if ($.grep(results, function (res) {
          return res === validationType.type;
        }).length === 0) {
          dfrd.resolve();

          if (rule.positive) {
            // FIX: In Contextual Action Panel control not sure why but need to add error,
            // otherwise "icon-success" get misaligned,
            // so for this fix adding and then removing error here
            self.addMessage(field, rule, isInline, showResultTooltip);
            self.removeMessage(field, rule, true);
            dfrd.resolve();
            self.addPositive(field);
          }
        } else if (!validationType.errorsForm) {
          // Rules that do not error the form need to resolve
          dfrd.resolve();
        }

        self.setIconOnParent(field, rule.type);
        var loc = self.getField(field);
        var data = loc.data("".concat(validationType.type, "message"));

        if (result && data && data.filter(function (rules) {
          return rules.id === rule.id || rule.message;
        }).length > 0) {
          self.removeMessage(field, rule, true);
        } // Test Enabling primary button in modal


        var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');

        if (modalBtn.length) {
          self.setPrimaryBtn(field.closest('.modal'), modalBtn);
        } // Test Enabling primary button in Calendar Popup


        var calendarPopupBtn = field.closest('#calendar-popup').find('.btn-modal-primary').not('.no-validation');

        if (calendarPopupBtn.length) {
          self.setPrimaryBtn(field.closest('#calendar-popup'), calendarPopupBtn);
        }

        if (rule.type === 'error') {
          field.closest('form').triggerHandler('aftervalidate', {
            field: field,
            rule: rule,
            isValid: result
          });
        }
      }

      for (i = 0, l = types.length; i < l; i++) {
        rule = Validation.rules[types[i]];
        dfd = $.Deferred();

        if (!rule) {
          continue;
        }

        if (rule.async) {
          rule.check(value, field, manageResult, dfd);
        } else {
          manageResult(rule.check(value, field), showTooltip, types[i], dfd);
        }

        dfds.push(dfd);
      }

      return dfds;
    },

    /**
     * Retrive the actionble element that should have an error class/icon appended to it.
     * @private
     * @param {jQuery[]} field the field being checked
     * @returns {jQuery[]} the field to be checked
     */
    getField: function getField(field) {
      if (field.is('select') && field.data('dropdown') !== undefined) {
        field = field.data('dropdown').pseudoElem;
      }

      return field;
    },

    /**
     * Returns true if the given object has an error
     * @param {jQuery[]} field the field being checked
     * @returns {boolean} whether or not the field currently has an error
     */
    hasError: function hasError(field) {
      return this.getField(field).hasClass('error');
    },

    /**
     * Adds a validation message/icon to a form field.
     * @private
     * @param {jQuery[]} field the field to be appended
     * @param {object} rule The validation message text
     * @param {boolean} inline whether or not the text should appear inside the input field
     *  (like a placeholder), or underneath the input field
     * @param {boolean} showTooltip whether or not the legacy validation Tooltip will contain the
     * message instead of placing it underneath
     * @param {boolean} isHelpMessage whether or not this validation message type is "alert"
     */
    addMessage: function addMessage(field, rule, inline, showTooltip, isHelpMessage) {
      if (rule.message === '') {
        return;
      }

      if (field.is('.dropdown, .multiselect') && $('#dropdown-list').is(':visible')) {
        return;
      }

      isHelpMessage = isHelpMessage || false;
      var loc = this.getField(field);
      var dataMsg = loc.data("".concat(rule.type, "message"));
      var validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;

      if (!isHelpMessage) {
        loc.addClass(rule.type === 'icon' ? 'custom-icon' : rule.type);
      } // Inline messages are now an array


      if (dataMsg && dataMsg === rule.message) {
        // No need to add new message
        return;
      }

      if (dataMsg && dataMsg.filter(function (rules) {
        return (rules.id || rules.message) === (rule.id || rule.message) && rules.message === rule.message;
      }).length > 0) {
        // No need to add new message
        return;
      }

      var appendedMsg = rule.message;

      if (dataMsg) {
        for (var i = 0; i < dataMsg.length; i++) {
          appendedMsg = "\u2022 ".concat(dataMsg[i].message);
        }

        appendedMsg += "<br>\u2022 ".concat(rule.message);
      }

      if (!dataMsg) {
        dataMsg = [];
      } // Find the message by id and remove


      field.closest('.field, .field-short').find("[data-rule-id=\"".concat(rule.id || rule.message, "\"]")).remove();

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.parent().find(".dropdown-wrapper > [data-rule-id=\"".concat(rule.id || rule.message, "\"]")).off('click.validate').remove();
      } // Remove the rule if it exists in the dataMsg


      dataMsg = dataMsg.filter(function (rules) {
        return rules.id !== rule.id;
      });
      dataMsg.push({
        id: rule.id,
        message: rule.message,
        type: rule.type
      });
      loc.data("".concat(validationType.type, "message"), dataMsg); // Add Aria

      if ($.fn.toast !== undefined) {
        $('body').toast({
          title: Locale.translate(validationType.titleMessageID),
          audibleOnly: true,
          message: appendedMsg
        });
      }

      if (!inline) {
        this.showTooltipMessage(field, appendedMsg, validationType.type, showTooltip);
        return;
      }

      field.data('isValid', false);
      this.showInlineMessage(field, rule, isHelpMessage);
    },

    /**
     * Shows an error icon
     * @private
     * @param {jQuery[]} field the field being appended
     * @param {string} type the error type
     * @returns {jQuery[]} the new icon's markup
     */
    showIcon: function showIcon(field, type) {
      var loc = this.getField(field).addClass(type === 'icon' ? 'custom-icon' : type);
      var svg = $.createIconElement({
        classes: ["icon-".concat(type)],
        icon: type
      });
      var closestField = loc.closest('.field, .field-short');
      var parent = field.parent();

      if (closestField.find("svg.icon-".concat(type)).length === 0) {
        if (parent.is('.editor-container')) {
          field.parent().addClass('is-error');
        }

        if (field.parent(':not(.editor-container)').find('.btn-actions').length === 1) {
          parent.find('.btn-actions').before(svg);
        } else if (parent.find('.data-description').length === 1) {
          parent.find('.data-description').before(svg);
        } else if (parent.find('.field-info').length === 1) {
          parent.find('.field-info').before(svg);
        } else if (field.is('textarea')) {
          field.after(svg);
        } else if (field.is('.dropdown, .multiselect')) {
          parent.find('.dropdown-wrapper').append(svg);
        } else if (field.is('.spinbox')) {
          parent.append(svg);
        } else if (field.is('.lookup')) {
          parent.append(svg);
        } else {
          parent.append(svg);
        }

        $('.icon-success', closestField).remove();
      } else {
        svg = closestField.find('svg.icon-error');
      }

      return svg;
    },

    /**
     * Shows an tooltip error
     * @private
     * @param {jQuery[]} field the field being appended
     * @param {string} message text content containing the validation message.
     * @param {string} type the validation type (error, alert, info, etc)
     * @param {boolean} showTooltip whether or not to initially show the tooltip
     */
    showTooltipMessage: function showTooltipMessage(field, message, type, showTooltip) {
      if (field.is(':radio')) {
        return;
      }

      var icon = this.showIcon(field, type);
      var representationField = field; // Add error classes to pseudo-markup for certain controls

      if (field.is('.dropdown, .multiselect') && field.data('dropdown') !== undefined) {
        var input = field.data('dropdown').pseudoElem;
        representationField = input;
        input.addClass(type === 'icon' ? 'custom-icon' : type);
      }

      field.closest('.field, .field-short').find('.formatter-toolbar').addClass(type === 'icon' ? 'custom-icon' : type);
      var tooltipAPI = icon.data('tooltip'); // Error tooltips should be positioned on the 'x' so that they sit directly
      // underneath the fields that they are indicating.

      function tooltipPositionCallback(placementObj) {
        var fieldRect = representationField[0].getBoundingClientRect();
        var elRect = tooltipAPI.tooltip[0].getBoundingClientRect();
        var rtl = $('html').is('[dir="rtl"]');
        var currX = placementObj.x;
        var xAdjustment = 0;

        if (rtl) {
          if (elRect.left < fieldRect.left) {
            xAdjustment += fieldRect.left - elRect.left;
          }
        } else if (elRect.right > fieldRect.right) {
          xAdjustment += (elRect.right - fieldRect.right) * -1;
        }

        placementObj.setCoordinate('x', currX + xAdjustment);

        if (!placementObj.nudges) {
          placementObj.nudges = {};
        }

        placementObj.nudges.x = xAdjustment;
        return placementObj;
      } // Build Tooltip


      if (!tooltipAPI) {
        icon.tooltip({
          content: message,
          placement: 'bottom',
          placementOpts: {
            callback: tooltipPositionCallback
          },
          trigger: 'focus',
          isError: true,
          tooltipElement: '#validation-tooltip'
        });
        tooltipAPI = icon.data('tooltip');
      } else {
        tooltipAPI.content = message;
      }

      field.on('focus.validate', function () {
        if (!tooltipAPI) {
          return;
        }

        tooltipAPI.show();
      }).on('blur.validate', function () {
        if (!tooltipAPI) {
          return;
        }

        tooltipAPI.hide();
      });

      if (tooltipAPI) {
        field.attr('data-error-type', 'tooltip');
      }

      this.setErrorIconOpacity(field);

      if (showTooltip && tooltipAPI) {
        tooltipAPI.show();
      }
    },

    /**
     * Shows an tooltip error
     * @private
     * @param {jQuery[]} field the field being toggled
     * @param {string} message text content containing the validation message
     * @param {string} type (error, alert, info, etc.)
     * @param {HTMLElement} markup existing HTML markup to use
     * @param {boolean} isShow whether or not the message is already showing
     */
    toggleRadioMessage: function toggleRadioMessage(field, message, type, markup, isShow) {
      var all;
      var loc;
      var name = field.attr('name');

      if (name && name.length) {
        all = $(":radio[name=\"".concat(name, "\"], :radio[name=\"").concat(name, "\"] + label"));
        loc = field.parent().is('.inline') ? $(":radio[name=\"".concat(name, "\"]:last")).parent() : $(":radio[name=\"".concat(name, "\"]:last + label"));

        if (isShow) {
          all.addClass(type === 'icon' ? 'custom-icon' : type);
          $(markup).addClass("radio-group-".concat(type)).insertAfter(loc);
        } else {
          all.removeClass(type);
          loc.next(".radio-group-".concat(type)).remove();
        }
      }
    },

    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     * @param {string} rule The validation rule data.
     * @param {boolean} isHelpMessage whether or not the validation type is "alert"
     */
    showInlineMessage: function showInlineMessage(field, rule, isHelpMessage) {
      isHelpMessage = isHelpMessage || false;
      var loc = this.getField(field);
      var validationType = Validation.ValidationTypes[rule.type] || Validation.ValidationTypes.error;
      rule.icon = rule.icon || validationType.icon;
      var markup;
      var icon;

      if (rule.type === 'error') {
        icon = "".concat(validationType.type, "-alert");
      } else {
        icon = theme.currentTheme.id && theme.currentTheme.id.indexOf('uplift') > -1 ? "".concat(validationType.type, "-alert") : "".concat(validationType.type);
      }

      if (rule.type === 'icon') {
        markup = '' + "<div class=\"custom-icon-message\" data-rule-id=\"".concat(rule.id || rule.message, "\">\n          ").concat($.createIcon({
          classes: ['icon-custom'],
          icon: rule.icon
        }), "\n          <pre class=\"audible\">\n            ").concat(Locale.translate(validationType.titleMessageID), "\n          </pre>\n          <p class=\"message-text\">").concat(rule.message, "</p>\n        </div>");
      } else {
        markup = '' + "<div class=\"".concat(validationType.type, "-message\" data-rule-id=\"").concat(rule.id || rule.message, "\">\n          ").concat($.createIcon({
          classes: ["icon-".concat(validationType.type)],
          icon: icon
        }), "\n          <pre class=\"audible\">\n            ").concat(Locale.translate(validationType.titleMessageID), "\n          </pre>\n          <p class=\"message-text\">").concat(rule.message, "</p>\n        </div>");
      }

      if (!isHelpMessage) {
        loc.addClass(rule.type === 'icon' ? 'custom-icon' : rule.type);
      }

      if (field.is(':radio')) {
        this.toggleRadioMessage(field, rule.message, validationType.type, markup, true);
      } else {
        // All other components
        loc.closest('.field, .field-short').find('.formatter-toolbar').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
        loc.closest('.field, .field-short').append(markup);
        loc.closest('.field, .field-short').find('.colorpicker-container').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
      }

      if (field.is('.spinbox')) {
        loc.closest('.spinbox-wrapper').addClass(validationType.type === 'icon' ? 'custom-icon' : validationType.type);
      } // Remove positive errors


      if (validationType.type === 'error') {
        field.parent().find('.icon-success').remove();
      } // Trigger an event


      field.triggerHandler(validationType.type, {
        field: field,
        message: rule.message
      });
      field.closest('form').triggerHandler(validationType.type, {
        field: field,
        message: rule.message
      });
    },

    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     */
    addPositive: function addPositive(field) {
      var svg = $.createIcon({
        icon: 'success',
        classes: 'icon-success'
      });

      if (!$('.icon-success', field.parent('.field, .field-short')).length) {
        field.parent('.field, .field-short').append(svg);
      }
    },

    /**
     * Remove the message form the field if there is one and mark the field valid, if no other messages.
     * @private
     * @param {jQuery[]} field the field which is having its error removed
     * @param {string} rule The validation rule to remove
     * @param {boolean} triggerEvents If true events will be fired
    */
    removeMessage: function removeMessage(field, rule) {
      var triggerEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // see if anything to remove
      var loc = this.getField(field);
      var oldData = loc.data("".concat(rule.type, "message"));
      var ruleId = rule.id || rule.message;

      if (!rule) {
        return;
      }

      if (rule.type === 'error' && !oldData || oldData.filter(function (rules) {
        return rules.id === ruleId;
      }).length === 0) {
        return;
      } // Remove the message from the array


      var newData = oldData.filter(function (rules) {
        return rules.id !== ruleId;
      });
      var noMoreMessages = newData.length === 0;

      if (noMoreMessages) {
        loc.removeData("".concat(rule.type, "message"));
      } else {
        loc.data("".concat(rule.type, "message"), newData);
      } // Find the message by id and remove


      field.closest('.field, .field-short').find("[data-rule-id=\"".concat(rule.id || rule.message, "\"]")).remove();

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.parent().find(".dropdown-wrapper > [data-rule-id=\"".concat(rule.id || rule.message, "\"]")).off('click.validate').remove();
      } // Trigger valid and remove error / message classes


      if (noMoreMessages && rule.type === 'error' && triggerEvents) {
        field.triggerHandler('valid', {
          field: field,
          message: ''
        });
        field.closest('form').triggerHandler('valid', {
          field: field,
          message: ''
        });
      }

      if (!noMoreMessages) {
        return;
      }

      field.removeClass("".concat(rule.type, " custom-icon")).data('isValid', true);

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.next().next().removeClass("".concat(rule.type, " custom-icon"));
        field.next().find('div.dropdown').removeClass("".concat(rule.type, " custom-icon"));
      }

      if (field.is(':radio')) {
        this.toggleRadioMessage(field, '', rule.type, '', false);
      }

      if (field.hasClass('spinbox')) {
        field.closest('.spinbox-wrapper').removeClass("".concat(rule.type, " custom-icon"));
      }

      if (field.hasClass('colorpicker')) {
        field.parent('.colorpicker-container').removeClass(rule.type);
      }

      if (field.closest('.field-fileupload').length > 0) {
        field.closest('.field-fileupload').find("input.".concat(rule.type)).removeClass(rule.type);
      } // Remove tooltip style message and tooltip


      if (field.attr("data-".concat(rule.type, "-type")) === 'tooltip') {
        var errorIcon = field.closest('.field, .field-short').find('.icon-error');
        var tooltipAPI = errorIcon.data('tooltip'); // Destroy tooltip

        if (tooltipAPI) {
          tooltipAPI.destroy();
        }

        if (this.inputs) {
          this.inputs.filter('input, textarea').off('focus.validate');
        } // Remove icon


        field.parent().find(".dropdown-wrapper > .icon-".concat(rule.type)).off('click.validate').remove(); // SVG Error Icon

        field.parent().find(".icon-".concat(rule.type)).remove();
        field.next(".icon-".concat(rule.type)).off('click.validate').remove();
        field.parent('.field, .field-short').find(".icon-".concat(rule.type)).remove();
        field.next('.inforCheckboxLabel').next(".icon-".concat(rule.type)).remove();
      }
    },

    /**
     * Shows an inline error message on a field
     * @private
     * @param {jQuery[]} field the field being modified
     */
    removePositive: function removePositive(field) {
      $('.icon-success', field.parent('.field, .field-short')).remove();
    },

    /**
     * Reset all form errors and values
     * @param {jQuery[]} form The form to reset.
     */
    resetForm: function resetForm(form) {
      var formFields = form.find('input, select, textarea, div.dropdown, div.editor'); // Clear Errors

      formFields.removeClass('error');
      form.find('.error').removeClass('error');
      form.find('.icon-error').remove();
      form.find('.icon-success').remove();
      form.find('.error-message').remove(); // Clear Warnings

      formFields.removeClass('alert');
      form.find('.alert').removeClass('alert');
      form.find('.icon-alert').remove();
      form.find('.alert-message').remove(); // Clear Informations

      formFields.removeClass('info');
      form.find('.info').removeClass('info');
      form.find('.icon-info').remove();
      form.find('.info-message').remove();
      setTimeout(function () {
        $('#validation-errors').addClass('is-hidden');
      }, 300); // Remove Dirty

      formFields.data('isDirty', false).removeClass('isDirty');
      form.find('.isDirty').removeClass('isDirty'); // reset form data

      if (form.is('form')) {
        form[0].reset();
      }

      var validationTypes = $.fn.validation.ValidationTypes;
      Object.keys(validationTypes).forEach(function (validationType) {
        formFields.removeData("".concat(validationType, "message"));
      });
      formFields.removeData('isValid');
    },

    /**
     * See if any form errors and check for any empty required fields.
     * @param {jQuery[]} form The form to check.
     * @returns {boolean} True if the form is valid, false otherwise.
     */
    isFormValid: function isFormValid(form) {
      if ($(form).find('.error-message').length > 0) {
        return false;
      }

      var formFields = $(form).find('[data-validate*="required"]');

      for (var i = 0; i < formFields.length; i++) {
        var field = $(formFields[i]);
        var value = this.value(field);

        if ((field.is(':visible') || field.is('select')) && !value) {
          return false;
        }
      }

      return true;
    },

    /**
     * Update method
     * @param {object} [settings] incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.init();
    }
  };

  var VALIDATE_COMPONENT_NAME = 'validate'; // Settings specific to error messages.
  // Used for backwards compatibility.

  var ERROR_MESSAGE_DEFAULTS = {
    type: 'error',
    inline: true
  };
  /**
   * jQuery Component Wrapper for the Validation Component
   */

  $.fn.validation = Validation;
  /**
   * Returns the specific type message data object for a Field
   * @param {object} [settings] incoming settings
   * @returns {string} messages as a string for the specific type
   */

  $.fn.getMessage = function (settings) {
    if (!settings) {
      settings = {
        type: 'error'
      };
    }

    var dataAttr = "".concat(settings.type, "message");
    var messages = $.fn.getField($(this)).data(dataAttr);
    var strMessages = '';

    if (messages) {
      if (messages.length === 1) {
        return messages[0].message;
      }

      for (var i = 0; i < messages.length; i++) {
        strMessages += "\u2022 ".concat(messages[i].message);
      }
    }

    return strMessages;
  };
  /**
   * Returns all messages on an object as an array.
   * @param {object} [settings] incoming settings
   * @returns {array} message data for the specific type
   */


  $.fn.getMessages = function (settings) {
    if (!settings) {
      settings = {
        type: 'error'
      };
    }

    var dataAttr = "".concat(settings.type, "message");
    var messages = $.fn.getField($(this)).data(dataAttr);

    if (!messages) {
      messages = [];
    }

    return messages;
  };
  /**
   * Retrive the actionble element that should have an error class/icon appended to it.
   * @private
   * @param {jQuery[]} field the field being checked
   * @returns {jQuery[]} the field to be checked
   */


  $.fn.getField = function (field) {
    if (field.is('select') && field.data('dropdown') !== undefined) {
      field = field.data('dropdown').pseudoElem;
    }

    return field;
  };
  /**
   * Returns the errormessage data object for a Field.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @deprecated as of v4.4.0.  Please use `$.fn.getMessage()` instead.
   * @param {object} [settings] incoming settings
   * @returns {object} error message data
   */


  $.fn.getErrorMessage = function (settings) {
    warnAboutDeprecation('$.fn.getMessage', '$.fn.getErrorMessage');
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    return $(this).getMessage(settings);
  };
  /**
   * ScrollIntoView and sets focus on an element
   * @param {boolean} [alignToTop] true (default) element will be aligned to the
   *  top of the visible area of the scrollable ancestor
   * @param {object} [settings] incoming settings
   */


  $.fn.scrollIntoView = function (alignToTop, settings) {
    if (typeof alignToTop !== 'boolean') {
      alignToTop = undefined;
    }

    var instance = new Validator(this, settings);
    var elem = instance.getField($(this));
    elem[0].scrollIntoView(alignToTop);
    elem.focus();

    if (elem.is('input.checkbox')) {
      elem = elem.next('.checkbox-label');

      if (elem[0]) {
        elem[0].scrollIntoView(alignToTop);
      }
    }
  };
  /**
   * Add a Message to a Field
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements receiving messages
   */


  $.fn.addMessage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$I);

      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$I, new Validator(this, settings));
      }

      var rule = {
        message: settings.message,
        type: settings.type,
        triggerEvents: settings.triggerEvents,
        icon: settings.icon,
        id: settings.id || settings.message
      };
      var field = $(this);
      instance.addMessage(field, rule, settings.inline, settings.showTooltip, settings.isAlert);
      instance.setIconOnParent(field, settings.type);
    });
  };
  /**
   * Add an error Message to a Field.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @deprecated as of v4.4.0.  Please use `$.fn.addMessage()` instead.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements receiving errors
   */


  $.fn.addError = function (settings) {
    warnAboutDeprecation('$.fn.addMessage', '$.fn.addError');
    var inline = true;

    if (typeof settings.inline === 'boolean' && settings.inline === false) {
      inline = false;
    }

    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    settings.inline = inline;
    return this.each(function () {
      $(this).addMessage(settings);
    });
  };
  /**
   * Remove a Message from a Field
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements having errors removed
   */


  $.fn.removeMessage = function (settings) {
    if (!settings) {
      settings = {
        type: 'error'
      };
    }

    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$I);

      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$I, new Validator(this, settings));
      }

      var field = $(this);
      var dataAttr = "".concat(settings.type, "message");
      var errors = $.fn.getField(field).data(dataAttr);

      if (field.hasClass('error') && settings.type === 'error') {
        field.removeClass('error');
      }

      if (!errors) {
        return;
      }

      for (var i = 0; i < errors.length; i++) {
        instance.removeMessage(field, errors[i], settings.triggerEvents);
      }

      instance.setIconOnParent(field, settings.type);
      $.removeData(this, COMPONENT_NAME$I);
    });
  };
  /**
   * Remove an error Message from a Field.
   * This method is slated to be removed in a future v4.10.0 or v5.0.0.
   * @deprecated as of v4.4.0.  Please use `$.fn.removeMessage()` instead.
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements having errors removed
   */


  $.fn.removeError = function (settings) {
    warnAboutDeprecation('$.fn.removeMessage', '$.fn.removeError');
    settings = utils.extend({}, settings, ERROR_MESSAGE_DEFAULTS);
    return this.each(function () {
      return $(this).removeMessage(settings);
    });
  };
  /**
   * The Actual Validate Component
   * @param {object|string} [settings] incoming settings, or an API method name
   * @param {object} args that can be passed to an API method, if called via string settings
   * @returns {jQuery[]} components being acted on
   */


  $.fn.validate = function (settings, args) {
    var settingsAreAPIFunction = typeof settings === 'string';
    return this.each(function () {
      var instance = $.data(this, VALIDATE_COMPONENT_NAME);

      if (instance && typeof instance !== 'string') {
        // If settings are a string, assume the string is a function on the instance API
        // that needs to be called, and attempt to call it.
        if (settingsAreAPIFunction) {
          if (typeof instance[settings] === 'function') {
            instance[settings](args);
          }

          return;
        } // Settings are object-based, and can be handled normally


        instance.updated(settings);
      } else {
        instance = $.data(this, VALIDATE_COMPONENT_NAME, new Validator(this, settings));
      }
    });
  };

  /**
   * Soho Validation Utilities
   * ========================================
   */

  /**
   * jQuery Utility function wrapper for checking whether or not a field passes validation.
   * @returns {boolean} whether or not the field is valid
   */
  $.fn.isValid = function () {
    var isValidAttr = $(this).data('isValid');
    return isValidAttr === undefined || isValidAttr === null ? true : isValidAttr;
  };
  /**
   * Check validation manually.
   * @returns {void}
   */


  $.fn.validateField = function () {
    var field = $(this);
    var api = Soho.components.Validator.prototype; //eslint-disable-line

    if (api && api.validate) {
      api.validate(field, false, 0);
    }
  };
  /**
   * Clear out the stuff on the Form
   */


  $.fn.resetForm = function () {
    var api = Soho.components.Validator.prototype; //eslint-disable-line

    api.resetForm(this);
  };

  var COMPONENT_NAME$J = 'datepicker';
  /**
   * A component to support date entry.
   * @class DatePicker
   * @constructor
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {boolean} [settings.showTime=false] If true the time selector will be shown.
   * @param {boolean} [settings.useCurrentTime=false] If true current time will be used for the time portion otherwise 12:00 midnight is used
   * @param {string} [settings.timeFormat] Format to use time section fx HH:mm,
   *  defaults current locale settings.
   * @param {number} [settings.minuteInterval]
   * @param {number} [settings.secondInterval]
   * @param {string} [settings.mode] Time picker options: 'standard', 'range',
   *  this controls the time picker.
   * @param {boolean} [settings.roundToInterval] In time picker mode, if a non-matching
   *  minutes value is entered,
   *  rounds the minutes value to the nearest interval when the field is blurred.
   * @param {string} [settings.dateFormat='locale'] Defaults to current locale but can be
   * @param {string} [settings.placeholder=false] Text to show in input element while empty.
   * @param {number} [settings.firstDayOfWeek=0] Set first day of the week. '1' would be Monday.
   * @param {object} [settings.disable] Disable dates in various ways.
   * For example `{minDate: 'M/d/yyyy', maxDate: 'M/d/yyyy'}`. Dates should be in format M/d/yyyy
   * or be a Date() object or string that can be converted to a date with new Date().
   * @param {function} [settings.disable.callback] return true to disable passed dates.
   * @param {array} [settings.disable.dates] Disable specific dates.
   * Example `{dates: ['12/31/2018', '01/01/2019']}`.
   * @param {array} [settings.disable.years] Disable specific years.
   * Example `{years: [2018, 2019]}`.
   * @param {string|date} [settings.disable.minDate] Disable up to a minimum date.
   * Example `{minDate: '12/31/2016'}`.
   * @param {string|date} [settings.disable.maxDate] Disable up to a maximum date.
   * Example `{minDate: '12/31/2019'}`.
   * @param {array} [settings.disable.dayOfWeek] Disable a specific of days of the week 0-6.
   * Example `{dayOfWeek: [0,6]}`.
   * @param {boolean} [settings.disable.isEnable=false] Inverse the disable settings.
   * If true all the disable settings will be enabled and the rest will be disabled.
   * So you can inverse the settings.
   * @param {boolean} [settings.disable.retrictMonths=false] Restrict month selections on datepicker.
   * It requires minDate and maxDate for the feature to activate.
   * For example if you have more non specific dates to disable then enable ect.
   * @param {boolean} [settings.showLegend=false] If true a legend is show to associate dates.
   * @param {boolean} [settings.showMonthYearPicker=true] If false the year and month switcher will be disabled.
   * @param {boolean} [settings.hideDays=false] If true the days portion of the calendar will be hidden.
   *  Usefull for Month/Year only formats.
   * @param {number} [settings.yearsAhead=5] The number of years ahead to show in the month/year picker should total 9 with yearsBack.
   * @param {number} [settings.yearsBack=4] The number of years back to show in the month/year picker should total 9 with yearsAhead.
   * @param {array} [settings.legend]  Legend Build up
   * for example `[{name: 'Public Holiday', color: '#76B051', dates: []},
   * {name: 'Weekends', color: '#EFA836', dayOfWeek: []}]`
   * @param {object} [settings.range] Range between two dates with various options.
   * @param {boolean} [settings.range.useRange=false] Use range of two dates options.
   * @param {string|date} [settings.range.start] Start date in range.
   * @param {string|date} [settings.range.end] End date in range.
   * @param {string} [settings.range.separator=' - '] Visual separator between two dates.
   * @param {number} [settings.range.minDays=0] Minimum days to be in range.
   * @param {number} [settings.range.maxDays=0] Maximum days to be in range.
   * @param {boolean} [settings.range.selectForward=false] Range only in forward direction.
   * @param {boolean} [settings.range.selectBackward=false] Range only in backward direction.
   * @param {boolean} [settings.range.includeDisabled=false] Include disable dates in range of dates.
   * @param {boolean} [settings.range.selectWeek=false] If true will act as a week picker.
   * @param {string} [settings.calendarName] The name of the calendar to use in instance of multiple calendars. At this time only ar-SA and ar-EG locales have either 'gregorian' or 'islamic-umalqura' as valid values.
   * @param {string} [settings.locale] The name of the locale to use for this instance. If not set the current locale will be used.
   * @param {string} [settings.language] The name of the language to use for this instance. If not set the current locale will be used or the passed locale will be used.
   * @param {boolean} [settings.useUTC=false] If true the dates will use UTC format. This is only partially
   * implemented https://jira.infor.com/browse/SOHO-3437
   * @param {boolean} [settings.hideButtons=false] If true bottom and next/prev buttons will be not shown.
   * @param {boolean} [settings.showToday=true] If true the today button is shown on the header.
   * @param {function} [settings.onOpenCalendar] Call back for when the calendar is open, allows you to set the date.
   * @param {boolean} [settings.isMonthPicker] Indicates this is a month picker on the month and week view. Has some slight different behavior.
   * @param {string} [settings.attributes] Add extra attributes like id's to the element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var DATEPICKER_DEFAULTS = {
    showTime: false,
    useCurrentTime: false,
    timeFormat: undefined,
    minuteInterval: undefined,
    secondInterval: undefined,
    mode: undefined,
    roundToInterval: undefined,
    dateFormat: 'locale',
    // or can be a specific format
    placeholder: false,
    firstDayOfWeek: 0,
    disable: {
      callback: null,
      dates: [],
      years: [],
      minDate: '',
      maxDate: '',
      dayOfWeek: [],
      isEnable: false,
      restrictMonths: false
    },
    showLegend: false,
    showMonthYearPicker: true,
    hideDays: false,
    yearsAhead: 5,
    yearsBack: 4,
    legend: [// Legend Build up exampleazure07
    {
      name: 'Public Holiday',
      color: 'azure06',
      dates: []
    }, {
      name: 'Weekends',
      color: 'turquoise06',
      dayOfWeek: []
    }],
    range: {
      useRange: false,
      // true - if datepicker using range dates
      start: '',
      // Start date '03/05/2018'
      end: '',
      // End date '03/21/2018'
      separator: ' - ',
      // separator string between two dates
      minDays: 0,
      // Minimum days
      maxDays: 0,
      // Maximum days
      selectForward: false,
      // Only in forward direction
      selectBackward: false,
      // Only in backward direction
      includeDisabled: false,
      // if true range will include disable dates in it
      selectWeek: false // if true will act as a week picker

    },
    calendarName: null,
    locale: null,
    language: null,
    useUTC: false,
    hideButtons: false,
    showToday: true,
    onOpenCalendar: null,
    isMonthPicker: false,
    attributes: null
  };

  function DatePicker(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, DATEPICKER_DEFAULTS);
    this.init();
  } // Plugin Methods


  DatePicker.prototype = {
    init: function init() {
      this.build();
      this.handleEvents();
    },

    /**
     * Add markup
     * @private
     * @returns {void}
     */
    build: function build() {
      // Add "is-disabled" css class to closest ".field" if element is disabled
      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      this.element.attr('autocomplete', 'off'); // Append a trigger button

      if (this.element.next().is('svg')) {
        this.trigger = this.element.next();
      } else {
        this.trigger = $.createIconElement('calendar').insertAfter(this.element);
      } // Hide icon if datepicker input is hidden


      if (this.element.hasClass('hidden')) {
        this.trigger.addClass('hidden');
      } // Enable classes and settings for week selection


      if (this.settings.range.selectWeek) {
        this.settings.selectForward = true;
        this.settings.minDays = 6;
        this.settings.maxDays = 7;
      } // Set the current calendar


      this.setLocale();
      this.addAria();

      if (!this.settings.locale && !this.settings.language) {
        this.setCurrentCalendar();
      }
    },

    /**
     * Set current locale to be used.
     * @private
     * @returns {void}
     */
    setLocale: function setLocale() {
      var _this = this;

      var s = this.settings;
      this.locale = Locale.currentLocale;

      if (this.settings.language) {
        Locale.getLocale(this.settings.language);
        this.language = this.settings.language;
      } else {
        this.language = Locale.currentLanguage.name;
      }

      if (s.locale) {
        Locale.getLocale(s.locale).done(function (locale) {
          var similarApi = _this.getSimilarApi('locale', locale);

          similarApi.forEach(function (api) {
            api.locale = Locale.cultures[locale];
            api.language = _this.settings.language || api.locale.language;
            api.setCurrentCalendar();
          });

          if (similarApi.length === 0) {
            _this.locale = Locale.cultures[locale];
            _this.language = _this.settings.language || _this.locale.language;

            _this.setCurrentCalendar();
          }
        });
      }

      if (s.language) {
        Locale.getLocale(s.language).done(function () {
          var similarApi = _this.getSimilarApi('language', s.language);

          similarApi.forEach(function (api) {
            api.language = s.language;
          });
        });
      }
    },

    /**
     * Get list of similar api elements.
     * @private
     * @param {string} key to check
     * @param {string} value to check
     * @returns {array} list of api elements
     */
    getSimilarApi: function getSimilarApi(key, value) {
      var elems = [].slice.call(document.querySelectorAll('.datepicker'));
      var similarApi = [];
      elems.forEach(function (node) {
        var datepickerApi = $(node).data('datepicker');

        if (datepickerApi && datepickerApi.settings[key] === value) {
          similarApi.push(datepickerApi);
        }
      });
      return similarApi;
    },

    /**
     * Sets current calendar information.
     * @private
     * @returns {void}
     */
    setCurrentCalendar: function setCurrentCalendar() {
      this.currentCalendar = Locale.calendar(this.settings.locale || this.locale.name, this.settings.language, this.settings.calendarName);
      this.isIslamic = this.currentCalendar.name === 'islamic-umalqura';
      this.isRTL = (this.locale.direction || this.locale.data.direction) === 'right-to-left';
      this.isFullMonth = this.settings.dateFormat.indexOf('MMMM') > -1;
      this.setFormat();
      this.mask();
    },

    /**
     * Add aria
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      this.label = $("label[for=\"".concat(this.element.attr('id'), "\"]"));
      this.label.append("<span class=\"audible\">".concat(Locale.translate('PressDown', {
        locale: this.locale.name,
        language: this.language
      }), "</span>"));
    },

    /**
     * Handle Keyboard Stuff
     * @private
     * @param {object} elem to handle.
     * @returns {void}
     */
    handleKeys: function handleKeys(elem) {
      var _this2 = this;

      var s = this.settings; // Handle Tab key while popup is open - the rest is handled in monthview.js now

      if (elem.is('#monthview-popup')) {
        elem.off('keydown.datepicker').on('keydown.datepicker', '.monthview-table, .monthview-monthyear-pane', function (e) {
          var handled = false;
          var key = e.keyCode || e.charCode || 0; // Tab closes Date Picker and goes to next field on the modal

          if (key === 9) {
            _this2.containFocus(e);

            handled = true;
          } // Esc closes Date Picker and goes back to field


          if (key === 27) {
            _this2.closeCalendar();

            _this2.element.focus();

            e.stopImmediatePropagation();
            handled = true;
          } // 't' selects today


          if (key === 84) {
            _this2.closeCalendar();

            _this2.element.focus();

            handled = true;
          }

          if (handled) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }

          return true;
        });
        elem.off('keydown.datepicker-tab').on('keydown.datepicker-tab', 'td, input, div.dropdown, button', function (e) {
          var key = e.keyCode || e.charCode || 0; // Tab closes Date Picker and goes to next field on the modal

          if (key === 9) {
            if (s.range.useRange && $(e.target).is('.next') && !s.range.selectWeek) {
              _this2.calendarAPI.days.find('td:visible:last').attr('tabindex', 0).focus();
            } else {
              _this2.containFocus(e);
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }

          return true;
        });
        return;
      } // Handle keys on the input field


      elem.off('keydown.datepicker').on('keydown.datepicker', function (e) {
        var _this2$settings, _this2$settings$dateF;

        var handled = false;
        var key = e.keyCode || e.charCode || 0;
        var hasMinusPattern = ((_this2$settings = _this2.settings) === null || _this2$settings === void 0 ? void 0 : (_this2$settings$dateF = _this2$settings == null ? void 0 : _this2$settings.dateFormat) === null || _this2$settings$dateF === void 0 ? void 0 : _this2$settings$dateF == null ? void 0 : _this2$settings$dateF.indexOf('-')) > -1; // Arrow Down or Alt first opens the dialog

        if (key === 40 && !_this2.isOpen()) {
          handled = true;

          _this2.openCalendar();

          setTimeout(function () {
            _this2.setFocusAfterOpen();
          }, 200);
        } // 't' selects today


        if (key === 84) {
          handled = true;

          _this2.setToday();
        } // '-' decrements day


        if (key === 189 && !e.shiftKey && !hasMinusPattern) {
          handled = true;

          _this2.adjustDay(false);
        } // '+' increments day


        if (key === 187 && e.shiftKey && !hasMinusPattern) {
          handled = true;

          _this2.adjustDay(true);
        }

        if (handled) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        return true;
      });
    },

    /**
     * Focus the next prev focusable element on the popup
     * @private
     * @param {object} e event.
     * @returns {void}
     */
    containFocus: function containFocus(e) {
      var reverse = e.shiftKey; // Set focus on (opt: next|prev) focusable element

      var focusables = this.popup.find(':focusable');
      var target = $(e.currentTarget);
      var isMonthViewPane = target.is('.monthview-monthyear-pane, #btn-monthyear-pane') || target.closest('.is-monthyear.is-monthonly').length > 0;

      if (isMonthViewPane) {
        focusables = this.popup.find(':focusable').not('td').not('.picklist-item a').add('.picklist-item.is-selected a:visible, .picklist-item.up a:visible, .picklist-item.down a:visible');
      }

      var index = focusables.index($(':focus'));

      if (!reverse) {
        index = index + 1 >= focusables.length ? 0 : index + 1;
      } else {
        index = index - 1 < 0 ? focusables.length - 1 : index - 1;
      }

      var elem = focusables.eq(index);
      elem.focus();
    },

    /**
     * Parse the Date Format Options
     * @private
     * @returns {void}
     */
    setFormat: function setFormat() {
      var s = this.settings;
      var localeDateFormat = _typeof(Locale) === 'object' && this.currentCalendar.dateFormat ? this.currentCalendar.dateFormat : null;
      var localeTimeFormat = _typeof(Locale) === 'object' && this.currentCalendar.timeFormat ? this.currentCalendar.timeFormat : null;

      if (_typeof(Locale) === 'object' && this.settings.calendarName) {
        localeDateFormat = Locale.calendar(this.settings.locale, this.settings.language, this.settings.calendarName).dateFormat;
        localeTimeFormat = Locale.calendar(this.settings.locale, this.settings.language, this.settings.calendarName).timeFormat;
      }

      if (_typeof(localeDateFormat) === 'object' && localeDateFormat.short !== undefined) {
        localeDateFormat = localeDateFormat.short;
      }

      if (s.dateFormat === 'locale') {
        this.pattern = localeDateFormat + (s.showTime ? " ".concat(s.timeFormat || localeTimeFormat) : '');
        s.dateFormat = this.pattern;
      } else {
        this.pattern = s.dateFormat + (s.showTime && s.timeFormat ? " ".concat(s.timeFormat) : '');
      }

      this.show24Hours = (this.pattern.match('H') || []).length > 0;
      this.isSeconds = (this.pattern.match('ss') || []).length > 0;
    },

    /**
     * Add masking with the mask function
     * @private
     * @returns {void}
     */
    mask: function mask() {
      this.setFormat();
      var s = this.settings;
      var maskOptions = {
        process: 'date',
        keepCharacterPositions: true,
        patternOptions: {
          format: this.pattern
        }
      };
      var validation = 'date availableDate';
      var events = {
        date: 'change blur enter',
        availableDate: 'change blur'
      };

      if (s.range.useRange) {
        maskOptions.process = 'rangeDate';
        maskOptions.patternOptions.delimeter = s.range.separator;
        validation = 'rangeDate';
        events = {
          rangeDate: 'change blur'
        };
      }

      maskOptions.processOnInitialize = false;

      if (this.isFullMonth) {
        this.pattern = this.settings.dateFormat;
      } else if (this.element.data('mask') === undefined) {
        this.element.mask(maskOptions);
      }

      this.addedValidation = false;

      if (this.element[0] && this.element[0].getAttribute && !this.element[0].getAttribute('data-validate')) {
        this.addedValidation = true;
        this.element.attr({
          'data-validate': validation,
          'data-validation-events': JSON.stringify(events)
        }).validate();
      }

      this.setPlaceholder();
    },

    /**
     * Set placeholder
     * @private
     * @returns {void}
     */
    setPlaceholder: function setPlaceholder() {
      var _this3 = this;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this3.pattern,
          locale: _this3.locale.name
        });
      };

      var s = this.settings;
      var placeholder = this.pattern;

      if (s.placeholder && (!this.element.attr('placeholder') || this.element.attr('placeholder') === 'M / D / YYYY')) {
        if (s.range.useRange) {
          placeholder = s.range.first && s.range.first.date ? formatDate(s.range.first.date) + s.range.separator + this.pattern : this.pattern + s.range.separator + this.pattern;
        }

        this.element[0].setAttribute('placeholder', placeholder);
      }
    },

    /**
     * Check if the calendar div is open or not
     * @private
     * @returns {boolean} whether or not the calendar div is open.
     */
    isOpen: function isOpen() {
      return this.popup && this.popup.is(':visible') && !this.popup.hasClass('is-hidden');
    },

    /**
     * Open the calendar in a popup
     * @private
     * @returns {void}
     */
    openCalendar: function openCalendar() {
      var _this4 = this;

      var self = this;
      var s = this.settings;
      var timeOptions = {};

      if ((this.element.is(':disabled') || this.element.attr('readonly')) && this.element.closest('.monthview').length === 0) {
        return;
      }

      $('#validation-tooltip').addClass('is-hidden');
      /**
      * Fires as the calendar popup is opened.
      * @event listopened
      * @memberof DatePicker
      * @property {object} event - The jquery event object
      */

      this.element.addClass('is-active is-open').trigger('listopened');
      this.timepickerContainer = $('<div class="datepicker-time-container"></div>');
      var clearButton = "<button type=\"button\" class=\"is-cancel btn-tertiary\">\n      ".concat(Locale.translate(this.settings.isMonthPicker ? 'Cancel' : 'Clear', {
        locale: this.locale.name,
        language: this.language
      }), "\n    </button>");
      var applyButton = " <button type=\"button\" class=\"is-select btn-primary\">\n      ".concat(Locale.translate('Apply', {
        locale: this.locale.name,
        language: this.language
      }), "\n    </button>");
      this.footer = $('' + "<div class=\"popup-footer\">\n        ".concat(this.isRTL ? applyButton + clearButton : clearButton + applyButton, "\n      </div>"));

      if (s.hideDays) {
        this.footer = $('' + "<div class=\"popup-footer\">\n          <button type=\"button\" class=\"is-cancel btn-tertiary\">\n            ".concat(Locale.translate('Clear', {
          locale: this.locale.name,
          language: this.language
        }), "\n          </button>\n          <button type=\"button\" class=\"is-select-month btn-primary\">\n            ").concat(Locale.translate('Apply', {
          locale: this.locale.name,
          language: this.language
        }), "\n          </button>\n        </div>"));
      }

      if (s.hideButtons) {
        this.footer = $('');
      } // Timepicker options


      if (s.showTime) {
        if (s.timeFormat === undefined) {
          // Getting time-format from date-format (dateFormat: 'M/d/yyyy HH:mm:ss')
          timeOptions.timeFormat = this.pattern.slice(this.pattern.indexOf(' ')).trim();
        } else {
          timeOptions.timeFormat = s.timeFormat;
        }

        if (s.minuteInterval !== undefined) {
          timeOptions.minuteInterval = s.minuteInterval;
        }

        if (s.secondInterval !== undefined) {
          timeOptions.secondInterval = s.minuteInterval;
        }

        if (s.mode !== undefined) {
          timeOptions.mode = s.mode;
        }

        if (s.roundToInterval !== undefined) {
          timeOptions.roundToInterval = s.roundToInterval;
        }
      }

      this.calendarContainer = $('<div class="monthview-container"></div>'); // Show Month

      this.setValueFromField(); // Set timepicker

      if (this.settings.showTime) {
        // Set to 12:00
        if (this.element.val() === '' && this.currentDate && this.currentDate.getDate() && !this.settings.useCurrentTime) {
          this.currentDate.setHours(0);
          this.currentDate.setMinutes(0);
          this.currentDate.setSeconds(0);
        }

        var timeFormat = this.settings.timeFormat ? this.settings.timeFormat : null;

        if (!timeFormat) {
          timeFormat = this.isSeconds ? this.currentCalendar.dateFormat.timestamp : this.currentCalendar.dateFormat.hour;
        }

        timeOptions.parentElement = this.timepickerContainer;
        timeOptions.locale = this.settings.locale;
        timeOptions.language = this.settings.language;
        this.time = Locale.formatDate(this.currentDate, {
          pattern: timeFormat,
          locale: this.locale.name,
          language: this.language
        });
        this.timepicker = this.timepickerContainer.timepicker(timeOptions).data('timepicker');
        this.setUseCurrentTime();
        this.timepickerContainer.find('.dropdown').dropdown();
        this.timepickerContainer.on('change.datepicker', function () {
          _this4.currentDate = _this4.setTime(_this4.currentDate);

          _this4.setValue(_this4.currentDate, true, true);
        }); // Wait for timepicker to initialize

        setTimeout(function () {
          _this4.timepicker.initValues = _this4.timepicker.getTimeFromField(_this4.time);

          _this4.timepicker.afterShow(_this4.timepickerContainer);

          return; // eslint-disable-line
        }, 1);
      }

      this.todayDate = new Date();
      this.todayMonth = this.todayDate.getMonth();
      this.todayYear = this.todayDate.getFullYear();
      this.todayDay = this.todayDate.getDate();

      if (this.isIslamic) {
        this.todayDateIslamic = Locale.gregorianToUmalqura(this.todayDate);
        this.todayYear = this.todayDateIslamic[0];
        this.todayMonth = this.todayDateIslamic[1];
        this.todayDay = this.todayDateIslamic[2];
      }

      this.settings.year = this.currentYear;
      this.settings.month = this.currentMonth;

      if (this.isIslamic) {
        this.settings.activeDateIslamic = this.activeDate instanceof Date ? Locale.gregorianToUmalqura(this.activeDate) : this.activeDate;
      }

      if (this.settings.onOpenCalendar) {
        // In some cases, month picker wants to set a specifc time.
        this.settings.activeDate = this.settings.onOpenCalendar();

        if (this.isIslamic) {
          this.settings.activeDateIslamic = Locale.gregorianToUmalqura(this.settings.activeDate);
          this.settings.year = this.settings.activeDateIslamic[0];
          this.settings.month = this.settings.activeDateIslamic[1];
        } else {
          this.settings.year = this.settings.activeDate.getFullYear();
          this.settings.month = this.settings.activeDate.getMonth();
        }
      } else {
        this.settings.activeDate = this.currentDate || this.todayDate;
        this.settings.activeDateIslamic = this.currentDateIslamic || this.todayDateIslamic;
      }

      this.settings.isPopup = true;
      this.settings.headerStyle = 'simple'; // Handle day change

      this.settings.onSelected = function (node, args) {
        _this4.currentDate = new Date(args.year, args.month, args.day);

        if (self.settings.range.useRange && self.settings.range.first && self.settings.range.selectWeek) {
          var first = dateUtils.firstDayOfWeek(new Date(), _this4.settings.firstDayOfWeek);
          var last = dateUtils.lastDayOfWeek(new Date(), _this4.settings.firstDayOfWeek);
          self.settings.range.first = {};
          self.settings.range.second = undefined;
          self.setWeekRange({
            day: first.getDate(),
            month: first.getMonth(),
            year: first.getFullYear()
          }, {
            day: last.getDate(),
            month: last.getMonth(),
            year: last.getFullYear()
          });
          self.closeCalendar();
          self.element.focus();
          return;
        }

        if (self.settings.range.useRange && self.settings.range.first && !self.settings.range.selectWeek) {
          return;
        }

        self.insertDate(_this4.currentDate);

        if (args.close) {
          self.closeCalendar();
          self.element.focus();
        }
      };

      if (this.settings.range.useRange && this.settings.range.selectWeek) {
        this.settings.onKeyDown = function (args) {
          if (args.key === 37 || args.key === 39) {
            return false;
          }

          if (args.key === 38 || args.key === 40) {
            // up and down a week
            // TODO - Later if this is really needed.
            return false;
          }

          if (args.key === 13) {
            // select a week
            // TODO - Later if this is really needed.
            return false;
          }

          return true;
        };
      }

      this.calendarAPI = new MonthView(this.calendarContainer, this.settings);
      this.calendar = this.calendarAPI.element;

      if (s.showTime) {
        this.calendar.addClass('is-timepicker');
      }

      if (s.hideDays) {
        this.calendar.addClass('is-monthyear');

        if (s.dateFormat === 'MMMM' || s.dateFormat === 'MMM' || s.dateFormat === 'MM') {
          this.calendar.addClass('is-monthonly');
        }

        if (s.dateFormat === 'yyyy') {
          this.calendar.addClass('is-yearonly');
        }
      }

      this.calendar.append(s.showTime ? this.timepickerContainer : '', this.footer);
      var placementParent = this.element;
      var placementParentXAlignment = this.isRTL ? 'right' : 'left';
      var parent = this.element.parent();

      if (parent.is('.datagrid-cell-wrapper')) {
        placementParentXAlignment = 'center';
        placementParent = this.element.next('.icon');
      }

      var popoverOpts = {
        content: this.calendar,
        placementOpts: {
          parent: placementParent,
          parentXAlignment: placementParentXAlignment,
          strategies: ['flip', 'nudge', 'shrink']
        },
        placement: 'bottom',
        popover: true,
        trigger: 'immediate',
        extraClass: this.settings.range.selectWeek ? 'monthview-popup is-range-week' : 'monthview-popup',
        tooltipElement: '#monthview-popup',
        initializeContent: false
      };
      this.trigger.popover(popoverOpts).off('show.datepicker').on('show.datepicker', function () {
        // Horizontal view on mobile
        if (window.innerHeight < 400 && _this4.popupClosestScrollable && _this4.popupClosestScrollable.length === 1) {
          _this4.popup.find('.arrow').hide();

          _this4.popup.css({
            'min-height': $('html').hasClass('theme-uplift-light') ? '' : "".concat(_this4.popupClosestScrollable[0].scrollHeight - 521, "px"),
            height: ''
          });

          _this4.popupClosestScrollable.css('min-height', '375px');
        } // Hide calendar until range to be pre selected


        if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
          _this4.popup.addClass('is-hidden');
        }

        if (_this4.settings.hideButtons) {
          _this4.popup.addClass('hide-buttons');
        }

        if (_this4.settings.showMonthYearPicker) {
          _this4.popup.find('.expandable-area').expandablearea({
            animationSpeed: 150,
            trigger: 'btn-monthyear-pane'
          });

          _this4.popup.find('.btn-monthyear-pane').button();
        } // Add range selection for each week


        if (_this4.settings.range.selectWeek) {
          var tableBody = _this4.popup.find('tbody');

          _this4.popup.find('.monthview-table tr').hover(function (e) {
            var tr = $(e.currentTarget);
            tableBody.find('td').removeClass('is-selected range-selection end-date');
            tr.find('td').addClass('range-selection');
          });
        }
      }).off('hide.datepicker').on('hide.datepicker', function () {
        _this4.popupClosestScrollable.add(_this4.popup).css('min-height', '');

        _this4.closeCalendar();
      });
      this.handleKeys($('#monthview-popup'));
      $('.monthview-footer a', this.calendar).button();
      this.popup = $('#monthview-popup');
      this.popupClosestScrollable = this.popup.closest('.scrollable');
      this.popup.attr('role', 'dialog');
      this.originalDate = this.element.val();
      this.calendarAPI.currentDate = this.currentDate;
      this.calendarAPI.currentDateIslamic = this.currentDateIslamic;
      this.calendarAPI.validatePrevNext(); // Calendar Day Events

      this.calendarAPI.days.off('click.datepicker').on('click.datepicker', 'td', function () {
        var td = $(this);

        if (td.hasClass('is-disabled')) {
          self.calendarAPI.activeTabindex(td, true);
        } else {
          if (s.range.useRange && (!s.range.first || s.range.second) && !s.range.selectWeek) {
            self.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected');
          }

          if (s.range.useRange && s.range.selectWeek) {
            var first = self.calendarAPI.getCellDate(self.calendar.find('td.range-selection').first());
            var last = self.calendarAPI.getCellDate(self.calendar.find('td.range-selection').last());
            self.setWeekRange(first, last);
            return;
          }

          if (!s.range.useRange) {
            self.calendarAPI.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected').removeAttr('tabindex');
          }

          var cell = $(this);
          cell.addClass("is-selected".concat(s.range.useRange ? ' range' : '')).attr('aria-selected', 'true');
          self.lastValue = null;
          self.insertSelectedDate(cell);

          if (s.range.useRange) {
            self.isFocusAfterClose = true;
          } else {
            self.closeCalendar();
            self.element.focus();
          }
        }
      }); // Calendar Footer Events

      this.footer.off('click.datepicker').on('click.datepicker', 'button', function (e) {
        var btn = $(this);

        if (btn.hasClass('is-cancel')) {
          /**
          * Fires after the value in the input is changed by any means.
          *
          * @event change
          * @memberof DatePicker
          * @property {object} event - The jquery event object
          */
          if (!self.settings.isMonthPicker) {
            self.element.val('').trigger('change').trigger('input');
            self.currentDate = null;
            self.clearRangeDates();
          }

          self.closeCalendar();
          self.element.focus();
        }

        if (btn.hasClass('is-cancel-month-pane')) {
          self.calendarAPI.monthYearPane.data('expandablearea').close();
        }

        if (btn.hasClass('is-select-month') || btn.hasClass('is-select-month-pane')) {
          var year = parseInt(self.calendarAPI.monthYearPane.find('.is-year .is-selected a').attr('data-year'), 10);
          var month = parseInt(self.calendarAPI.monthYearPane.find('.is-month .is-selected a').attr('data-month'), 10);
          var day = 1;
          self.currentDate = new Date(year, month, day);

          if (self.isIslamic) {
            self.currentDateIslamic[0] = year;
            self.currentDateIslamic[1] = month;
            self.currentDateIslamic[2] = day;
            self.currentYear = year;
            self.currentMonth = month;
            self.currentDay = day;
            self.currentDate = Locale.umalquraToGregorian(year, month, day);
          }

          if (s.range.useRange) {
            self.isFocusAfterClose = false;
          } else if (btn.hasClass('is-select-month')) {
            self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
            self.closeCalendar();
          }

          if (btn.hasClass('is-select-month-pane')) {
            self.calendarAPI.showMonth(month, year);
          }
        }

        if (btn.hasClass('is-select')) {
          var status = self.calendarAPI.setRangeSelByClick();

          if (status === 1) {
            self.closeCalendar();
          } else if (status === 2) {
            self.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
            self.closeCalendar();
          } else if (status === 3) {
            e.preventDefault();
            return;
          } else {
            self.insertSelectedDate();
            self.closeCalendar();
          }

          if (!btn.hasClass('is-select-month-pane')) {
            self.element.focus();
          }
        }

        e.preventDefault();

        if (btn.hasClass('is-select-month-pane')) {
          self.calendarAPI.monthYearPane.data('expandablearea').close();
          self.popup.find('.btn-primary.is-select').focus();
        }
      });
      this.popup.off('click.datepicker-today').on('click.datepicker-today', '.hyperlink.today', function (e) {
        e.preventDefault();

        if (s.range.useRange) {
          self.setToday(true);

          if (!s.range.second || s.range.second && !s.range.second.date) {
            e.preventDefault();
          }
        } else {
          self.setToday();
          self.closeCalendar();
        }
      });
      setTimeout(function () {
        utils.addAttributes(_this4.popup.find('.btn-monthyear-pane'), _this4, _this4.settings.attributes, 'btn-monthyear');
        utils.addAttributes(_this4.popup.find('.is-cancel'), _this4, _this4.settings.attributes, 'btn-cancel');
        utils.addAttributes(_this4.popup.find('.is-select'), _this4, _this4.settings.attributes, 'btn-select');
        self.calendarAPI.validatePrevNext();
        self.setFocusAfterOpen();
      }, 50);
    },

    /**
     * Set time picker options for `useCurrentTime` setting.
     * @private
     * @returns {void}
     */
    setUseCurrentTime: function setUseCurrentTime() {
      if (this.settings.useCurrentTime && this.timepicker.minuteSelect.length) {
        var isSeconds = this.isSeconds && this.timepicker.secondSelect.length;

        var leadingZero = function leadingZero(n) {
          return (n < 10 ? '0' : '') + n;
        };

        var setOption = function setOption(elem, value) {
          if (!elem.find("option:contains(".concat(value, ")")).length) {
            elem.find('option:selected').prop('selected', false);
            elem.prepend($("<option selected >".concat(value, "</option>")));
          }
        };

        var d = new Date();
        setOption(this.timepicker.minuteSelect, leadingZero(d.getMinutes()));

        if (isSeconds) {
          setOption(this.timepicker.secondSelect, leadingZero(d.getSeconds()));
        }

        if (typeof this.time === 'string' && this.time !== '' && this.currentDate && this.currentDate.getDate()) {
          setOption(this.timepicker.minuteSelect, leadingZero(this.currentDate.getMinutes()));

          if (isSeconds) {
            setOption(this.timepicker.secondSelect, leadingZero(this.currentDate.getSeconds()));
          }
        }
      }
    },

    /**
     * Clear the dates in settings range object.
     * @private
     * @returns {void}
     */
    clearRangeDates: function clearRangeDates() {
      var s = this.settings;

      if (s.range.useRange) {
        s.range.start = DATEPICKER_DEFAULTS.range.start;
        s.range.end = DATEPICKER_DEFAULTS.range.end;

        if (s.range.data) {
          delete s.range.data;
        }
      }
    },

    /**
     * Inserts the currently selected (higlighted in azure) date.
     * @private
     * @param {object} cell The cell to check otherwise the selected cell is used.
     * @returns {void}
     */
    insertSelectedDate: function insertSelectedDate(cell) {
      var self = this;
      var cellDate = self.calendarAPI.getCellDate(cell || self.calendar.find('td.is-selected').last());
      var day = cellDate.day;
      var month = cellDate.month;
      var year = cellDate.year;
      self.currentDate = new Date(year, month, day);

      if (self.isIslamic) {
        self.currentDateIslamic[0] = year;
        self.currentDateIslamic[1] = month;
        self.currentDateIslamic[2] = day;
        self.currentYear = year;
        self.currentMonth = month;
        self.currentDay = day;
        self.currentDate = Locale.umalquraToGregorian(year, month, day);
      }

      self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
    },

    /**
     * Inserts a week range in the field.
     * @private
     * @param {object} first The first range object.
     * @param {object} last The last range object.
     * @returns {void}
     */
    setWeekRange: function setWeekRange(first, last) {
      var s = this.settings;
      s.range.first.date = new Date(first.year, first.month, first.day);
      s.range.second = undefined;
      this.setValue(new Date(last.year, last.month, last.day));
      this.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected');
    },

    /**
     * Close the calendar popup.
     * This method is slated to be removed in a future v4.15.0 or v5.0.0.
     * @deprecated as of v4.9.0. Please use `closeCalendar()` instead.
     * @returns {void}
     */
    close: function close() {
      return deprecateMethod(this.closeCalendar, this.close).apply(this);
    },

    /**
     * Close the calendar in a popup
     * @private
     * @returns {void}
     */
    closeCalendar: function closeCalendar() {
      // Remove range entries
      var cell = this.calendarAPI && this.calendarAPI.days.length ? this.calendarAPI.days.find('td.is-selected') : null;
      this.resetRange({
        cell: cell
      }); // Close timepicker

      if (this.settings.showTime && this.timepickerControl && this.timepickerControl.isOpen()) {
        this.timepickerControl.closeTimePopup();
      }

      if (this.popup && this.popup.length) {
        this.popup.hide().remove();
      }

      var popoverAPI = this.trigger.data('tooltip');

      if (popoverAPI) {
        popoverAPI.destroy();
      }

      if (this.calendarAPI) {
        delete this.calendarAPI.datepickerApi;
      }

      if (this.element.hasClass('is-active')) {
        /**
        * Fires as the calendar popup is closed.
        *
        * @event listclosed
        * @memberof DatePicker
        * @property {object} event - The jquery event object
        */
        this.element.trigger('listclosed');
        this.element.removeClass('is-active is-open');
      }
    },

    /**
     * Set focus after opening the calendar
     * @private
     * @returns {void}
     */
    setFocusAfterOpen: function setFocusAfterOpen() {
      var s = this.settings;

      if (!this.calendar) {
        return;
      }

      if (s.range.useRange) {
        if (s.range.first && s.range.first.label && (!s.range.second || s.range.second && !s.range.second.date)) {
          this.setRangeFirstPart(s.range.first.date);
        }

        this.calendarAPI.setRangeSelected();

        if (s.range.second && s.range.first.date && s.range.second.date) {
          this.element.val(this.getRangeValue());
        } // Pre selection compleated now show the calendar


        this.popup.removeClass('is-hidden');
      }

      this.calendarAPI.datepickerApi = this;

      if (s.range.useRange && s.range.selectWeek) {
        var tr = this.calendar.find('td.is-selected').first().parent();
        this.calendar.find('td[tabindex]').removeAttr('tabindex');
        tr.attr('tabindex', '0').focus();
        return;
      }

      this.calendarAPI.activeTabindex(this.calendar.find('td.is-selected'), true);
    },

    /**
     * Set range first part
     * @private
     * @param {object} date .
     * @returns {void}
     */
    setRangeFirstPart: function setRangeFirstPart(date) {
      var s = this.settings;

      var dateObj = function dateObj(d) {
        return new Date(d.year, d.month, d.day);
      };

      var minCell = this.calendarAPI.days.find('td:visible:first');
      var maxCell = this.calendarAPI.days.find('td:visible:last');
      var key = this.isIslamic ? stringUtils.padDate(date[0], date[1], date[2]) : stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
      var cell = this.calendarAPI.days.find("[data-key=\"".concat(key, "\"]"));
      var row = cell.closest('tr');

      if (this.isIslamic) {
        this.currentDate = Locale.umalquraToGregorian(date[0], date[1], date[2], date[3], date[4], date[5], date[6]);
        this.currentDateIslamic = date;
      } else {
        this.currentDate = date;
      }

      var min = this.calendarAPI.getCellDate(minCell);
      var max = this.calendarAPI.getCellDate(maxCell);
      s.range.first = {
        date: this.isIslamic ? _toConsumableArray(date) : date,
        cell: cell,
        row: row,
        rowIdx: row.index(),
        cellIdx: cell.index()
      };
      s.range.extra = {
        minCell: minCell,
        maxCell: maxCell,
        min: this.isIslamic ? [min.year, min.month, min.day] : dateObj(min),
        max: this.isIslamic ? [max.year, max.month, max.day] : dateObj(max),
        cellLength: row.children('td').length
      };
      this.calendarAPI.settings.range.first = s.range.first;
      this.calendarAPI.settings.range.extra = s.range.extra;
    },

    /**
     * Put the date in the field and select on the calendar
     * @private
     * @param {object} date .
     * @param {boolean} isReset .
     * @returns {void}
     */
    insertDate: function insertDate(date, isReset) {
      var s = this.settings;
      var year = '';
      var month = '';
      var day = '';

      if (date instanceof Array) {
        year = date[0];
        month = date[1];
        day = date[2].toString();
      } else if (date instanceof Date && !isNaN(this.getTime(date))) {
        year = date.getFullYear();
        month = date.getMonth();
        day = date.getDate().toString();
      } else {
        return;
      } // Make sure Calendar is showing that month


      if (this.calendarAPI.currentMonth !== month || this.calendarAPI.currentYear !== year) {
        this.calendarAPI.showMonth(month, year);
      }

      if (!this.isOpen()) {
        return;
      } // Show the Date in the UI


      var dateTd = this.calendarAPI.days.find('td:not(.alternate)').filter(function () {
        return $(this).text().toLowerCase() === day;
      });

      if (dateTd.hasClass('is-disabled')) {
        this.calendarAPI.activeTabindex(dateTd, true);
      } else {
        if (this.settings.showTime) {
          if (isReset) {
            this.time = Locale.formatDate(date, {
              pattern: this.currentCalendar.dateFormat.hour,
              locale: this.locale.name,
              language: this.language
            });

            if (this.settings.roundToInterval) {
              $('#timepicker-minutes').val('');
              date = this.setTime(date);
            }
          } else {
            date = this.setTime(date);
          }
        }

        this.setValue(date, true);

        if (s.range.useRange) {
          this.calendarAPI.days.find('.is-selected').removeAttr('aria-selected').removeAttr('tabindex');
        } else {
          this.calendarAPI.days.find('.is-selected').removeClass('is-selected range').removeAttr('aria-selected').removeAttr('tabindex');
        }

        dateTd.addClass("is-selected".concat(s.range.useRange ? ' range' : '')).attr({
          'aria-selected': true
        });
        this.calendarAPI.activeTabindex(dateTd, true);
      }
    },

    /**
     * Set the Formatted value in the input
     * @private
     * @param {object|string} date The date to set in date format or a valid datestring
     * @param {boolean} trigger If true will trigger the change event.
     * @param {boolean} isTime will pass to set range.
     * @returns {void}
     */
    setValue: function setValue(date, trigger, isTime) {
      var s = this.settings;
      this.currentDate = date;

      if (date instanceof Array) {
        this.currentDateIslamic = date;
        this.currentDate = Locale.umalquraToGregorian(date[0], date[1], date[2], date[3], date[4], date[5]);
      }

      if (s.range.useRange) {
        if (!isTime) {
          this.setRangeToElem(date, false);
        }
      } else {
        this.element.val(Locale.formatDate(date, {
          pattern: this.pattern,
          locale: this.locale.name
        }));
      }

      if (trigger) {
        if (s.range.useRange) {
          if (!isTime) {
            this.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
          }
        } else {
          this.element.trigger('change').trigger('input');
        }
      }
    },

    /**
      * Get a unqiue and comparable time from the date.
      * @param  {[type]} date [description]
      * @returns {string} comparable time string
      */
    getTime: function getTime(date) {
      return Array.isArray(date) ? date.join('') : date.getTime();
    },

    /**
     * Set range value to element
     * @private
     * @param {object} date .
     * @param {boolean} isSingleDate .
     * @returns {void}
     */
    setRangeToElem: function setRangeToElem(date, isSingleDate) {
      var _this5 = this;

      var s = this.settings;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this5.pattern,
          locale: _this5.locale.name
        });
      };

      var value = formatDate(date);
      var handled = false; // Closed calendar

      if (!this.isOpen()) {
        if (!isSingleDate) {
          handled = true;
          var d = date || new Date();
          this.currentMonth = d.getMonth();
          this.currentYear = d.getFullYear();
          this.currentDay = d.getDate();
          this.currentDate = d;
          s.range.first = s.range.first || {};
          s.range.second = s.range.second || {};
          s.range.first.date = d;
          s.range.second.date = d;
          value = this.getRangeValue();
        }
      } else {
        // Opened calendar
        var key = this.isIslamic ? stringUtils.padDate(date[0], date[1], date[2]) : stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
        var cell = this.calendarAPI.days.find("[data-key=\"".concat(key, "\"]"));
        var row = cell.closest('tr');

        if (s.range.second) {
          if (!s.range.second.date) {
            delete s.range.second.date;

            if ($.isEmptyObject(s.range.second)) {
              delete s.range.second;
            }
          } else {
            this.resetRange({
              cell: cell
            });
          }
        }

        var time = {};

        if (s.range.first) {
          time.date = this.getTime(date);
          time.firstdate = this.getTime(s.range.first.date);
          time.min = this.calendarAPI.getDifferenceToDate(s.range.first.date, s.range.minDays);
          time.max = this.calendarAPI.getDifferenceToDate(s.range.first.date, s.range.maxDays);
        }

        if (!s.range.first || isSingleDate) {
          this.setRangeFirstPart(date);
          value = this.getRangeValue();
          this.setPlaceholder();
        } else if (!s.range.second && s.range.selectBackward && time.date > time.firstdate || s.range.selectForward && time.date < time.firstdate || s.range.maxDays > 0 && time.date > time.max.aftertime || time.date < time.max.beforetime) {
          this.resetRange({
            cell: cell
          });
          this.setRangeFirstPart(date);
          value = this.getRangeValue();
          this.setPlaceholder();
        } else {
          // Set second part for range
          handled = true;

          if (this.isIslamic) {
            this.currentDate = Locale.umalquraToGregorian(date[0], date[1], date[2], date[3], date[4], date[5], date[6]);
            this.currentDateIslamic = date;
          } else {
            this.currentDate = date;
          } // minDays


          if (s.range.minDays > 0) {
            if (time.date >= time.firstdate && time.date < time.min.aftertime) {
              date = time.min.after;

              if (time.date === time.firstdate) {
                time.date = this.getTime(date);
              }
            } else if (time.date < time.firstdate && time.date > time.min.beforetime) {
              date = time.min.before;
            }

            key = this.isIslamic ? stringUtils.padDate(date[0], date[1], date[2]) : stringUtils.padDate(date.getFullYear(), date.getMonth(), date.getDate());
            cell = this.calendarAPI.days.find("[data-key=\"".concat(key, "\"]"));
            row = cell.closest('tr');
          }

          if (time.date > time.firstdate) {
            s.range.second = {
              date: date,
              cell: cell,
              row: row,
              rowIdx: row.index(),
              cellIdx: cell.index()
            };
          } else {
            s.range.second = s.range.first;
            s.range.first = {
              date: date,
              cell: cell,
              row: row,
              rowIdx: row.index(),
              cellIdx: cell.index()
            };
          }

          value = this.getRangeValue();
        }
      } // Set range value(first only or both parts) on element


      this.element.val(value); // Set data to use in triggerHandler

      if (!handled) {
        s.range.data = {
          value: value,
          dates: [s.range.first.date],
          startDate: s.range.first.date,
          start: formatDate(s.range.first.date)
        };
      } else {
        s.range.data = {
          value: value,
          dates: !this.calendarAPI ? [s.range.first.date] : this.calendarAPI.getDateRange(s.range.first.date, s.range.second.date),
          startDate: s.range.first.date,
          start: formatDate(s.range.first.date),
          endDate: s.range.second.date,
          end: formatDate(s.range.second.date)
        };
        this.closeCalendar();

        if (this.isFocusAfterClose) {
          delete this.isFocusAfterClose;
          this.element.focus();
        }
      }
    },

    /**
     * Reset range values
     * @private
     * @param {object} options cell: to keep selection, isData: to delete the data
     * @returns {void}
     */
    resetRange: function resetRange(options) {
      options = options || {};

      if (this.settings.range.useRange) {
        delete this.settings.range.first;
        delete this.settings.range.second;
        delete this.settings.range.extra;

        if (options.isData) {
          delete this.settings.range.data;
        }

        if (this.calendarAPI) {
          delete this.calendarAPI.settings.range.first;
          delete this.calendarAPI.settings.range.second;
          delete this.calendarAPI.settings.range.extra;

          if (options.isData) {
            delete this.calendarAPI.settings.range.data;
          }
        }

        if (this.calendarAPI && this.calendarAPI.days.length) {
          this.calendarAPI.days.find('td').removeClass('range range-next range-prev range-selection end-date is-selected');
        }

        if (options.cell) {
          options.cell.addClass('is-selected');
        }
      }
    },

    /**
     * Set the range value from the field
     * @private
     * @returns {void}
     */
    setRangeValueFromField: function setRangeValueFromField() {
      var _this6 = this;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this6.pattern,
          locale: _this6.locale.name
        });
      };

      var parseDate = function parseDate(d) {
        return Locale.parseDate(d, {
          pattern: _this6.pattern,
          locale: _this6.locale.name
        }, false);
      };

      var getDateTime = function getDateTime(d) {
        return d && typeof d.getTime === 'function' ? d : new Date();
      };

      var alignDates = function alignDates(dates) {
        var d1 = parseDate(dates[0]);
        var d2 = parseDate(dates[1]);
        var isAlreadyIslamic = _this6.isIslamic && Array.isArray(d1);

        if (!isAlreadyIslamic) {
          d1 = Locale.gregorianToUmalqura(new Date(dates[0]));
          d2 = Locale.gregorianToUmalqura(new Date(dates[1]));
        }

        if (d1 && d2) {
          d1 = _this6.getTime(getDateTime(d1));
          d2 = _this6.getTime(getDateTime(d2));

          if (_this6.isIslamic && !isAlreadyIslamic) {
            dates[0] = Locale.gregorianToUmalqura(new Date(dates[0]));
            dates[1] = Locale.gregorianToUmalqura(new Date(dates[1]));
          }

          return d1 > d2 ? [dates[1], dates[0]] : [dates[0], dates[1]];
        }

        return dates;
      };

      var s = this.settings;
      var field = {};
      field.value = s.range.value || this.element.val().trim();
      field.isEmpty = field.value === ''; // Field value dates

      if (!field.isEmpty && field.value.indexOf(s.range.separator) > -1) {
        field.dates = alignDates(field.value.split(s.range.separator));
      } else if (!field.isEmpty && field.value.indexOf(s.range.separator.slice(0, -1)) > -1) {
        field.dates = field.value.split(s.range.separator.slice(0, -1));
      } else if (!field.isEmpty && field.value.indexOf(s.range.separator) === -1) {
        field.dates = [formatDate(field.value)];
      } // Start/End dates


      if (!s.range.data && s.range.start && s.range.end && field.isEmpty) {
        var dates;

        if (typeof s.range.start === 'string' && typeof s.range.end === 'string') {
          dates = alignDates([s.range.start, s.range.end]);
        } else if (typeof s.range.start !== 'string' && typeof s.range.end === 'string') {
          dates = alignDates([formatDate(s.range.start), s.range.end]);
        } else if (typeof s.range.start === 'string' && typeof s.range.end !== 'string') {
          dates = alignDates([s.range.start, formatDate(s.range.end)]);
        } else {
          dates = alignDates([formatDate(s.range.start), formatDate(s.range.end)]);
        }

        s.range.start = formatDate(dates[0]);
        s.range.end = formatDate(dates[1]);
      }

      s.range.first = s.range.first || {};
      s.range.second = s.range.second || {}; // Start date

      if (s.range.data && s.range.data.startDate) {
        s.range.first.date = s.range.data.startDate;
      } else if (s.range.start && typeof s.range.start === 'string') {
        s.range.first.date = parseDate(s.range.start);
      } else if (field.dates) {
        s.range.first.date = this.isIslamic && Array.isArray(field.dates[0]) ? field.dates[0] : parseDate(field.dates[0]);
      } // End date


      if (s.range.data && s.range.data.endDate) {
        s.range.second.date = s.range.data.endDate;
      } else if (s.range.end && typeof s.range.end === 'string') {
        s.range.second.date = parseDate(s.range.end);
      } else if (field.dates) {
        s.range.second.date = this.isIslamic && Array.isArray(field.dates[1]) ? field.dates[1] : parseDate(field.dates[1]);
      }

      if (this.calendarAPI) {
        this.calendarAPI.setRangeSelected();
      }

      if (field.isEmpty || !field.isEmpty && !s.range.data) {
        var value = formatDate(s.range.first.date);

        if (value) {
          this.element.val(value);
        }
      } else {
        return false;
      }

      return true;
    },

    /**
     * Get the value from the field and set the internal variables or use current date
     * @private
     * @returns {void}
     */
    setValueFromField: function setValueFromField() {
      var _this7 = this;

      var s = this.settings;
      this.setCurrentCalendar();

      if (s.range.useRange && this.element.val().trim() === '') {
        this.resetRange({
          isData: true
        });
      }

      if (s.range.useRange && (this.element.val().trim() !== '' || s.range.start && s.range.end || s.range.data && s.range.data.startDate && s.range.data.endDate)) {
        if (!this.setRangeValueFromField()) {
          if (this.currentDate && typeof this.currentDate.getMonth === 'function') {
            this.currentMonth = this.currentDate.getMonth();
            this.currentYear = this.currentDate.getFullYear();
            this.currentDay = this.currentDate.getDate();
          }

          if (this.currentDate && this.isIslamic) {
            this.currentYear = this.currentDateIslamic[0];
            this.currentMonth = this.currentDateIslamic[1];
            this.currentDay = this.currentDateIslamic[2];
          }

          return;
        }
      }

      var self = this;
      var fieldValue = this.element.val();
      var gregorianValue = fieldValue;

      if (this.isIslamic && fieldValue) {
        var islamicValue = Locale.parseDate(this.element.val(), {
          pattern: this.pattern,
          locale: this.locale.name
        });

        if (islamicValue instanceof Date) {
          gregorianValue = Locale.umalquraToGregorian(islamicValue.getFullYear(), islamicValue.getMonth(), islamicValue.getDate());
        } else if (islamicValue instanceof Array) {
          gregorianValue = Locale.umalquraToGregorian(islamicValue[0], islamicValue[1], islamicValue[2], islamicValue[3], islamicValue[4], islamicValue[5]);
        }
      }

      var getSelectedDay = function getSelectedDay() {
        var day = new Date().getDate();

        if (_this7.calendarAPI) {
          var selected = _this7.calendarAPI.dayMap.filter(function (d) {
            return d.elem.is('.is-selected');
          });

          if (selected.length) {
            day = parseInt(selected[0].key.substr(6), 10);
          }
        }

        return day;
      };

      var selectedDay = getSelectedDay();
      this.currentDate = gregorianValue || new Date();

      if (typeof this.currentDate === 'string') {
        this.currentDate = Locale.parseDate(this.currentDate, {
          pattern: this.pattern,
          locale: this.locale.name,
          calendarName: this.settings.calendarName
        }, false);

        if (this.pattern && this.pattern.indexOf('d') === -1) {
          this.currentDate.setDate(selectedDay);
        }
      }

      if (this.currentDate === undefined) {
        this.currentDate = Locale.parseDate(gregorianValue, {
          pattern: this.pattern,
          locale: this.locale.name,
          calendarName: this.settings.calendarName
        }, false);
      }

      if (this.isIslamic) {
        this.currentDateIslamic = Locale.gregorianToUmalqura(this.currentDate);
        this.currentYear = this.currentDateIslamic[0];
        this.currentMonth = this.currentDateIslamic[1];
        this.currentDay = this.currentDateIslamic[2];
      } else {
        this.currentDate = this.currentDate || new Date();
        this.currentMonth = this.currentDate.getMonth();
        this.currentYear = this.currentDate.getFullYear();
        this.currentDay = this.currentDate.getDate();
      } // Check and fix two digit year for main input element


      var dateFormat = self.pattern;
      var isStrict = !(dateFormat.indexOf('MMMM') > -1 || dateFormat.indexOf('MMM') > -1 || dateFormat === 'yyyy' || dateFormat === 'MMMM' || dateFormat === 'MMM' || dateFormat === 'MM');
      var fieldValueTrimmed = self.element.val().trim();

      if (fieldValueTrimmed !== '' && !s.range.useRange) {
        var parsedDate = Locale.parseDate(fieldValueTrimmed, {
          pattern: self.pattern,
          locale: this.locale.name,
          calendarName: this.settings.calendarName
        }, isStrict);
        var hours = 0;

        if (this.isIslamic) {
          hours = parsedDate[3];
        } else {
          hours = parsedDate === null || parsedDate === void 0 ? void 0 : parsedDate == null ? void 0 : parsedDate.getHours();
        }

        if (!this.isIslamic && parsedDate && hours < 12 && self.element.val().trim().indexOf(this.currentCalendar.dayPeriods[1]) > -1) {
          parsedDate.setHours(hours + 12);
        }

        if (this.isIslamic && parsedDate && hours < 12 && self.element.val().trim().indexOf(this.currentCalendar.dayPeriods[1]) > -1) {
          hours += 12;
        }

        if (!this.isIslamic && self.pattern && self.pattern.indexOf('d') === -1) {
          parsedDate.setDate(selectedDay);
        }

        if (this.isIslamic && self.pattern && self.pattern.indexOf('d') === -1) {
          parsedDate[2] = selectedDay;
        }

        if (parsedDate !== undefined && self.element.val().trim() !== '' && !s.range.useRange) {
          self.setValue(parsedDate);

          if (fieldValueTrimmed !== self.element.val().trim()) {
            this.element.trigger('change').trigger('input');
          }
        }
      }

      if (s.range.useRange && s.range.first && s.range.first.date && s.range.second) {
        if (s.range.second.date) {
          this.element.val(this.getRangeValue());
        } else {
          this.setRangeToElem(this.currentDate, true);
        }
      }
    },

    /**
     * Set input to enabled.
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },

    /**
     * Set input to disabled.
     * @returns {void}
     */
    disable: function disable() {
      this.enable();
      this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
    },

    /**
     * Detects whether or not the component is disabled
     * @returns {boolean} whether or not the component is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Set input to readonly.
     * @returns {void}
     */
    readonly: function readonly() {
      this.enable();
      this.element.attr('readonly', 'readonly');
    },

    /**
     * Detects whether or not the component is readonly
     * @returns {boolean} whether or not the component is readonly
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },

    /**
     * Set to todays date in current format.
     * @private
     * @param {boolean} keepFocus if true keep focus on calendar
     * @returns {void}
     */
    setToday: function setToday(keepFocus) {
      var s = this.settings;
      this.lastValue = null;
      this.currentDate = new Date();

      if (this.isReadonly() || this.isDisabled()) {
        return;
      }

      if (!this.settings.useCurrentTime) {
        this.currentDate = this.setTime(this.currentDate);
      }

      if (this.isIslamic) {
        var islamicDateParts = Locale.gregorianToUmalqura(this.currentDate);
        this.currentDateIslamic = islamicDateParts;
      }

      var currentDate = this.isIslamic ? this.currentDateIslamic : this.currentDate;

      if (this.isOpen()) {
        if (s.range.useRange) {
          if (!s.range.first || s.range.first && !s.range.first.date) {
            this.calendarAPI.days.find('td:visible').removeClass('is-selected').removeAttr('aria-selected');
            this.insertDate(currentDate, true);

            if (keepFocus && this.calendarAPI) {
              var cell = this.calendarAPI.dayMap.filter(function (d) {
                return d.elem.is('.is-selected');
              });

              if (cell && cell.length) {
                setTimeout(function () {
                  cell[0].elem.focus();
                }, 0);
              }
            }
          } else if (s.range.first && s.range.first.date && (!s.range.second || s.range.second && !s.range.second.date)) {
            this.setRangeToElem(currentDate, false);
          } else if (s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
            this.resetRange({
              isData: true
            });
            this.insertDate(currentDate, true);
          }
        } else {
          this.insertDate(currentDate, true);
        }
      } else {
        if (s.range.useRange) {
          this.setRangeToElem(this.currentDate);
        } else {
          var options = {
            pattern: this.pattern,
            locale: this.locale.name
          };
          var islamicDateText = Locale.formatDate(currentDate, options);
          this.element.val(islamicDateText);
        }
        /**
        * Fires after the value in the input is changed by user interaction.
        *
        * @event input
        * @memberof DatePicker
        * @property {object} event - The jquery event object
        */


        if (s.range.useRange) {
          this.element.trigger('change', [s.range.data]).trigger('input', [s.range.data]);
        } else {
          this.element.trigger('change').trigger('input');
        }
      }
    },

    /**
     * Set the date to one more or one less day.
     * @param  {boolean} plusMinus True for increment, false for decrement
     */
    adjustDay: function adjustDay(plusMinus) {
      if (this.isReadonly() || this.isDisabled()) {
        return;
      }

      if (!this.currentDate) {
        this.setToday();
      }

      var options = {
        pattern: this.pattern,
        locale: this.locale.name
      };
      var currentDate = this.isIslamic ? this.currentDateIslamic : this.currentDate;

      if (this.isIslamic) {
        currentDate[2] += plusMinus ? 1 : -1;
        currentDate = Locale.umalquraToGregorian(this.currentDateIslamic[0], this.currentDateIslamic[1], this.currentDateIslamic[2], this.currentDateIslamic[3], this.currentDateIslamic[4], this.currentDateIslamic[5], this.currentDateIslamic[6]);
        currentDate.setDate(currentDate.getDate() + (plusMinus ? 1 : -1));
        currentDate = Locale.gregorianToUmalqura(currentDate);
      } else {
        currentDate.setDate(currentDate.getDate() + (plusMinus ? 1 : -1));
      }

      this.element.val(Locale.formatDate(currentDate, options));
      this.element.trigger('change').trigger('input');
    },

    /**
     * Set time
     * @private
     * @param {object} date .
     * @returns {void}
     */
    setTime: function setTime(date) {
      var hasPopup = this.popup !== undefined;

      if (!this.timepicker || !hasPopup) {
        if (!this.settings.useCurrentTime) {
          date.setHours(0, 0, 0, 0);
        }

        return date;
      }

      var hours = this.popup.find('.dropdown.hours').val();
      var minutes = this.popup.find('.dropdown.minutes').val();
      var seconds = this.isSeconds ? this.popup.find('.dropdown.seconds').val() : 0;
      var period = this.popup.find('.dropdown.period');
      var periodValue = period.val();
      hours = period.length && periodValue === this.currentCalendar.dayPeriods[1] && hours < 12 ? parseInt(hours, 10) + 12 : hours;
      hours = period.length && (periodValue === this.currentCalendar.dayPeriods[0] || !periodValue) && parseInt(hours, 10) === 12 ? 0 : hours;

      if (date instanceof Array) {
        date[3] = hours ? parseInt(hours, 10) : date[3];
        date[4] = minutes ? parseInt(minutes, 10) : date[4];
        date[5] = seconds ? parseInt(seconds, 10) : date[5];
      } else {
        date = new Date(date);
        date.setHours(hours, minutes, seconds);
      }

      return date;
    },

    /**
     * Get the current date from the field. In date format
     * @returns {Date} the set date object
     */
    getCurrentDate: function getCurrentDate() {
      return this.currentDate;
    },

    /**
     * Updates the component instance. Can be used after being passed new settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, DATEPICKER_DEFAULTS);
      }

      return this.teardown().init();
    },

    /**
     * Get range value to insert in element
     * @private
     * @returns {string} range dates to display in element
     */
    getRangeValue: function getRangeValue() {
      var _this8 = this;

      var s = this.settings;

      var formatDate = function formatDate(d) {
        return Locale.formatDate(d, {
          pattern: _this8.pattern,
          locale: _this8.locale.name
        });
      };

      if (s.range.useRange && s.range.first && s.range.first.date && s.range.second && s.range.second.date) {
        return "".concat(formatDate(s.range.first.date) + s.range.separator + formatDate(s.range.second.date));
      }

      if (s.range.useRange && s.range.first && s.range.first.date) {
        return s.placeholder ? "".concat(formatDate(s.range.first.date) + s.range.separator + this.pattern) : formatDate(s.range.first.date);
      }

      return '';
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      if (this.isOpen()) {
        this.closeCalendar();
      }

      this.element.off('blur.datepicker change.datepicker-rangeclear keyup.datepicker-rangeclear');
      this.trigger.remove();
      this.element.removeAttr('placeholder');

      if (this.calendarAPI) {
        this.calendarAPI.destroy();
      }

      if (this.calendar && this.calendar.length) {
        this.calendar.remove();
      }

      if (this.popup && this.popup.length) {
        this.popup.remove();
      }

      var maskApi = this.element.data('mask');

      if (maskApi) {
        maskApi.destroy();
      }

      this.element.removeAttr('data-mask');
      this.element.removeData('mask');
      this.element.off('keydown.datepicker blur.validate change.validate keyup.validate focus.validate');

      if (this.addedValidation) {
        this.element.removeAttr('data-validate').removeData('validate validationEvents');
        delete this.addedValidation;
      }

      return this;
    },

    /**
     * Destroy and remove added markup, reset back to default
     * @returns {void}
     */
    destroy: function destroy() {
      this.closeCalendar();
      this.teardown();

      if (this.element[0]) {
        $.removeData(this.element[0], COMPONENT_NAME$J);
      }
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this9 = this;

      var self = this;
      var s = this.settings;
      this.trigger.on('click.datepicker', function () {
        if (self.isOpen()) {
          self.closeCalendar();
        } else {
          self.openCalendar();
        }
      });
      this.handleKeys(this.element); // Fix two digit year for main input element

      self.element.on('blur.datepicker', function () {
        if (_this9.element.val().trim() !== '') {
          _this9.setValueFromField();
        }
      }); // Clear setting range dates

      this.element.on('change.datepicker-rangeclear keyup.datepicker-rangeclear', function () {
        if (!_this9.isOpen() && _this9.element.val().trim() === '') {
          self.clearRangeDates();
        }
      }); // Set initialize value

      if (!this.isOpen() && s.range.useRange && !s.range.first) {
        this.setRangeValueFromField();
        var value = this.getRangeValue();

        if (value) {
          this.element.val(value);
        }
      }
    }
  };

  /**
   * jQuery Component Wrapper for Datepicker
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.datepicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$J);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$J, new DatePicker(this, settings));
      }
    });
  };

  var validTagNames = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'code', 'div'];
  /**
   * Defines a style that can be used inside a Fontpicker component
   * @class FontPickerStyle
   * @param {string} id a unique identifying string for this Fontpicker style. This value should be unique when compared to other styles within the same fontpicker.
   * @param {string} displayName the human-readable name for the Fontpicker style.
   * @param {string} [tagName='p'] a string representing a valid HTML tag to use for this style. Defaults to "span".
   * @param {string} [className=''] a string containing a valid CSS class selector to append to the tag.
   * @param {CSSStyleDeclaration} [styleProps] valid CSS props to add to the fontpicker style.
   */

  function FontPickerStyle(id, displayName) {
    var tagName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'p';
    var className = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var styleProps = arguments.length > 4 ? arguments[4] : undefined;

    // 'id' is required.
    if (!id || typeof id !== 'string' || !displayName.length) {
      throw new Error('"id" property must be defined and unique.');
    }

    this.id = id; // `displayName` is required.

    if (!displayName || typeof displayName !== 'string' || !displayName.length) {
      throw new Error('"displayName" property must be defined.');
    }

    this.displayName = displayName; // `tagName` is required, but defaults to `p`

    tagName = tagName.toLowerCase();

    if (validTagNames.indexOf(tagName) === -1) {
      tagName = 'p';
    }

    this.tagName = tagName;

    if (typeof className === 'string' && className.length) {
      this.className = className;
    }

    if (styleProps instanceof CSSStyleDeclaration) {
      this.styleProps = styleProps;
    }

    return this;
  }

  FontPickerStyle.prototype = {
    /**
     * @param {string} content text content to be styled.
     * @returns {string} containing the content surrounded in this style's format.
     */
    render: function render(content) {
      // Sanitize incoming content
      content = xssUtils.stripHTML(content);
      return "<".concat(this.tagName, ">").concat(content, "</").concat(this.tagName, ">");
    }
  };

  var COMPONENT_NAME$K = 'fontpicker'; // Default Settings
  // NOTE: new settings are created at runtime to avoid retention of state on FontPickerStyle objects

  function fontpickerSettingsFactory() {
    return {
      popupmenuSettings: {
        offset: {
          y: 10
        }
      },
      styles: [new FontPickerStyle('default', Locale.translate('FontPickerNormal')), new FontPickerStyle('header1', Locale.translate('FontPickerHeader').replace('{0}', '1'), 'h3'), new FontPickerStyle('header2', Locale.translate('FontPickerHeader').replace('{0}', '2'), 'h4')]
    };
  }
  /**
   * Fontpicker Component
   * @class FontPicker
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   */


  function FontPicker(element, settings) {
    if (!(element instanceof HTMLElement)) {
      throw new Error('Property "element" is not an HTMLElement type');
    }

    this.settings = utils.mergeSettings(element, settings, fontpickerSettingsFactory());

    if (settings && Array.isArray(settings.styles)) {
      this.settings.styles = settings.styles;
    }

    this.element = element;
    this.init();
  } // Plugin Methods


  FontPicker.prototype = {
    /**
     * @returns {Popupmenu|undefined} the Popupmenu API for the picker, if applicable.
     */
    get menuAPI() {
      var api = $(this.element).data('popupmenu');

      if (!api) {
        return undefined;
      }

      return api;
    },

    /**
     * @returns {FontPickerStyle} currently selected font
     */
    get selected() {
      var selected;
      this.settings.styles.forEach(function (style) {
        if (style.selected) {
          selected = style;
        }
      });

      if (!selected) {
        this.settings.styles[0].selected = true;
        return this.settings.styles[0];
      }

      return selected;
    },

    /**
     * Gets a reference to a FontPickerStyle object defined within this component, targeted by its ID.
     * @param {string} id an id representing a font style within this fontpicker's selections.
     * @returns {FontPickerStyle} a font style within this component's selections by its unique ID.
     */
    getStyleById: function getStyleById(id) {
      var targetStyle;
      this.settings.styles.forEach(function (style) {
        if (style.id === id) {
          targetStyle = style;
        }
      });

      if (!targetStyle) {
        throw new Error("No FontPickerStyle available with id \"".concat(id, "\""));
      }

      return targetStyle;
    },

    /**
     * Gets a reference to a FontPickerStyle object defined within this component, targeted by its Tag Name.
     * @param {string} tagName an id representing a font style within this fontpicker's selections.
     * @returns {FontPickerStyle} a font style within this component's selections by its unique ID.
     */
    getStyleByTagName: function getStyleByTagName(tagName) {
      var targetStyle;
      this.settings.styles.forEach(function (style) {
        if (style.tagName === tagName) {
          targetStyle = style;
        }
      });

      if (!targetStyle) {
        throw new Error("No FontPickerStyle available with tagName \"".concat(tagName, "\""));
      }

      return targetStyle;
    },

    get disabled() {
      return this.trueDisabled;
    },

    /**
     * @param {boolean} bool whether or not to disable this component
     * @returns {void}
     */
    set disabled(bool) {
      this.trueDisabled = bool;

      if (bool === true) {
        this.element.disabled = true;
        return;
      }

      this.element.disabled = false;
    },

    /**
     * @returns {array} of tagNames currently supported by this fontpicker
     */
    get supportedTagNames() {
      var tagNames = [];
      this.settings.styles.forEach(function (style) {
        tagNames.push(style.tagName);
      });
      return tagNames;
    },

    /**
     * Do initialization, build up and / or add events ect.
     * @returns {object} The Component prototype, useful for chaining.
     */
    init: function init() {
      // Ensure we have an array for this, otherwise reset to default.
      if (!Array.isArray(this.settings.styles) || !this.settings.styles.length) {
        this.settings.styles = fontpickerSettingsFactory().styles;
      } // Do initialization. Build or Events ect


      return this.build().handleEvents();
    },

    /**
     * Add any needed markup to the component.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    build: function build() {
      var $element = $(this.element); // Invoke button

      var ddIcon = this.element.querySelector('svg.icon.icon-dropdown');

      if (!ddIcon) {
        ddIcon = $.createIcon({
          icon: 'dropdown',
          classes: ['icon-dropdown']
        });
        this.element.insertAdjacentHTML('beforeend', ddIcon);
      }

      this.ddIcon = this.element.querySelector('svg.icon.icon-dropdown');
      $element.button(); // Invoke menu

      var $menu = $element.next('.popupmenu');

      if (!$menu || !$menu.length) {
        $menu = $('<ul class="popupmenu fontpicker-menu"></ul>').insertAfter(this.element);
      }

      $menu.html(this.buildMenuHTML());
      var menuSettings = utils.extend({}, this.settings.popupmenuSettings, {
        menu: $menu,
        stretchToWidestMenuItem: true
      });
      $element.popupmenu(menuSettings); // Set initial state

      this.render(); // Add audible label

      this.audible = $("<span class=\"audible\">".concat(Locale.translate('FontPickerStyle'), "</span>"));
      this.element.prepend(this.audible[0]);
      return this;
    },

    /**
     * Renders the button's display.
     * @private
     * @returns {void}
     */
    render: function render() {
      var selected = this.selected;
      var spanElem = this.element.querySelector('span:not(.audible)');
      $(spanElem).html(selected.displayName);
    },

    /**
     * @private
     * Builds the Fontpicker's Popupmenu HTML
     * @returns {string} representing the Popupmenu's HTML.
     */
    buildMenuHTML: function buildMenuHTML() {
      var menuHTML = '';
      this.settings.styles.forEach(function (style) {
        var itemRender = style.render(style.displayName);
        menuHTML += "<li class=\"fontpicker-style\">\n        <a href=\"#\" data-val=\"".concat(style.id, "\">").concat(itemRender, "</a>\n      </li>");
      });
      return "".concat(menuHTML);
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @returns {object} The Component prototype, useful for chaining.
     * @private
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      $(this.element).on("selected.".concat(COMPONENT_NAME$K), function (e, selectedItem) {
        var val = selectedItem.attr('data-val');

        _this.select(val);
      }).on("updated.".concat(COMPONENT_NAME$K), function (e, settings) {
        self.updated(settings);
      });
      return this;
    },

    /**
     * Selects a font from the list
     * @param {string|FontPickerStyle} id either an ID string, or a direct reference to a FontPickerStyle
     * @param {boolean} preventEvent whether or not to fire an event to annouce the selection change.  In some cases, this method is called directly by a parent component, which may have been responsible for the change by other means.
     * @returns {void}
     */
    select: function select(id, preventEvent) {
      if (!id || typeof id !== 'string' && !(id instanceof FontPickerStyle)) {
        throw new Error('"id" property must be defined in order to select.');
      } // If this is not a FontPickerStyle, assume a string type and attempt to get via ID.


      var style;

      if (!(id instanceof FontPickerStyle)) {
        style = this.getStyleById(id);
      } else {
        style = id;
      } // Deselect all other styles except for this one.


      this.settings.styles.forEach(function (thisStyle) {
        thisStyle.selected = false;
      });
      style.selected = true; // Update the button's visuals

      this.render(style); // Notify externally

      if (!preventEvent) {
        $(this.element).triggerHandler('font-selected', [style]);
      }
    },

    /**
     * Handle updated settings and values.
     * @param {object} [settings=undefined] optional incoming fontpicker settings
     * @returns {object} [description]
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        var incomingStyles;

        if (Array.isArray(settings.styles)) {
          incomingStyles = settings.styles;
        }

        this.settings = utils.mergeSettings(this.element, settings, this.settings);

        if (incomingStyles) {
          this.settings.styles = incomingStyles;
        }
      }

      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      // Remove icon
      var ddIcon = this.element.querySelector('svg.icon.icon-dropdown');
      ddIcon.parentNode.removeChild(ddIcon); // Destroy sub-components

      var menuAPI = this.menuAPI;

      if (menuAPI && typeof menuAPI.destroy === 'function') {
        menuAPI.destroy();
      }

      var buttonAPI = $(this.element).data('button');

      if (buttonAPI && typeof buttonAPI.destroy === 'function') {
        buttonAPI.destroy();
      } // Remove events


      $(this.element).off(["selected.".concat(COMPONENT_NAME$K), "updated.".concat(COMPONENT_NAME$K)].join(' '));
      return this;
    },

    /**
     * Completely removes this component instance from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$K);
    }
  };

  $.fn.fontpicker = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$K);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$K, new FontPicker(this, settings));
      }
    });
  };

  var COMPONENT_NAME$L = 'toolbar';
  /**
   * The Toolbar Component manages various levels of application navigation.
   * It contains a group of buttons that functionally related content. Each panel
   * consists of two levels: the top level identifies the category or section header,
   * and the second level provides the associated options.
   *
   * @class Toolbar
   * @param {HTMLElement|jQuery[]} element the base Toolbar element
   * @param {object} [settings] incoming settings
   *
   * @param {boolean} [settings.rightAligned=false] Will always attempt to right-align the contents of
   *  the toolbar. By default if there is no title it will left align. This forces right alignment.
   * @param {number} [settings.maxVisibleButtons=3] Total amount of buttons that can be present, not
   *  including the More button.
   * @param {boolean} [settings.resizeContainers=true] If true, uses Javascript to size the Title and
   *  Buttonset elements in a way that shows as much of the Title area as possible.
   * @param {boolean} [settings.favorButtonset=true] If "resizeContainers" is true, setting this to
   *  true will try to display as many buttons as possible while resizing the toolbar.
   *  Setting to false attempts to show the entire title instead.
   * @param {object} [settings.moreMenuSettings] If defined, provides a toolbar-level method of
   *  defining settings that will be applied to the More Actions button's popupmenu instance.
   * @param {boolean} [settings.noSearchfieldReinvoke=false] If true, does not manage the lifecycle
   *  of an internal toolbarsearchfield automatically.  Allows an external controller
   *  to do it instead.
   * @param {Array} [settings.attributes] If defined, passes user-defined attributes into the Toolbar
   *  and some of its subcomponents
   */

  var TOOLBAR_DEFAULTS = {
    rightAligned: false,
    maxVisibleButtons: 3,
    resizeContainers: true,
    favorButtonset: true,
    moreMenuSettings: undefined,
    noSearchfieldReinvoke: false,
    attributes: null
  };

  function Toolbar(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TOOLBAR_DEFAULTS);
    this.init();
  } // Plugin Methods


  Toolbar.prototype = {
    /**
     * Initializes the Toolbar Component
     * @private
     * @chainable
     * @returns {this} component instance
     */
    init: function init() {
      return this.setup().build().handleEvents();
    },

    /**
     * Detects discrepencies in settings.  In general, configures the component
     * based on user settings.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    setup: function setup() {
      // Can't have zero buttons
      if (this.settings.maxVisibleButtons <= 0) {
        this.settings.maxVisibleButtons = TOOLBAR_DEFAULTS.maxVisibleButtons;
      }

      return this;
    },

    /**
     * Adds additional markup, wraps some internal elements, and helps construct a
     * complete Toolbar representation in the HTML Markup. This method also builds the
     * "More Actions" menu and ties its elements to the toolbar items.
     * @private
     * @chainable
     * @returns {this} component instance
     */
    build: function build() {
      var _moreMenuAttrs;

      var self = this;
      this.element.attr('role', 'toolbar');

      if (this.settings.resizeContainers && this.element.is(':not(:hidden)')) {
        this.element[0].classList.add('do-resize');
      }

      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes(this.element, this, this.settings.attributes);
      }

      this.buildAriaLabel(); // keep track of how many popupmenus there are with an ID.
      // Used for managing events that are bound to $(document)

      if (!this.id) {
        this.id = parseInt($('.toolbar, .formatter-toolbar').index(this.element), 10);
      } // Check for a "title" element.  This element is optional.
      // If a title element exists, a tooltip will be created for when it's not
      // possible to show the entire title text on screen.


      this.title = this.element.children('.title');

      if (this.title.length) {
        this.element[0].classList.add('has-title');
        this.cutoffTitle = false;
        this.title.on('beforeshow.toolbar', function () {
          return self.cutoffTitle;
        }).tooltip({
          content: "".concat(this.title.text().trim())
        });
      } else {
        this.element[0].classList.remove('has-title');
      } // Container for main group of buttons and input fields.  Only these spill into the More menu.


      this.buttonset = this.element.children('.buttonset');

      if (!this.buttonset.length) {
        this.buttonset = $('<div class="buttonset"></div>');

        if (this.title.length) {
          this.buttonset.insertAfter(this.title);
        } else {
          this.buttonset.prependTo(this.element);
        }
      }

      this.element[this.settings.rightAligned ? 'addClass' : 'removeClass']('right-aligned'); // Add and invoke More Button, if it doesn't exist

      this.more = this.element.find('.btn-actions');

      if (this.more.length === 0 && !this.element.hasClass('no-actions-button')) {
        var moreContainer = this.element.find('.more');

        if (!moreContainer.length) {
          moreContainer = $('<div class="more"></div>').appendTo(this.element);
        }

        this.more = $('<button class="btn-actions" type="button"></button>').html("".concat($.createIcon({
          icon: 'more'
        }), "<span class=\"audible\">").concat(Locale.translate('MoreActions'), "</span>")).attr('title', Locale.translate('More')).appendTo(moreContainer);
      } // Reference all interactive items in the toolbar


      this.buttonsetItems = this.buttonset.children('button').add(this.buttonset.find('input')); // Searchfield Wrappers
      // Items contains all actionable items in the toolbar, including the ones in
      // the title, and the more button

      this.items = this.buttonsetItems.add(this.title.children('button')).add(this.more); // Invoke buttons

      var buttons = this.items.filter('button, input[type="button"], [class^="btn"]');
      buttons.each(function (i) {
        var btn = $(this);
        var buttonControl = btn.data('button');

        if (!buttonControl) {
          btn.button();
        }

        var tooltipControl = $(this).data('tooltip');

        if (!tooltipControl && btn.attr('title')) {
          btn.tooltip();
        }

        if (!btn.is('.btn-menu') && Array.isArray(self.settings.attributes)) {
          utils.addAttributes(btn, self, self.settings.attributes, "button-".concat(i));
        }
      }); // Invoke searchfields

      if (!this.settings.noSearchfieldReinvoke) {
        var searchfields = this.items.filter('.searchfield, .toolbar-searchfield-wrapper, .searchfield-wrapper');
        searchfields.each(function (i, item) {
          var sf = $(item);

          if (sf.is('.toolbar-searchfield-wrapper, .searchfield-wrapper')) {
            sf = sf.children('.searchfield');
          }

          if (!sf.data('searchfield')) {
            var searchfieldOpts = $.extend({}, utils.parseSettings(sf[0]));
            sf.searchfield(searchfieldOpts);
          }

          utils.addAttributes(sf, self, self.settings.attributes, 'searchfield');
        });
      } // Setup the More Actions Menu.  Add Menu Items for existing buttons/elements in
      // the toolbar, but hide them initially. They are revealed when overflow checking
      // happens as the menu is opened.


      var popupMenuInstance = this.more.data('popupmenu');
      var moreAriaAttr = this.more.attr('aria-controls');

      if (!popupMenuInstance) {
        this.moreMenu = $("#".concat(moreAriaAttr));

        if (!this.moreMenu.length) {
          this.moreMenu = this.more.next('.popupmenu, .popupmenu-wrapper');
        }

        if (!this.moreMenu.length) {
          this.moreMenu = $("<ul id=\"popupmenu-toolbar-".concat(this.id, "\" class=\"popupmenu\"></ul>")).insertAfter(this.more);
        } // Allow toolbar to understand pre-wrapped popupmenus
        // Angular Support -- See SOHO-7008


        if (this.moreMenu.is('.popupmenu-wrapper')) {
          this.moreMenu = this.moreMenu.children('.popupmenu');
        }
      } else {
        this.moreMenu = popupMenuInstance.menu;
      }

      function menuItemFilter() {
        return $(this).parent('.buttonset, .inline').length;
      }

      var menuItems = [];
      this.items.not(this.more).not('.ignore-in-menu').filter(menuItemFilter).each(function () {
        menuItems.push(self.buildMoreActionsMenuItem($(this)));
      });
      menuItems.reverse();
      $.each(menuItems, function (i, item) {
        if (item.text() !== '') {
          item.prependTo(self.moreMenu);
        }
      });
      this.defaultMenuItems = this.moreMenu.children('li:not(.separator)');
      this.hasDefaultMenuItems = this.defaultMenuItems.length > 0; // If no more menu attributes are directly added through settings,
      // use the toolbar's with an `actionbutton` suffix

      var moreMenuAttrs;

      if (this.settings.moreMenuSettings && Array.isArray(this.settings.moreMenuSettings.attributes)) {
        moreMenuAttrs = this.settings.moreMenuSettings.attributes;
      }

      if ((!moreMenuAttrs || !moreMenuAttrs.length) && Array.isArray(this.settings.attributes)) {
        moreMenuAttrs = this.settings.attributes.map(function (attr) {
          var value = "".concat(attr.value, "-actionbutton");
          return {
            name: attr.name,
            value: value
          };
        });
      }

      if (!((_moreMenuAttrs = moreMenuAttrs) !== null && _moreMenuAttrs !== void 0 && (_moreMenuAttrs == null ? void 0 : _moreMenuAttrs.length))) {
        moreMenuAttrs = null;
      } // Setup an Event Listener that will refresh the contents of the More Actions
      // Menu's items each time the menu is opened.


      var menuButtonSettings = utils.extend({}, this.settings.moreMenuSettings, {
        trigger: 'click',
        menu: this.moreMenu,
        attributes: moreMenuAttrs
      }, this.hasDefaultMenuItems ? {
        predefined: this.defaultMenuItems
      } : {});

      if (popupMenuInstance) {
        this.more.on('beforeopen.toolbar', function () {
          self.refreshMoreActionsMenu(self.moreMenu);
        }).triggerHandler('updated', [menuButtonSettings]);
      } else {
        this.more.popupmenu(menuButtonSettings).on('beforeopen.toolbar', function () {
          self.refreshMoreActionsMenu(self.moreMenu);
        });
      } // Setup the tabindexes of all items in the toolbar and set the starting active button.


      function setActiveToolbarItem() {
        self.items.attr('tabindex', '-1');
        var active = self.items.filter('.is-selected');

        if (active.length) {
          self.activeButton = active.first().attr('tabindex', '0');
          self.items.not(self.activeButton).removeClass('is-selected');
          return;
        } // Set active to the first item in the toolbar.


        active = self.items.filter(':visible:not(:disabled)').first().attr('tabindex', '0');
        self.activeButton = active; // If the whole toolbar is hidden (contextual toolbars, etc),
        // automatically set the first non-disabled item as visible

        if (self.element.is(':hidden, .is-hidden')) {
          self.activeButton = self.items.filter(':not(:disabled)').first().attr('tabindex', '0');
          return;
        }

        if (self.isItemOverflowed(active)) {
          active.attr('tabindex', '-1');
          self.activeButton = self.more.addClass('is-selected').attr('tabindex', '0');
        }
      }

      setActiveToolbarItem(); // Toggles the More Menu based on overflow of toolbar items

      this.adjustMenuItemVisibility();
      this.handleResize();
      /**
       * Fires when the Toolbar has completely rendered all its DOM elements.
       *
       * @event rendered
       * @memberof Toolbar
       * @param {jQuery.Event} e the jQuery Event object
       */

      this.element.triggerHandler('rendered');
      var searchfieldWrapper = this.buttonset.find('.searchfield-wrapper, .toolbar-searchfield-wrapper');

      if (searchfieldWrapper.length) {
        searchfieldWrapper.trigger('reanimate');
      }

      return this;
    },

    /**
     * Builds a single "More Actions Menu" item from a source toolbar item.
     * Also sets up linkage between the menu item and the original toolbar item to
     * allow events/properties to propagate when the More Actions item is acted upon.
     * @private
     * @param {jQuery[]} item the source item from the toolbar.
     * @returns {jQuery[]} a jQuery-wrapped <li> representing a More Actions menu
     *  implementation of the toolbar item.
     */
    buildMoreActionsMenuItem: function buildMoreActionsMenuItem(item) {
      var popupLi; // If this item should be skipped, just return out

      if (item.data('skipit') === true) {
        item.data('skipit', undefined);
        return popupLi;
      } // Attempt to re-use an existing <li>, if possible.
      // If a new one is created, setup the linkage between the original element and its
      // "More Actions" menu counterpart.


      var a = item.data('action-button-link');

      if (!a || !a.length) {
        popupLi = $('<li></li>');
        a = $('<a href="#"></a>').appendTo(popupLi); // Setup data links between the buttons and their corresponding list items

        item.data('action-button-link', a);
        a.data('original-button', item);
      } else {
        popupLi = a.parent();
      } // Refresh states


      if (item.hasClass('hidden')) {
        popupLi.addClass('hidden');
      }

      if (item.is(':disabled')) {
        popupLi.addClass('is-disabled');
        a.prop('disabled', true);
      } else {
        popupLi.removeClass('is-disabled');
        a.prop('disabled', false);
      } // Refresh Text


      a.text(this.getItemText(item)); // Pass along any icons except for the dropdown (which is added as part of the submenu design)

      var submenuDesignIcon = $.getBaseURL('#icon-dropdown');
      var icon = item.children('.icon').filter(function () {
        var iconName = $(this).getIconName();
        return iconName && iconName !== submenuDesignIcon && iconName.indexOf('dropdown') === -1;
      });

      if (icon && icon.length) {
        a.html("<span>".concat(a.text(), "</span>"));
        icon.clone().detach().prependTo(a);
      }

      var linkspan = popupLi.find('b');

      if (linkspan.length) {
        this.moreMenu.addClass('has-icons');
        linkspan.detach().prependTo(popupLi);
      }

      function addItemLinksRecursively(menu, diffMenu, parentItem) {
        var children = menu.children('li');
        var id = diffMenu.attr('id');
        diffMenu.children('li').each(function (i, diffMenuItem) {
          var dmi = $(diffMenuItem); // "Diffed" Menu Item

          var omi = children.eq(i); // Corresponding "Original" menu item

          var dmiA = dmi.children('a'); // Anchor inside of "Diffed" menu item

          var omiA = omi.children('a'); // Anchor inside of "Original" menu item

          var dmiID = dmi.attr('id');
          var dmiAID = dmiA.attr('id'); // replace menu item ids with spillover-menu specific ids.

          if (dmiID) {
            dmi.removeAttr('id').attr('data-original-menu-item', dmiID);
          }

          if (dmiAID) {
            dmiA.removeAttr('id').attr('data-original-menu-anchor', dmiAID);
          }

          omiA.data('action-button-link', dmiA);
          dmiA.data('original-button', omiA);
          var omiSubMenu = omi.children('.wrapper').children('.popupmenu');
          var dmiSubMenu = dmi.children('.wrapper').children('.popupmenu');

          if (omiSubMenu.length && dmiSubMenu.length) {
            addItemLinksRecursively(omiSubMenu, dmiSubMenu, dmi);
          }
        });
        diffMenu.removeAttr('id').attr('data-original-menu', id);
        parentItem.addClass('submenu');
        var appendTarget;

        if (parentItem.is(popupLi)) {
          appendTarget = parentItem.children('.wrapper');

          if (!appendTarget || !appendTarget.length) {
            appendTarget = $('<div class="wrapper"></div>');
          }

          appendTarget.html(diffMenu);
          parentItem.append(appendTarget);
        }
      }

      var index = this.items.not(this.more).not('.searchfield').index(item);

      if (item.is('.btn-menu')) {
        var _menuBtnAttrs;

        // Automatically apply attributes to menu buttons if attributes are set on the toolbar,
        // but the menubutton doesn't have them.
        // If no more menu attributes are directly added through settings,
        // use the toolbar's with an `actionbutton` suffix
        var menuBtnAttrs;

        if (this.settings.attributes && this.settings.attributes.length) {
          menuBtnAttrs = this.settings.attributes.map(function (attr) {
            return {
              name: attr.name,
              value: "".concat(attr.value, "-menubutton-").concat(index)
            };
          });
        }

        if (!((_menuBtnAttrs = menuBtnAttrs) !== null && _menuBtnAttrs !== void 0 && (_menuBtnAttrs == null ? void 0 : _menuBtnAttrs.length))) {
          menuBtnAttrs = null;
        }

        if (!item.data('popupmenu')) {
          item.popupmenu({
            attributes: menuBtnAttrs
          });
        } else if (!a.children('.icon.arrow').length) {
          a.append($.createIcon({
            classes: 'icon arrow icon-dropdown',
            icon: 'dropdown'
          }));
        }

        var menu = item.data('popupmenu').menu;
        var diffMenu = menu.clone();
        addItemLinksRecursively(menu, diffMenu, popupLi);
      }

      if (item.is('[data-popdown]')) {
        item.popdown();
      }

      return popupLi;
    },

    /**
     * Refreshes the More Actions Menu items' text content, icons, states, and submenu content
     * based on changes made directly to their counterpart elements in the Toolbar.  Can also
     * optionally refresh only part of the menu.
     * @param {jQuery[]} menu the menu/submenu to be refreshed.
     */
    refreshMoreActionsMenu: function refreshMoreActionsMenu(menu) {
      var self = this;
      $('li > a', menu).each(function () {
        var a = $(this);
        var li = a.parent();
        var item = a.data('originalButton');
        var itemParent;
        var text = self.getItemText(item);
        var submenu;

        if (item) {
          if (a.find('span').length) {
            a.find('span').text(text.trim());
          } else {
            a.text(text.trim());
          }

          if (item.isHiddenAtBreakpoint() || item.parent().isHiddenAtBreakpoint()) {
            li.addClass('hidden');
          } else {
            li.removeClass('hidden');
          }

          if (item.parent().is('.is-disabled') || item.is(':disabled')) {
            // if it's disabled menu item, OR a disabled menu-button
            li.addClass('is-disabled');
            a.prop('disabled', true);
            a.attr('tabindex', '-1');
          } else {
            li.removeClass('is-disabled');
            a.prop('disabled', false);
          }

          if (item.is('a')) {
            itemParent = item.parent('li');

            if (itemParent.is('.is-checked')) {
              li.addClass('is-checked');
            } else {
              li.removeClass('is-checked');
            }
          }

          if (item.is('.btn-menu')) {
            submenu = a.parent().find('.popupmenu').first();
            self.refreshMoreActionsMenu(submenu);
          }
        }
      });
    },

    /**
     * Gets the complete text contnts of a Toolbar Item, in order to create its
     * corresponding "more actions" menu item.
     *
     * Order of operations for populating the List Item text:
     * 1. span contents (.audible), then
     * 2. button title attribute, then
     * 3. tooltip text (if applicable)
     * @param {jQuery[]} item the item being evaluated.
     * @returns {string} the complete text representation.
     */
    getItemText: function getItemText(item) {
      if (!item) {
        return '';
      }

      var span = item.find('span').first();
      var title = item.attr('title');
      var tooltip = item.data('tooltip');
      var tooltipText = tooltip && typeof tooltip.content === 'string' ? tooltip.content : undefined;
      var popupLiText;

      if (title !== '' && title !== undefined) {
        popupLiText = title;
      } else if (tooltipText) {
        popupLiText = tooltipText;
      } else if (span.length) {
        popupLiText = span.text();
      } else {
        popupLiText = item.text();
      }

      return xssUtils.stripHTML(popupLiText);
    },

    /**
     * Sets up all necessary event handling on a Toolbar component
     * @private
     * @chainable
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.items.on('keydown.toolbar', function (e) {
        self.handleKeys(e);
      }).on('click.toolbar', function (e) {
        self.handleClick(e);
      });
      this.items.filter('.btn-menu, .btn-actions').on('close.toolbar', function onClosePopup() {
        var el = $(this);
        var last;

        if (el.is('.is-overflowed')) {
          last = self.getLastVisibleButton();

          if (last && last.length) {
            last[0].focus();
          }

          return;
        }

        if (document.activeElement && document.activeElement.tagName === 'INPUT') {
          return;
        }

        if (el) {
          el.focus();
        }

        self.buttonset.scrollTop(0);
      });
      this.items.not(this.more).on('selected.toolbar', function (e, anchor) {
        e.stopPropagation();
        self.handleSelected(e, anchor);
      });
      this.more.on('keydown.toolbar', function (e) {
        self.handleKeys(e);
      }).on('beforeopen.toolbar', function () {
        self.adjustMenuItemVisibility();
      }).on('selected.toolbar', function (e, anchor) {
        e.stopPropagation();
        self.handleSelected(e, anchor);
      }); // Handle possible AJAX calls on Toolbar Menu buttons
      // TODO: Need to handle mouseenter/touchstart/keydown events that will cause this to trigger,
      // instead of directly handling this itself.

      this.more.on('show-submenu.toolbar', function (e, li) {
        self.handleTransferToMenuButtonItem(e, li);
      });
      this.element.on('updated.toolbar', function (e, settings) {
        e.stopPropagation();
        self.updated(settings);
      }).on('recalculate-buttons.toolbar', function (e, containerDims) {
        self.handleResize(containerDims);
      }).on('scrollup.toolbar', function () {
        var moduleTabsParent = self.element.parents('.tab-container.module-tabs');

        if (moduleTabsParent.length) {
          moduleTabsParent.scrollTop(0);
        }
      });
      $('body').on("resize.toolbar-".concat(this.id), function () {
        self.handleResize();
      }); // Trigger _handleResize()_ once to fix container sizes.

      this.handleResize();
      return this;
    },

    /**
     * Event Handler for the Soho Popupmenu's custom 'show-submenu' event, specifically for
     * the case of a menu button that's been spilled over into this Toolbar's More Actions menu.
     * @param {jQuery.Event} e custom `show-submenu` jQuery event
     * @param {jQuery[]} li the `li.submenu` element.
     */
    handleTransferToMenuButtonItem: function handleTransferToMenuButtonItem(e, li) {
      var originalMenuButton = li.children('a').data('original-button');

      if (!originalMenuButton) {
        return;
      }

      var popupAPI = originalMenuButton.data('popupmenu');

      if (!popupAPI || typeof popupAPI.settings.beforeOpen !== 'function') {
        return;
      } // Call out to the MenuButton's AJAX source, get its contents, and populate
      // the corresponding More Actions menu sub-item.


      popupAPI.callSource(e);
      this.buildMoreActionsMenuItem(originalMenuButton);
    },

    /**
     * Event handler for the Soho `selected` event on toolbar items
     * @private
     * @param {jQuery.Event} e custom `selected` event
     * @param {jQuery[]} anchor a reference to the anchor that was selected
     * @returns {void}
     */
    handleSelected: function handleSelected(e, anchor) {
      var itemLink = anchor.data('original-button');
      var li = anchor.parent();
      var itemEvts;
      var toolbarEvts;
      var popup;
      var popupTrigger; // Don't continue if hidden/readonly/disabled

      if (li.is('.hidden, .is-disabled') || anchor.is('[readonly], [disabled]')) {
        e.preventDefault();
        return;
      }

      if (itemLink && itemLink.length > 0) {
        itemEvts = itemLink.listEvents();
        toolbarEvts = this.element.listEvents(); // Make sure the active button is set properly

        this.setActiveButton(itemLink); // Handle popdowns with a custom placement algorithm that correctly pops the menu
        // open against the "More Actions" button instead of in an empty space
        // SOHO-7087

        if (itemLink.is('[data-popdown]')) {
          popupTrigger = itemLink.data('popdown');

          if (this.isItemOverflowed(itemLink)) {
            popupTrigger.settings.trigger = this.more;
            popupTrigger.updated();
          }
        } // Fire Angular Events


        if (itemLink.attr('ng-click') || itemLink.attr('data-ng-click')) {
          itemLink.trigger('click');
          return;
        } // Check the Toolbar Button for the existence of certain event types.
        // Checks the button, and checks the toolbar container element for delegated events.


        var evtTypes = ['click', 'touchend', 'touchcancel'];

        for (var i = 0; i < evtTypes.length; i++) {
          var type = evtTypes[i]; // Check toolbar element for delegated-down events first

          if (toolbarEvts && toolbarEvts[type] && toolbarEvts[type].delegateCount > 0) {
            var el = this.element;
            var evt = $.Event(type);
            evt.target = el.find(itemLink)[0];
            el.trigger(evt);
            return;
          } // Check for events directly on the element


          if (itemEvts && itemEvts[type] || itemLink[0]["on".concat(type)]) {
            itemLink.trigger(type);
            return;
          }
        } // If the linked element is a child of a menu button, trigger its 'selected' event.


        popup = itemLink.parents('.popupmenu');
        popupTrigger = popup.data('trigger');

        if (popup.length && popupTrigger instanceof $ && popupTrigger.length) {
          popupTrigger.triggerHandler('selected', [itemLink]);
          return;
        } // Manually Trigger Select on the linked item, since it won't be done by another event


        this.triggerSelect(itemLink);
        return;
      } // If no item link exists, it's a pre-defined menu item.
      // Trigger 'selected' manually on the toolbar element.
      // Normally this would happen by virtue of triggering the "click"
      // handlers on a linked button above.


      this.triggerSelect(anchor);
    },

    /**
     * Event handler for clicks on toolbar items
     * @private
     * @listens {jQuery.Event} e
     * @param {jQuery.Event} e jQuery click event
     * @returns {boolean} basic "false" return expected for click events
     */
    handleClick: function handleClick(e) {
      this.setActiveButton($(e.currentTarget));
      this.triggerSelect($(e.currentTarget));
      return false;
    },

    /**
     * Event handler for key presses on toolbar items
     * @private
     * @listens {jQuery.Event} e
     * @param {jQuery.Event} e `keypress` event
     * @returns {void}
     */
    handleKeys: function handleKeys(e) {
      var self = this;
      var key = e.which;
      var target = $(e.target);
      var isActionButton = target.is('.btn-actions');
      var isRTL = Locale.isRTL();

      if (key === 37 && target.is(':not(input)') || key === 38 && target.is(':not(input.is-open)')) {
        // Don't navigate away if Up Arrow in autocomplete field that is open
        e.preventDefault();

        if (isActionButton) {
          self.setActiveButton(isRTL ? self.getFirstVisibleButton() : self.getLastVisibleButton());
        } else {
          self.navigate(isRTL ? 1 : -1);
        }
      }

      if (key === 39 && target.is(':not(input)') || key === 40 && target.is(':not(input.is-open)')) {
        // Don't navigate away if Down Arrow in autocomplete field that is open
        e.preventDefault();

        if (isActionButton) {
          self.setActiveButton(isRTL ? self.getLastVisibleButton() : self.getFirstVisibleButton());
        } else {
          self.navigate(isRTL ? -1 : 1);
        }
      }
    },

    /**
     * Re-renders the toolbar element and adjusts all internal parts to account for the new size.
     * @param {object} [containerDims] an object containing dimensions that can be set
     *  on the Toolbar's title and buttonset elements.
     * @param {number} [containerDims.title] represents the width that will be applied
     *  to the title element
     * @param {number} [containerDims.buttonset] represents the width that will be
     *  applied to the buttonset element
     * @returns {void}
     */
    handleResize: function handleResize(containerDims) {
      if (this.settings.resizeContainers) {
        var title = containerDims ? containerDims.title : undefined;
        var buttonset = containerDims ? containerDims.buttonset : undefined;
        this.sizeContainers(title, buttonset);
      }

      var buttons = this.getButtonsetButtons();

      for (var i = 0; i < buttons.length; i++) {
        buttons[i].removeClass('is-overflowed');
      }

      if (this.element.is(':not(:hidden)')) {
        this.adjustMenuItemVisibility();
        this.toggleMoreMenu(); // Added 9/16/2015 due to issue HFC-2876
      }
    },

    /**
     * Resizes the Toolbar's internal container areas (title, buttonset) to make
     * efficient use of their space.
     * @private
     * @chainable
     * @param {number} titleSize desired size of the title element.
     * @param {number} buttonsetSize desired size of the buttonset element.
     */
    sizeContainers: function sizeContainers(titleSize, buttonsetSize) {
      var containerElem = this.element[0];
      var titleElem = this.title[0];
      var buttonsetElem = this.buttonset[0];
      var moreElem = this.more[0]; // Don't do this at all unless we have a title element (which is optional)

      if (!this.title || !this.title.length) {
        return;
      } // If the element's hidden and has defined sizes, remove them so we can use the defaults.


      if (this.element.is(':hidden')) {
        buttonsetElem.style.width = '';
        titleElem.style.width = '';
        containerElem.classList.remove('do-resize');
        return;
      }

      var WHITE_SPACE = 30;
      var MIN_TITLE_SIZE = 44 + WHITE_SPACE;
      var MIN_BUTTONSET_SIZE = 0;
      buttonsetElem.style.width = '';
      titleElem.style.width = '';

      if (!containerElem.classList.contains('do-resize')) {
        containerElem.classList.add('do-resize');
      }

      var toolbarDims = $(containerElem).getHiddenSize();
      var buttonsetDims = $(buttonsetElem).getHiddenSize();
      var titleDims = $(titleElem).getHiddenSize();
      var moreDims = $(moreElem).getHiddenSize();
      var toolbarPadding = parseInt(toolbarDims.padding.left, 10) + parseInt(toolbarDims.padding.right, 10);

      if (isNaN(moreDims.width)) {
        moreDims.width = 50;
      }

      if (isNaN(buttonsetDims.width) || buttonsetDims.width < MIN_BUTTONSET_SIZE) {
        buttonsetDims.width = MIN_BUTTONSET_SIZE;
      }

      function addPx(val) {
        return "".concat(val, "px");
      } // Get the target size of the title element


      var self = this;
      var hasTitleSizeGetter = titleSize !== undefined && !isNaN(titleSize);
      var hasButtonsetSizeGetter = buttonsetSize !== undefined && !isNaN(buttonsetSize);
      var d;
      this.cutoffTitle = false; // Determine the target sizes for title, based on external setters,
      //  or building an estimated size.

      function getTargetTitleWidth() {
        if (hasTitleSizeGetter) {
          return parseInt(titleSize, 10);
        }

        if (self.settings.favorButtonset === true) {
          return toolbarDims.width - (toolbarPadding + (hasButtonsetSizeGetter ? parseInt(buttonsetSize, 10) : buttonsetDims.width) + moreDims.width);
        }

        return titleDims.scrollWidth;
      }

      var targetTitleWidth = getTargetTitleWidth(); // Determine the target sizes for buttonset

      function getTargetButtonsetWidth() {
        if (hasButtonsetSizeGetter) {
          return parseInt(buttonsetSize, 10);
        }

        if (self.settings.favorButtonset === true) {
          return buttonsetDims.width;
        }

        return toolbarDims.width - (toolbarPadding + (hasTitleSizeGetter ? parseInt(titleSize, 10) : titleDims.scrollWidth) + moreDims.width);
      }

      var targetButtonsetWidth = getTargetButtonsetWidth();

      if (this.settings.favorButtonset) {
        // Cut off the buttonset anyway if title is completely hidden.  Something's gotta give!
        if (targetTitleWidth < MIN_TITLE_SIZE) {
          this.cutoffTitle = true;
          d = Math.abs(targetTitleWidth - MIN_TITLE_SIZE);
          targetTitleWidth = MIN_TITLE_SIZE;
          targetButtonsetWidth -= d;
        }

        buttonsetElem.style.width = addPx(targetButtonsetWidth + 2);
        titleElem.style.width = addPx(targetTitleWidth - 2); // Recheck if title is overflowed to ellipsis

        if (titleElem.textContent && targetTitleWidth < stringUtils.textWidth(titleElem.textContent.trim())) {
          this.cutoffTitle = true;
        }

        if (targetTitleWidth > stringUtils.textWidth($(titleElem).find('h1').text().trim())) {
          this.cutoffTitle = false;
        }

        return;
      } //= =========================
      // Favor the title element
      // Cut off the title anyway if buttonset is completely hidden.  Something's gotta give!


      if (targetButtonsetWidth < MIN_BUTTONSET_SIZE) {
        this.cutoffTitle = true;
        d = Math.abs(targetButtonsetWidth - MIN_BUTTONSET_SIZE);
        targetButtonsetWidth = MIN_BUTTONSET_SIZE;
        targetTitleWidth -= d;
      } // Always favor the title by one extra px for Chrome


      titleElem.style.width = addPx(targetTitleWidth + 2);
      buttonsetElem.style.width = addPx(targetButtonsetWidth - 2);
    },

    /**
     * Changes the "active" button on the toolbar.
     * @param {number} direction can be `-1` (previous), `1` (next), or `0` (remain on current).
     * @returns {void}
     */
    navigate: function navigate(direction) {
      var items = this.items.filter(':visible:not(:disabled)');
      var current = items.index(this.activeButton);
      var next = current + direction;
      var target;

      if (next >= 0 && next < items.length) {
        target = items.eq(next);
      }

      if (next >= items.length) {
        target = items.first();
      }

      if (next === -1) {
        target = items.last();
      }

      if (this.isItemOverflowed(target)) {
        target = this.more;
      }

      this.setActiveButton(target);
    },

    /**
     * Gets a reference to the last visible (not overflowed) button inside of the buttonset.
     * @returns {jQuery[]} the last visible button in the buttonset.
     */
    getLastVisibleButton: function getLastVisibleButton() {
      var items = $(this.items.get().reverse()).not(this.more);
      var target;
      var i = 0;
      var elem;

      while (!target && i < items.length) {
        elem = $(items[i]);

        if (!this.isItemOverflowed(elem)) {
          target = elem;
          break;
        }

        i++;
      }

      if (!target || target.length === 0) {
        target = items.first();
      }

      while (target.length && target.is('.separator, *:disabled, *:hidden')) {
        target = target.prev();
      }

      return target;
    },

    /**
     * Gets a reference to the first visible (not overflowed) button inside of the buttonset.
     * @returns {jQuery[]} the first visible button in the buttonset.
     */
    getFirstVisibleButton: function getFirstVisibleButton() {
      var i = 0;
      var items = this.items;
      var target = items.eq(i);

      while (target.is('.separator, *:disabled, *:hidden')) {
        i++;
        target = items.eq(i);
      }

      return target;
    },

    /**
     * Sets the currently "active" (focused) Toolbar item
     * @param {jQuery[]} activeButton the preferred target element to make active.
     * @param {boolean} [noFocus] if defined, prevents this method from giving focus
     *  to the new active button.
     */
    setActiveButton: function setActiveButton(activeButton, noFocus) {
      // Return out of this if we're clicking the currently-active item
      if (activeButton[0] === this.activeButton[0]) {
        return;
      }

      var self = this;

      function getMoreOrLast() {
        if (self.moreButtonIsDisabled() || !self.element.hasClass('has-more-button')) {
          return self.getLastVisibleButton();
        }

        return self.more;
      }

      function getActiveButton() {
        // Menu items simply set the "More Actions" button as active
        if (activeButton.is('a')) {
          return getMoreOrLast();
        } // If it's the more button, hide the tooltip and set it as active


        var tooltip = self.more.data('tooltip');

        if (activeButton[0] === self.more[0]) {
          if (tooltip && tooltip.tooltip.is(':not(.hidden)')) {
            tooltip.hide();
          }

          return getMoreOrLast();
        } // Overflowed items also set


        if (self.isItemOverflowed(activeButton)) {
          if (!activeButton.is('.searchfield')) {
            return getMoreOrLast();
          }
        }

        return activeButton;
      }

      this.items.add(this.more).attr('tabindex', '-1').removeClass('is-selected');
      this.activeButton = getActiveButton();
      this.activeButton.addClass('is-selected').attr('tabindex', '0');

      if (!noFocus && this.activeButton[0]) {
        if (this.buttonsetItems.length > 1) {
          this.activeButton[0].focus();
        }
        /**
         * Fires when the Toolbar's currently `active` element has changed.
         *
         * @event navigate
         * @memberof Toolbar
         * @param {jQuery.Event} e the jQuery Event object
         * @param {jQuery} activeButton a reference to the new active button.
         */


        this.element.triggerHandler('navigate', [this.activeButton]);
      }
    },

    /**
     * Triggers a "selected" event on the base Toolbar element using a common element as an argument.
     * @param {HTMLElement|SVGElement|jQuery[]} element a jQuery Object containing an
     *  anchor tag, button, or input field.
     */
    triggerSelect: function triggerSelect(element) {
      var elem = $(element);

      if (elem.is(this.more) || elem.is('.btn-menu, li.submenu')) {
        return;
      }
      /**
       * Fires when a Toolbar item is selected.
       *
       * @event selected
       * @memberof Toolbar
       * @property {jQuery.Event} e the jQuery event object
       * @property {jQuery[]} itemLink a reference to the corresponding toolbar item, wrapped in a jQuery selector
       */


      this.element.triggerHandler('selected', [elem]);
    },

    /**
     * Assembles and returns a list of all buttons inside the Buttonset element.
     * @returns {array} of elements inside the buttonset
     */
    getButtonsetButtons: function getButtonsetButtons() {
      var buttons = [];
      var items = this.buttonsetItems;
      var item;

      for (var i = 0; i < items.length; i++) {
        item = items.eq(i);

        if (item.data('action-button-link') !== undefined && item.is(':not(.searchfield)')) {
          buttons.push(item);
        }
      }

      return buttons;
    },

    /**
     * Gets and Iterates through a list of toolbar items and determines which are
     * currently overflowed, and which are visible.
     * @param {array} buttons an Array of jQuery-wrapped elements that represents toolbar items.
     * @returns {object} containing a `visible` items array, and a `hidden` items array.
     */
    getVisibleButtons: function getVisibleButtons(buttons) {
      var self = this;
      var hiddenButtons = [];
      var visibleButtons = [];

      if (!buttons || !Array.isArray(buttons)) {
        buttons = this.getButtonsetButtons();
      }

      for (var i = 0; i < buttons.length; i++) {
        buttons[i][0].classList.remove('is-overflowed');
      }

      function getButtonVisibility(button) {
        if (!self.isItemOverflowed(button)) {
          visibleButtons.push(button);
        } else {
          hiddenButtons.push(button);
        }
      }

      for (var _i = 0; _i < buttons.length; _i++) {
        getButtonVisibility(buttons[_i]);
      }

      return {
        visible: visibleButtons,
        hidden: hiddenButtons
      };
    },

    /**
     * Gets and Iterates through the full list of Toolbar Items and determines which
     *  ones should currently be present in the More Actions menu.
     * @private
     * @param {object} items an object (normally generated by `_.getVisibleButtons()`)
     *  containing arrays of currently visible and hidden buttons, along with some meta-data.
     * @returns {void}
     */
    adjustMenuItemVisibility: function adjustMenuItemVisibility(items) {
      var iconDisplay = 'removeClass';

      if (!items) {
        items = this.getVisibleButtons();
      }

      function toggleClass($elem, doHide) {
        var elem = $elem[0];
        var li = $elem.data('action-button-link').parent()[0];
        var elemIsHidden = $elem.isHiddenAtBreakpoint();

        if (doHide) {
          li.classList.add('hidden');
          elem.classList.remove('is-overflowed');
          return;
        }

        if (!elemIsHidden) {
          li.classList.remove('hidden');
        }

        elem.classList.add('is-overflowed');

        if ($elem.find('.icon').length) {
          iconDisplay = 'addClass';
        }
      }

      var i = 0;

      for (i; i < items.visible.length; i++) {
        toggleClass(items.visible[i], true);
      }

      for (i = 0; i < items.hidden.length; i++) {
        toggleClass(items.hidden[i], false);
      }

      var numIcons = 0;
      this.moreMenu.find('.icon').each(function () {
        if (!$(this).parent().parent().hasClass('hidden') && !$(this).hasClass('icon-dropdown')) {
          numIcons++;
        }
      });

      if (numIcons > 0) {
        iconDisplay = 'addClass';
      }

      this.moreMenu[iconDisplay]('has-icons');
    },

    /**
     * Detects whether or not a toolbar item is currently overflowed.  In general,
     *  toolbar items are considered overflow if their right-most edge sits past the
     *  right-most edge of the buttonset border.  There are some edge-cases.
     * @param {jQuery[]} item the Toolbar item being tested.
     * @returns {boolean} whether or not the item belongs in the More Actions menu
     */
    isItemOverflowed: function isItemOverflowed(item) {
      // No items will be overflowed if the `More Actions` menu is purposefully disabled.
      if (this.moreButtonIsDisabled()) {
        return false;
      }

      if (!item || item.length === 0) {
        return true;
      }

      var itemIndexInButtonset = this.buttonsetItems.filter(':not(.hidden)').index(item);
      var maxVisibleButtons = this.settings.maxVisibleButtons; // the `maxVisibleButtons` calculation should include a visible More Actions button.
      // Subtract one from the `maxVisibleButtons` setting to account for the More Button,
      // if it's visible. See SOHO-7237

      if (this.moreButtonIsVisible()) {
        maxVisibleButtons -= 1;
      } // In cases where a Title is present and buttons are right-aligned,
      // only show up to the maximum allowed.


      if (this.title.length) {
        if (itemIndexInButtonset >= maxVisibleButtons) {
          return true;
        }
      }

      if (this.buttonset.scrollTop() > 0) {
        this.buttonset.scrollTop(0);
      } // unwrap from jQuery


      if (item instanceof $ && item.length) {
        item = item[0];
      }

      var classList = item.classList;
      var style = window.getComputedStyle(item);

      if (classList.contains('btn-actions')) {
        return true;
      }

      if (classList.contains('searchfield')) {
        return false;
      }

      if (style.display === 'none') {
        return true;
      }

      var isRTL = Locale.isRTL();
      var itemRect = item.getBoundingClientRect();
      var buttonsetRect = this.buttonset[0].getBoundingClientRect();
      var itemOutsideXEdge = isRTL ? itemRect.left <= buttonsetRect.left : itemRect.right >= buttonsetRect.right;
      var itemBelowYEdge = itemRect.bottom >= buttonsetRect.bottom;
      return itemBelowYEdge === true || itemOutsideXEdge === true;
    },

    /**
     * @returns {boolean} whether or not this toolbar is able to have a More Button
     */
    moreButtonIsDisabled: function moreButtonIsDisabled() {
      return this.element[0].classList.contains('no-actions-button');
    },

    /**
     * Detection for this toolbar to have a More Button
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @deprecated as of v4.4.0. Please use `moreButtonIsDisabled()` instead.
     * @returns {boolean} whether or not the More Actions button is disabled.
     */
    hasNoMoreButton: function hasNoMoreButton() {
      return deprecateMethod(this.moreButtonIsDisabled, this.hasNoMoreButton).apply(this);
    },

    /**
    * Detection for whether or not More Actions menu is currently visible.  This is
    * different than the More Actions menu being disabled.  This check determines
    * whether or not items have spilled over, causing the menu to be shown or hidden.
    * @returns {boolean} whether or not More Actions menu is currently visible.
    */
    moreButtonIsVisible: function moreButtonIsVisible() {
      return this.element[0].classList.contains('has-more-button');
    },

    /**
     * Determines whether or not the "more actions" button should be displayed.
     * @private
     * @returns {undefined} whether or not the "more actions" button should be displayed.
     */
    toggleMoreMenu: function toggleMoreMenu() {
      if (this.moreButtonIsDisabled()) {
        return;
      }

      var overflowItems = this.moreMenu.children('li:not(.separator)');
      var hiddenOverflowItems = overflowItems.not('.hidden');
      var method = 'removeClass';

      if (hiddenOverflowItems.length > 0) {
        method = 'addClass';
      }

      this.element[method]('has-more-button');
      var popupAPI = this.more.data('popupmenu');

      if (method === 'removeClass') {
        if (!popupAPI) {
          return;
        }

        popupAPI.close();
        var menuItems = popupAPI.menu.find('li:not(.separator)').children('a');
        var shouldFocus = false;
        menuItems.add(this.more).each(function () {
          if (document.activeElement === this) {
            shouldFocus = true;
          }
        });

        if (shouldFocus) {
          var lastVisibleButton = this.getLastVisibleButton()[0];

          if (lastVisibleButton) {
            lastVisibleButton.focus();
          }
        }
      }
    },

    /**
     * Creates an `aria-label` attribute on the toolbar, for bettery accessibility.
     * Based on AOL Access Guidelines:
     * http://access.aol.com/dhtml-style-guide-working-group/#toolbar
     * @private
     * @returns {void}
     */
    buildAriaLabel: function buildAriaLabel() {
      // Don't re-build if one already exists.
      if (this.element.attr('aria-label')) {
        return;
      }

      var isHeader = this.element.closest('.header').length === 1;
      var id = this.element.attr('id') || '';
      var title = this.element.children('.title');
      var prevLabel = this.element.prev('label');
      var prevSpan = this.element.prev('.label');

      function getLabelText() {
        if (isHeader) {
          return $('header.header').find('h1').text();
        }

        if (title.length) {
          return title.filter('div').text();
        }

        if (prevLabel.length) {
          return prevLabel.text();
        }

        if (prevSpan.length) {
          return prevSpan.text();
        }

        return "".concat(id, " ").concat(Locale.translate('Toolbar'));
      }

      var labelText = getLabelText();
      this.element.attr('aria-label', labelText.replace(/\s+/g, ' ').trim());
    },

    /**
     * @param {object} [settings] incoming different settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (this.settings.noSearchfieldReinvoke) {
        this.keepSearchfield = true;
      }

      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.teardown().init();
    },

    /**
     * Enables the entire Toolbar component
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.items.prop('disabled', false);
      this.more.prop('disabled', false);
    },

    /**
     * Disables the entire Toolbar component
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.items.prop('disabled', true);
      this.more.prop('disabled', true).data('popupmenu').close();
    },

    /**
     * Returns the Toolbar's internal markup to its original state.
     * @chainable
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var self = this;
      $('body').off("resize.toolbar-".concat(this.id));
      var moreMenuChildren = this.moreMenu === undefined ? [] : this.moreMenu.children('li');
      moreMenuChildren.each(function () {
        self.teardownMoreActionsMenuItem($(this), true);
      }); // Remove AJAX-ified menu items.

      moreMenuChildren.not(this.defaultMenuItems).remove();
      delete this.defaultMenuItems;
      delete this.hasDefaultMenuItems;
      this.items.each(function (i, item) {
        var tooltipAPI = $(item).data('tooltip');

        if (tooltipAPI && typeof tooltipAPI.destroy === 'function') {
          tooltipAPI.destroy();
        }

        var buttonAPI = $(item).data('button');

        if (buttonAPI && typeof buttonAPI.destroy === 'function') {
          buttonAPI.destroy();
        }

        item.classList.remove('is-overflowed');
        item.removeAttribute('tabindex');
      });
      this.items.off(["keydown.".concat(COMPONENT_NAME$L), "click.".concat(COMPONENT_NAME$L), "focus.".concat(COMPONENT_NAME$L), "blur.".concat(COMPONENT_NAME$L), "close.".concat(COMPONENT_NAME$L), "selected.".concat(COMPONENT_NAME$L)].join(' '));
      delete this.items;

      if (this.title && this.title.length) {
        var dataTooltip = this.title.off('beforeshow.toolbar').data('tooltip');

        if (dataTooltip && typeof dataTooltip.destroy === 'function') {
          dataTooltip.destroy();
        }

        this.title[0].style.width = '';
        delete this.cutoffTitle;
        delete this.title;
      }

      if (this.buttonsetItems) {
        delete this.buttonsetItems;
      }

      if (this.buttonset.children('.searchfield-wrapper').length) {
        // this flag is set in `updated()` if the setting `noSearchfieldReinvoke` is set
        // to `true` before an update is performed. The Searchfield will stay in-tact for
        // one update cycle, or until the setting is reset to `true`.
        if (!this.settings.noSearchfieldReinvoke && !this.keepSearchfield) {
          var searchFields = this.buttonset.children('.searchfield-wrapper').children('.searchfield');
          var searchFieldAPI = searchFields.data('searchfield');

          if (searchFieldAPI && typeof searchFieldAPI.destroy === 'function') {
            searchFields.data('searchfield').destroy();
          }
        } else if (this.keepSearchfield) {
          delete this.keepSearchfield;
        }
      }

      if (this.buttonset && this.buttonset.length) {
        this.buttonset[0].style.width = '';
        delete this.buttonset;
      }

      if (this.moreMenu) {
        delete this.moreMenu;
      }

      if (this.more.length && this.more.data('popupmenu') !== undefined) {
        this.more.off(["keydown.".concat(COMPONENT_NAME$L), "beforeopen.".concat(COMPONENT_NAME$L), "selected.".concat(COMPONENT_NAME$L), "show-submenu.".concat(COMPONENT_NAME$L)].join(' '));
        this.more.data('popupmenu').destroy();
        delete this.more;
      } // Only delete the references, not the markup


      if (this.activeButton) {
        delete this.activeButton;
      }

      this.element.off(["updated.".concat(COMPONENT_NAME$L), "recalculate-buttons.".concat(COMPONENT_NAME$L), "scrollup.".concat(COMPONENT_NAME$L)].join(' '));
      this.element[0].classList.remove('do-resize');
      this.element.removeAttr('role').removeAttr('aria-label');
      return this;
    },

    /**
     * Tears down a More Actions Menu item.
     * @private
     * @param {jQuery[]} item the existing <li> from inside the More Actions menu.
     * @param {boolean} doRemove if defined, causes the list item to be removed from
     *  the more actions menu.
     */
    teardownMoreActionsMenuItem: function teardownMoreActionsMenuItem(item, doRemove) {
      var self = this;
      var li = $(item);
      var a = li.children('a');
      var itemLink = a.data('original-button');
      a.off('mousedown.toolbar click.toolbar touchend.toolbar touchcancel.toolbar');
      var icons = li.find('.icon');

      if (icons.length) {
        icons.remove();
      }

      var submenuContainer;

      if (li.is('.submenu')) {
        submenuContainer = li.children('.wrapper').children('.popupmenu');
        submenuContainer.children('li').each(function () {
          self.teardownMoreActionsMenuItem($(this), true);
        });
      }

      if (itemLink && itemLink.length) {
        $.removeData(a[0], 'original-button');
        $.removeData(itemLink[0], 'action-button-link');
        a.remove();

        if (submenuContainer) {
          submenuContainer.off().parent('.wrapper').off().remove();
        }

        if (doRemove) {
          li.remove();
        }
      }
    },

    /**
     * Destroys this Toolbar Component instance and completely disassociates it from
     *  its corresponding DOM Element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$L);
    }
  };

  /**
   * jQuery Component Wrapper for Toolbar
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.toolbar = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$L);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$L, new Toolbar(this, settings));
      }
    });
  };

  var COMPONENT_NAME$M = 'editor';
  var EDITOR_PARENT_ELEMENTS = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'code'];
  /**
  * The Editor Component displays and edits markdown.
  *
  * @class Editor
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.buttons =
  * { editor: [ 'header1', 'header2', 'separator', 'bold', 'italic', 'underline', 'strikethrough',
  * 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist',
  * 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'source' ], source: [ 'visual' ] }]
  * An array with all the visible buttons in it.
  * @param {string} [settings.excludeButtons = { editor: ['backColor'], source: [] }] An array with all the buttons in it to excloude
  * @param {string} [settings.firstHeader = 'h3'] Allows you to set if the first header inserted is a h3 or h4 element.
  * You should set this to match the structure of the parent page for accessibility
  * @param {boolean} [settings.secondHeader = 'h4'] Allows you to set if the second header inserted is a h3 or
  * h4 element. You should set this to match the structure of the parent page for accessibility
  * @param {string} [settings.placeholder] If set to some text this will be shown as placeholder text in the editor.
  * @param {string} [settings.pasteAsPlainText = false] If true, when you paste into the editor the element will be unformatted to plain text.
  * @param {string} [settings.anchor = { url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false }] An object with settings related to controlling link behavior when inserted example: `{url: 'http://www.example.com', class: 'hyperlink', target: 'NewWindow', isClickable: false, showIsClickable: false},` the url is the default url to display. Class should normally stay hyperlink and represents the styling class. target can be 'NewWindow' or 'SameWindow', isClickable make the links appear clickable in the editor, showIsClickable will show a checkbox to allow the user to make clickable links in the link popup.
  * @param {string} [settings.image = { url: 'https://imgplaceholder.com/250x250/2578A9/ffffff/fa-image' }] Info object to populate the image dialog defaulting to ` {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}`
  * @param {function} [settings.onLinkClick = null] Call back for clicking on links to control link behavior.
  * @param {function} [settings.showHtmlView = false] If set to true, editor should be displayed in HTML view initialy.
  * @param {function} [settings.preview = false] If set to true, editor should be displayed in preview mode with noneditable content.
  * @param {string} [settings.paragraphSeparator = 'p'] Only can use 'p'|'br'|'div', If set to anything else will not run `defaultParagraphSeparator` execCommand.
  * @param {boolean} [settings.useFlexToolbar = false] if set to true, renders the toolbar as flex toolbar.
  * @param {boolean} [settings.useSourceFormatter = false] true will format the html content in source mode.
  * @param {boolean} [settings.formatterTabsize = 4] number of spaces can use for indentation.
  * @param {boolean} [settings.rows = null] Number of rows that will be shown in each part of the editor. Set like textarea rows attributes to adjust the height of the editor without css. Example: `{ editor: 10, source: 20 }`
  * @param {string|array} [settings.attributes = null] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var EDITOR_DEFAULTS = {
    buttons: {
      editor: ['fontPicker', 'separator', 'bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist', 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'clearFormatting', 'separator', 'source'],
      source: ['fontPicker', 'separator', 'bold', 'italic', 'underline', 'strikethrough', 'separator', 'foreColor', 'backColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight', 'separator', 'quote', 'orderedlist', 'unorderedlist', 'separator', 'anchor', 'separator', 'image', 'separator', 'clearFormatting', 'separator', 'visual']
    },
    excludeButtons: {
      editor: ['backColor'],
      source: ['backColor']
    },
    rows: {
      editor: null,
      source: null
    },
    delay: 200,
    placeholder: null,
    pasteAsPlainText: false,
    // anchor > target: 'SameWindow'|'NewWindow'| any string value
    anchor: {
      url: 'http://www.example.com',
      class: 'hyperlink',
      target: 'NewWindow',
      isClickable: false,
      showIsClickable: false
    },
    image: {
      url: '/images/placeholder-80x80.png'
    },
    onLinkClick: null,
    showHtmlView: false,
    preview: false,
    paragraphSeparator: 'p',
    useFlexToolbar: true,
    useSourceFormatter: false,
    formatterTabsize: 4,
    fontpickerSettings: {
      popupmenuSettings: {
        showArrow: false,
        offset: {
          y: 0
        }
      }
    },
    attributes: null
  };

  function Editor(element, settings) {
    this.settings = utils.mergeSettings(element, settings, EDITOR_DEFAULTS);

    if (settings !== null && settings !== void 0 && (settings == null ? void 0 : settings.buttons)) {
      this.settings.buttons = settings.buttons;
    }

    this.element = $(element);
    this.init();
  } // Editor Methods


  Editor.prototype = {
    /**
     * @returns {Toolbar|ToolbarFlex} a reference to the Editor's Toolbar API
     */
    get toolbarAPI() {
      var api;

      if (this.toolbar && this.toolbar.length) {
        api = this.toolbar.data(this.settings.useFlexToolbar ? 'toolbar-flex' : 'toolbar');
      }

      return api;
    },

    init: function init() {
      var _this = this;

      this.id = "".concat(utils.uniqueId(this.element, 'editor'), "-id");
      this.container = this.element.parent('.field, .field-short').addClass('editor-container');
      this.label = this.element.prevAll('.label').first(); // Preview mode

      if (!this.previewRendered && (this.element.hasClass('is-preview') || this.settings.preview)) {
        this.container[0].classList.add('is-preview');
        this.element[0].classList.remove('is-disabled', 'is-readonly', 'is-preview');
        this.element[0].setAttribute('contenteditable', false);
        this.element[0].removeAttribute('aria-multiline');
        this.element[0].removeAttribute('role');
        return;
      }

      var s = this.settings;
      s.anchor = $.extend({}, EDITOR_DEFAULTS.anchor, s.anchor);
      s.image = $.extend({}, EDITOR_DEFAULTS.image, s.image);
      s.anchor.defaultUrl = s.anchor.url;
      s.anchor.defaultClass = s.anchor.class;
      s.anchor.defaultTargetText = s.anchor.target;
      s.anchor.defaultIsClickable = s.anchor.isClickable;
      s.anchor.targets = s.anchor.targets || {
        SameWindow: '',
        NewWindow: '_blank'
      };
      $.each(this.settings.anchor.targets, function (key, val) {
        if (_this.settings.anchor.defaultTargetText.toLowerCase() === key.toLowerCase()) {
          _this.settings.anchor.target = val;
          _this.settings.anchor.defaultTarget = val;
        }
      }); // Convert legacy header settings into Fontpicker settings

      if (this.settings.firstHeader || this.settings.secondHeader) {
        if (!Array.isArray(this.settings.fontpickerSettings.styles)) {
          this.settings.fontpickerSettings.styles = [];
        }

        if (!this.settings.fontpickerSettings.styles.length) {
          this.settings.fontpickerSettings.styles.push(new FontPickerStyle('legacyDefault', 'Default'));
        }

        if (this.settings.firstHeader) {
          warnAboutDeprecation('`fontpickerSettings.styles` setting', '`firstHeader` setting', 'Editor Component');
          this.settings.fontpickerSettings.styles.push(new FontPickerStyle('legacyHeader1', 'Header 1', this.settings.firstHeader));
          delete this.settings.firstHeader;
        }

        if (this.settings.secondHeader) {
          warnAboutDeprecation('`fontpickerSettings.styles` setting', '`secondHeader` setting', 'Editor Component');
          this.settings.fontpickerSettings.styles.push(new FontPickerStyle('legacyHeader2', 'Header 2', this.settings.secondHeader));
          delete this.settings.secondHeader;
        }
      }

      if (s.buttons && s.buttons.editor) {
        var foundOldSettings = false;
        var styles = [new FontPickerStyle('default', 'Default', 'p')];
        var headers = s.buttons.editor.filter(function (el) {
          return el.substr(0, 6) === 'header';
        });

        for (var i = 0; i < headers.length; i++) {
          var hLevel = headers[i].substr(6, 1);
          foundOldSettings = true;
          styles.push(new FontPickerStyle("header".concat(hLevel), "Header ".concat(hLevel), "h".concat(hLevel)));
        }

        if (foundOldSettings) {
          s.buttons.editor = s.buttons.editor.filter(function (el) {
            return el.substr(0, 6) !== 'header';
          });
          s.fontpickerSettings = {
            styles: styles
          };
        }

        if (s.buttons.editor[0] === 'separator') {
          s.buttons.editor.splice(0, 1);
        }

        if (foundOldSettings) {
          s.buttons.editor = ['fontPicker'].concat(s.buttons.editor);
        }
      }

      if (!s.anchor.defaultTarget) {
        if (s.anchor.target && $.trim(s.anchor.target).length) {
          s.anchor.defaultTarget = s.anchor.target;
        } else {
          s.anchor.defaultTargetText = Locale.translate('SameWindow');
          s.anchor.defaultTarget = s.anchor.targets[s.anchor.defaultTargetText];
        }
      }

      this.setup(); // Set default paragraph separator

      if (typeof s.paragraphSeparator === 'string' && /^(p|br|div)$/.test(s.paragraphSeparator)) {
        document.execCommand('defaultParagraphSeparator', false, s.paragraphSeparator);
      }

      if (this.element.hasClass('is-readonly')) {
        this.readonly();
      }

      if (this.settings.showHtmlView) {
        this.toggleSource();
      }

      this.setRowsHeight();
      return this;
    },
    setup: function setup() {
      this.isActive = true;
      this.modals = {};
      this.initElements().bindSelect().bindPaste().setPlaceholders().bindWindowActions().setupKeyboardEvents().onPasteTriggered();
    },
    initElements: function initElements() {
      // Make it an editor
      this.element.attr({
        contentEditable: true,
        'aria-multiline': true,
        role: 'textbox',
        'aria-labelledby': this.container.find('.label').length ? this.container.find('.label')[0].id : 'no-id'
      }); // Bind functionality for Pre elements. We dont use this yet but could if we
      // want to edit code blocks.

      this.element.attr('data-editor', true); // Build the textarea that will be used as source view and for content serialization

      this.initTextarea();
      this.bindParagraphCreation().bindTab();
      this.createToolbar().bindButtons().bindModals().bindAnchorPreview();
      return this;
    },
    // Returns true if the source view is currently active.
    sourceViewActive: function sourceViewActive() {
      return this.element.hasClass('source-view-active');
    },
    // Bind Events for the place holder
    setPlaceholders: function setPlaceholders() {
      if (!this.settings.placeholder) {
        return this;
      }

      this.element.attr('placeholder', this.settings.placeholder);
      return this;
    },
    // Returns the currently visible element - either the main editor window,
    // or the source-view textarea
    getCurrentElement: function getCurrentElement() {
      return this.sourceViewActive() ? this.textarea : this.element;
    },
    bindParagraphCreation: function bindParagraphCreation() {
      var _this2 = this;

      var currentElement = this.getCurrentElement();
      currentElement.on('keyup.editor', function (e) {
        var node = _this2.getSelectionStart();

        var tagName;

        if (node && node.getAttribute('data-editor') && node.children.length === 0) {
          document.execCommand('formatBlock', false, 'p');
        }

        if (e.which === 13) {
          node = _this2.getSelectionStart();
          tagName = node.tagName.toLowerCase();

          if (tagName !== 'li' && !_this2.isListItemChild(node)) {
            if (!e.shiftKey) {
              document.execCommand('formatBlock', false, 'p');
            }

            if (tagName === 'a') {
              document.execCommand('unlink', false, null);
            }
          }
        }
      });
      return this;
    },
    bindTab: function bindTab() {
      var _this3 = this;

      var currentElement = this.getCurrentElement();
      currentElement.on('keydown.editor', function (e) {
        if (e.which === 9) {
          // Override tab only for pre nodes
          var tag = _this3.getSelectionStart().tagName.toLowerCase();

          if (tag === 'pre') {
            e.preventDefault();
            document.execCommand('insertHtml', null, '    ');
          } // Tab to indent list structures!


          if (tag === 'li') {
            e.preventDefault(); // If Shift is down, outdent, otherwise indent

            document.execCommand(e.shiftKey ? 'outdent' : 'indent', e);
          }
        }

        if (e.which === 8) {
          var text = _this3.element.text().toString().trim().replace(/\s/g, '');

          if (window.getSelection().toString().trim().replace(/\s/g, '') === text) {
            _this3.element.html('');
          }
        }
      });
      return this;
    },
    // Set excluded buttons
    setExcludedButtons: function setExcludedButtons() {
      var _this4 = this;

      var excludeButtons = function excludeButtons(elements, toExclude) {
        var separatorIndex = -1;
        var numOfExcluded = 0;
        return elements.filter(function (x, i) {
          var r = true; // Exclude matching buttons but keep separator/s

          if (toExclude.indexOf(x) > -1 && x !== 'separator') {
            numOfExcluded++;
            r = false;
          } else if (x === 'separator' && i - numOfExcluded - 1 === separatorIndex) {
            // Exclude extra separator/s
            numOfExcluded = 0;
            r = false;
          }

          if (x === 'separator') {
            separatorIndex = i;
          }

          return r;
        });
      }; // Run only if it needs (excludeButtons)


      var setButtons = function setButtons() {
        var s = _this4.settings;
        var btns = s.buttons;
        var exBtns = s.excludeButtons;

        if (_this4.sourceViewActive()) {
          return exBtns && exBtns.source && exBtns.source.length ? excludeButtons(btns.source, exBtns.source) : btns.source;
        }

        return exBtns && exBtns.editor && exBtns.editor.length ? excludeButtons(btns.editor, exBtns.editor) : btns.editor;
      };

      return setButtons();
    },

    /**
     * @private
     * @returns {this} component instance
     */
    createToolbar: function createToolbar() {
      var _this5 = this;

      if (this.toolbar) {
        return this;
      }

      var toolbarCssClasses = [this.settings.useFlexToolbar ? 'flex-toolbar' : 'toolbar', 'editor-toolbar', 'formatter-toolbar'].join(' ');
      var sectionCss = '';
      var moreButtonHTML = '';

      if (this.settings.useFlexToolbar) {
        sectionCss = 'toolbar-section ';
        moreButtonHTML = "<div class=\"toolbar-section more\">\n        <button class=\"btn-actions btn-editor\">\n          <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n            <use href=\"#icon-more\"></use>\n          </svg>\n        </button>\n      </div>";
      }

      var btns = this.setExcludedButtons();
      var buttonsHTML = '';

      for (var i = 0, l = btns.length; i < l; i += 1) {
        var btn = this.buttonTemplate(btns[i]);

        if (btn && this.element.hasClass('source-view-active') && btns[i] !== 'visual') {
          btn = btn.replace('type="button"', 'type="button" disabled');
        }

        if (btn) {
          buttonsHTML += btn;
        }
      } // Add automation attributes to each buttons


      var btnAttributes = '';

      if (this.settings.attributes) {
        btnAttributes = this.getAutomationAttributes('-editor-toolbar');
        btnAttributes = JSON.stringify(btnAttributes);
        btnAttributes = " data-options='{\"attributes\": ".concat(btnAttributes, "}'");
      }

      var toolbar = "<div class=\"".concat(toolbarCssClasses, "\" data-init=\"false\" id=\"editor-toolbar-").concat(this.id, "\"").concat(btnAttributes, ">\n      <div class=\"").concat(sectionCss, "buttonset\">\n        ").concat(buttonsHTML, "\n      </div>\n      ").concat(moreButtonHTML, "\n    </div>");

      if (this.element.parent().find('.icon-dirty').length) {
        this.toolbar = $(toolbar).insertBefore(this.element.parent().find('.icon-dirty'));
      } else {
        this.toolbar = $(toolbar).insertBefore(this.sourceViewActive() ? this.element.prev() : this.element);
      } // Invoke Fontpicker, if applicable


      var fpElement = this.toolbar.find('[data-action="fontStyle"]').first();

      if (fpElement && fpElement.length) {
        // Set suffix for fontpicker automation attributes
        if (this.settings.attributes) {
          var fpAttributes = this.getAutomationAttributes('-editor-fontpicker');

          if (_typeof(this.settings.fontpickerSettings.popupmenuSettings) === 'object') {
            this.settings.fontpickerSettings.popupmenuSettings.attributes = fpAttributes;
          } else if (!this.settings.fontpickerSettings.popupmenuSettings) {
            this.settings.fontpickerSettings.popupmenuSettings = {
              attributes: fpAttributes
            };
          }
        }

        fpElement.fontpicker(this.settings.fontpickerSettings);
        this.fontPickerElem = fpElement;
      } // Invoke Colorpicker, if applicable


      var cpElements = this.toolbar.find('[data-action="foreColor"], [data-action="backColor"]');
      cpElements.colorpicker({
        placeIn: 'editor',
        popupmenuSettings: {
          offset: {
            y: 0
          },
          showArrow: false
        }
      });
      $('.trigger', cpElements).off('click.colorpicker'); // Invoke the (Flex?) Toolbar

      this.toolbar[this.settings.useFlexToolbar ? 'toolbarflex' : 'toolbar']({
        moreMenuSettings: {
          offset: {
            y: 0
          },
          showArrow: false
        }
      }); // Invoke Tooltips

      this.toolbar.find('button[title]').tooltip(); // Adjust color picker alignment, for opened by toolbar overflowed items

      cpElements.on('beforeopen.editor', function (e, menu) {
        var toolbarApi = _this5.toolbar.data('toolbar') || _this5.toolbar.data('toolbar-flex');

        if (toolbarApi) {
          toolbarApi.overflowedItems.forEach(function (item) {
            if (item.type === 'colorpicker' && menu) {
              menu.parent('.popupmenu-wrapper').off('afterplace.editor') // if reached more then once
              .one('afterplace.editor', function (evt, args) {
                if (typeof args.width === 'undefined') {
                  var _args$container, _args$element;

                  var containerW = ((_args$container = args.container) === null || _args$container === void 0 ? void 0 : _args$container == null ? void 0 : _args$container.outerWidth()) || -1;
                  var elementW = ((_args$element = args.element) === null || _args$element === void 0 ? void 0 : _args$element == null ? void 0 : _args$element.outerWidth()) || -1;
                  var left = (containerW - elementW) / 2;

                  if (left > -1) {
                    args.element.css('left', "".concat(left, "px"));
                  }
                }
              });
            }
          });
        }
      });
      return this;
    },

    /**
     * Get append suffix with automation attributes
     * @private
     * @param {string} suffix to use
     * @returns {object|array} attributes with suffix
     */
    getAutomationAttributes: function getAutomationAttributes(suffix) {
      var _this6 = this;

      var s = this.settings;
      var attributes = s.attributes;

      if (s.attributes && typeof suffix === 'string' && suffix !== '') {
        if (Array.isArray(s.attributes)) {
          attributes = [];
          s.attributes.forEach(function (item) {
            var value = typeof item.value === 'function' ? item.value(_this6) : item.value;
            attributes.push({
              name: item.name,
              value: value + suffix
            });
          });
        } else {
          var value = typeof s.attributes.value === 'function' ? s.attributes.value(this) : s.attributes.value;
          attributes = {
            name: s.attributes.name,
            value: value + suffix
          };
        }
      }

      return attributes;
    },

    /**
    * Switch between source and editing toolbar.
    * @returns {void}
    */
    switchToolbars: function switchToolbars() {
      this.destroyToolbar(); // Rebind everything to the new element

      this.setupTextareaEvents();
      this.createToolbar();
      this.bindButtons().bindModals().bindAnchorPreview();
      this.bindSelect().bindPaste().setupKeyboardEvents();
      this.toolbar.find('button').button();
    },
    initTextarea: function initTextarea() {
      var _this7 = this;

      var self = this;

      if (this.textarea && !this.settings.showHtmlView) {
        return this;
      }

      this.textarea = this.createTextarea(); // fill the text area with any content that may already exist within the editor DIV

      this.textarea.text(xssUtils.sanitizeHTML(this.element.html().toString()));
      self.container.on('input.editor keyup.editor', '.editor', debounce(function (e) {
        _this7.textarea.text(xssUtils.sanitizeHTML(_this7.element.html().toString()));

        _this7.resetEmptyEditor(e);

        _this7.element.trigger('change');
      }, 400));
      $('html').on("themechanged.".concat(COMPONENT_NAME$M), function () {
        _this7.setRowsHeight();

        if (!_this7.sourceView.hasClass('hidden')) {
          _this7.adjustSourceLineNumbers();
        }
      });
      this.setupTextareaEvents();
      return this.textarea;
    },

    /**
     * Set or reset the `rows` setting height
     * @private
     */
    setRowsHeight: function setRowsHeight() {
      var _this$settings, _this$settings$rows, _this$settings3, _this$settings3$rows;

      var isUplift = theme.currentTheme.id && theme.currentTheme.id.indexOf('uplift') > -1;

      if ((_this$settings = this.settings) !== null && _this$settings !== void 0 && (_this$settings$rows = _this$settings == null ? void 0 : _this$settings.rows) !== null && _this$settings$rows !== void 0 && (_this$settings$rows == null ? void 0 : _this$settings$rows.editor)) {
        var _this$settings2, _this$settings2$rows;

        this.element.height(((_this$settings2 = this.settings) === null || _this$settings2 === void 0 ? void 0 : (_this$settings2$rows = _this$settings2 == null ? void 0 : _this$settings2.rows) === null || _this$settings2$rows === void 0 ? void 0 : _this$settings2$rows == null ? void 0 : _this$settings2$rows.editor) * (isUplift ? 26 : 22.2));
      }

      if ((_this$settings3 = this.settings) !== null && _this$settings3 !== void 0 && (_this$settings3$rows = _this$settings3 == null ? void 0 : _this$settings3.rows) !== null && _this$settings3$rows !== void 0 && (_this$settings3$rows == null ? void 0 : _this$settings3$rows.source)) {
        var _this$settings4, _this$settings4$rows;

        this.element.parent().find('.editor-source').height(((_this$settings4 = this.settings) === null || _this$settings4 === void 0 ? void 0 : (_this$settings4$rows = _this$settings4 == null ? void 0 : _this$settings4.rows) === null || _this$settings4$rows === void 0 ? void 0 : _this$settings4$rows == null ? void 0 : _this$settings4$rows.source) * (isUplift ? 26 : 26) + 15);
      }
    },

    /**
     * Clean up the editor content on change.
     * @private
     */
    resetEmptyEditor: function resetEmptyEditor() {
      this.savedSelection = this.saveSelection();
      var sep = this.settings.paragraphSeparator === 'p' ? 'p' : 'div';
      var html = this.element.html().toString().trim(); // Cleanout browser specific logic to level things

      html = this.element.html().toString().trim();

      if (html === '<br>' || html === "<".concat(sep, "><br></").concat(sep, ">")) {
        this.element.html('');
      }

      this.element.contents().filter(function () {
        return this.nodeType === 3 && this.textContent.trim() !== '';
      }).wrap("<".concat(sep, "></").concat(sep, ">"));
      html = this.element.html().toString().trim();
      this.textarea.html(xssUtils.sanitizeHTML(html));
      var newSelection = this.saveSelection();

      var isNumber = function isNumber(n) {
        return typeof n === 'number';
      };

      var isPresent = function isPresent(obj) {
        return obj && obj[0] && isNumber(obj[0].startOffset) && isNumber(obj[0].endOffset);
      };

      var getOffset = function getOffset(obj) {
        return isPresent(obj) ? {
          start: obj[0].startOffset,
          end: obj[0].endOffset
        } : null;
      };

      var offset = {
        old: getOffset(this.savedSelection),
        new: getOffset(newSelection)
      };

      if (!(offset.old !== null && offset.new !== null && offset.old.start === offset.new.start && offset.old.end === offset.new.end)) {
        this.restoreSelection(this.savedSelection);
      }
    },

    /**
     * Remove whitespace between tags.
     * @private
     */
    removeWhiteSpace: function removeWhiteSpace() {
      var html = this.element.html().toString().trim();

      var count = function count(str) {
        var re = />\s+</g;
        return ((str || '').match(re) || []).length;
      }; // Remove Whitepsace after tags


      if (count(html) > 0) {
        this.element.html(html.replace(/>\s+</g, '><'));
      }
    },

    /**
     * Do creation and setup on the editor.
     * @private
     * @returns {object} The proto object for chaining.
     */
    createTextarea: function createTextarea() {
      this.sourceView = $('<div></div>').attr({
        class: 'editor-source editable hidden',
        id: "editor-source-".concat(this.id)
      }).insertBefore(this.element);
      $('<ul></ul>').addClass('line-numbers').appendTo(this.sourceView);
      var textareaContainer = $('<div class="text-container"></div>').appendTo(this.sourceView);
      var newTextareaID = "source-textarea-".concat($('[id^="source-textarea-"]').length + 1);
      var labelContents = "".concat(this.element.prev('.label').addClass('audible').text(), " - HTML Source View");
      $("<label class=\"audible\" for=\"".concat(newTextareaID, "\">").concat(labelContents, "</label>")).appendTo(textareaContainer);
      var textarea = $("<textarea id=\"".concat(newTextareaID, "\" class=\"editable\"></textarea>")).appendTo(textareaContainer);
      return textarea;
    },

    /**
     * Trigger the click event on the buttons.
     * @param  {object} e the event data
     * @param  {object} btn the button types to trigger
     */
    triggerClick: function triggerClick(e, btn) {
      $("button[data-action=\"".concat(btn, "\"]"), this.toolbar).trigger('click.editor');
    },

    /**
     * Set up keyboard handling.
     * @private
     * @returns {object} The proto object for chaining.
     */
    setupKeyboardEvents: function setupKeyboardEvents() {
      var _this8 = this;

      var currentElement = this.getCurrentElement();
      var keys = {
        b: 66,
        // {Ctrl + B} bold
        e: 69,
        // {Ctrl + E} justifyCenter
        h: 72,
        // {Ctrl + H} anchor
        i: 73,
        // {Ctrl + I} italic --------with SHIFT: {Ctrl + Shift + I} image
        l: 76,
        // {Ctrl + L} justifyLeft
        bl: 55,
        // {Ctrl + Shift + 7} bullet list
        n: 56,
        // {Ctrl + Shift + 8} numbered list
        q: 81,
        // {Ctrl + Q} blockquotes
        r: 82,
        // {Ctrl + R} justifyRight
        u: 85,
        // {Ctrl + U} underline
        h3: 51,
        // {Ctrl + 3} h3
        h4: 52,
        // {Ctrl + 4} h4
        space: 32,
        // {Ctrl + Space} Clear Formatting
        sv: 192 // {Ctrl + ~} toggle source -or- visualview

      };
      currentElement.on('keydown.editor', function (e) {
        e = e || window.event;

        if (e.which) {
          keys.charCode = e.which;
        } else if (e.keyCode) {
          keys.charCode = e.keyCode;
        } else {
          keys.charCode = false;
        }

        switch (e.ctrlKey && keys.charCode) {
          case keys.h3:
            _this8.triggerClick(e, "append-".concat(_this8.settings.firstHeader));

            break;

          case keys.h4:
            _this8.triggerClick(e, "append-".concat(_this8.settings.secondHeader));

            break;

          case keys.b:
            _this8.triggerClick(e, 'bold');

            e.preventDefault();
            break;

          case keys.e:
            _this8.triggerClick(e, 'justifyCenter');

            break;

          case keys.h:
            _this8.triggerClick(e, 'anchor');

            e.preventDefault();
            break;

          case keys.i:
            _this8.triggerClick(e, e.shiftKey ? 'image' : 'italic');

            if (!e.shiftKey) {
              e.preventDefault();
            }

            break;

          case keys.bl:
            if (e.shiftKey) {
              _this8.triggerClick(e, 'insertunorderedlist');
            }

            e.preventDefault();
            break;

          case keys.l:
            if (!e.shiftKey) {
              _this8.triggerClick(e, 'justifyLeft');
            }

            e.preventDefault();
            break;

          case keys.n:
            if (e.shiftKey) {
              _this8.triggerClick(e, 'insertorderedlist');
            }

            break;

          case keys.q:
            _this8.triggerClick(e, 'append-blockquote');

            break;

          case keys.r:
            _this8.triggerClick(e, 'justifyRight');

            break;

          case keys.u:
            _this8.triggerClick(e, 'underline');

            e.preventDefault();
            break;

          case keys.space:
            _this8.triggerClick(e, 'clearFormatting');

            break;

          case keys.sv:
            _this8.triggerClick(e, currentElement === _this8.element ? 'source' : 'visual');

            break;
        }
      }); // Open link in new windows/tab, if clicked with command-key(for mac) or ctrl-key(for windows)

      this.element.on('mousedown.editor', 'a', function (e) {
        var href = $(this).attr('href');

        if (Environment.browser.name !== 'firefox' && Environment.os.name === 'Mac OS X' && (e.metaKey || e.ctrlKey)) {
          window.open(href, '_blank');
          e.preventDefault();
        }
      });
      this.element.on('updated.editor', function () {
        _this8.updated();
      });
      return this;
    },
    setupTextareaEvents: function setupTextareaEvents() {
      var _this9 = this;

      // Adjust line numbers on input
      this.textarea.off('.editor').on('input.editor keyup.editor', function () {
        if (!_this9.sourceView.hasClass('hidden')) {
          _this9.adjustSourceLineNumbers();
        }
      }).on('focus.editor', function () {
        _this9.sourceView.addClass('is-focused');
      }).on('blur.editor', function (e) {
        _this9.sourceView.removeClass('is-focused');

        _this9.element.empty().html(xssUtils.sanitizeHTML(_this9.textarea.val()));

        if (_this9.element.data('validate')) {
          _this9.element.data('validate').validate(_this9.element, true, e);
        }
      });
      return this;
    },

    /**
     * Set the heights and adjust the line number feature.
     * @private
     * @returns {void}
     */
    adjustSourceLineNumbers: function adjustSourceLineNumbers() {
      var container = this.textarea.parent();
      var lineHeight = parseInt(getComputedStyle(this.textarea[0]).lineHeight, 10);
      var YPadding = this.textarea.innerHeight() - this.textarea.height();
      this.textarea[0].style.height = '';
      var scrollHeight = this.textarea[0].scrollHeight;
      var lineNumberCount = Math.floor((scrollHeight - YPadding) / lineHeight);
      var numberList = this.sourceView.find('.line-numbers');
      var lastIdx = numberList.find('li').length;
      var list = '';
      var i = 0;

      if (!this.lineNumbers || lineNumberCount !== this.lineNumbers) {
        if (!this.lineNumbers) {
          // Build the list of line numbers from scratch
          this.lineNumbers = lineNumberCount;

          while (i < this.lineNumbers) {
            list += "<li role=\"presentation\"><span>".concat(i + 1, "</span></li>");
            i++;
          }

          numberList.append(list);
        } else if (this.lineNumbers < lineNumberCount) {
          // Add extra line numbers to the bottom
          while (i < lineNumberCount - this.lineNumbers) {
            list += "<li role=\"presentation\"><span>".concat(lastIdx + i + 1, "</span></li>");
            i++;
          }

          numberList.append(list);
        } else if (this.lineNumbers > lineNumberCount) {
          // Remove extra line numbers from the bottom
          i = this.lineNumbers - lineNumberCount;
          numberList.find('li').slice(-i).remove();
        }

        this.lineNumbers = lineNumberCount;
      }

      container[0].style.width = "calc(100% - ".concat(numberList.outerWidth() + 2, "px)");

      if (scrollHeight !== this.textarea[0].scrollHeight) {
        this.adjustSourceLineNumbers();
        return;
      }

      this.textarea[0].style.height = "".concat(numberList[0].scrollHeight - 13, "px");
    },
    wrapTextInTags: function wrapTextInTags(insertedText, selectedText, action) {
      var tags;
      var finalText;

      switch (action) {
        case 'bold':
          tags = ['<b>', '</b>'];
          break;

        case 'italic':
          tags = ['<i>', '</i>'];
          break;

        case 'underline':
          tags = ['<u>', '</u>'];
          break;

        case 'strikethrough':
          tags = ['<strike>', '</strike>'];
          break;

        case 'append-blockquote':
          tags = ['<blockquote>', '</blockquote>'];
          break;

        default:
          tags = ['', ''];
      }

      if (action === 'anchor') {
        var alink = $("<a href=\"".concat(insertedText, "\">").concat(selectedText, "</a>"));

        if (this.settings.anchor.class && $.trim(this.settings.anchor.class).length) {
          alink.addClass(this.settings.anchor.class);
        }

        if (this.settings.anchor.target && $.trim(this.settings.anchor.target).length) {
          alink.attr('target', this.settings.anchor.target);
        }

        if (this.settings.anchor.isClickable) {
          alink.attr('contenteditable', false);
        } else {
          alink.removeAttr('contenteditable');
        }

        finalText = alink[0].outerHTML;
      } else {
        finalText = tags[0] + insertedText + selectedText + tags[1];
      }

      return finalText;
    },
    insertTextAreaContent: function insertTextAreaContent(text, action) {
      var el = this.textarea[0];
      var val = el.value;
      var sel;
      var startPos;
      var endPos;
      var scrollTop; // Always have empty text

      text = text || '';

      if (document.selection && el.tagName === 'TEXTAREA') {
        // IE textarea support
        $(el).focus();
        sel = document.selection.createRange();
        sel.text = this.wrapTextInTags(text, sel.text, action);
        $(el).focus();
      } else if (el.selectionStart || el.selectionStart === '0') {
        // MOZILLA/NETSCAPE support
        startPos = el.selectionStart;
        endPos = el.selectionEnd;
        scrollTop = el.scrollTop;
        sel = this.wrapTextInTags(text, val.substring(startPos, endPos), action);
        el.value = val.substring(0, startPos) + sel + val.substring(endPos, val.length);
        $(el).focus();
        el.selectionStart = startPos + sel.length;
        el.selectionEnd = startPos + sel.length;
        el.scrollTop = scrollTop;
      } else {
        // IE input[type=text] and other browsers
        el.value += this.wrapTextInTags(text, el.value, action);
        $(el).focus();
        /* eslint-disable no-self-assign */

        el.value = el.value; // hack to force cursor to end of text

        /* eslint-enable no-self-assign */
      }
    },
    buttonTemplate: function buttonTemplate(btnType) {
      var buttonLabels = this.getButtonLabels(this.settings.buttonLabels);
      var buttonTemplates = {
        bold: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ToggleBold'), "\" data-action=\"bold\" data-element=\"b\">").concat(buttonLabels.bold, "</button>"),
        italic: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ToggleItalic'), "\" data-action=\"italic\" data-element=\"i\">").concat(buttonLabels.italic, "</button>"),
        underline: "<button type=\"button\" class=\"btn btn-editor underline\" title=\"".concat(Locale.translate('ToggleUnderline'), "\" data-action=\"underline\" data-element=\"u\">").concat(buttonLabels.underline, "</button>"),
        strikethrough: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('StrikeThrough'), "\" data-action=\"strikethrough\" data-element=\"strike\">").concat(buttonLabels.strikethrough, "</button>"),
        foreColor: "<button type=\"button\" class=\"btn btn-editor colorpicker-editor-button\" title=\"".concat(Locale.translate('TextColor'), "\" data-action=\"foreColor\" data-element=\"foreColor\" data-init=\"false\">").concat(buttonLabels.foreColor, "</button>"),
        backColor: "<button type=\"button\" class=\"btn btn-editor colorpicker-editor-button\" title=\"".concat(Locale.translate('BackgroundColor'), "\" data-action=\"backColor\" data-element=\"backColor\">").concat(buttonLabels.backColor, "</button>"),
        superscript: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('Superscript'), "\" data-action=\"superscript\" data-element=\"sup\">").concat(buttonLabels.superscript, "</button>"),
        subscript: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('Subscript'), "\" data-action=\"subscript\" data-element=\"sub\">").concat(buttonLabels.subscript, "</button>"),
        separator: '<div class="separator"></div>',
        anchor: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('InsertAnchor'), "\" data-action=\"anchor\" data-modal=\"modal-url-").concat(this.id, "\" data-element=\"a\">").concat(buttonLabels.anchor, "</button>"),
        image: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('InsertImage'), "\" data-action=\"image\" data-modal=\"modal-image-").concat(this.id, "\" data-element=\"img\">").concat(buttonLabels.image, "</button>"),
        header1: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ToggleH3'), "\" data-action=\"append-").concat(this.settings.firstHeader, "\" data-element=\"").concat(this.settings.firstHeader, "\">").concat(buttonLabels.header1, "</button>"),
        header2: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ToggleH4'), "\" data-action=\"append-").concat(this.settings.secondHeader, "\" data-element=\"").concat(this.settings.secondHeader, "\">").concat(buttonLabels.header2, "</button>"),
        quote: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('Blockquote'), "\" data-action=\"append-blockquote\" data-element=\"blockquote\">").concat(buttonLabels.quote, "</button>"),
        orderedlist: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('OrderedList'), "\" data-action=\"insertorderedlist\" data-element=\"ol\">").concat(buttonLabels.orderedlist, "</button>"),
        unorderedlist: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('UnorderedList'), "\" data-action=\"insertunorderedlist\" data-element=\"ul\">").concat(buttonLabels.unorderedlist, "</button>"),
        fontPicker: "<button type=\"button\" class=\"btn btn-editor fontpicker\" data-action=\"fontStyle\" data-init=\"false\"><span>".concat('FontPicker', "</span></button>"),
        justifyLeft: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('JustifyLeft'), "\" data-action=\"justifyLeft\" >").concat(buttonLabels.justifyLeft, "</button>"),
        justifyCenter: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('JustifyCenter'), "\" data-action=\"justifyCenter\">").concat(buttonLabels.justifyCenter, "</button>"),
        justifyRight: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('JustifyRight'), "\" data-action=\"justifyRight\" >").concat(buttonLabels.justifyRight, "</button>"),
        clearFormatting: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ClearFormatting'), "\" data-action=\"clearFormatting\" >").concat(buttonLabels.clearFormatting, "</button>"),
        source: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ViewSource'), "\" data-action=\"source\" >").concat(buttonLabels.source, "</button>"),
        visual: "<button type=\"button\" class=\"btn btn-editor\" title=\"".concat(Locale.translate('ViewVisual'), "\" data-action=\"visual\" >").concat(buttonLabels.visual, "</button>")
      };
      return buttonTemplates[btnType] || false;
    },
    getIcon: function getIcon(textName, iconName, className) {
      return "<span class=\"audible\">".concat(Locale.translate(textName), "</span>").concat($.createIcon({
        classes: className || '',
        icon: iconName
      }));
    },
    getButtonLabels: function getButtonLabels(buttonLabelType) {
      var buttonLabels = {
        bold: this.getIcon('Bold', 'bold'),
        italic: this.getIcon('Italic', 'italic'),
        underline: this.getIcon('Underline', 'underline'),
        superscript: '<span aria-hidden="true"><b>x<sup>1</sup></b></span>',
        subscript: '<span aria-hidden="true"><b>x<sub>1</sub></b></span>',
        strikethrough: this.getIcon('StrikeThrough', 'strike-through'),
        foreColor: this.getIcon('TextColor', 'fore-color'),
        backColor: this.getIcon('BackgroundColor', 'back-color'),
        anchor: this.getIcon('InsertAnchor', 'link'),
        image: this.getIcon('InsertImage', 'insert-image'),
        header1: this.getIcon('ToggleH3', 'h3'),
        header2: this.getIcon('ToggleH4', 'h4'),
        quote: this.getIcon('Blockquote', 'quote'),
        orderedlist: this.getIcon('OrderedList', 'number-list'),
        unorderedlist: this.getIcon('UnorderedList', 'bullet-list'),
        pre: '<span aria-hidden="true"><b>0101</b></span>',
        indent: '<span aria-hidden="true"><b>&rarr;</b></span>',
        outdent: '<span aria-hidden="true"><b>&larr;</b></span>',
        justifyLeft: this.getIcon('JustifyLeft', 'left-text-align'),
        justifyCenter: this.getIcon('JustifyCenter', 'center-text'),
        justifyRight: this.getIcon('JustifyRight', 'right-text-align'),
        clearFormatting: this.getIcon('ClearFormatting', 'clear-formatting'),
        source: this.getIcon('ViewSource', 'html', 'html-icon'),
        visual: this.getIcon('ViewVisual', 'visual', 'visual-icon')
      };
      var customButtonLabels;

      if (_typeof(buttonLabelType) === 'object') {
        customButtonLabels = buttonLabelType;
      }

      if (_typeof(customButtonLabels) === 'object') {
        for (var attrname in customButtonLabels) {
          if (customButtonLabels.hasOwnProperty(attrname)) {
            // eslint-disable-line
            buttonLabels[attrname] = customButtonLabels[attrname];
          }
        }
      }

      return buttonLabels;
    },
    // Show the Buttons
    activateButton: function activateButton(tag) {
      this.toolbar.find("[data-element=\"".concat(tag, "\"]")).addClass('is-active');
    },
    // Bind Events to Toolbar Buttons
    bindButtons: function bindButtons() {
      var _this10 = this;

      var self = this;

      function editorButtonActionHandler(e, item) {
        var btn = item instanceof ToolbarFlexItem ? $(item.element) : $(e.target); // Don't do anything if it's the More Button

        if (btn.is('.btn-actions')) {
          return;
        }

        var action = btn.attr('data-action');
        var currentElem = self.getCurrentElement();
        e.preventDefault();
        currentElem.focus();

        if (self.selection === undefined) {
          self.checkSelection();
        }

        if (!self.sourceViewActive()) {
          btn.toggleClass('is-active');
        }

        if (action) {
          self.execAction(action, e);

          if (btn && !self.isBtnOverflowedItem(btn)) {
            btn.focus();
          }
        }

        if (Environment.browser.name === 'ie' || Environment.browser.isEdge()) {
          currentElem.trigger('change');
        }

        if (btn[0].classList.contains('longpress-target')) {
          return false;
        }
      } // Most components work fine with the `selected` event on the toolbars.
      // Colorpicker components aren't "triggered" by a selected event, so they work
      // off of the click event.


      if (this.settings.useFlexToolbar) {
        this.toolbar.on('selected.editor', editorButtonActionHandler);
        this.toolbar.on('click.editor', '.colorpicker-editor-button', editorButtonActionHandler);
      } else {
        this.toolbar.on('click.editor', 'button', editorButtonActionHandler);
      }

      if (this.fontPickerElem) {
        this.fontPickerElem.on('font-selected', function (e, fontPickerStyle) {
          _this10.execFormatBlock(fontPickerStyle.tagName);
        });
      }

      return this;
    },
    bindModals: function bindModals() {
      var self = this;
      var modalSettings = {
        noRefocus: false
      };
      this.modals = {
        url: this.createURLModal(),
        image: this.createImageModal()
      };
      $("[name=\"em-target-".concat(this.id, "\"]")).dropdown();
      $("#modal-url-".concat(this.id, ", #modal-image-").concat(this.id)).modal(modalSettings).on('beforeopen', function () {
        self.savedSelection = self.saveSelection();

        if ($(this).attr('id') === "modal-url-".concat(self.id)) {
          if (!self.selectionRange) {
            return undefined;
          }
        }
      }).off('open').on('open', function () {
        var isTouch = Environment.features.touch;
        var id = $(this).attr('id');
        var input = $('input:first', this);
        var button = $('.modal-buttonset .btn-modal-primary', this);
        $("[name=\"em-url-".concat(self.id, "\"]")).val(self.settings.anchor.url);
        $("[name=\"em-class-".concat(self.id, "\"]")).val(self.settings.anchor.class);
        $("[name=\"em-target-".concat(self.id, "\"]")).val(self.settings.anchor.target).trigger('updated');
        $("[name=\"em-isclickable-".concat(this.id, "\"]")).prop('checked', self.settings.anchor.isClickable);
        setTimeout(function () {
          if (isTouch && id === "modal-image-".concat(self.id)) {
            button.focus();
          } else {
            input.focus().select();
          }
        }, 10);
      }).off('beforeclose').on('beforeclose', function () {
        var action = $(this).is('.editor-modal-image') ? 'image' : 'anchor';

        if (self.toolbar) {
          var btn = self.toolbar.find("[data-action=\"".concat(action, "\"]"));
          var modalApi = $(this).data('modal');

          if (btn && modalApi) {
            modalApi.settings.noRefocus = self.isBtnOverflowedItem(btn);
          }
        }
      }).off('close').on('close', function (e, isCancelled) {
        self.restoreSelection(self.savedSelection);

        if (isCancelled) {
          return;
        } // insert image or link


        if ($(this).attr('id') === "modal-url-".concat(self.id)) {
          var currentLink = $(self.findElementInSelection('a', self.element[0]));

          if (currentLink.length) {
            self.updateCurrentLink(currentLink);
          } else {
            self.createLink($("[name=\"em-url-".concat(self.id, "\"]"), this));
          }
        } else {
          self.insertImage($("#image-".concat(self.id)).val());
        }
      });
      return this;
    },

    /**
    * Function that creates the Url Modal Dialog. This can be customized by making
     a modal with ID `#modal-url-${this.id}`
    * @private
    * @returns {void}
    */
    createURLModal: function createURLModal() {
      var _this11 = this;

      var s = this.settings;
      var urlModal = $("#modal-url-".concat(this.id));

      if (urlModal.length > 0) {
        return urlModal;
      }

      var targetOptions = '';
      var isTargetCustom = true;
      $.each(s.anchor.targets, function (key, val) {
        targetOptions += "<option value=\"".concat(val, "\">").concat(Locale.translate(key), "</option>");

        if (_this11.settings.anchor.defaultTargetText.toLowerCase() === key.toLowerCase()) {
          isTargetCustom = false;
        }
      });

      if (isTargetCustom) {
        targetOptions += "<option value=\"".concat(s.anchor.target, "\">").concat(s.anchor.target, "</option>");
      }

      var modalAttributes;
      var ddAttributes = ''; // Set automation attributes settings for dropdown

      if (s.attributes) {
        modalAttributes = this.getAutomationAttributes('-editor-modal');
        ddAttributes = JSON.stringify(modalAttributes);
        ddAttributes = " data-options='{\"attributes\": ".concat(ddAttributes, "}'");
      } // TODO: Rename to link when you get strings


      var output = $("<div class=\"modal editor-modal-url\" id=\"modal-url-".concat(this.id, "\"></div>")).html("<div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <h1 class=\"modal-title\">".concat(Locale.translate('InsertAnchor'), "</h1>\n        </div>\n        <div class=\"modal-body\">\n          <div class=\"field\">\n            <label for=\"em-url-").concat(this.id, "\" class=\"required\">").concat(Locale.translate('Url'), "</label>\n            <input id=\"em-url-").concat(this.id, "\" name=\"em-url-").concat(this.id, "\" data-validate=\"required\" type=\"text\" value=\"").concat(s.anchor.url, "\">\n          </div>\n          ").concat(s.anchor.showIsClickable ? "<div class=\"field\">\n            <input type=\"checkbox\" class=\"checkbox\" id=\"em-isclickable-".concat(this.id, "\" name=\"em-isclickable-").concat(this.id, "\" checked=\"").concat(s.anchor.isClickable, "\">\n            <label for=\"em-isclickable-").concat(this.id, "\" class=\"checkbox-label\"> ").concat(Locale.translate('Clickable'), "</label>\n          </div>") : '', "\n          <div class=\"field\">\n            <label for=\"em-class-").concat(this.id, "\">").concat(Locale.translate('CssClass'), "</label>\n            <input id=\"em-class-").concat(this.id, "\" name=\"em-class-").concat(this.id, "\" type=\"text\" value=\"").concat(s.anchor.class, "\">\n          </div>\n          <div class=\"field\">\n            <label for=\"em-target-").concat(this.id, "\" class=\"label\"> ").concat(Locale.translate('Target'), "</label>\n            <select id=\"em-target-").concat(this.id, "\" name=\"em-target-").concat(this.id, "\" class=\"dropdown\"").concat(ddAttributes, ">\n              ").concat(targetOptions, "\n            </select>\n          </div>\n          <div class=\"modal-buttonset\">\n            <button type=\"button\" class=\"btn-modal btn-cancel\"> ").concat(Locale.translate('Cancel'), "</button>\n            <button type=\"button\" class=\"btn-modal-primary\"> ").concat(Locale.translate('Insert'), "</button>\n          </div>\n        </div>\n      </div>")); // Add automation attributes

      if (s.attributes) {
        var inputs = [].slice.call(output[0].querySelectorAll('[type="text"]'));
        var buttons = [].slice.call(output[0].querySelectorAll('button'));
        inputs.forEach(function (input, i) {
          return utils.addAttributes($(input), _this11, modalAttributes, "input".concat(i));
        });
        buttons.forEach(function (btn, i) {
          return utils.addAttributes($(btn), _this11, modalAttributes, "button".concat(i));
        });
      }

      return output.appendTo('body');
    },

    /**
     * Function that creates the Image Dialog. This can be customized by making a
      modal with ID `#modal-image-{this.id}`
     * @private
     * @returns {void}
     */
    createImageModal: function createImageModal() {
      var _this12 = this;

      var imageModal = $("#modal-image-".concat(this.id));

      if (imageModal.length > 0) {
        return imageModal;
      }

      var output = $("<div class=\"modal editor-modal-image\" id=\"modal-image-".concat(this.id, "\"></div>'")).html("<div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <h1 class=\"modal-title\">".concat(Locale.translate('InsertImage'), "</h1>\n        </div>\n        <div class=\"modal-body no-scroll\">\n          <div class=\"field\">\n            <label for=\"image-").concat(this.id, "\" class=\"required\">").concat(Locale.translate('Url'), "</label>\n            <input id=\"image-").concat(this.id, "\" name=\"image-").concat(this.id, "\" type=\"text\" data-validate=\"required\" value=\"").concat(this.settings.image.url, "\">\n          </div>\n          <div class=\"modal-buttonset\">\n            <button type=\"button\" class=\"btn-modal btn-cancel\">\n              ").concat(Locale.translate('Cancel'), "</button>\n            <button type=\"button\" class=\"btn-modal-primary\">\n              ").concat(Locale.translate('Insert'), "</button>\n          </div>\n        </div>\n      </div>")); // Add automation attributes

      if (this.settings.attributes) {
        var modalAttributes = this.getAutomationAttributes('-editor-modal');
        var inputs = [].slice.call(output[0].querySelectorAll('[type="text"]'));
        var buttons = [].slice.call(output[0].querySelectorAll('button'));
        inputs.forEach(function (input, i) {
          return utils.addAttributes($(input), _this12, modalAttributes, "input".concat(i));
        });
        buttons.forEach(function (btn, i) {
          return utils.addAttributes($(btn), _this12, modalAttributes, "button".concat(i));
        });
      }

      return output.appendTo('body');
    },
    bindAnchorPreview: function bindAnchorPreview() {
      this.element.find('a').tooltip({
        content: function content() {
          return $(this).attr('href');
        }
      });
    },
    updateCurrentLink: function updateCurrentLink(alink) {
      var emUrl = xssUtils.stripTags(document.querySelector("[name=\"em-url-".concat(this.id, "\"]")).value);
      var emClass = xssUtils.stripTags(document.querySelector("[name=\"em-class-".concat(this.id, "\"]")).value);
      var emTarget = xssUtils.stripTags(document.querySelector("[name=\"em-target-".concat(this.id, "\"]")).value);
      var emIsClickable = this.settings.anchor.showIsClickable ? document.querySelector("[name=\"em-isclickable-".concat(this.id, "\"]")).checked : this.settings.anchor.isClickable;

      if (alink) {
        alink[0].setAttribute('href', this.fixLinkFormat(emUrl && $.trim(emUrl).length ? emUrl : this.settings.anchor.defaultUrl));
        alink[0].setAttribute('class', emClass && $.trim(emClass).length ? emClass : this.settings.anchor.defaultClass);
        alink[0].setAttribute('data-url', (emUrl && $.trim(emUrl).length ? emUrl : this.settings.anchor.defaultUrl).replace('http://', ''));
      }

      if (emIsClickable) {
        alink.attr('contenteditable', false);
      } else {
        alink.removeAttr('contenteditable');
      }

      if (emTarget && $.trim(emTarget).length) {
        alink.attr('target', emTarget);
      } else {
        alink.removeAttr('target');
      }
    },
    createLink: function createLink(input) {
      var _this13 = this;

      // Restore Selection in the Editor and Variables
      this.restoreSelection(this.savedSelection); // Fix and Format the Link

      var cleanValue = xssUtils.stripTags(this.fixLinkFormat(input[0].value));
      input.val(cleanValue); // Set selection url/class/target for Link

      this.settings.anchor.url = input.val();
      this.settings.anchor.class = document.querySelector("[name=\"em-class-".concat(this.id, "\"]")).value;
      this.settings.anchor.target = document.querySelector("[name=\"em-target-".concat(this.id, "\"]")).value;
      this.settings.anchor.isClickable = this.settings.anchor.showIsClickable ? document.querySelector("[name=\"em-isclickable-".concat(this.id, "\"]")).checked : this.settings.anchor.isClickable;
      var alink = $("<a data-url=\"".concat(cleanValue, "\" href=\"").concat(cleanValue, "\">").concat(cleanValue, "</a>"));

      if (this.settings.anchor.class && $.trim(this.settings.anchor.class).length) {
        alink.addClass(this.settings.anchor.class);
      }

      if (this.settings.anchor.target && $.trim(this.settings.anchor.target).length) {
        alink.attr('target', this.settings.anchor.target);
      }

      if (this.settings.anchor.isClickable) {
        alink.attr('contenteditable', false);
      } else {
        alink.removeAttr('contenteditable');
      }

      if (this.sourceViewActive()) {
        this.insertTextAreaContent(input.val(), 'anchor');
      } else {
        var sel;
        var range;
        var rangeChildren;
        var rangeStr;
        var rangeImg;

        if (!this.selection.isCollapsed || Environment.browser.isIE11()) {
          // get example from: http://jsfiddle.net/jwvha/1/
          // and info: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
          if (window.getSelection) {
            // IE9 and non-IE
            sel = window.getSelection();

            if (sel.getRangeAt && sel.rangeCount) {
              range = sel.getRangeAt(0);
              rangeStr = "".concat(range);

              if (rangeStr.trim() !== '') {
                alink.html(rangeStr);
              }

              rangeChildren = range.commonAncestorContainer.children;
              var len = rangeChildren ? rangeChildren.length : 0;

              for (var i = 0; i < len; i++) {
                var rangeChild = rangeChildren[i];

                if (rangeChild instanceof HTMLImageElement) {
                  rangeImg = rangeChild;
                }
              }

              if (rangeImg) {
                alink.html(rangeImg.outerHTML);
              }

              range.deleteContents(); // Range.createContextualFragment() would be useful here but is
              // only relatively recently standardized and is not supported in
              // some browsers (IE9, for one)

              var el = document.createElement('div');
              el.innerHTML = alink[0].outerHTML;
              var frag = document.createDocumentFragment();
              var node;
              var lastNode;

              while (node = el.firstChild) {
                // eslint-disable-line
                lastNode = frag.appendChild(node);
              }

              range.insertNode(frag); // Preserve the selection

              if (lastNode) {
                range = range.cloneRange();
                range.setStartAfter(lastNode);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
          }
        } else {
          document.execCommand('insertHtml', null, alink[0].outerHTML);
          setTimeout(function () {
            _this13.getCurrentElement().focus();
          }, 1);
        }

        this.bindAnchorPreview();
      }
    },
    fixLinkFormat: function fixLinkFormat(value) {
      if (value.match(/^https?:\/\//)) {
        return value;
      }

      return "http://".concat(value);
    },
    // Setup Events For Text Selection
    bindSelect: function bindSelect() {
      var _this14 = this;

      var selectionTimer = '';

      this.selectionHandler = function () {
        clearTimeout(selectionTimer);
        selectionTimer = setTimeout(function () {
          _this14.checkSelection();
        }, _this14.settings.delay);
      };

      var currentElement = this.getCurrentElement();
      currentElement.off('mouseup.editor keyup.editor').on('mouseup.editor keyup.editor', this.selectionHandler);
      return this;
    },
    checkSelection: function checkSelection() {
      var newSelection;

      if (this.selection === undefined) {
        if (this.sourceViewActive()) {
          newSelection = this.textarea.val().substring(this.textarea[0].selectionStart, this.textarea[0].selectionEnd).toString().trim();
          this.hideToolbarActions();
          return;
        }
      }

      newSelection = window.getSelection();
      var selectionElement = this.getSelectionElement();

      if (!selectionElement) {
        this.hideToolbarActions();
      } else {
        this.checkSelectionElement(newSelection, selectionElement);
      }

      return this;
    },
    getSelectionElement: function getSelectionElement() {
      var range;
      var current;
      var parent;
      var result;
      var selection = window.getSelection();

      var getElement = function getElement(e) {
        var localParent = e;

        try {
          while (!localParent.getAttribute('data-editor')) {
            localParent = localParent.parentNode;
          }
        } catch (errb) {
          return false;
        }

        return localParent;
      }; // First try on current node


      try {
        range = selection.getRangeAt(0);
        current = range.commonAncestorContainer;
        parent = current.parentNode;
        result = current.getAttribute('data-editor') ? current : getElement(parent); // If not search in the parent nodes.
      } catch (err) {
        result = getElement(parent);
      }

      return result;
    },
    // See if the Editor is Selected and Show Toolbar
    checkSelectionElement: function checkSelectionElement(newSelection, selectionElement) {
      var currentElement = this.sourceViewActive() ? this.sourceView[0] : this.element[0];
      this.selection = newSelection;
      this.selectionRange = this.selection.getRangeAt(0);

      if (currentElement === selectionElement) {
        this.setToolbarButtonStates();
        return;
      }

      this.hideToolbarActions();
    },
    // Set button states for toolbar buttons
    setToolbarButtonStates: function setToolbarButtonStates() {
      this.toolbar.find('button').removeClass('is-active');
      this.checkActiveButtons();
      return this;
    },

    /**
     * Check and set the active states on toolba rbuttons.
     * @private
     */
    checkActiveButtons: function checkActiveButtons() {
      this.checkButtonState('bold');
      this.checkButtonState('italic');
      this.checkButtonState('underline');
      this.checkButtonState('strikethrough');
      this.checkColorButtonState('foreColor');

      if (this.toolbar.find('.buttonset [data-action="backColor"]').length) {
        this.checkColorButtonState('backColor');
      }

      if (this.fontPickerElem) {
        this.checkButtonState('fontStyle');
      }

      var parentNode = this.getSelectedParentElement();

      while (parentNode.tagName !== undefined && EDITOR_PARENT_ELEMENTS.indexOf(parentNode.tagName.toLowerCase) === -1) {
        this.activateButton(parentNode.tagName.toLowerCase()); // we can abort the search upwards if we leave the contentEditable element

        if (this.element.is(parentNode)) {
          break;
        }

        parentNode = parentNode.parentNode;
      }
    },
    checkButtonState: function checkButtonState(command) {
      if (!document.queryCommandState) {
        return;
      } // 'fontStyle' type notifies the FontPicker component if the current selection doesn't match.


      if (this.fontPickerElem && command === 'fontStyle') {
        var fontpickerAPI = this.fontPickerElem.data('fontpicker');
        var fontpickerSupportedTags = fontpickerAPI.supportedTagNames;
        var selectedElem = this.getSelectionParentElement();
        var searchElems = $(selectedElem).add($(selectedElem).parentsUntil(this.element));
        var targetElemTag;
        var fontStyle;

        for (var i = 0; i < searchElems.length && fontStyle === undefined; i++) {
          targetElemTag = searchElems[i].tagName.toLowerCase();

          if (fontpickerSupportedTags.indexOf(targetElemTag) > -1) {
            fontStyle = fontpickerAPI.getStyleByTagName(targetElemTag);
            fontpickerAPI.select(fontStyle, true);
            break;
          }
        }

        return;
      } // Standard Button State Check


      if (document.queryCommandState(command)) {
        this.toolbar.find("[data-action=\"".concat(command, "\"]")).addClass('is-active');
      } else {
        this.toolbar.find("[data-action=\"".concat(command, "\"]")).removeClass('is-active');
      }
    },
    rangeSelectsSingleNode: function rangeSelectsSingleNode(range) {
      var startNode = range.startContainer;
      return startNode === range.endContainer && startNode.hasChildNodes() && range.endOffset === range.startOffset + 1;
    },
    getSelectedParentElement: function getSelectedParentElement() {
      var selectedParentElement = null;
      var range = this.selectionRange;

      if (this.rangeSelectsSingleNode(range)) {
        selectedParentElement = range.startContainer.childNodes[range.startOffset];
      } else if (range.startContainer.nodeType === 3) {
        selectedParentElement = range.startContainer.parentNode;
      } else {
        selectedParentElement = range.startContainer;
      }

      return selectedParentElement;
    },
    // Hide Toolbar
    hideToolbarActions: function hideToolbarActions() {
      if (this.toolbar !== undefined) {
        this.toolbar.removeClass('is-active');
      }
    },
    // Handle Pasted In Text
    bindPaste: function bindPaste() {
      var self = this;
      var currentElement = self.getCurrentElement();

      this.pasteWrapper = function (e) {
        var paste;

        if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
          paste = e.originalEvent.clipboardData.getData('text/plain'); // Standard
        } else {
          paste = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : false; // MS : false
        }

        var p;
        var paragraphs;
        var html = '';

        if (self.sourceViewActive()) {
          return this;
        }

        if (paste && !e.defaultPrevented) {
          e.preventDefault();
          paragraphs = paste.split(/[\r\n]/g);

          for (p = 0; p < paragraphs.length; p += 1) {
            if (paragraphs[p] !== '') {
              if (navigator.userAgent.match(/firefox/i) && p === 0) {
                html += "<p>".concat(self.htmlEntities(paragraphs[p]), "</p>");
              } else if (/\.(gif|jpg|jpeg|tiff|png)$/i.test(paragraphs[p])) {
                html += "<img src=\"".concat(self.htmlEntities(paragraphs[p]), "\" />");
              } else {
                html += "<p>".concat(self.htmlEntities(paragraphs[p]), "</p>");
              }
            }
          }

          if (document.queryCommandSupported('insertText')) {
            document.execCommand('insertHTML', false, html);
            return false;
          } // IE > 7


          self.pasteHtmlAtCaret(html);
        }
      };

      this.pasteWrapperHtml = function (e) {
        if (self.sourceViewActive()) {
          return this;
        }

        var types;
        var clipboardData;
        var pastedData;
        var paste;
        var p;
        var paragraphs;

        if (e.clipboardData || e.originalEvent) {
          if (e.clipboardData && e.clipboardData.types) {
            clipboardData = e.clipboardData;
          } else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            clipboardData = e.originalEvent.clipboardData;
          }
        }

        if (clipboardData && clipboardData.types) {
          types = clipboardData.types;

          if (types instanceof DOMStringList && types.contains('text/html') || types.indexOf && types.indexOf('text/html') !== -1 || Environment.browser.isEdge()) {
            pastedData = e.originalEvent.clipboardData.getData('text/html');
          }

          if (types instanceof DOMStringList && types.contains('text/plain')) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          }

          if (_typeof(types) === 'object' && types[0] && types[0] === 'text/plain' && !types[1]) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          }
        } else {
          paste = window.clipboardData ? window.clipboardData.getData('Text') : '';
          paragraphs = paste.split(/[\r\n]/g);
          pastedData = '';

          for (p = 0; p < paragraphs.length; p += 1) {
            if (paragraphs[p] !== '') {
              if (navigator.userAgent.match(/firefox/i) && p === 0) {
                pastedData += "<p>".concat(self.htmlEntities(paragraphs[p]), "</p>");
              } else if (/\.(gif|jpg|jpeg|tiff|png)$/i.test(paragraphs[p])) {
                pastedData += "<img src=\"".concat(self.htmlEntities(paragraphs[p]), "\" />");
              } else {
                pastedData += "<p>".concat(self.htmlEntities(paragraphs[p]), "</p>");
              }
            }
          }
        }

        self.pastedData = Environment.browser.isIE11() ? pastedData : self.getCleanedHtml(pastedData);
        /**
        * Fires before paste.
        *
        * @event beforepaste
        * @memberof Editor
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {string} pastedData .
        */

        $.when(self.element.triggerHandler('beforepaste', [{
          pastedData: self.pastedData
        }])).done(function () {
          if (self.pastedData && !e.defaultPrevented) {
            if (!Environment.browser.isIE11() && !Environment.browser.isEdge()) {
              e.preventDefault();
            }

            if (document.queryCommandSupported('insertText')) {
              document.execCommand('insertHTML', false, self.pastedData);
              return false;
            }

            self.pasteHtmlAtCaret(self.pastedData);
          }
          /**
          * Fires after paste.
          *
          * @event afterpaste
          * @memberof Editor
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {string} pastedData .
          */


          self.element.triggerHandler('afterpaste', [{
            pastedData: self.pastedData
          }]);
          self.pastedData = null;
        });

        if (!Environment.browser.isIE11()) {
          return false;
        }
      };

      currentElement.on('paste.editor', self.settings.pasteAsPlainText ? self.pasteWrapper : self.pasteWrapperHtml);
      return this;
    },
    pasteHtmlAtCaret: function pasteHtmlAtCaret(html) {
      var self = this;
      var templIE11 = 'x-text-content-templ-x';
      var sel;
      var range;

      if (window.getSelection) {
        sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          range = sel.getRangeAt(0);
          range.deleteContents();

          if (Environment.browser.isIE11()) {
            html = templIE11;
          } // Range.createContextualFragment() would be useful here but is
          // only relatively recently standardized and is not supported in
          // some browsers


          var el = document.createElement('div');
          el.innerHTML = html;
          var frag = document.createDocumentFragment();
          var node;
          var lastNode;

          while (node = el.firstChild) {
            // eslint-disable-line
            lastNode = frag.appendChild(node);
          }

          range.insertNode(frag); // Preserve the selection

          if (lastNode) {
            range = range.cloneRange();
            range.setStartAfter(lastNode);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
          } // IE 11


          if (Environment.browser.isIE11()) {
            var maxRun = 50;
            var deferredIE11 = $.Deferred();

            var waitForPastedData = function waitForPastedData(elem, savedContent) {
              maxRun--;

              if (maxRun < 0) {
                deferredIE11.reject();
                return;
              } // If data has been processed by browser, process it


              if (elem.childNodes && elem.childNodes.length > 0) {
                // Retrieve pasted content via innerHTML
                // (Alternatively loop through elem.childNodes or elem.getElementsByTagName here)
                html = elem.innerHTML; // self.pastedData = getCleanedHtml(elem.innerHTML);
                // Restore saved content

                elem.innerHTML = '';
                elem.appendChild(savedContent);
                deferredIE11.resolve();
              } else {
                // Else wait 5ms and try again
                setTimeout(function () {
                  waitForPastedData(elem, savedContent);
                }, 5);
              }
            }; // Everything else: Move existing element contents to a DocumentFragment for safekeeping


            var savedContent = document.createDocumentFragment();

            while (self.element[0].childNodes.length > 0) {
              savedContent.appendChild(self.element[0].childNodes[0]);
            } // Then wait for browser to paste content into it and cleanup


            waitForPastedData(self.element[0], savedContent);
            $.when(deferredIE11).done(function () {
              var str = '';
              var thisNode = self.element.find(":contains(+ ".concat(templIE11, ")")).filter(function () {
                return this.textContent === templIE11;
              });

              if (!thisNode.length) {
                thisNode = self.element.find(":contains(+ ".concat(templIE11, ")")).filter(function () {
                  return this.textContent.indexOf(templIE11) > -1 && this.tagName !== 'UL';
                });
              }

              html = self.getCleanedHtml(html); // Working with list
              // Start with "<li"

              var pasteHtml = '';

              if (/(^(\s+?)?<li)/ig.test(html)) {
                // Pasted data starts and ends with "li" tag
                if (/((\s+?)?<\/li>(\s+?)?$)/ig.test(html)) {
                  // ends with "</li>"
                  // Do not add "ul" if pasting on "li" node
                  if (!thisNode.is('li')) {
                    html = "<ul>".concat(html, "</ul>");
                  }

                  pasteHtml = html;
                } else if (thisNode.is('li')) {
                  // Missing at the end "</li>" tag
                  // Pasting on "li" node
                  pasteHtml = "".concat(html, "</li>");
                } else {
                  // Not pasting on "li" node
                  // If ul was closed and have extra nodes after list close
                  str = html.match(/<\/ul|<\/ol/gi) || []; // Pasted data contains "ul or ol" tags

                  if (str.length) {
                    pasteHtml = html;
                  } else {
                    pasteHtml = "".concat(html, "</li></ul>");
                  }
                }
              } else if (/((\s+?)?<\/li>(\s+?)?$)/ig.test(html)) {
                // Ends with "</li>" tag, but not started with "li" tag
                // Pasting on "li" node
                if (thisNode.is('li')) {
                  pasteHtml = "<li>".concat(html);
                } else {
                  str = html.match(/<ul|<ol/gi) || []; // Pasted data contains "ul or ol" tags

                  if (str.length) {
                    html += str[str.length - 1].replace(/<(ul|ol)/gi, '<$1>');
                  } else {
                    html = "<ul>".concat(html, "</ul>");
                  }

                  pasteHtml = html;
                }
              }

              if (pasteHtml) {
                DOM.html(thisNode, pasteHtml, '*');
              } // Default case


              str = self.element[0].innerHTML;

              if (str.indexOf(templIE11) > -1) {
                str = str.replace(templIE11, html);
              }

              self.element[0].innerHTML = self.getCleanedHtml(str);
            });
          }
        }
      } else if (document.selection && document.selection.type !== 'Control') {
        document.selection.createRange().pasteHTML(html);
      }
    },
    // Get cleaned extra from html
    getCleanedHtml: function getCleanedHtml(pastedData) {
      var attributeStripper;
      var s = pastedData || '';
      var badAttributes = ['start', 'xmlns', 'xmlns:o', 'xmlns:w', 'xmlns:x', 'xmlns:m', 'onmouseover', 'onmouseout', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onload', 'onfocus', 'onblur', 'onclick', 'style']; // Remove extra word formating

      if (this.isWordFormat(s)) {
        s = this.cleanWordHtml(s);
      } // Remove bad attributes


      for (var i = 0, l = badAttributes.length; i < l; i++) {
        attributeStripper = new RegExp(" ".concat(badAttributes[i], "=\"(.*?)\""), 'gi');
        s = this.stripAttribute(s, badAttributes[i], attributeStripper);
        attributeStripper = new RegExp(" ".concat(badAttributes[i], "='(.*?)'"), 'gi');
        s = this.stripAttribute(s, badAttributes[i], attributeStripper);
      } // Remove "ng-" directives and "ng-" classes


      s = s.replace(/\sng-[a-z-]+/, ''); // Remove comments

      s = s.replace(/<!--(.*?)-->/gm, ''); // Remove extra spaces

      s = s.replace(/\s\s+/g, ' ').replace(/\s>+/g, '>'); // Remove extra attributes from list elements

      s = s.replace(/<(ul|ol)(.*?)>/gi, '<$1>'); // Remove empty list

      s = s.replace(/<li><\/li>/gi, '');
      s = s.replace(/<(ul|ol)><\/(ul|ol)>/gi, ''); // Remove html and body tags

      s = s.replace(/<\/?(html|body)(.*?)>/gi, ''); // Remove header tag and content

      s = s.replace(/<head\b[^>]*>(.*?)<\/head>/gi, ''); // Remove empty tags

      s = s.replace(/<[^(br|/>)]+>[\s]*<\/[^>]+>/gi, '');

      if (s.indexOf('') > -1) {
        // Replace span and paragraph tags from bulleted list pasting
        s = s.replace(/<\/p>/gi, '</li>');
        s = s.replace(/<p><span><span><\/span><\/span>/gi, '<li>'); // Remove white space

        s = s.replace(/<\/li>\s<li>/gi, '<\/li><li>'); // Add in opening and closing ul tags

        s = [s.slice(0, s.indexOf('<li>')), '<ul>', s.slice(s.indexOf('<li>'))].join('');
        s = [s.slice(0, s.lastIndexOf('</li>')), '</ul>', s.slice(s.lastIndexOf('</li>'))].join('');
      }

      return s;
    },
    htmlEntities: function htmlEntities(str) {
      // converts special characters (e.g., <) into their escaped/encoded values (e.g., &lt;).
      // This allows you to display the string without the browser reading it as HTML.
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    },
    bindWindowActions: function bindWindowActions() {
      var _this15 = this;

      var editorContainer = this.container;
      var currentElement = this.getCurrentElement();
      var self = this;
      this.element // Work around for Chrome's bug wrapping contents in <span>
      // http://www.neotericdesign.com/blog/2013/3/working-around-chrome-s-contenteditable-span-bug
      .on('DOMNodeInserted', function (e) {
        var target = $(e.target);
        var helper = $('<b>helper</b>');

        if (e.target.tagName === 'IMG') {
          target.removeAttr('id style srcset');
        } else if (e.target.tagName === 'SPAN') {
          target.before(helper);
          helper.after(target.contents());
          helper.add(target).remove();
        }
      }); // Handle visual styles at the container level on blur/focus

      function containerFocusHandler() {
        var elem = $(this);
        editorContainer.addClass('is-active');
        setTimeout(function () {
          if (elem.hasClass('error')) {
            editorContainer.parent().find('.editor-toolbar').addClass('error');
            editorContainer.parent().find('.editor-source').addClass('error');
          }
        }, 100);
      }

      function containerBlurHandler() {
        editorContainer.removeClass('is-active');
        editorContainer.parent().find('.editor-toolbar').removeClass('error');
        editorContainer.parent().find('.editor-source').removeClass('error');
      }

      this.container.on("focusin.".concat(COMPONENT_NAME$M), '.editor, .editor-source', containerFocusHandler).on("focusout.".concat(COMPONENT_NAME$M), '.editor, .editor-source', containerBlurHandler);
      this.container.on("mouseenter.".concat(COMPONENT_NAME$M), function () {
        if (!_this15.element.hasClass('error')) {
          _this15.container.addClass('is-hover');
        }
      }).on("mouseleave.".concat(COMPONENT_NAME$M), function () {
        _this15.container.removeClass('is-hover');
      });

      if (self.settings.onLinkClick) {
        editorContainer.on('click.editorlinks', 'a', function (e) {
          self.settings.onLinkClick(e, {
            elem: _this15,
            url: e.currentTarget.getAttribute('data-url')
          });
          e.preventDefault();
          e.stopImmediatePropagation();
          e.stopPropagation();
        });
      } // Attach Label


      this.label.on('click.editor', function () {
        currentElement.focus();
      });
      currentElement.attr('aria-label', this.label.text());
      return this;
    },
    // Restore Text Selection
    restoreSelection: function restoreSelection(savedSel) {
      var sel = window.getSelection();

      if (!savedSel) {
        savedSel = this.savedSelection;
      }

      if (savedSel) {
        sel.removeAllRanges();

        for (var i = 0, len = savedSel.length; i < len; i += 1) {
          sel.addRange(savedSel[i]);
        }
      }
    },
    // Save Text Selection
    saveSelection: function saveSelection() {
      var ranges;
      var sel = window.getSelection();

      if (sel.getRangeAt && sel.rangeCount) {
        ranges = [];

        for (var i = 0, len = sel.rangeCount; i < len; i += 1) {
          ranges.push(sel.getRangeAt(i));
        }

        return ranges;
      }

      return null;
    },
    // Get the Element the Caret idea from http://bit.ly/1kRmZIL
    getSelectionStart: function getSelectionStart() {
      var node = document.getSelection().anchorNode;
      var startNode = node && node.nodeType === 3 ? node.parentNode : node;
      return startNode;
    },
    getrange: function getrange() {
      return window.getSelection().getRangeAt(0);
    },
    // Find element within the selection
    // http://stackoverflow.com/questions/6052870/how-to-know-if-there-is-a-link-element-within-the-selection
    findElementInSelection: function findElementInSelection(tagname, container) {
      var el;
      var comprng;
      var selparent;
      var rng = this.getrange();

      if (rng) {
        selparent = rng.commonAncestorContainer || rng.parentElement(); // Look for an element *around* the selected range

        for (el = selparent; el !== container; el = el.parentNode) {
          if (el && el.tagName && el.tagName.toLowerCase() === tagname) {
            return el;
          }
        } // Look for an element *within* the selected range


        if (!rng.collapsed && (rng.text === undefined || rng.text) && selparent.getElementsByTagName) {
          el = selparent.getElementsByTagName(tagname);
          comprng = document.createRange ? document.createRange() : document.body.createTextRange();

          for (var i = 0, len = el.length; i < len; i++) {
            // determine if element el[i] is within the range
            if (document.createRange) {
              // w3c
              comprng.selectNodeContents(el[i]);

              if (rng.compareBoundaryPoints(Range.END_TO_START, comprng) < 0 && rng.compareBoundaryPoints(Range.START_TO_END, comprng) > 0) {
                return el[i];
              }
            } else {
              // microsoft
              comprng.moveToElementText(el[i]);

              if (rng.compareEndPoints('StartToEnd', comprng) < 0 && rng.compareEndPoints('EndToStart', comprng) > 0) {
                return el[i];
              }
            }
          }
        }
      }
    },
    // Restore if Selection is a Link
    restoreLinkSelection: function restoreLinkSelection() {
      var currentLink = $(this.findElementInSelection('a', this.element[0]));
      this.settings.anchor.url = this.settings.anchor.defaultUrl;
      this.settings.anchor.class = this.settings.anchor.defaultClass;
      this.settings.anchor.target = this.settings.anchor.defaultTarget;
      this.settings.anchor.isClickable = this.settings.anchor.defaultIsClickable;

      if (currentLink.length) {
        this.settings.anchor.url = currentLink.attr('href');
        this.settings.anchor.class = currentLink.attr('class');
        this.settings.anchor.target = currentLink.attr('target');
        var contenteditable = currentLink.attr('contenteditable');

        if (contenteditable === false || contenteditable === 'false') {
          this.settings.anchor.isClickable = true;
        }
      }
    },
    // Run the CE action.
    execAction: function execAction(action) {
      var currentElement = this.getCurrentElement(); // Visual Mode

      if (currentElement === this.element) {
        if (action.indexOf('append-') > -1) {
          this.execFormatBlock(action.replace('append-', ''));
        } else if (action === 'anchor') {
          this.restoreLinkSelection();
          this.modals.url.data('modal').open();
        } else if (action === 'image') {
          this.modals.image.data('modal').open();
        } else if (action === 'foreColor' || action === 'backColor') {
          this.execColorActions(action);
        } else if (action === 'clearFormatting') {
          this.clearFormatting();
        } else if (action === 'source' || action === 'visual') {
          this.toggleSource();
        } else {
          document.execCommand(action, false, null);
        }
      } else {
        // Source Mode
        switch (action) {
          case 'visual':
            this.toggleSource();
            break;

          case 'anchor':
            this.modals.url.data('modal').open();
            break;

          default:
            this.insertTextAreaContent(null, action);
            break;
        }
      }

      this.checkSelection();
    },
    insertImage: function insertImage(url) {
      document.execCommand('insertImage', false, url);
    },

    /**
     * Toggle to source or preview mode.
     * @param {boolean} forceToSourceMode true will force to toggle in to source mode.
     * @returns {void}
     */
    toggleSource: function toggleSource(forceToSourceMode) {
      var _this16 = this;

      // Preview Mode
      var doPreviewMode = function doPreviewMode(res) {
        var content = res || _this16.textarea.val();

        content = xssUtils.sanitizeHTML(content);
        content = _this16.getCleanedHtml(content);

        _this16.element.empty().removeClass('source-view-active hidden');

        _this16.sourceView.addClass('hidden').removeClass('is-focused');

        _this16.element.trigger('focus.editor');

        _this16.switchToolbars();

        _this16.textarea.off('input.editor-firechange');

        setTimeout(function () {
          var _this16$toolbar;

          _this16.element[0].innerHTML = content;
          content = _this16.element[0].innerHTML;
          /**
           * Fires after preview mode activated.
           * @event afterpreviewmode
           * @memberof Editor
           * @property {object} event The jquery event object
           * @property {string} content Additional argument
           */

          _this16.element.triggerHandler('afterpreviewmode', content);

          var btn = (_this16$toolbar = _this16.toolbar) === null || _this16$toolbar === void 0 ? void 0 : _this16$toolbar == null ? void 0 : _this16$toolbar.find('[data-action="source"]');

          if (btn && !_this16.isBtnOverflowedItem(btn)) {
            btn.focus();
          }
        }, 0);
      }; // Source Mode


      var doSourceMode = function doSourceMode(res) {
        var _this16$toolbar2;

        var content = res || _this16.element.html().trim().replace(/\s+/g, ' ').replace(/<br( \/)?>/g, '<br>\n').replace(/<\/p> /g, '</p>\n\n').replace(/<\/blockquote>( )?/g, '</blockquote>\n\n');

        if (_this16.settings.useSourceFormatter) {
          content = _this16.formatHtml(content);
        }

        _this16.element.addClass('source-view-active');

        _this16.switchToolbars();

        _this16.textarea.val(content).focus();

        _this16.sourceView.removeClass('hidden');

        _this16.element.addClass('hidden');

        _this16.adjustSourceLineNumbers();

        _this16.textarea.focus();

        content = _this16.textarea.val();

        _this16.textarea.off('input.editor-firechange').on('input.editor-firechange', function () {
          _this16.element.trigger('change');
        });
        /**
         * Fires after source mode activated.
         * @event aftersourcemode
         * @memberof Editor
         * @property {object} event The jquery event object
         * @property {string} content Additional argument
         */


        _this16.element.triggerHandler('aftersourcemode', content);

        var btn = (_this16$toolbar2 = _this16.toolbar) === null || _this16$toolbar2 === void 0 ? void 0 : _this16$toolbar2 == null ? void 0 : _this16$toolbar2.find('[data-action="visual"]');

        if (btn && !_this16.isBtnOverflowedItem(btn)) {
          btn.focus();
        }
      }; // Check the false value


      var isFalse = function isFalse(v) {
        return typeof v === 'string' && v.toLowerCase() === 'false' || typeof v === 'boolean' && v === false || typeof v === 'number' && v === 0;
      };

      if (this.sourceViewActive() && !forceToSourceMode) {
        var content = this.textarea.val();
        /**
         * Fires before preview mode activated.
         * @event beforepreviewmode
         * @memberof Editor
         * @property {object} event The jquery event object
         * @property {string} content Additional argument
         */

        $.when(this.element.triggerHandler('beforepreviewmode', content)).done(function (res) {
          if (!isFalse(res)) {
            doPreviewMode(res);
          }
        });
      } else {
        var _content = this.element.html();
        /**
         * Fires before source mode activated.
         * @event beforesourcemode
         * @memberof Editor
         * @property {object} event The jquery event object
         * @property {string} content Additional argument
         */


        $.when(this.element.triggerHandler('beforesourcemode', _content)).done(function (res) {
          if (!isFalse(res)) {
            doSourceMode(res);
          }
        });
      }
    },

    /**
     * Check button is overflowed item or not.
     * @private
     * @param  {jQuery} btn button to check
     * @returns {boolean} true if button is overflowed item
     */
    isBtnOverflowedItem: function isBtnOverflowedItem(btn) {
      var toolbarApi = this.toolbar.data('toolbar') || this.toolbar.data('toolbar-flex');
      var found = false;

      if (toolbarApi) {
        toolbarApi.overflowedItems.forEach(function (item) {
          if (btn.is(item.element)) {
            found = true;
          }
        });
      }

      return found;
    },

    /**
     * Function to clear formatting on selected area.
     * @private
     * @returns {void}
     */
    clearFormatting: function clearFormatting() {
      var _this17 = this;

      var parentEl = this.getSelectionParentElement();
      var parentTag = parentEl.tagName;
      var align = {}; // Function to get text-align value if found

      var getTextAlign = function getTextAlign() {
        var isFound = function isFound(el) {
          return el && el.style && el.style.textAlign !== '';
        };

        var elem = parentEl;
        var found = isFound(elem);
        var max = 9999;

        while (!found && max > 0) {
          max--;
          elem = elem ? elem.parentNode : null;
          found = elem && elem === _this17.element[0] || isFound(elem);
        }

        var r = {
          found: elem && elem !== parentEl && elem !== _this17.element[0]
        };

        if (r.found) {
          r.elem = elem;
          r.textAlign = elem.style.textAlign;
        }

        return r;
      }; // Clear other formated tags.


      var clearFormatedTags = function clearFormatedTags() {
        var replaceTag = function replaceTag(elem) {
          var parent = elem.parentNode;
          var p = document.createElement('p');
          p.innerHTML = elem.innerHTML;
          parent.replaceChild(p, elem);
        };

        if (EDITOR_PARENT_ELEMENTS.indexOf(parentTag) > -1) {
          if (parentTag !== 'p') {
            document.execCommand('removeFormat', false, null);
            replaceTag(parentEl);
          }
        } else {
          EDITOR_PARENT_ELEMENTS.forEach(function (el) {
            if (el !== 'p') {
              var _nodes = [].slice.call(parentEl.querySelectorAll(el));

              _nodes.forEach(function (node) {
                return replaceTag(node);
              });
            }
          });
        } // Blockquote or Pre


        var nodes = [].slice.call(_this17.element[0].querySelectorAll('blockquote, pre'));

        var _loop = function _loop(i, l) {
          var found = false;
          var children = [].slice.call(nodes[i].children);

          var checkChildren = function checkChildren(childrenNodes) {
            for (var i2 = 0, l2 = childrenNodes.length; i2 < l2; i2++) {
              var child = childrenNodes[i2];
              var childChildren = [].slice.call(child.children);

              if (child === parentEl) {
                found = true;
              }

              if (childChildren.length && !found) {
                checkChildren(childChildren);
              }
            }
          };

          checkChildren(children);

          if (found) {
            document.execCommand('removeFormat', false, null);
            replaceTag(nodes[i]);
          }
        };

        for (var i = 0, l = nodes.length; i < l; i++) {
          _loop(i);
        }
      }; // Clear all lists belongs to selection area


      var clearLists = function clearLists() {
        var normalizeList = function normalizeList(list) {
          var items = [].slice.call(list.querySelectorAll('li'));

          if (items.length > 0) {
            var fragment = document.createDocumentFragment();
            items.forEach(function (item) {
              var textNode = document.createTextNode(item.textContent);
              fragment.appendChild(textNode);
              fragment.appendChild(document.createElement('br'));
            });
            var target = items[0].parentNode;
            target.parentNode.insertBefore(fragment, target.nextSibling);
            target.parentNode.removeChild(target);
          }
        };

        if (parentTag === 'li') {
          normalizeList(parentEl.parentNode);
        } else if (/ul|ol/.test(parentTag)) {
          normalizeList(parentEl);
        } else {
          var setEl = function setEl() {
            return $(parentEl).closest('.editor').length ? parentEl.parentNode : null;
          };

          var elem = parentEl.classList.contains('editor') ? parentEl : setEl();

          if (elem) {
            var lists = [].slice.call(elem.querySelectorAll('ul, ol'));
            lists.forEach(function (list) {
              return normalizeList(list);
            });
          }
        }
      }; // Check if selection contains given node


      var containsNodeInSelection = function containsNodeInSelection(node) {
        var sel = window.getSelection();
        var r = false;

        if (Environment.browser.isIE11()) {
          var rangeAt = sel.getRangeAt(0);
          var range = document.createRange();
          range.selectNode(node);
          var s2s = rangeAt.compareBoundaryPoints(Range.START_TO_END, range);
          var s2e = rangeAt.compareBoundaryPoints(Range.START_TO_START, range);
          var e2s = rangeAt.compareBoundaryPoints(Range.END_TO_START, range);
          var e2e = rangeAt.compareBoundaryPoints(Range.END_TO_END, range);
          r = s2s !== s2e || e2s !== e2e || s2s !== e2e;
        } else {
          r = sel.containsNode(node, true);
        }

        return r;
      }; // Convert hyperlinks to plain text in selected area.


      var hyperlinksToText = function hyperlinksToText() {
        var toText = function toText(a) {
          var parent = a.parentNode;
          var text = a.firstChild;
          parent.insertBefore(text, a);
          parent.removeChild(a);
          parent.normalize();
        };

        if (parentTag === 'a') {
          toText(parentEl);
        } else {
          var links = [].slice.call(parentEl.querySelectorAll('a'));
          links.forEach(function (a) {
            if (containsNodeInSelection(a)) {
              toText(a);
            }
          });
        }
      };

      if (parentEl && parentTag) {
        parentTag = parentTag.toLowerCase();
        align = getTextAlign();
        clearLists();
        clearFormatedTags();
        hyperlinksToText();
      } // Some browser (IE, Firefox) use attr 'align' instead style `text-align`


      var gParentEl = parentEl.parentNode;

      if (gParentEl && gParentEl !== this.element[0]) {
        var alignAttrElems = [].slice.call(gParentEl.querySelectorAll('[align]'));
        alignAttrElems.forEach(function (el) {
          return el.removeAttribute('align');
        });
      }

      document.execCommand('removeFormat', false, null); // Restore style `text-align`, some browser (chrome, safari) clear `text-align` on parent node with command `removeFormat`

      if (align.found) {
        align.elem.style.textAlign = align.textAlign;
      }
    },

    /**
     * Get selection parent element.
     * @private
     * @returns {object} parent element.
     */
    getSelectionParentElement: function getSelectionParentElement() {
      var parentEl = null;
      var sel;

      if (window.getSelection) {
        sel = window.getSelection();

        if (sel.rangeCount) {
          parentEl = sel.getRangeAt(0).commonAncestorContainer;

          if (parentEl.nodeType !== 1) {
            parentEl = parentEl.parentNode;
          }
        }
      } else {
        sel = document.selection;

        if (sel && sel.type !== 'Control') {
          parentEl = sel.createRange().parentElement();
        }
      }

      return parentEl;
    },

    /**
     * Get ['foreColor'|'backColor'] button icon color state for the toolbar.
     * @private
     * @param  {[type]} action [description]
     * @returns {object} The button state info.
     */
    checkColorButtonState: function checkColorButtonState(action) {
      var cpBtn = $("[data-action=\"".concat(action, "\"]"), this.toolbar);
      var cpApi = cpBtn.data('colorpicker');
      var preventColors = ['transparent', '#1a1a1a', '#f0f0f0', '#ffffff', '#313236'];
      var color = document.queryCommandValue(action); // Set selection color checkmark in picker popup
      // by adding/updating ['data-value'] attribute

      if (cpApi && color !== 'rgb(0, 0, 0)') {
        if (Environment.browser.name === 'firefox' && action === 'backColor') {
          color = $(window.getSelection().focusNode.parentNode).css('background-color');
        } // IE-11 queryCommandValue returns the as decimal


        if (typeof color === 'number') {
          color = cpApi.decimal2rgb(color);
        }

        color = color ? cpApi.rgb2hex(color) : '';
        cpBtn.attr('data-value', color).find('.icon').css('color', preventColors.indexOf(color.toLowerCase()) > -1 ? '' : color);
      }

      return {
        cpBtn: cpBtn,
        cpApi: cpApi,
        color: color
      };
    },

    /**
     * Execute ['foreColor'|'backColor'] button actions.
     * @private
     * @param  {[type]} action [description]
     */
    execColorActions: function execColorActions(action) {
      var _this18 = this;

      var state = this.checkColorButtonState(action);
      var cpBtn = state.cpBtn;
      var cpApi = state.cpApi;
      cpBtn.one('selected.editor', function (e, item) {
        // Detect Flex Toolbar item
        var target = item;

        if (target !== undefined && !(target instanceof $) && target.element) {
          target = $(item.element);
        } // Use the value to set the color


        var value = "".concat(target.data('value')).toLowerCase();
        value = value !== '#' ? value : '';

        if (value.indexOf('#') === -1) {
          value = "#".concat(value);
        }

        if (value === '#') {
          value = ''; // clear format
        }

        cpBtn.attr('data-value', value).find('.icon').css('color', value);

        if (Environment.browser.name === 'ie' || action === 'foreColor') {
          if (value) {
            document.execCommand(action, false, value);
          } else {
            document.execCommand('removeFormat', false, action);
          }
        } else {
          // [action: backColor] - for Chrome/Firefox/Safari
          // FIX: "backColor" - Chrome/Firefox/Safari
          // some reason font/span node not get inserted with "backColor"
          // so use "fontSize" command to add node, then remove size attribute
          // this fix will conflict with combination of font size & background color
          document.execCommand('fontSize', false, '2');

          var parent = _this18.getSelectionParentElement().parentNode;

          var els = parent.getElementsByTagName('font'); // Clearing all the background style in any element node in selection's parent

          for (var i = 0, j = els.length; i < j; i++) {
            if (els[i].hasAttribute('style')) {
              els[i].style.backgroundColor = '';
            }
          } // Using timeout, firefox not executes with current call stack


          setTimeout(function () {
            for (var _i = 0, l = els.length; _i < l; _i++) {
              if (els[_i].hasAttribute('size')) {
                els[_i].style.backgroundColor = value;

                els[_i].removeAttribute('size');
              }
            }
          }, 0);
        }
      }); // Toggle colorpicker

      cpApi.toggleList();
    },

    /**
     * Formats the currently-selected block of content in the editor with a predefined HTML element
     * and style, if applicable.
     * @param {string} el, the desired block-level element with which to wrap the current block.
     * @returns {void}
     */
    execFormatBlock: function execFormatBlock(el) {
      if (this.selection === undefined) {
        this.checkSelection();
      }

      if (!this.selection || !(this.selection instanceof Selection)) {
        return;
      }

      var selectionData = this.getSelectionData(this.selection.anchorNode); // FF handles blockquote differently on formatBlock
      // allowing nesting, we need to use outdent
      // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla

      if (el === 'blockquote' && selectionData.el && selectionData.el.parentNode.tagName.toLowerCase() === 'blockquote') {
        return document.execCommand('outdent', false, null);
      }

      if (selectionData.tagName === el) {
        el = 'p';
      } // When IE we need to add <> to heading elements and
      // blockquote needs to be called as indent
      // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
      // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777


      if (Environment.browser.name === 'ie') {
        if (el === 'blockquote') {
          return document.execCommand('indent', false, el);
        }

        el = "<".concat(el, ">");
      } // Reset some formatting thats not consistent with headers


      if (document.queryCommandState('bold')) {
        document.execCommand('bold', false, el);
      }

      if (document.queryCommandState('italic')) {
        document.execCommand('italic', false, el);
      }

      if (document.queryCommandState('underline')) {
        document.execCommand('underline', false, el);
      }

      if (document.queryCommandState('strikethrough')) {
        document.execCommand('strikethrough', false, el);
      }

      if (selectionData.el && selectionData.el.innerHTML && selectionData.el.innerHTML.indexOf('<font') > -1) {
        document.execCommand('removeFormat', false, 'foreColor');
        document.execCommand('removeFormat', false, 'backColor');
      }

      if (selectionData.el && selectionData.el.innerHTML && selectionData.el.innerHTML.substr(0, 4) === '<ul>') {
        document.execCommand('insertunorderedlist', false, el);
        document.execCommand('removeFormat', false, el);
      }

      if (this.selection.anchorNode && this.selection.anchorNode.parentNode && this.selection.anchorNode.parentNode.parentElement.nodeName === 'UL') {
        document.execCommand('insertunorderedlist', false, el);
        document.execCommand('removeFormat', false, el);
      }

      if (selectionData.el && selectionData.el.innerHTML && selectionData.el.innerHTML.substr(0, 4) === '<ol>') {
        document.execCommand('insertorderedlist', false, el);
        document.execCommand('removeFormat', false, el);
      }

      if (this.selection.anchorNode && this.selection.anchorNode.parentNode && this.selection.anchorNode.parentNode.parentElement.nodeName === 'OL') {
        document.execCommand('insertorderedlist', false, el);
        document.execCommand('removeFormat', false, el);
      }

      document.execCommand('formatBlock', false, el);
      this.checkActiveButtons();
    },
    // Get What is Selected
    getSelectionData: function getSelectionData(el) {
      var tagName;

      if (el && el.tagName) {
        tagName = el.tagName.toLowerCase();
      }

      while (el && EDITOR_PARENT_ELEMENTS.indexOf(tagName) === -1) {
        el = el.parentNode;

        if (el && el.tagName) {
          tagName = el.tagName.toLowerCase();
        }
      }

      return {
        el: el,
        tagName: tagName
      };
    },
    isListItemChild: function isListItemChild(node) {
      var parentNode = node.parentNode;
      var tagName = parentNode.tagName.toLowerCase();

      while (EDITOR_PARENT_ELEMENTS.indexOf(tagName) === -1 && tagName !== 'div') {
        if (tagName === 'li') {
          return true;
        }

        parentNode = parentNode.parentNode;

        if (parentNode && parentNode.tagName) {
          tagName = parentNode.tagName.toLowerCase();
        } else {
          return false;
        }
      }

      return false;
    },
    destroyToolbar: function destroyToolbar() {
      // Unbind all events attached to the old element that involve triggering the toolbar hide/show
      var checkJQ = function checkJQ(el) {
        return el || $();
      };

      this.toolbar = checkJQ(this.toolbar);
      this.element = checkJQ(this.element);
      this.textarea = checkJQ(this.textarea);
      var toolbarApi = this.toolbar.data('toolbar') || this.toolbar.data('toolbar-flex');

      if (toolbarApi) {
        toolbarApi.destroy();
      } // Cleanup buttons


      var buttons = this.toolbar.find('button');

      for (var i = 0, l = buttons.length; i < l; i++) {
        var tooltip = $(buttons[i]).data('tooltip');

        if (tooltip && typeof tooltip.destroy === 'function') {
          tooltip.destroy();
        }

        var button = $(buttons[i]).data('button');

        if (button && typeof button.destroy === 'function') {
          button.destroy();
        }
      } // Cleanup pickers


      var colorpickers = $('[data-action="foreColor"], [data-action="backColor"]', this.element);

      for (var _i2 = 0, _l = colorpickers.length; _i2 < _l; _i2++) {
        var colorpicker = $(colorpickers[_i2]).data('colorpicker');

        if (colorpicker && typeof colorpicker.destroy === 'function') {
          colorpicker.destroy();
        }
      }

      if (this.fontPickerElem) {
        this.fontPickerElem.off("font-selected.".concat(COMPONENT_NAME$M));
        var fontpickerAPI = this.fontPickerElem.data('fontpicker');

        if (fontpickerAPI) {
          fontpickerAPI.destroy();
        }

        delete this.fontPickerElem;
      } // Unbind/Remove Toolbar Component (generically)


      this.toolbar.off(["click.".concat(COMPONENT_NAME$M), "selected.".concat(COMPONENT_NAME$M)].join(' '));
      this.toolbar.remove();
      delete this.toolbar; // Remove events that could be bound to either:
      // - the WYSIWYG editor
      // - the source code view

      var boundEventNames = ['blur', 'DOMNodeInserted', 'focus', "input.".concat(COMPONENT_NAME$M), "keydown.".concat(COMPONENT_NAME$M), "keypress.".concat(COMPONENT_NAME$M), "keyup.".concat(COMPONENT_NAME$M), "mouseup.".concat(COMPONENT_NAME$M), "mousedown.".concat(COMPONENT_NAME$M), "paste.".concat(COMPONENT_NAME$M)].join(' ');
      this.element.off(boundEventNames);
      this.textarea.off(boundEventNames);
      this.element.prev('.label').off('click.editor');
      this.container.closest('.editor-container').off('focus.editor blur.editor click.editorlinks');
      var state = this.checkColorButtonState('foreColor');
      var cpBtn = state.cpBtn;
      cpBtn.off('selected.editor');
      state = this.checkColorButtonState('backColor');
      cpBtn = state.cpBtn;
      cpBtn.off('selected.editor');
      delete this.pasteWrapper;
      delete this.pasteWrapperHtml;
      delete this.selectionHandler;
      $(window).off('resize.editor');

      if (this.modals) {
        var modalTypes = Object.keys(this.modals);

        for (var _i3 = 0, _l2 = modalTypes.length; _i3 < _l2; _i3++) {
          var modal = $("#modal-".concat(modalTypes[_i3], "-").concat(this.id));
          var modalApi = modal.data('modal');
          modal.off('beforeclose.editor close.editor open.editor beforeopen.editor');

          if (modalApi && typeof modalApi.destroy === 'function') {
            modalApi.destroy();
          }

          modal.remove();
        }
      }

      delete this.modals;
      this.element.trigger('destroy.toolbar.editor');
    },

    /**
     * Setup the preview mode.
     * @private
     * @returns {void}
     */
    setPreviewMode: function setPreviewMode() {
      var containerClassList = this.container[0].classList;
      var elementClassList = this.element[0].classList;

      if (!containerClassList.contains('is-preview')) {
        if (!this.isEditable()) {
          var classes = ['is-disabled', 'is-readonly', 'is-preview'];
          containerClassList.remove.apply(containerClassList, classes);
          elementClassList.remove.apply(elementClassList, classes);
        }

        if (this.sourceViewActive()) {
          this.toggleSource();
        }

        containerClassList.add('is-preview');
        elementClassList.remove('is-preview');
        this.element[0].setAttribute('contenteditable', false);
        this.element[0].removeAttribute('aria-multiline');
        this.element[0].removeAttribute('role'); // Remove tooltip for links in editor

        var links = [].slice.call(this.element[0].querySelectorAll('a'));
        links.forEach(function (link) {
          var tooltipApi = $(link).data('tooltip');

          if (tooltipApi && typeof tooltipApi.destroy === 'function') {
            tooltipApi.destroy();
          }
        });
      }
    },

    /**
     * Destroy preview mode.
     * @private
     * @returns {void}
     */
    destroyPreviewMode: function destroyPreviewMode() {
      if (!this.container[0]) {
        return;
      }

      var classList = this.container[0].classList;

      if (classList.contains('is-preview')) {
        classList.remove('is-preview');

        if (!this.previewRendered) {
          this.previewRendered = true;
          this.init();
        } else {
          this.element[0].setAttribute('aria-multiline', true);
          this.element[0].setAttribute('role', 'textbox');
          this.bindAnchorPreview();
        }
      }
    },

    /**
     * Check for the editor is in preview mode.
     * @returns {boolean} true if editor in preview mode
     */
    isPreview: function isPreview() {
      return this.container[0] ? this.container[0].classList.contains('is-preview') : false;
    },

    /**
     * Check for the editor is in editable mode.
     * @returns {boolean} true if editor is editabled
     */
    isEditable: function isEditable() {
      var _this19 = this;

      var isEnabled = true;

      var isContains = function isContains(el, className) {
        return el.classList.contains(className);
      };

      ['is-disabled', 'is-readonly', 'is-preview'].forEach(function (className) {
        if (isContains(_this19.container[0], className) || isContains(_this19.element[0], className)) {
          isEnabled = false;
        }
      });
      return isEnabled;
    },

    /**
     * Updates the component instance.  Can be used after being passed new settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, EDITOR_DEFAULTS);
      }

      return this.teardown().init();
    },
    teardown: function teardown() {
      this.destroyToolbar(); // Cleanup Source View elements and events

      if (this.sourceView) {
        this.sourceView.off('.editor');
        this.sourceView.remove();
        delete this.sourceView;
      }

      delete this.textarea;

      if (this.lineNumbers) {
        delete this.lineNumbers;
      }

      if (this.selection) {
        delete this.selection;
      }

      if (this.selectionRange) {
        delete this.selectionRange;
      } // Cleanup container


      this.container.off(["focusin.".concat(COMPONENT_NAME$M), "focusout.".concat(COMPONENT_NAME$M), "mouseneter.".concat(COMPONENT_NAME$M), "mouseleave.".concat(COMPONENT_NAME$M), "input.".concat(COMPONENT_NAME$M), "keyup.".concat(COMPONENT_NAME$M)].join(' '));
      this.container.removeClass('editor-container');
      delete this.container; // Cleanup label

      this.label.off("click.".concat(COMPONENT_NAME$M));
      delete this.label; // Cleanup Editor Element

      this.element.attr('contenteditable', 'false');
      this.element.off(["mousedown.".concat(COMPONENT_NAME$M), "updated.".concat(COMPONENT_NAME$M)].join(' '));
      $('html').off("themechanged.".concat(COMPONENT_NAME$M));
      delete this.id;
      delete this.isActive;
      return this;
    },

    /**
     * Destroy this component instance and remove all events and reset back to default.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$M);
    },

    /**
    * Disable the editable area.
    * @returns {void}
    */
    disable: function disable() {
      this.destroyPreviewMode();
      this.element.addClass('is-disabled').attr('contenteditable', 'false');
      this.container.addClass('is-disabled');
    },

    /**
    * Enable the editable area.
    * @returns {void}
    */
    enable: function enable() {
      this.destroyPreviewMode();
      this.element.removeClass('is-disabled is-readonly').attr('contenteditable', 'true');
      this.container.removeClass('is-disabled is-readonly');
    },

    /**
    * Make the editable area readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      this.destroyPreviewMode();
      this.element.removeClass('is-readonly').attr('contenteditable', 'false');
      this.container.addClass('is-readonly');
    },

    /**
     * Make the editable mode.
     * @returns {void}
     */
    editable: function editable() {
      this.enable();
    },

    /**
     * Make the preview mode.
     * @returns {void}
     */
    preview: function preview() {
      if (!this.container[0].classList.contains('is-preview')) {
        this.setPreviewMode();
      }
    },

    /**
     * Called whenever a paste event has occured
     * @returns {void}
     */
    onPasteTriggered: function onPasteTriggered() {
      if (Environment.browser.name !== 'firefox' && document.addEventListener) {
        document.addEventListener('paste', function (e) {
          if (typeof e.clipboardData !== 'undefined') {
            var copiedData = e.clipboardData.items[0]; // Get the clipboard data
            // If the clipboard data is of type image, read the data

            if (copiedData.type.indexOf('image') === 0) {
              var imageFile = copiedData.getAsFile(); // We will use HTML5 FileReader API to read the image file

              var reader = new FileReader();

              reader.onload = function (evt) {
                var result = evt.target.result; // base64 encoded image

                document.execCommand('insertImage', false, result); // Create an image element and append it to the content editable div
                // var img = document.createElement('img');
                // img.src = result;
                // document.getElementById('editablediv').appendChild(img);
              }; // Read the image file


              reader.readAsDataURL(imageFile);
            }
          }
        }, false);
      }
    },
    isWordFormat: function isWordFormat(content) {
      return /<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i.test(content) || /class="OutlineElement/.test(content) || /id="?docs\-internal\-guid\-/.test(content);
    },
    cleanWordHtml: function cleanWordHtml(content) {
      var s = content; // Word comments like conditional comments etc

      s = s.replace(/<!--[\s\S]+?-->/gi, ''); // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
      // MS Office namespaced tags, and a few other tags

      s = s.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, ''); // Convert <s> into <strike> for line-though

      s = s.replace(/<(\/?)s>/gi, '<$1strike>'); // Replace nbsp entites to char since it's easier to handle

      s = s.replace(/&nbsp;/gi, "\xA0"); // Convert <span style="mso-spacerun:yes"></span> to string of alternating
      // breaking/non-breaking spaces of same length

      s = s.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function (str, spaces) {
        return spaces.length > 0 ? spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join("\xA0") : '';
      }); // Remove line breaks / Mso classes

      s = s.replace(/(\n|\r| class=(\'|")?Mso[a-zA-Z]+(\'|")?)/g, ' ');
      var badTags = ['style', 'script', 'applet', 'embed', 'noframes', 'noscript']; // Remove everything in between and including "badTags"

      for (var i = 0, l = badTags.length; i < l; i++) {
        var re = new RegExp("<".concat(badTags[i], ".*?").concat(badTags[i], "(.*?)>"), 'gi');
        s = s.replace(re, '');
      }

      return s;
    },
    // Strip attributes
    stripAttribute: function stripAttribute(s, attribute, attributeStripper) {
      return attribute === 'style' ? this.stripStyles(s, attributeStripper) : s.replace(attributeStripper, '');
    },
    // Strip styles
    stripStyles: function stripStyles(s, styleStripper) {
      var stylesToKeep = ['color', 'font-size', 'background', 'font-weight', 'font-style', 'text-decoration', 'text-align'];
      return s.replace(styleStripper, function (m) {
        m = m.replace(/( style=|("|\'))/gi, '');
        var attributes = m.split(';');
        var strStyle = '';

        for (var i = 0; i < attributes.length; i++) {
          var entry = attributes[i].split(':');
          strStyle += stylesToKeep.indexOf(entry[0]) > -1 ? "".concat(entry[0], ":").concat(entry[1], ";") : '';
        }

        return strStyle !== '' ? " style=\"".concat(strStyle, "\"") : '';
      });
    },

    /**
     * Format given string to proper indentation.
     * @param {string} html true will force to toggle in to source mode.
     * @returns {string} formated value
     */
    formatHtml: function formatHtml(html) {
      html = html.trim();
      var s = this.settings;
      var tokens = html.split(/</);
      var indentLevel = 0;
      var result = '';

      function getIndent(level) {
        var tabsize = typeof s.formatterTabsize === 'number' ? s.formatterTabsize : 4;
        var indentation = '';
        var i = level * tabsize;

        if (level > -1) {
          while (i--) {
            indentation += ' ';
          }
        }

        return indentation;
      }

      for (var i = 0, l = tokens.length; i < l; i++) {
        var parts = tokens[i].split(/>/);

        if (parts.length === 2) {
          if (tokens[i][0] === '/') {
            indentLevel--;
          }

          result += getIndent(indentLevel);

          if (tokens[i][0] !== '/') {
            indentLevel++;
          }

          if (i > 0) {
            result += '<';
          }

          result += "".concat(parts[0].trim(), ">\n");

          if (parts[1].trim() !== '') {
            result += "".concat(getIndent(indentLevel) + parts[1].trim().replace(/\s+/g, ' '), "\n");
          }

          if (parts[0].match(/^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)/)) {
            indentLevel--;
          }
        } else {
          result += "".concat(getIndent(indentLevel) + parts[0], "\n");
        }
      }

      return result.trim();
    },

    /**
     * Clear the editor of its contents.
     */
    clear: function clear() {
      this.element.empty();
      this.textarea.empty();
      this.sourceView.find('.line-numbers').empty();
      this.sourceView.find('.textarea-print').empty();
    }
  };

  $.fn.editor = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$M);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$M, new Editor(this, settings));
      }
    });
  };

  var COMPONENT_NAME$N = 'hierarchy';
  /**
   * The displays customizable hierarchical data such as an org chart.
   *
   * @class Hierarchy
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {string} [settings.legend] Pass in custom markdown for the legend structure.
   * @param {string} [settings.legendKey] Key to use for the legend matching
   * @param {array} [settings.dataset=[]] Hierarchical Data to display
   * @param {boolean} [settings.newData=[]] New data to be appended into dataset
   * @param {string} [settings.templateId] Additional product name information to display
   * @param {number} [settings.leafHeight=null] Set the height of the leaf
   * @param {number} [settings.leafWidth=null] Set the width of the leaf
   * @param {string} [settings.beforeExpand=null] A callback that fires before node expansion of a node.
   * @param {boolean} [settings.renderSubLevel=false] If true elements with no children will be rendered detached
   * @param {boolean} [settings.layout=string] Which layout should be rendered {'horizontal', 'mobile-only', 'stacked', 'paging'}
   * @param {object} [settings.emptyMessage] An optional settings object for the empty message when there is no data.
   * @param {string} [settings.emptyMessage.title=(Locale ? Locale.translate('NoData')] The text to show
   * @param {string} [settings.emptyMessage.info=''] Longer block of test to show.
   * @param {string} [settings.emptyMessage.icon='icon-empty-no-data'] The icon to show.
   * @param {object} [settings.emptyMessage.button='{}'] The button and text to show with an optional click function.
   */

  var HIERARCHY_DEFAULTS = {
    legend: [],
    legendKey: '',
    dataset: [],
    newData: [],
    templateId: '',
    // Id to the Html Template
    leafHeight: null,
    leafWidth: null,
    beforeExpand: null,
    renderSubLevel: false,
    layout: 'horizontal',
    // stacked, horizontal, paging, mobile-only
    rootId: null,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };

  function Hierarchy(element, settings) {
    this.settings = utils.mergeSettings(element, settings, HIERARCHY_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Hierarchy Methods


  Hierarchy.prototype = {
    init: function init() {
      var s = this.settings; // Set chart id

      if (this.rootId === null && this.element.attr('id') === undefined) {
        this.rootId = 'hierarchyChart';
      } else if (this.element.attr('id')) {
        this.settings.rootId = this.element.attr('id');
      } else {
        this.rootId = 'hierarchyChart';
      }

      s.colorClass = ['azure08', 'turquoise02', 'amethyst06', 'slate06', 'amber06', 'emerald07', 'ruby06']; // Setup events

      this.handleEvents(); // Safety check, check for data

      if (s.dataset === undefined || s.dataset.length === 0 || !Array.isArray(s.dataset)) {
        this.element.emptymessage(s.emptyMessage);
        return;
      }

      if (s.dataset[0] && s.dataset[0].children && s.dataset[0].children.length > 0 || this.isStackedLayout()) {
        this.render(s.dataset[0]);
      } else if (s.dataset && s.dataset.children.length > 0) {
        this.render(s.dataset);
      }

      if (s.leafHeight !== null && s.leafWidth !== null) {
        var style = "'body .hierarchy .leaf,body .hierarchy .sublevel .leaf,body .hierarchy .container .root.leaf { width: ".concat(s.leafWidth, "px;  height: ").concat(s.leafHeight, "px;  }'");
        $("<style type=\"text/css\" id=\"hierarchyLeafStyles\">".concat(style, "</style>")).appendTo('body');
      }

      if (s.layout) {
        this.setLayout(s.layout);
      } // Automation attributes


      this.setAutomationAttributes();
    },

    /**
     * Set automation attributes.
     * @private
     * @returns {void}
     */
    setAutomationAttributes: function setAutomationAttributes() {
      var _this = this;

      var leaves = [].slice.call(this.element[0].querySelectorAll('.leaf'));
      leaves.forEach(function (leaf) {
        var leafJq = $(leaf);
        var d = leafJq.data();

        if (d && d.attributes) {
          var btnToggle = leafJq.find('.btn-expand, .btn-collapse');
          utils.addAttributes(leafJq, _this, d.attributes, 'hierarchy-leaf');
          utils.addAttributes(btnToggle, _this, d.attributes, 'hierarchy-btn-toggle');
        }
      });
    },

    /**
     * Setup the hierarchy layout.
     * @private
     * @param {string} layout The layout to display
     * @returns {void}
     */
    setLayout: function setLayout(layout) {
      if (this.isPagingLayout()) {
        layout = 'paging';
      }

      if (this.isMobileOnly()) {
        layout = 'mobile-only';
      }

      switch (layout) {
        case 'horizontal':
          this.element.addClass('layout-is-horizontal');
          break;

        case 'stacked':
          this.element.addClass('layout-is-stacked');
          break;

        case 'paging':
          this.element.addClass('layout-is-paging');
          break;

        case 'mobile-only':
          this.element.addClass('layout-is-mobile-only');
          break;

        default:
          this.element.addClass('layout-is-horizontal');
      }
    },

    /**
     * Attach all event handlers
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      var s = this.settings; // Expand or Collapse

      self.element.off('click.hierarchy').on('click.hierarchy', '.btn', function (e) {
        // Stacked layout doesn't expand/collapse
        if (self.isStackedLayout()) {
          return;
        }

        if (s.newData.length > 0) {
          s.newData = [];
        }

        var nodeId = $(this).closest('.leaf').attr('id');
        var nodeData = $("#".concat(nodeId)).data();
        var domObject = {
          branch: $(this).closest('li'),
          leaf: $(this).closest('.leaf'),
          button: $(this)
        };

        if (nodeData.isExpanded) {
          self.collapse(e, nodeData, domObject);
        } else {
          self.expand(e, nodeData, domObject);
        }
      });
      this.element.on('keypress', '.leaf', function (e) {
        var nodeId = $(this).attr('id');
        var nodeData = $("#".concat(nodeId));

        if (e.which === 13) {
          if (nodeData.isExpanded) {
            self.collapse(e, nodeData);
          } else {
            self.expand(e, nodeData);
          }
        }
      });
      self.element.off('dblclick.hierarchy').on('dblclick.hierarchy', '.leaf', function (e) {
        var nodeId = e.currentTarget.id;
        var nodeData = $("#".concat(nodeId)).data();
        var dblClickEvent = {
          event: e,
          data: nodeData
        };
        e.stopImmediatePropagation();

        _this2.element.trigger('dblclick', dblClickEvent);
      });
      /**
       * Fires when node is selected
       * @event selected
       * @memberof Hierarchy
       * @param {object} event - The jquery event object
       * @param {object} eventInfo - More info to identify the node.
       */

      self.element.on('mouseup', '.leaf, .back button', function (e) {
        var leaf = $(this);
        var target = $(e.target);
        var hierarchy = leaf.closest('.hierarchy').data('hierarchy');
        var nodeData = leaf.data();
        var nodeId = $(this).attr('id');
        var targetInfo = {
          target: e.target,
          pageX: e.pageX,
          pageY: e.pageY
        };
        var isButton = target.is('button');
        var isNotBack = !target.hasClass('btn-back');
        var isBack = target.is('.btn-back');
        var svgHref = target.find('use').prop('href');
        var isCollapseButton = svgHref ? svgHref.baseVal === '#icon-caret-up' : false;
        var isExpandButton = svgHref ? svgHref.baseVal === '#icon-caret-down' : false;
        var isForward = svgHref ? svgHref.baseVal === '#icon-caret-right' : false;
        var isActions = target.hasClass('btn-actions');
        var isAction = target.is('a') && target.parent().parent().is('ul.popupmenu');
        var isAncestor = leaf.hasClass('ancestor');
        var eventType = 'selected';
        e.stopImmediatePropagation();

        if (isAction && $(target).parent().data('disabled')) {
          return;
        }

        $('.leaf.is-selected').removeClass('is-selected');
        $("#".concat(nodeId)).addClass('is-selected'); // Is collapse event

        if (isButton && isCollapseButton && isNotBack) {
          eventType = isAncestor ? 'back' : 'collapse';
        } // Is expand event


        if (isButton && isExpandButton && isNotBack) {
          eventType = 'expand';
        }

        if (isBack) {
          eventType = 'back';
        }

        if (isActions) {
          eventType = 'actions';
          hierarchy.buildActionsMenu(nodeData, leaf);
        }

        if (isAction) {
          eventType = 'action';
        }

        if (isButton && isForward && isNotBack) {
          eventType = 'forward';
        } // Is right click event


        if (e.which === 3) {
          eventType = 'rightClick';
        }

        if (!hierarchy) {
          return;
        }

        var eventInfo = {
          id: nodeId,
          data: nodeData,
          actionReference: isAction ? target.data('actionReference') : null,
          targetInfo: targetInfo,
          eventType: eventType,
          isForwardEvent: hierarchy.isForwardEvent(eventType),
          isBackEvent: hierarchy.isBackEvent(eventType),
          isAddEvent: hierarchy.isAddEvent(eventType),
          isExpandEvent: hierarchy.isExpandEvent(eventType),
          isCollapseEvent: hierarchy.isCollapseEvent(eventType),
          isSelectedEvent: hierarchy.isSelectedEvent(eventType),
          isActionsEvent: hierarchy.isActionsEvent(eventType),
          isActionEvent: hierarchy.isActionEvent(eventType),
          allowLazyLoad: hierarchy.allowLazyLoad(nodeData, eventType)
        };
        leaf.trigger('selected', eventInfo);
      });
    },

    /**
     * Manually set selection on a leaf
     * @public
     * @param {string} nodeId id used to find leaf
     */
    selectLeaf: function selectLeaf(nodeId) {
      var leaf = $("#".concat(nodeId));
      $('.leaf.is-selected').removeClass('is-selected');
      leaf.addClass('is-selected');
      var eventInfo = {
        data: leaf.data(),
        actionReference: null,
        isForwardEvent: false,
        isBackEvent: false,
        isAddEvent: false,
        isExpandEvent: false,
        isCollapseEvent: false,
        isSelectedEvent: true,
        isActionsEvent: false,
        isActionEvent: false,
        allowLazyLoad: false
      };
      leaf.trigger('selected', eventInfo);
    },

    /**
     * Update existing leaf actions with new actions
     * @public
     * @param {object} eventInfo eventType, target, data, ect..
     * @param {array} updatedActions -actions to be appended to the menu
     */
    updateActions: function updateActions(eventInfo, updatedActions) {
      var leaf = $(eventInfo.targetInfo.target).closest('.leaf');
      var nodeData = eventInfo.data;
      var popupMenu = $(leaf).find('.popupmenu');
      var popupMenuControl = popupMenu.data('trigger').data().popupmenu;
      var lineItemsToRemove = popupMenu.find('li').not(':eq(0)');
      $(lineItemsToRemove).each(function (idx, item) {
        $(item).remove();
      });
      nodeData.menu.actions = updatedActions;
      popupMenu.append(this.getActionMenuItems(nodeData)); // Setup flag to prevent double-open

      popupMenuControl.keydownThenClick = true;
      popupMenuControl.open();
      popupMenuControl.handleAfterPlace(null, {
        element: popupMenu.parent(),
        parent: $(leaf).find('.btn-actions'),
        placement: 'bottom'
      });
    },

    /**
     * @private
     * @param {object} data associated with leaf
     * @param {leaf} leaf jQuery reference in DOM
     */
    buildActionsMenu: function buildActionsMenu(data, leaf) {
      var popupMenu = $(leaf).find('.popupmenu');
      var template = []; // Safety

      if (data.menu === undefined) {
        return;
      } // Reset & rebuild


      popupMenu.empty();

      if (data.menu.details) {
        popupMenu.addClass('has-detail-fields');
        template.push("<li><div class=\"detail-fields\">".concat(data.menu.details.map(function (v) {
          return "<div class=\"dt-fields-row\"><div class=\"dt-fields-cell\">".concat(v.key, "</div><div class=\"dt-fields-cell\">").concat(v.value, "</div></div>");
        }).join(''), "</div></li>"));
      }

      if (data.menu.actions) {
        template.push(this.getActionMenuItems(data));
      }

      template.forEach(function (i) {
        popupMenu.append(i);
      });
    },

    /**
     * @private
     * @param {object} data the data to be iterated
     * @returns {string} returns list items as a string
     */
    getActionMenuItems: function getActionMenuItems(data) {
      var _this3 = this;

      var actions = data.menu.actions.map(function (a) {
        if (a.disabled === undefined) {
          a.disabled = false;
        }

        return a;
      });
      var opAttr;

      var opAttrStr = function opAttrStr(idx) {
        return utils.stringAttributes(_this3, opAttr, "option-".concat(idx));
      };

      if (data.attributes) {
        opAttr = this.getAutomationAttributes(data, '-hierarchy-popupmenu');
      } // Ignoring next line. Eslint expects template literals vs string concat.
      // However template literals break JSON.stringify() in this case

      /* eslint-disable */


      var actionMarkup = actions.map(function (a, idx) {
        if (a.hasOwnProperty('data')) {
          if (a.data.type === 'separator') {
            return "<li class=\"separator\"></li>";
          }
        }

        return "\n        <li data-disabled=\"".concat(a.disabled, "\" class=\"").concat(a.menu ? 'submenu' : '', "\">\n          <a href=\"").concat(a.url, "\"").concat(opAttrStr(idx), " data-action-reference=\"").concat(JSON.stringify(a.data), "\">\n            ").concat(a.value, "\n            ").concat(a.menu ? '<svg class="arrow icon-dropdown icon" focusable="false" aria-hidden="true" role="presentation"><use href="#icon-dropdown"></use></svg>' : '', "\n          </a>\n          ").concat(a.menu ? "<div class=\"wrapper\" role=\"application\" aria-hidden=\"true\">\n            <ul class=\"popupmenu\">\n              ".concat(a.menu.map(function (x, idx2) {
          return "\n              <li data-disabled=\"".concat(a.disabled, "\">\n                <a href=\"").concat(a.url, "\"").concat(opAttrStr("".concat(idx, "-").concat(idx2)), " data-action-reference=\"").concat(JSON.stringify(a.data), "\">").concat(x.value, "</a>\n              </li>");
        }).join(''), "\n            </ul>\n          </div>") : '', "\n        </li>");
      }).join('');
      /* eslint-enable */

      return actionMarkup;
    },

    /**
     * Check if event is back
     * @private
     * @param {string} eventType is back
     * @returns {boolean} true if back event
     */
    isBackEvent: function isBackEvent(eventType) {
      return eventType === 'back';
    },

    /**
     * Check if event is forward
     * @private
     * @param {string} eventType is forward
     * @returns {boolean} true if forward event
     */
    isForwardEvent: function isForwardEvent(eventType) {
      return eventType === 'forward';
    },

    /**
     * Check if event is add
     * @private
     * @param {string} eventType is add
     * @returns {boolean} true if add event
     */
    isAddEvent: function isAddEvent(eventType) {
      return eventType === 'add';
    },

    /**
     * Check if event is expand
     * @private
     * @param {string} eventType is expand
     * @returns {boolean} true if expand event
     */
    isExpandEvent: function isExpandEvent(eventType) {
      return eventType === 'expand';
    },

    /**
     * Check if event is collapse
     * @private
     * @param {string} eventType is collapse
     * @returns {boolean} true if collapse event
     */
    isCollapseEvent: function isCollapseEvent(eventType) {
      return eventType === 'collapse';
    },

    /**
     * Check if event is selected
     * @private
     * @param {string} eventType is selected
     * @returns {boolean} true if selected event
     */
    isSelectedEvent: function isSelectedEvent(eventType) {
      return eventType === 'selected';
    },

    /**
     * Checks if is actions event
     * @private
     * @param {string} eventType is actions
     * @returns {boolean} true if actions event
     */
    isActionsEvent: function isActionsEvent(eventType) {
      return eventType === 'actions';
    },

    /**
     * @private
     * @param {string} evenType is action
     * @returns {boolean} true if action
     */
    isActionEvent: function isActionEvent(evenType) {
      return evenType === 'action';
    },

    /**
     * Check to see if lazy load is allowed
     * @private
     * @param {object} data contains info
     * @param {string} eventType is expand
     * @returns {boolean} true if lazy load is allowed
     */
    allowLazyLoad: function allowLazyLoad(data, eventType) {
      if (data === undefined || eventType === undefined) {
        return false;
      }

      return !data.isLoaded && !data.isLeaf && eventType === 'expand';
    },

    /**
     * Process data attached through jquery data
     * @private
     * @param {string} nodeId .
     * @param {string} currentDataObject .
     * @param {string} newDataObject .
     * @param {string} params .
     * @returns {object} data
     */
    data: function data(nodeId, currentDataObject, newDataObject, params) {
      /* eslint-disable no-use-before-define */
      if (params === undefined) {
        params = {};
      }

      var s = this.settings;
      var obj = currentDataObject.isRootNode ? currentDataObject : currentDataObject[0];
      var nodeData = [];

      if (s.newData.length > 0) {
        s.newData = [];
      }

      function addChildrenToObject(thisObj, thisParams) {
        if (thisParams.insert) {
          delete thisObj.isLeaf;
          thisObj.isExpanded = true;
        }

        if (newDataObject.length !== 0 && thisParams.insert) {
          thisObj.children = [newDataObject];
        } else {
          thisObj.children = newDataObject;
        }
      }

      function checkForChildren(self, thisObj, thisNewDataObject) {
        Object.keys(thisObj).forEach(function (prop) {
          if (prop === 'id' && nodeId === thisObj.id) {
            if (!thisObj.isLoaded && !thisObj.isRootNode) {
              addChildrenToObject(thisObj, params);
            }

            nodeData.push(thisObj);
          }
        });

        if (thisObj.children) {
          processData(self, thisObj.children); // eslint-disable-line
        }
      }

      function processData(self, thisObj, thisNewDataObject) {
        if (thisObj.length === undefined) {
          checkForChildren(self, thisObj);
        } else {
          for (var i = 0, l = thisObj.length; i < l; i++) {
            checkForChildren(self, thisObj[i]);
          }
        }
      }

      if (newDataObject !== undefined) {
        processData(this, obj);
      }

      if (nodeData.length !== 0) {
        $("#".concat(nodeData[0].id)).data(nodeData[0]);
      }

      return nodeData[0];
      /* eslint-enable no-use-before-define */
    },

    /**
     * Add data as children for the given nodeId.
     * @private
     * @param {string} nodeId .
     * @param {object} currentDataObject info
     * @param {object} newDataObject .
     * @returns {void}
     */
    add: function add(nodeId, currentDataObject, newDataObject) {
      var s = this.settings;
      var id = currentDataObject.id !== undefined ? currentDataObject.id : nodeId;
      var node = $("#".concat(id));
      var parentContainer = node.parent().hasClass('leaf-container') ? node.parent().parent() : node.parent();
      var selectorObject = {};
      var isSubLevelChild = parentContainer.parent().attr('class') !== 'sub-level';
      var subListExists = parentContainer.children('.sublist').length === 1;

      if (isSubLevelChild) {
        if (subListExists) {
          selectorObject.element = parentContainer.children('.sublist');
        } else {
          selectorObject.el = parentContainer.append('<ul class=\'sublist\'></ul>');
          selectorObject.element = $(selectorObject.el).find('.sublist');
        }
      } else {
        selectorObject.el = parentContainer.children('ul');
        selectorObject.element = $(selectorObject.el);
      }

      if (selectorObject.element.length === 0) {
        selectorObject.el = parentContainer.append('<ul></ul>');
        selectorObject.element = $(selectorObject.el).find('ul');
      }

      if (!currentDataObject.isRootNode) {
        for (var i = 0, l = newDataObject.length; i < l; i++) {
          s.newData.push(newDataObject[i]);
        }

        this.createLeaf(newDataObject, selectorObject.element);
      }

      this.updateState(node, false, null, 'add');
    },

    /**
     * Closes popupmenu
     * @private
     * @param {object} node leaf containing btn-actions
     */
    closePopupMenu: function closePopupMenu(node) {
      var actionButton = node.find('.btn-actions');

      if (actionButton.length !== 0) {
        actionButton.data('popupmenu').close();
      }
    },

    /**
     * Expand the nodes until nodeId is displayed on the page.
     * @private
     * @param {object} event .
     * @param {object} nodeData info
     * @param {object} domObject .
     * @returns {void}
     */
    expand: function expand(event, nodeData, domObject) {
      var s = this.settings;
      var node = domObject.leaf;
      var nodeTopLevel = node.next(); // close popupmenu if open

      this.closePopupMenu(node);
      nodeTopLevel.animateOpen();
      /**
       * Fires when leaf expanded.
       *
       * @event expanded
       * @memberof Hierarchy
       * @type {object}
       * @param {object} event - The jquery event object
       * @param {array} args [nodeData, dataset]
       */

      this.element.trigger('expanded', [nodeData, s.dataset]);

      if (node.hasClass('root')) {
        nodeTopLevel = nodeTopLevel.next('ul');
        nodeTopLevel.animateOpen();
      }

      node.parent().removeClass('branch-collapsed').addClass('branch-expanded');
      this.updateState(node, false, null, 'expand');
    },

    /**
     * Collapse the passed in nodeId.
     * @private
     * @param {object} event .
     * @param {object} nodeData info
     * @param {object} domObject .
     * @returns {void}
     */
    collapse: function collapse(event, nodeData, domObject) {
      var _this4 = this;

      var s = this.settings;
      var node = domObject.leaf;
      var nodeTopLevel = node.next(); // close popupmenu if open

      this.closePopupMenu(node);
      nodeTopLevel.animateClosed().on('animateclosedcomplete', function () {
        /**
         * Fires when leaf collapsed.
         *
         * @event collapsed
         * @memberof Hierarchy
         * @type {object}
         * @param {object} event - The jquery event object
         * @param {array} args [nodeData, dataset]
         */
        _this4.element.trigger('collapsed', [nodeData, s.dataset]);
      });

      if (node.hasClass('root')) {
        nodeTopLevel = nodeTopLevel.next('ul');
        nodeTopLevel.animateClosed();
      }

      node.parent().removeClass('branch-expanded').addClass('branch-collapsed');
      this.updateState(node, false, null, 'collapse');
    },

    /**
     * Main render method
     * @private
     * @param {object} data info.
     * @returns {void}
     */
    render: function render(data) {
      var _this5 = this;

      /* eslint-disable no-use-before-define */
      var s = this.settings;
      var thisLegend = s.legend;
      var thisChildren = data.children;
      var rootNodeHTML = [];
      var uniqueId = "".concat(utils.uniqueId(this.element, 'hierarchy'));
      var structure = {
        legend: '<legend><ul></ul></legend>',
        chart: '<ul class="container"><li class="chart"></li></ul>',
        toplevel: this.isPagingLayout() ? '<ul class="child-nodes"></ul>' : '<ul class="top-level"></ul>',
        sublevel: this.isPagingLayout() ? '' : '<ul class="sub-level"></ul>'
      }; // Append chart structure to hierarchy container

      $("#".concat(this.settings.rootId)).append(structure.chart);
      var chart = $("#".concat(this.settings.rootId, " .chart"));

      if (thisLegend.length !== 0) {
        $("#".concat(this.settings.rootId)).prepend(structure.legend);
        var element = $("#".concat(this.settings.rootId, " legend"));
        this.createLegend(element);
      } // check to see how many children are not leafs and have children


      if (this.isSingleChildWithChildren()) {
        $(chart).addClass('has-single-child');
      } // Create root node


      this.setColor(data);

      if (this.isPagingLayout() && data.parentDataSet) {
        var backAutomationAttr = " id=\"".concat(uniqueId, "-back-button\" data-automation-id=\"automation-id-").concat(uniqueId, "-back-button\"");
        var backMarkup = "<div class=\"back\">\n        <button type=\"button\" class=\"btn-icon hide-focus btn-back\"".concat(backAutomationAttr, ">\n          <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n            <use href=\"#icon-caret-left\"></use>\n          </svg>\n          <span>Back</span>\n        </button></div>"); // Append back button to chart to go back to view previous level

        var backButton = $(backMarkup).appendTo(chart); // Wrap back button and leaf after leaf has been rendered

        setTimeout(function () {
          return backButton.next($('.leaf')).addBack($('.back')).wrapAll('<div class="back-container"></div>');
        }); // Attach data reference to back button

        backButton.children('button').data(data); // Class used to adjust heights and account for back button

        $(chart).addClass('has-back');
      }

      if (data.isMultiRoot) {
        var multiRootHTML = "<div class=\"leaf multiRoot\"><div><h2>".concat(data.multiRootText, "</h2></div></div>");
        multiRootHTML = xssUtils.sanitizeHTML(multiRootHTML);
        rootNodeHTML.push(multiRootHTML);
        $(rootNodeHTML[0]).addClass('root').appendTo(chart);
      } else if (data.ancestorPath !== null && data.ancestorPath !== undefined) {
        data.ancestorPath.push(data.centeredNode);
        var ancestorHTML = "".concat(data.ancestorPath.map(function (a) {
          return " ".concat(_this5.getTemplate(a), " ");
        }).join(''));
        ancestorHTML = xssUtils.sanitizeHTML(ancestorHTML);
        rootNodeHTML.push(ancestorHTML);
        $(rootNodeHTML[0]).addClass('root ancestor').appendTo(chart);
        var roots = this.element.find('.leaf.root');
        roots.each(function (index, root) {
          _this5.updateState(root, false, data.ancestorPath[index], 'add');

          if (index === roots.length - 1) {
            $(root).addClass('is-selected');
          }
        });
      } else {
        var centeredNode = data.centeredNode;
        var leaf;

        if (this.isStackedLayout() && centeredNode !== null) {
          leaf = this.getTemplate(centeredNode);
        } else if (!this.isStackedLayout()) {
          leaf = this.getTemplate(data);
        }

        if (leaf) {
          leaf = xssUtils.sanitizeHTML(leaf);
          rootNodeHTML.push(leaf);
          $(rootNodeHTML[0]).addClass('root is-selected').appendTo(chart);
        }

        if (centeredNode && centeredNode !== null) {
          this.updateState(this.element.find('.leaf.root'), true, centeredNode, undefined);
        } else {
          this.updateState(this.element.find('.leaf.root'), true, data, undefined);
        }
      }

      function renderSubChildren(self, subArray, thisData) {
        if (subArray !== null && subArray !== undefined) {
          for (var i = 0, l = subArray.length; i < l; i++) {
            var obj = subArray[i];
            subArrayChildren(self, obj); // eslint-disable-line
          }
        }
      } // Create children nodes


      if (thisChildren && thisChildren.length > 0) {
        for (var i = 0, l = thisChildren.length; i < l; i++) {
          var childObject = data.children[i].children; // If child has no children then render the element in the top level
          // If paging then render all children in the top level
          // If not paging and child has children then render in the sub level

          if (this.isLeaf(thisChildren[i]) && !this.isPagingLayout() && s.renderSubLevel) {
            this.createLeaf(data.children[i], $(structure.toplevel));
          } else if (this.isPagingLayout()) {
            this.createLeaf(data.children[i], $(structure.toplevel));
          } else {
            this.createLeaf(data.children[i], $(structure.sublevel));
          }

          if (childObject !== undefined && childObject !== null) {
            var subArray = data.children[i].children;
            var self = this;
            renderSubChildren(self, subArray);
          }
        }
      }

      function subArrayChildren(self, obj, thisData) {
        Object.keys(obj).forEach(function (prop) {
          if (prop === 'children') {
            var nodeId = obj.id;
            var currentDataObject = obj;
            var newDataObject = obj.children;

            if (newDataObject !== null && newDataObject !== undefined) {
              if (newDataObject.length > 0) {
                self.add(nodeId, currentDataObject, newDataObject);
              }
            }

            return renderSubChildren(self, newDataObject);
          }

          return true;
        });
      }

      var containerWidth = this.element.find('.container').outerWidth();
      var windowWidth = $(window).width();
      var center = (containerWidth - windowWidth) / 2;
      this.element.scrollLeft(center); // Add a no-sublevel class if only two levels (to remove extra border)

      var topLevel = this.element.find('.top-level');

      if (this.element.find('.sub-level').length === 0 && topLevel.length === 1) {
        topLevel.addClass('no-sublevel');
      }
      /* eslint-enable no-use-before-define */

    },

    /**
     * @private
     * @returns {boolean} true if paging layout
     */
    isPagingLayout: function isPagingLayout() {
      return this.settings.layout && this.settings.layout === 'paging';
    },

    /**
     * @private
     * @returns {boolean} true if mobile only
     */
    isMobileOnly: function isMobileOnly() {
      return this.settings.layout && this.settings.layout === 'mobile-only';
    },

    /**
     * @private
     * @returns {boolean} true if stacked layout
     */
    isStackedLayout: function isStackedLayout() {
      return this.settings.layout && this.settings.layout === 'stacked';
    },

    /**
     * Checks to see if children have children
     * @private
     * @returns {boolean} true if have children
     */
    isSingleChildWithChildren: function isSingleChildWithChildren() {
      if (this.isStackedLayout()) {
        return false;
      }

      var s = this.settings;

      if (s.dataset && s.dataset[0] && s.dataset[0].children) {
        var i = s.dataset[0].children.length;
        var count = 0;

        while (i--) {
          if (!s.dataset[0].children[i].isLeaf) {
            count++;
          }
        }

        return count === 1;
      }

      return false;
    },

    /**
     * Get append suffix with automation attributes
     * @private
     * @param {array} data for attributes to use
     * @param {string} suffix to use
     * @returns {object|array} attributes with suffix
     */
    getAutomationAttributes: function getAutomationAttributes(data, suffix) {
      var _this6 = this;

      var attributes = data.attributes;

      if (data.attributes && typeof suffix === 'string' && suffix !== '') {
        if (Array.isArray(data.attributes)) {
          attributes = [];
          data.attributes.forEach(function (item) {
            var value = typeof item.value === 'function' ? item.value(_this6) : item.value;
            attributes.push({
              name: item.name,
              value: value + suffix
            });
          });
        } else {
          var value = typeof data.attributes.value === 'function' ? data.attributes.value(this) : data.attributes.value;
          attributes = {
            name: data.attributes.name,
            value: value + suffix
          };
        }
      }

      return attributes;
    },

    /**
     * Builds leaf template
     * @private
     * @param {object} data leaf data
     * @returns {string} compiled template as HTML string
     */
    getTemplate: function getTemplate(data) {
      var _this7 = this;

      var template = Tmpl.compile("{{#dataset}}".concat($("#".concat(xssUtils.stripTags(this.settings.templateId))).html(), "{{/dataset}}"), {
        dataset: data
      }); // Init popupmenu after rendered in DOM

      setTimeout(function () {
        var actionButton = $("#btn-".concat(xssUtils.stripTags(data.id)));

        if (actionButton.length !== 0) {
          var attributes = _this7.getAutomationAttributes(data, '-hierarchy-popupmenu');

          actionButton.hideFocus().popupmenu({
            attachToBody: false,
            attributes: attributes
          });
        }
      }, 1);
      return $(template).prop('outerHTML');
    },

    /**
     * Add the legend from the Settings
     * @private
     * @param {object} element .
     * @returns {void}
     */
    createLegend: function createLegend(element) {
      var s = this.settings;
      var mod = 4;
      var index = 0;

      for (var i = 0, l = s.legend.length; i < l; i++) {
        var thislabel = s.legend[i].label;
        var color = s.colorClass[i];

        if (i - 1 % mod + 1 === mod) {
          element.append('<ul></ul>');
          index++;
        }

        element.children('ul').eq(index).append('' + "<li>\n          <span class=\"key ".concat(color, "\"></span>\n          <span>").concat(thislabel, "</span>\n        </li>"));
      }
    },

    /**
     * Creates a leaf node under element for nodeData
     * @private
     * @param {object} nodeData contains info.
     * @param {object} container .
     * @returns {void}
     */
    createLeaf: function createLeaf(nodeData, container) {
      var self = this; // Needs to be unique in the chance of multiple charts

      var chart = $("#".concat(self.settings.rootId, " .chart"), self.container);
      var elClassName = container.attr('class');
      var el = elClassName !== undefined ? $("#".concat(self.settings.rootId, " .").concat(elClassName)) : container;

      if (el.length < 1) {
        if (elClassName === 'top-level') {
          container.insertAfter('.root');
        } else {
          container.appendTo(chart);
        }
      }

      function processDataForLeaf(thisNodeData) {
        self.setColor(thisNodeData);
        var leaf = self.getTemplate(thisNodeData);
        var rootId = self.settings.rootId;
        var parent = el.length === 1 ? el : container;
        var branchState = thisNodeData.isExpanded || thisNodeData.isExpanded === undefined ? 'branch-expanded' : 'branch-collapsed';

        if (thisNodeData.isLeaf) {
          branchState = '';
        }

        if ($("#".concat(rootId, " #").concat(thisNodeData.id)).length === 1) {
          return;
        }

        parent.append("<li class=".concat(branchState, ">").concat($(leaf)[0].outerHTML, "</li>"));

        if (thisNodeData.children) {
          var childrenNodes = '';

          for (var j = 0, l = thisNodeData.children.length; j < l; j++) {
            self.setColor(thisNodeData.children[j]);
            var childLeaf = self.getTemplate(thisNodeData.children[j]);

            if (j === thisNodeData.children.length - 1) {
              childrenNodes += "<li>".concat($(childLeaf)[0].outerHTML, "</li>");
            } else {
              childrenNodes += "<li>".concat($(childLeaf)[0].outerHTML, "</li>");
            }
          }

          parent = $("#".concat(rootId, " #").concat(xssUtils.stripTags(thisNodeData.id))).parent();
          parent.append("<ul>".concat(childrenNodes, "</ul>"));
          var childLength = thisNodeData.children.length;

          while (childLength--) {
            var lf = $("#".concat(rootId, " #").concat(xssUtils.stripTags(thisNodeData.children[childLength].id)));
            self.updateState(lf, false, thisNodeData.children[childLength], undefined);
          }
        }
      }

      if (nodeData.length) {
        for (var i = 0, l = nodeData.length; i < l; i++) {
          var isLast = i === nodeData.length - 1;
          processDataForLeaf(nodeData[i]);
          self.updateState($("#".concat(self.settings.rootId, " #").concat(xssUtils.stripTags(nodeData[i].id))), false, nodeData[i], undefined);
        }
      } else {
        processDataForLeaf(nodeData);
        self.updateState($("#".concat(self.settings.rootId, " #").concat(xssUtils.stripTags(nodeData.id))), false, nodeData, undefined);
      }
    },

    /**
     * Set leaf colors matching data to key in legend
     * @private
     * @param {object} data contains info.
     * @returns {void}
     */
    setColor: function setColor(data) {
      var _this8 = this;

      var s = this.settings;
      this.setRootColor(data);

      if (this.isStackedLayout()) {
        if (data.ancestorPath && data.ancestorPath !== null) {
          data.ancestorPath.forEach(function (d) {
            _this8.setRootColor(d);
          });
        }

        if (data.centeredNode && data.centeredNode !== null) {
          this.setRootColor(data.centeredNode);
        }
      }

      if (data.children && !data.isRootNode) {
        for (var k = 0, ln = data.children.length; k < ln; k++) {
          for (var j = 0, x = s.legend.length; j < x; j++) {
            if (data.children[k][s.legendKey] === s.legend[j].value) {
              data.children[k].colorClass = s.colorClass[j];
            }
          }
        }
      }
    },

    /**
     * Set the color of the root element.
     * @private
     * @param {object} data  The data object to use.
     */
    setRootColor: function setRootColor(data) {
      var s = this.settings;

      for (var i = 0, l = s.legend.length; i < l; i++) {
        if (data[s.legendKey] === s.legend[i].value) {
          data.colorClass = s.colorClass[i];
          break;
        } else if (data[s.legendKey] === '') {
          data.colorClass = 'default-color';
        }
      }
    },

    /**
     * Check to see if particular node is a leaf
     * @private
     * @param {object} dataNode contains data info
     * @returns {boolean} whether or not a particular node is a leaf
     */
    isLeaf: function isLeaf(dataNode) {
      var s = this.settings;

      if (dataNode.isLeaf) {
        return dataNode.isLeaf;
      }

      if (s.beforeExpand) {
        return dataNode.isLeaf;
      } // Node is not a leaf and should display and expand/collapse icon


      if (dataNode.children && dataNode.children.length > 0) {
        return false;
      }

      return true;
    },

    /**
     * Handle all leaf state here,
     * get the current state via .data() and re-attach the new state
     * @private
     * @param {string} leaf .
     * @param {boolean} isRoot .
     * @param {object} nodeData .
     * @param {string} eventType .
     * @returns {void}
     */
    updateState: function updateState(leaf, isRoot, nodeData, eventType) {
      // set data if it has not been set already
      if ($.isEmptyObject($(leaf).data()) && nodeData) {
        var d = nodeData === undefined ? {} : nodeData;
        $(leaf).data(d);
      }

      var s = this.settings;
      var btn = $(leaf).find('.btn');
      var expandCaret = this.isPagingLayout() ? 'caret-right' : 'caret-up';
      var data = $(leaf).data();

      if (data === undefined && nodeData !== undefined) {
        data = nodeData;
      } // data has been loaded if it has children


      if (data.children && data.children.length !== 0 || eventType === 'add') {
        data.isExpanded = true;
        data.isLoaded = true;
      }

      if (isRoot) {
        data.isRootNode = true;
        data.isLoaded = true;
      }

      if (data.isExpanded === undefined && data.children || eventType === 'expand') {
        data.isExpanded = true;
      } // defaults to collapsed state


      if (data.isExpanded === undefined || eventType === 'collapse') {
        data.isExpanded = false;
      }

      if (data.isExpanded) {
        btn.find('svg.icon').changeIcon(expandCaret);
        btn.addClass('btn-expand').removeClass('btn-collapse');
      } else {
        btn.find('svg.icon').changeIcon('caret-down');
        btn.addClass('btn-collapse').removeClass('btn-expand');
      }

      if (data.isLeaf || data.isRootNode) {
        btn.addClass('btn-hidden');
      }

      if (data.isLeaf) {
        data.isLoaded = false;
        data.isExpanded = false;
      } // Keep reference of the parent dataset for paging


      if (this.isPagingLayout()) {
        data.parentDataSet = s.dataset;
      } // Reset data


      $(leaf).data(data);
    },

    /**
     * Reloads hierarchy control with new dataset
     * @private
     * @param {object} options hierarchy
     * @returns {void}
     */
    reload: function reload(options) {
      this.destroy();
      this.element.hierarchy(options);
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    unbind: function unbind() {
      this.element.empty();
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, HIERARCHY_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Removes the component from existence
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      this.element.removeData(COMPONENT_NAME$N);
    }
  };

  /**
   * jQuery Component Wrapper for Hierarchy
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.hierarchy = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$N);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$N, new Hierarchy(this, settings));
      }
    });
  };

  var COMPONENT_NAME$O = 'fieldfilter';
  /**
   * Ability to have a dropdown next to the field.
   *
   * @class FieldFilter
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   * @param {array} [settings.dataset]  Array of data
   * @param {object} [settings.dropdownOpts]  Gets passed to this control's dropdown
   * @param {string} [settings.template] An Html String with the mustache template for the view.
   */

  var FIELDFILTER_DEFAULTS = {
    dataset: [],
    dropdownOpts: {},
    // Dropdown custom settings
    template: '' + "<label>".concat(Locale.translate('FieldFilter'), "</label>\n    <select class=\"dropdown no-init field-filter-dropdown\">\n      {{#dataset}}\n        <option\n          {{#value}} value=\"{{value}}\"{{/value}}\n          {{#selected}} selected{{/selected}}\n          {{#disabled}} class=\"is-disabled\" disabled{{/disabled}}\n          {{#icon}} data-icon=\"{{icon}}\"{{/icon}}\n        >{{text}}</option>\n      {{/dataset}}\n    </select>")
  };

  function FieldFilter(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FIELDFILTER_DEFAULTS);
    this.init();
  } // FieldFilter Methods


  FieldFilter.prototype = {
    init: function init() {
      this.render();
      this.handleEvents();
      this.setFiltered();
    },

    /**
     * Render the template against the dataset.
     * @private
     * @param {array} dataset  The dataset to use
     * @returns {void}
     */
    render: function render(dataset) {
      var s = this.settings;
      dataset = dataset || s.dataset; // Render "mustache" Template

      if (_typeof(Tmpl) === 'object' && dataset && s.template) {
        // create a copy of an inlined template
        if (s.template instanceof $) {
          s.template = "".concat(s.template.html());
        } else if (typeof s.template === 'string') {
          // If a string doesn't contain HTML elments,
          // assume it's an element ID string and attempt to select with jQuery
          if (!stringUtils.containsHTML(s.template)) {
            s.template = $("#".concat(s.template)).html();
          }
        }

        var renderedTmpl = Tmpl.compile(s.template, {
          dataset: !s.dropdownOpts.source ? dataset : []
        }); // eslint-disable-line

        var emptyTmpl = '' + "<label for=\"ffdropdown-empty\" class=\"audible\">\n          ".concat(Locale.translate('FieldFilter'), "\n        </label>\n        <select id=\"ffdropdown-empty\" name=\"ffdropdown-empty\" class=\"dropdown no-init field-filter-dropdown\"></select>");

        if (dataset.length > 0) {
          this.element.before(renderedTmpl);
        } else if (dataset.length === 0) {
          this.element.before(renderedTmpl || emptyTmpl);
        } // Set element id


        var id = this.element.attr('id') || this.element.attr('name');

        if (typeof id === 'undefined') {
          id = utils.uniqueId(this.element, 'fieldfilter-');
          this.element[0].setAttribute('id', id);
        }

        var ffId = "".concat(id, "-ff"); // Set Field

        this.field = this.element.closest('.field, .field-short'); // RTL list x-position

        var isRTL = Locale.isRTL();
        s.dropdownOpts = s.dropdownOpts || {};

        if (isRTL && _typeof(s.dropdownOpts) === 'object') {
          if (s.dropdownOpts.placementOpts) {
            s.dropdownOpts.placementOpts.x = this.element.outerWidth();
          } else {
            s.dropdownOpts.placementOpts = {
              x: this.element.outerWidth()
            };
          }
        } // Set Dropdown


        s.dropdownOpts.cssClass = s.dropdownOpts.cssClass ? "".concat(s.dropdownOpts.cssClass, " ffdropdown") : 'ffdropdown';
        s.dropdownOpts.noSearch = true; // Find the field filter dropdown

        this.ffdropdown = this.field.find('select.dropdown.field-filter-dropdown');
        this.ffdropdown.dropdown(s.dropdownOpts).prev('label').addClass('audible');
        this.ffdropdown[0].setAttribute('id', ffId);
        this.ffdropdown[0].setAttribute('name', ffId);
        this.ffdropdown.prev('label')[0].setAttribute('for', ffId); // Add css classes

        var labelText = this.ffdropdown.prev('label').prev('label').text();
        this.field.addClass('fieldfilter-wrapper');
        this.field.find('div.dropdown span.audible').text(labelText);
        this.field.find('div.dropdown span').addClass('audible'); // Dropdown api

        this.ddApi = this.ffdropdown.data('dropdown');

        if (this.ddApi && this.ddApi.icon) {
          this.ddApi.icon.addClass('ffdropdown-icon');
        } // Add test automation ids


        utils.addAttributes(this.field, this, this.settings.attributes, '', true);
        utils.addAttributes(this.field.find('label:not(.audible)'), this, this.settings.attributes, 'label', true);
        utils.addAttributes(this.field.find('select'), this, this.settings.attributes, 'select', true);
      }
    },

    /**
     * Set currently filtered item
     * @private
     * @returns {object} The api
     */
    setFiltered: function setFiltered() {
      if (this.ddApi) {
        var item = this.ddApi.element.find('option:selected');
        this.filtered = this.getTriggerData(item);
      }

      return this;
    },

    /**
     * Get currently triggerData for given item args
     * @private
     * @param {object} args selected item.
     * @returns {object} The api
     */
    getTriggerData: function getTriggerData(args) {
      var s = this.settings;
      var dataset = s.dropdownOpts.source && this.ddApi ? this.ddApi.dataset : s.dataset;
      return {
        idx: args.index(),
        item: args,
        data: dataset[args.index()]
      };
    },

    /**
     * Get current filter type
     * @returns {object} The current filter type
     */
    getFilterType: function getFilterType() {
      this.setFiltered();
      return this.filtered;
    },

    /**
     * Set filter type to given value
     * @param {number|string} value to be set, index or value.
     * @returns {void}
     */
    setFilterType: function setFilterType(value) {
      if (this.ddApi) {
        var newIdx = -1;
        var s = this.settings;
        var dataset = s.dropdownOpts.source && this.ddApi ? this.ddApi.dataset : s.dataset;

        if (typeof value === 'number' && value > -1 && value < dataset.length) {
          newIdx = value;
        } else if (typeof value === 'string') {
          var option = this.ffdropdown.find("option[value=\"".concat(value, "\"]"));

          if (!option.length) {
            option = this.ffdropdown.find('option').filter(function () {
              return $(this).text() === value;
            });
          }

          if (option.length) {
            newIdx = option.index();
          }
        } // Make filtered


        if (newIdx !== -1 && newIdx !== this.ffdropdown[0].selectedIndex) {
          this.ffdropdown[0].selectedIndex = newIdx;
          this.ddApi.updated();
          this.ffdropdown.triggerHandler('change');
          this.setFiltered();
          this.element.triggerHandler('filtered', [this.filtered]);
        }
      }
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {object} The api
     */
    handleEvents: function handleEvents() {
      var _this = this;

      this.ffdropdown.on("listopened.".concat(COMPONENT_NAME$O), function () {
        // drowpdownWidth - border (52)
        var extra = _this.field.is('.field-short') ? 42 : 52;
        $('#dropdown-list ul').width(_this.element.outerWidth() + extra);
      }).on("selected.".concat(COMPONENT_NAME$O), function (e, args) {
        /**
         * Fires after the value in the dropdown is selected.
         * @event filtered
         * @memberof FieldFilter
         * @property {object} event The jquery event object.
         * @property {object} data for selected item.
         */
        var triggerData = _this.getTriggerData(args);

        _this.element.triggerHandler('filtered', [triggerData]);
      });
      return this;
    },
    // END: Handle Events -------------------------------------------------

    /**
     * Set component to readonly.
     * @returns {object} The api
     */
    readonly: function readonly() {
      this.ffdropdown.readonly();
      return this;
    },

    /**
     * Set component to enabled.
     * @returns {object} The api
     */
    enable: function enable() {
      this.ffdropdown.enable();
      return this;
    },

    /**
     * Set component to disabled.
     * @returns {object} The api
     */
    disable: function disable() {
      this.ffdropdown.disable();
      return this;
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.ffdropdown.off(".".concat(COMPONENT_NAME$O)); // Remove Dropdown

      if (this.ddApi && typeof this.ddApi.destroy === 'function') {
        this.ddApi.destroy();
      }

      this.ffdropdown.add(this.ffdropdown.prev('label')).remove();
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element[0], settings, FIELDFILTER_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Teardown process for this plugin
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$O);
    }
  };

  /**
   * jQuery Component Wrapper for FieldFilter
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.fieldfilter = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$O);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$O, new FieldFilter(this, settings));
      }
    });
  };

  var COMPONENT_NAME$P = 'fieldoptions';
  /**
  * A control bind next to another component to add some extra functionality.
  * @class FieldOptions
  * @deprecated as of v4.20.0. This component is no longer supported by the IDS team.
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */

  var FIELDOPTIONS_DEFAULTS = {};

  function FieldOptions(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FIELDOPTIONS_DEFAULTS);
    this.init();
    warnAboutRemoval('FieldOptions');
  } // FieldOptions Methods


  FieldOptions.prototype = {
    init: function init() {
      this.setElements();
      this.handleEvents();
    },

    /**
     * Set all elements used by the Control
     * @private
     * @returns {object} The api
     */
    setElements: function setElements() {
      var _this = this;

      this.isFirefox = Environment.browser.name === 'firefox';
      this.isSafari = Environment.browser.isSafari();
      this.field = this.element.closest('.field, .radio-group');
      this.targetElem = this.element;
      var label = this.field.find('label');

      if (label) {
        this.label = label;
      } // In some cases, adjust the target element


      if (this.element[0].className.match(/(dropdown|multiselect)/)) {
        this.targetElem = this.element.data('dropdown').pseudoElem;
      }

      if (this.element[0].className.match(/(fileupload)/)) {
        this.targetElem = this.field.find('.fileupload[type="text"]');
      }

      this.field.addClass('is-fieldoptions');
      this.fieldParent = this.element.closest('.field').parent();
      this.trigger = this.field.find('.btn-actions'); // Fix: Some reason firfox "event.relatedTarget" not working
      // with un-focusable elements(ie.. div) on focusout, use "contentEditable"
      // https://stackoverflow.com/a/43010274

      if (this.isFirefox && this.trigger.length) {
        this.trigger[0].contentEditable = true;
        this.trigger.on("keydown.".concat(COMPONENT_NAME$P), function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;

          if (key !== 9) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      } // Adjust some setting for popupmenu this trigger(action button)


      setTimeout(function () {
        _this.popupmenuApi = _this.trigger.data('popupmenu');

        if (_this.popupmenuApi) {
          _this.popupmenuApi.settings.returnFocus = false;
          _this.popupmenuApi.settings.offset.y = 10;
        }
      }, 100);
      return this;
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {object} The api
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      var self = this;
      var datepicker = this.element.data('datepicker');
      var timepicker = this.element.data('timepicker');
      var dropdown = this.element.data('dropdown');
      var lookup = this.element.data('lookup') || this.element.hasClass('lookup');
      var isCheckbox = this.element.is('.checkbox');
      var isFileupload = this.element.is('.fileupload');
      var isSearchfield = this.element.is('.searchfield');
      var isColorpicker = this.element.is('.colorpicker');
      var isRadio = this.element.closest('.radio-group').length > 0;
      var isFieldset = this.element.is('.data') && this.element.closest('.summary-form').length > 0; // Helper functions

      var isFocus = function isFocus(elem) {
        return $(':focus').is(elem);
      };

      var addFocused = function addFocused(elem) {
        (elem || _this2.element).addClass('is-focused');
      };

      var removeFocused = function removeFocused(elem) {
        (elem || _this2.element).removeClass('is-focused');
      };

      var canActive = function canActive() {
        var r = isFocus(_this2.element);
        r = datepicker && datepicker.isOpen() ? false : r;
        r = timepicker && timepicker.isOpen() ? false : r;
        r = dropdown && dropdown.isOpen() ? false : r;
        return r;
      };

      var doActive = function doActive() {
        self.element.add(self.trigger).add(self.field).add(self.fieldParent).addClass('is-active');
      };

      var doUnactive = function doUnactive() {
        self.element.add(self.trigger).add(self.field).add(self.fieldParent).removeClass('is-active');
      };

      var canUnactive = function canUnactive(e) {
        var r = !isFocus(_this2.element);
        r = _this2.trigger.is(e.relatedTarget) ? false : r;
        r = _this2.trigger.is('.is-open') ? false : r;
        r = datepicker && datepicker.isOpen() ? false : r;
        r = timepicker && timepicker.isOpen() ? false : r;
        r = $(e.relatedTarget).prev().is(_this2.element) ? false : r;
        r = dropdown && dropdown.isOpen() ? false : r;
        r = lookup && lookup.modal && lookup.modal.isOpen() ? false : r;
        r = isColorpicker && _this2.element.is('.is-open') ? false : r;
        return r;
      };

      var onPopupToggle = function onPopupToggle(elem) {
        if (elem.trigger) {
          elem.trigger.off("show.".concat(COMPONENT_NAME$P)).on("show.".concat(COMPONENT_NAME$P), function () {
            doActive();
          }).off("hide.".concat(COMPONENT_NAME$P)).on("hide.".concat(COMPONENT_NAME$P), function (e) {
            if (canUnactive(e)) {
              doUnactive();

              _this2.element.removeClass('is-open');
            }
          });
        }
      };

      var getTriggerTopVal = function getTriggerTopVal() {
        var height = _this2.element.height();

        var returns;

        if (isFieldset) {
          var lineHeight = parseInt(_this2.element.css('line-height'), 10);

          if (height > lineHeight) {
            _this2.element.removeClass('is-singleline');

            returns = ((_this2.element.outerHeight() - _this2.trigger.height()) / 2 + 0) * -1;
            var diff = lineHeight - 16;
            returns += diff ? diff / 2 : 0;
          } else {
            _this2.element.addClass('is-singleline');

            returns = 2;
          }
        } else if (isRadio) {
          returns = (height - 10 - _this2.trigger.height()) / 2 * -1;
        }

        return returns;
      };

      var setTriggerCssTop = function setTriggerCssTop() {
        _this2.trigger.css({
          top: "".concat(getTriggerTopVal() - 1, "px")
        });
      }; // Set field-options visibility.
      // In touch environments, the button should always be visible.
      // In desktop environments, the button should only display when the field is in use.


      if (Environment.features.touch) {
        this.field.addClass('visible');
        this.trigger.on("beforeopen.".concat(COMPONENT_NAME$P), function (e) {
          if (!canActive()) {
            return;
          }

          doActive();
        }).on("close.".concat(COMPONENT_NAME$P), function (e) {
          if (!canUnactive(e)) {
            return;
          }

          doUnactive();
        });
      } else {
        this.field.removeClass('visible');
        this.field.on("mouseover.".concat(COMPONENT_NAME$P), function () {
          if (self.element.prop('disabled') || self.element.closest('is-disabled').length) {
            return;
          }

          if (self.field[0].className.indexOf('visible') < 0) {
            self.field[0].classList.add('visible');
          }
        }).on("mouseout.".concat(COMPONENT_NAME$P), function () {
          if (self.field[0].className.indexOf('visible') > -1) {
            self.field[0].classList.remove('visible');
          }
        });
      } // Adjust stack order for dropdown


      if (dropdown) {
        setTimeout(function () {
          var popupmenu = _this2.trigger.data('popupmenu');

          if (popupmenu) {
            popupmenu.menu.closest('.popupmenu-wrapper').css({
              'z-index': '4502'
            });
          }
        }, 0);
      } // Bind active/unactive on show datepicker or timepicker


      if (datepicker || timepicker) {
        if (datepicker) {
          onPopupToggle(datepicker);
        } else {
          onPopupToggle(timepicker);
        }
      } // Adjust return focus for timepicker


      if (timepicker) {
        timepicker.settings.returnFocus = false;
      } // Move trigger(action-button) in to lookup-wrapper


      if (lookup || isColorpicker) {
        this.field.on("click.".concat(COMPONENT_NAME$P), '.lookup-wrapper .trigger, .colorpicker-container .trigger', function () {
          doActive();
        });

        if (isColorpicker) {
          this.element.on("beforeopen.".concat(COMPONENT_NAME$P), function () {
            doActive();
          });
        }
      } // Checkbox add parent css class


      if (isCheckbox) {
        this.trigger.addClass('is-checkbox');

        if (!Environment.features.touch && this.isSafari) {
          this.field.on("click.".concat(COMPONENT_NAME$P), '.checkbox-label', function () {
            doActive();
          }).on("mouseout.".concat(COMPONENT_NAME$P), '.checkbox-label', function () {
            doUnactive();
          });
        }
      } // Bind fileupload events


      if (isFileupload) {
        this.element.on("change.".concat(COMPONENT_NAME$P), function () {
          _this2.targetElem.focus();
        });
        this.field.on("click.".concat(COMPONENT_NAME$P), '.trigger, .trigger-close', function () {
          doActive();
        });
      } // Move trigger(action-button) in to searchfield-wrapper


      if (isSearchfield) {
        setTimeout(function () {
          _this2.trigger.add(_this2.trigger.next('.popupmenu')).appendTo(_this2.element.closest('.searchfield-wrapper'));
        }, 0);
      } // Fieldset - set trigger(action-button) top value and bind events


      if (isFieldset) {
        setTriggerCssTop();
        this.targetElem.add(this.trigger).on("keydown.".concat(COMPONENT_NAME$P), function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;

          if (key === 13) {
            setTimeout(function () {
              doActive();
            }, 0);
          }
        });
        this.targetElem.attr('tabindex', 0).on("click.".concat(COMPONENT_NAME$P), function () {
          doActive();
        });
        $(document).on("click.".concat(COMPONENT_NAME$P), function (e) {
          if (!$(e.target).is(_this2.element)) {
            doUnactive();
          }
        });
        $('body').on("resize.".concat(COMPONENT_NAME$P), function () {
          setTriggerCssTop();
        });
      } // Radio group - set trigger(action-button) top value and bind events


      if (isRadio) {
        setTriggerCssTop();
        this.element.on("focusin.".concat(COMPONENT_NAME$P), '.radio', function () {
          var delay = _this2.isSafari ? 200 : 0;
          addFocused();
          setTimeout(function () {
            doActive();
          }, delay);
        }).on("focusout.".concat(COMPONENT_NAME$P), '.radio', function () {
          removeFocused();
        });
        $('body').on("resize.".concat(COMPONENT_NAME$P), function () {
          setTriggerCssTop();
        });
      } // Element events


      this.targetElem.on("focusin.".concat(COMPONENT_NAME$P), function () {
        doActive();

        if (isRadio && _this2.isSafari) {
          addFocused();
        }
      }).on("focusout.".concat(COMPONENT_NAME$P), function (e) {
        var delay = _this2.isSafari ? 200 : 0;

        if (isRadio && _this2.isSafari) {
          removeFocused();
        }

        setTimeout(function () {
          if (canUnactive(e)) {
            doUnactive();
          }
        }, delay);
      }); // Trigger(action button) events

      this.trigger.on("focusin.".concat(COMPONENT_NAME$P, " click.").concat(COMPONENT_NAME$P), function () {
        doActive();
      }).on("focusout.".concat(COMPONENT_NAME$P), function (e) {
        if (canUnactive(e)) {
          doUnactive();
        }
      }).on("selected.".concat(COMPONENT_NAME$P), function () {
        _this2.popupmenuApi.settings.returnFocus = true;
      }).on("close.".concat(COMPONENT_NAME$P), function (e) {
        if (canUnactive(e)) {
          doUnactive();
        }
      }); // FIX: Safari - by default does not get focus on some elements while using tab key
      // https://stackoverflow.com/a/29106095

      if (this.isSafari || isFileupload) {
        if (isRadio) {
          this.element.attr('tabindex', 0);
        }

        this.targetElem.on("keydown.".concat(COMPONENT_NAME$P), function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;

          if (key === 9 && !e.shiftKey) {
            if (isRadio) {
              _this2.targetElem.find(':checked, .radio:first').not(':disabled').focus();

              _this2.targetElem.find('.radio').off("keydown.".concat(COMPONENT_NAME$P)).on("keydown.".concat(COMPONENT_NAME$P), function (e2) {
                var key2 = e2.which || e2.keyCode || e2.charCode || 0;

                if (key2 === 9 && !e.shiftKey) {
                  setTimeout(function () {
                    _this2.trigger.focus();
                  }, 0);
                }
              });
            } else {
              _this2.trigger.focus();
            }

            doActive();
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      this.element.on("listopened.".concat(COMPONENT_NAME$P), function () {
        doActive();
      }).on("listclosed.".concat(COMPONENT_NAME$P), function () {
        doUnactive();
      });
      return this;
    },
    // END: Handle Events -------------------------------------------------

    /**
    * Set component to enabled.
    * @returns {object} The api
    */
    enable: function enable() {
      this.trigger.prop('disabled', false);
      return this;
    },

    /**
    * Set component to disabled.
    * @returns {object} The api
    */
    disable: function disable() {
      this.trigger.prop('disabled', true);
      return this;
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.field.off(["click.".concat(COMPONENT_NAME$P), "mouseover.".concat(COMPONENT_NAME$P), "mouseout.".concat(COMPONENT_NAME$P)].join(' '));
      this.element.off(["beforeopen.".concat(COMPONENT_NAME$P), "change.".concat(COMPONENT_NAME$P), "focusin.".concat(COMPONENT_NAME$P), "focusout.".concat(COMPONENT_NAME$P), "listclosed.".concat(COMPONENT_NAME$P), "listopened.".concat(COMPONENT_NAME$P)].join(' '));
      this.trigger.off(["beforeopen.".concat(COMPONENT_NAME$P), "click.".concat(COMPONENT_NAME$P), "focusin.".concat(COMPONENT_NAME$P), "focusout.".concat(COMPONENT_NAME$P), "selected.".concat(COMPONENT_NAME$P), "close.".concat(COMPONENT_NAME$P)].join(' '));
      this.targetElem.off(["click.".concat(COMPONENT_NAME$P), "keydown.".concat(COMPONENT_NAME$P)].join(' '));
      $('body').off(["resize.".concat(COMPONENT_NAME$P)].join(' '));
      $(document).off(["click.".concat(COMPONENT_NAME$P)].join(' '));
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FIELDOPTIONS_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$P);
    }
  };

  /**
   * jQuery Component Wrapper for FieldOptions
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.fieldoptions = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$P);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$P, new FieldOptions(this, settings));
      }
    });
  };

  var COMPONENT_NAME$Q = 'fileupload';
  /**
  * A list of items with add/remove/delete and sort functionality.
  * @class FileUpload
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  */

  var FILEUPLOAD_DEFAULTS = {};

  function FileUpload(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FILEUPLOAD_DEFAULTS);
    this.init();
  } // FileUpload Methods


  FileUpload.prototype = {
    init: function init() {
      this.build();
    },
    // Example Method
    build: function build() {
      var _this = this;

      var self = this;
      var elem = this.element;
      var hasInlineLabel = !elem.is('input.fileupload');
      this.fileInput = hasInlineLabel ? elem.find('input') : elem;
      elem.closest('.field, .field-short').addClass('field-fileupload'); // append markup

      var id = elem.find('input').attr('name');

      if (!hasInlineLabel) {
        id = elem.attr('id') || elem.attr('name');
      }

      var elemClass = !hasInlineLabel ? elem.attr('class') : elem.find('input').attr('class');
      elemClass = elemClass ? " ".concat(elemClass) : '';
      var instructions = Locale.translate('FileUpload');
      this.shadowLabel = $("<label for=\"".concat(id, "-filename\">").concat(elem.text(), " <span class=\"audible\">").concat(instructions, "</span></label>"));
      this.shadowField = $("<input readonly id=\"".concat(id, "-filename\" class=\"fileupload-background-transparent").concat(elemClass, "\" type=\"text\">"));
      var svg = "<span class=\"trigger\">".concat($.createIcon('folder'), "</span>");
      var svgClose = "<span class=\"trigger-close\" tabindex=\"-1\">".concat($.createIcon('close'), "</span>");

      if (!hasInlineLabel) {
        var orgLabel = elem.prev('label'); // Could be wrapped (angular)

        if (orgLabel.length === 0) {
          orgLabel = elem.parent().prev('label');
        }

        this.shadowLabel.html("".concat(orgLabel.text(), " <span class=\"audible\">").concat(instructions, "</span>"));
        orgLabel.addClass('audible').add(this.fileInput).attr('tabindex', '-1').attr('aria-hidden', 'true');
      }

      if (elem.parent().find('input[type="text"]').length === 0) {
        elem.before(this.shadowLabel, this.shadowField);
        this.fileInput.after(svg, svgClose);
      } // if there is a value attribute, then this will be used as the current value since unable to set files[0].name
      // move it to the text input and remove it off the file input


      var fileInputValue = this.fileInput.attr('value');

      if (fileInputValue && fileInputValue.length > 0) {
        this.shadowField.val(fileInputValue);
        this.fileInput.attr('value', '');
      }

      this.textInput = this.shadowField;
      this.svg = elem.parent().find('.trigger');
      this.svgClose = elem.parent().find('.trigger-close');
      /*
      * Added Keydown for Keyboard Backspace and remove Keypress because it doesn't detect Backspace
      */

      this.textInput.on('keydown.fileupload', function (e) {
        var handle = false;

        if (e.which === 13 || e.which === 32) {
          elem.parent().find('[type="file"]').trigger('click');
          handle = true;
        } else if (e.which === 8) {
          if (Environment.browser.isIE11()) e.preventDefault();

          _this.clearUploadFile();

          handle = true;
        }

        if (handle) {
          e.stopPropagation();
        }
      });
      this.svg.on('click.fileupload', function (e) {
        _this.fileInput.trigger('click');

        if (hasInlineLabel) {
          _this.fileInput.data("handleEvent".concat([e.type || '']), e.handleObj);
        }
      });
      this.svgClose.on('click.fileupload', function (e) {
        _this.clearUploadFile();

        if (hasInlineLabel) {
          _this.fileInput.data("handleEvent +".concat([e.type || '']), e.handleObj);
        }
      });

      if (this.fileInput.is(':disabled')) {
        this.textInput.prop('disabled', true);
      }

      if (elem.hasClass('required')) {
        this.shadowLabel.addClass('required');
        elem.removeClass('required');
      }

      if (this.fileInput.attr('data-validate')) {
        this.textInput.attr('data-validate', this.fileInput.attr('data-validate'));
        this.textInput.validate();
      }

      if (this.fileInput.attr('readonly')) {
        this.textInput.prop('disabled', false);
        this.textInput[0].classList.remove('fileupload-background-transparent');
        this.fileInput.attr('disabled', 'disabled');
      }
      /*
      * New Event for File Upload Change
      */


      this.fileInput.on('change.fileupload', function () {
        if (this.files.length > 0) {
          self.textInput.val(this.files[0].name).trigger('change');
          self.svgClose.show().addClass('is-visible');
        } else if (!self.clearing) {
          self.clearUploadFile();
        }
      }); // Fix - Not to bubble events when clicked on trigger/close icons

      this.fileInput.on('click.fileupload', function (e) {
        var handleEventData = _this.fileInput.data("handleEvent".concat([e.type || '']));

        if (handleEventData && handleEventData.type === e.type && e.handleObj.namespace === 'fileupload') {
          _this.fileInput.data("handleEvent".concat([e.type || '']), null);

          e.preventDefault();
        }
      }); // Support Drag and Drop

      this.textInput.on('dragenter.fileupload', function () {
        _this.fileInput.css('z-index', '1');
      });
      this.textInput.on('dragleave.fileupload, dragend.fileupload, drop.fileupload', function () {
        setTimeout(function () {
          _this.fileInput.css('z-index', '-1');
        }, 1);
      }); // Add test automation ids

      utils.addAttributes(elem, this, this.settings.attributes);
      utils.addAttributes(this.svg, this, this.settings.attributes, 'btn-trigger');
      utils.addAttributes(this.svgClose, this, this.settings.attributes, 'btn-trigger-close');
    },

    /*
    * Clear the Input Upload File
    */
    clearUploadFile: function clearUploadFile() {
      this.clearing = true;
      this.fileInput.add(this.textInput).val('');
      this.svgClose.hide().removeClass('is-visible');
      this.fileInput.triggerHandler('change');
      this.clearing = false;
    },
    // Unbind all events
    unbind: function unbind() {
      this.svg.add(this.svgClose).off('click.fileupload');
      this.fileInput.off('change.fileupload');
      this.fileInput.prev('label');
      this.textInput.off();
      this.element.closest('.field-fileupload').removeClass('field-fileupload').find('>label:first, >[type="text"]:first, .trigger, .trigger-close, .icon-dirty, .msg-dirty').remove();
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FILEUPLOAD_DEFAULTS);
      } // Nothing to do here as there are no settings.


      return this;
    },

    /**
    * Teardown process for this plugin
    * @returns {void}
    */
    destroy: function destroy() {
      this.shadowField.remove();
      this.shadowLabel.remove();
      $.removeData(this.element[0], COMPONENT_NAME$Q);
    },

    /**
    * Disable the input and button.
    * @returns {void}
    */
    disable: function disable() {
      this.textInput.prop('disabled', true);
      this.fileInput.prop('disabled', true);
    },

    /**
    * Enable the input and button.
    * @returns {void}
    */
    enable: function enable() {
      this.textInput.prop('disabled', false).prop('readonly', false);
      this.fileInput.removeAttr('disabled');
    },

    /**
    * Make the input readonly and disable the button.
    * @returns {void}
    */
    readonly: function readonly() {
      this.textInput.prop('readonly', true);
      this.fileInput.prop('disabled', true);
      this.textInput.prop('disabled', false);
      this.textInput.removeClass('fileupload-background-transparent');
    }
  };

  /**
   * jQuery Component Wrapper for FileUpload
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.fileupload = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Q);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Q, new FileUpload(this, settings));
      }
    });
  };

  var COMPONENT_NAME$R = 'fileuploadadvanced';
  /**
  * A trigger field for uploading a single file.
  * @class FileUploadAdvanced
  * @constructor
  *
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.isStandalone=true] On page(true)|on modal(false), used for some visual style only.
  * @param {string} [settings.standaloneClass='standalone'] Css class if on page.
  * @param {string} [settings.allowedTypes='*'] Restrict file types(ie. 'jpg|png|gif') ['*' all types]
  * @param {number} [settings.maxFiles=99999] Max number of files can be uploaded
  * @param {number} [settings.maxFilesInProcess=99999] Max number of files can be uploaded while in process
  * @param {number} [settings.maxFileSize=-1] Max file size in bytes, -1 for unlimited
  * @param {string} [settings.fileName='myfile'] Variable name to read from server
  * @param {boolean} [settings.isDisabled=false] Make control disabled
  * @param {boolean} [settings.showBrowseButton=true] Add way to browse files to upload
  * @param {Function} [settings.send] Method for send file to upload
  * @param {string} [settings.textDropArea] Text to show in drop area
  * @param {string} [settings.textDropAreaWithBrowse] Text to show in drop area when browse option true
  * @param {string} [settings.textBtnCancel] Hidden text for cancel button
  * @param {string} [settings.textBtnCloseError] Hidden text for error close button
  * @param {string} [settings.textBtnRemove] Hidden text for remove button
  * @param {string} [settings.errorAllowedTypes] Error text for allowed types
  * @param {string} [settings.errorMaxFileSize] Error text for max file size
  * @param {string} [settings.errorMaxFiles] Error text for max files to upload
  * @param {string} [settings.errorMaxFilesInProcess] Error text for max files in process
  */

  var FILEUPLOADADVANCED_DEFAULTS = {
    isStandalone: true,
    //
    standaloneClass: 'standalone',
    // css class if on page
    allowedTypes: '*',
    // restrict file types(ie. 'jpg|png|gif') ['*' all types]
    maxFiles: 99999,
    // max files can be upload
    maxFilesInProcess: 99999,
    // max files can be upload while in process
    maxFileSize: -1,
    // max file size in bytes, -1 for unlimited
    fileName: 'myfile',
    // variable name to read from server
    isDisabled: false,
    // Disabled
    showBrowseButton: true,
    // Browse files to upload
    send: null,
    // Function to send files to server
    // Text strings
    textDropArea: null,
    textDropAreaWithBrowse: null,
    textBtnCancel: null,
    textBtnCloseError: null,
    textBtnRemove: null,
    // Error strings
    errorAllowedTypes: null,
    errorMaxFileSize: null,
    errorMaxFiles: null,
    errorMaxFilesInProcess: null
  };

  function FileUploadAdvanced(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, FILEUPLOADADVANCED_DEFAULTS);
    this.init();
  } // FileUploadAdvanced Methods


  FileUploadAdvanced.prototype = {
    init: function init() {
      this.build();
      this.handleEvents();
      return this;
    },

    /**
     * Add markup
     * @private
     * @returns {void}
     */
    build: function build() {
      var s = this.settings;
      var html;
      var cssClassList = s.isStandalone ? s.standaloneClass : ''; // Re-evaluate strings

      s.textDropArea = s.textDropArea || Locale.translate('TextDropArea');
      s.textDropAreaWithBrowse = s.textDropAreaWithBrowse || Locale.translate('TextDropAreaWithBrowse');
      s.textBtnCancel = s.textBtnCancel || Locale.translate('TextBtnCancel');
      s.textBtnCloseError = s.textBtnCloseError || Locale.translate('TextBtnCloseError');
      s.textBtnRemove = s.textBtnRemove || Locale.translate('TextBtnRemove');
      s.errorAllowedTypes = s.errorAllowedTypes || "<em>".concat(Locale.translate('Error'), "</em>: ").concat(Locale.translate('ErrorAllowedTypes'));
      s.errorMaxFileSize = s.errorMaxFileSize || "<em>".concat(Locale.translate('Error'), "</em>: ").concat(Locale.translate('ErrorMaxFileSize'));
      s.errorMaxFiles = s.errorMaxFiles || "<em>".concat(Locale.translate('Error'), "</em>: ").concat(Locale.translate('ErrorMaxFiles'));
      s.errorMaxFiles = s.errorMaxFiles.replace('{n}', s.maxFiles);
      s.errorMaxFilesInProcess = s.errorMaxFilesInProcess || "<em>".concat(Locale.translate('Error'), "</em>: ").concat(Locale.translate('ErrorMaxFilesInProcess')); // Disabled

      if (this.element.is('.is-disabled')) {
        s.isDisabled = true;
      }

      if (s.isDisabled) {
        cssClassList += ' is-disabled';
      } // Browse files option


      if (s.showBrowseButton) {
        var types = '';
        var id = utils.uniqueId(this.element, 'fileupload-adv-');
        var fileExtensions = s.allowedTypes.split(/[\s|]+/g);
        var isExtra = s.maxFilesInProcess > 1 ? ' multiple' : '';
        isExtra += s.isDisabled ? ' disabled' : '';

        if (fileExtensions.length === 1) {
          if (fileExtensions[0] !== '*') {
            types = ".".concat(fileExtensions[0]);
          }
        } else {
          for (var i = 0, l = fileExtensions.length; i < l; i++) {
            types += ".".concat(fileExtensions[i] + (i !== l - 1 ? ',' : ''));
          }
        }

        html = '' + "<div class=\"fileupload-wrapper ".concat(cssClassList, "\">\n          <div class=\"container drop-area\">\n            ").concat($.createIcon('upload'), "\n            <label class=\"fileupload-adv-browse-lbl\">\n              <span>").concat(s.textDropAreaWithBrowse, "</span>\n              <input type=\"file\" name=\"").concat(id, "\" accept=\"").concat(types, "\"").concat(isExtra, " />\n            </label>\n          </div>\n        </div>");
      } else {
        // Without browse files option
        html = '' + "<div class=\"fileupload-wrapper ".concat(cssClassList, "\">\n          <div class=\"container drop-area\">\n            ").concat($.createIcon('upload'), "\n            <p>").concat(s.textDropArea, "</p>\n          </div>\n        </div>");
      }

      DOM.append(this.element, html, '<div><svg><use><label><span><input>');
      this.dropArea = $('.drop-area', this.element); // Add test automation ids

      utils.addAttributes(this.dropArea, this, this.settings.attributes);
      utils.addAttributes(this.dropArea.find('svg'), this, this.settings.attributes, 'icon');
      utils.addAttributes(this.dropArea.find('label'), this, this.settings.attributes, 'label');
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      var s = this.settings;
      this.dropArea // Drag enter
      .on('dragenter.fileuploadadvanced', function (e) {
        self.element.triggerHandler('filesdragenter');
        e.stopPropagation();
        e.preventDefault();

        if (s.isDisabled) {
          return;
        }

        $(this).addClass('hover');
      }) // Drag over
      .on('dragover.fileuploadadvanced', function (e) {
        e.stopPropagation();
        e.preventDefault();
      }) // Drop
      .on('drop.fileuploadadvanced', function (e) {
        var files = e.originalEvent.dataTransfer.files;
        e.preventDefault();

        if (s.isDisabled) {
          return;
        }
        /**
        * Fires when file/s drag and droped to drop area.
        *
        * @event filesdroped
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {array} files - List of files droped
        */


        self.element.triggerHandler('filesdroped', [files]);
        $(this).removeClass('hover is-focus');
        self.handleFileUpload(files);
      });

      if (s.showBrowseButton && !s.isDisabled) {
        var label = this.dropArea.find('.fileupload-adv-browse-lbl');
        var input = label.find('input[type="file"]'); // Only let open dialog if clicked on link or input

        label.click(function (e) {
          if (!$(e.target).is('.hyperlink, input[type="file"]')) {
            e.preventDefault();
          }
        });
        input.hideFocus();
        input.on('hidefocusremove.fileuploadadvanced', function (e) {
          e.stopPropagation();

          _this.dropArea.addClass('is-focus');
        }).on('hidefocusadd.fileuploadadvanced', function (e) {
          e.stopPropagation();

          _this.dropArea.removeClass('is-focus');
        }).on('change.fileuploadadvanced', function (e) {
          e.stopPropagation();
          self.handleFileUpload(this.files);
        });
      } // If the files are dropped outside the div, files will open in the browser window.
      // To avoid this prevent 'drop' event on document.


      $(document).on('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced', function (e) {
        e.stopPropagation();
        e.preventDefault();

        if (e.type === 'dragover') {
          self.dropArea.removeClass('hover');
        }
      });
    },

    /**
    * Read the file contents using HTML5 FormData()
    * @param {object} files File object containing uploaded files.
    * @returns {void}
    */
    handleFileUpload: function handleFileUpload(files) {
      var s = this.settings; // Clear previous errors in general area

      $('span.msg', this.element).closest('.error').remove(); // Total files completed

      this.totalCompleted = this.totalCompleted || 0; // Max files can be upload

      var filesLen = this.totalCompleted + files.length + $('.progress', this.element).length;

      if (filesLen > s.maxFiles) {
        this.showError(s.errorMaxFiles);
        return;
      }

      if (filesLen > s.maxFilesInProcess) {
        this.showError(s.errorMaxFilesInProcess);
        return;
      }

      var fileName = s.fileName.replace('[]', '');
      /* eslint-disable no-continue */

      for (var i = 0, l = files.length; i < l; i++) {
        // Check if file type allowed
        if (!this.isFileTypeAllowed(files[i].name)) {
          this.showError(s.errorAllowedTypes, files[i]);
          continue;
        } // Check for max file size


        if (s.maxFileSize !== -1 && files[i].size > s.maxFileSize) {
          this.showError(s.errorMaxFileSize, files[i]);
          continue;
        }
        /**
        * Fires before create the progress status object.
        *
        * @event beforecreatestatus
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file - file to set the status
        */


        this.element.triggerHandler('beforecreatestatus', [files[i]]); // use FormData API

        var fd = new FormData();
        fd.append("".concat(fileName, "[]"), files[i]);
        var status = this.createStatus(files[i]);
        status.container.find('.status-icon .action').focus();
        /**
        * Fires after create the progress status object.
        *
        * @event aftercreatestatus
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file - file to set the status
        */

        this.element.triggerHandler('aftercreatestatus', [files[i]]);

        if (typeof s.send === 'function') {
          s.send(fd, status);
        } else {
          this.sendFileToServer(fd, status);
        }
      }
      /* eslint-enable no-continue */


      if (s.showBrowseButton) {
        // Clear browse file input
        this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').val('');
      }
    },

    /**
    * Create status object
    * @param {object} file to create progress status.
    * @returns {object} contains file and status methods to access.
    */
    createStatus: function createStatus(file) {
      var _this2 = this;

      var self = this;
      var s = this.settings;
      var container = $('' + "<div class=\"container\">\n        <div class=\"file-row\">\n          <span class=\"status-icon\">\n            <button type=\"button\" class=\"btn-icon action\">\n              ".concat($.createIcon({
        icon: 'close',
        classes: ['icon-close']
      }), "\n              <span>").concat(s.textBtnCancel, "</span>\n            </button>\n          </span>\n          <span class=\"description\">").concat(file.name, "</span>\n          <div class=\"l-pull-right\">\n            <span class=\"size\">").concat(this.formatFileSize(file.size), "</span>\n          </div>\n        </div>\n        <div class=\"progress-row\">\n          <span class=\"progress\">\n            <span class=\"progress-bar\" data-value=\"0\"></span>\n          </span>\n        </div>\n      </div>"));
      var btnCancel = $('.action', container).button();
      var rightSide = $('.l-pull-right', container);
      var progressBar = $('.progress-bar', container).progress({
        animationLength: 10
      }); // Add this container

      this.dropArea.after(container); // Update progress-bar

      var setProgress = function setProgress(progress) {
        /**
        * Fires when file progress status changes.
        *
        * @event fileprogress
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} status - `{ file, progress }`
        */
        _this2.element.triggerHandler('fileprogress', [{
          file: file,
          progress: progress
        }]);

        progressBar.attr('data-value', progress).triggerHandler('updated');
      }; // Set abort action


      var setAbort = function setAbort(jqxhr) {
        btnCancel.on('click.fileuploadadvanced', function () {
          /**
          * Fires when file aborted.
          *
          * @event fileaborted
          * @memberof FileUploadAdvanced
          * @property {object} event - The jquery event object
          * @property {object} file - aborted
          */
          _this2.element.triggerHandler('fileaborted', [file]);

          if (jqxhr && typeof jqxhr.abort === 'function') {
            jqxhr.abort();
          }

          btnCancel.off('click.fileuploadadvanced');
          container.remove();
        });
      }; // Set completed state


      var setCompleted = function setCompleted(data) {
        data = data && typeof data.remove === 'function' ? data : {
          remove: function remove() {}
        };
        container.addClass('completed'); // Add "Completed" icon

        btnCancel.after($.createIcon('check')); // Add "Remove from server" button

        rightSide.append('' + "<button type=\"button\" class=\"btn-icon action\">\n          ".concat($.createIcon({
          classes: ['icon-close'],
          icon: 'close'
        }), "\n          <span>").concat(s.textBtnRemove, "</span>\n        </button>")); // Set "Remove from server" button action

        $('.action', rightSide).button().on('click.fileuploadadvanced', function () {
          $(this).off('click.fileuploadadvanced');
          container.remove(); // TODO: server call for removing data

          data.remove();
          /**
           * Fires when attached file removed.
           *
           * @event fileremoved
           * @memberof FileUploadAdvanced
           * @property {object} event - The jquery event object
           * @property {object} file uploaded
           */

          self.element.triggerHandler('fileremoved', [file]);
        }); // Remove Cancel button and progress-bar area

        progressBar.destroy();
        btnCancel.off('click.fileuploadadvanced');
        btnCancel.add(progressBar.closest('.progress-row')).remove(); // Increment to total files completed

        self.totalCompleted++;
        /**
        * Fires when file complete uploading.
        *
        * @event filecompleteuploading
        * @memberof FileUploadAdvanced
        * @property {object} event - The jquery event object
        * @property {object} file uploaded
        */

        self.element.triggerHandler('filecompleteuploading', [file]);
      };

      return {
        file: file,
        container: container,
        setProgress: setProgress,
        setAbort: setAbort,
        setCompleted: setCompleted
      };
    },

    /**
    * Function you can implement to send data to the server.
    * @param {object} formData - Contains the form data / file data.
    * @param {object} status - Status of the upload operation
    * @returns {void}
    */
    sendFileToServer: function sendFileToServer(formData, status) {
      var jqXHR = {
        abort: function abort() {}
      };
      var tempData = {
        remove: function remove() {}
      };
      var percent = 0;
      var total = parseFloat(status.file.size);
      /* eslint-disable new-cap */

      var timer = new $.fn.timer(function () {
        status.setCompleted(tempData);
      }, total);
      /* eslint-enable new-cap */

      $(timer.event).on('update', function (e, data) {
        percent = Math.ceil(data.counter / total * 100);
        status.setProgress(percent);
      });
      status.setAbort(jqXHR);
    },

    /**
     * Show error on ui
     * @private
     * @param {string} error to display
     * @param {object} file contains the error.
     * @returns {void}
     */
    showError: function showError(error, file) {
      var container;
      var s = this.settings;

      if (error === s.errorMaxFiles || error === s.errorMaxFilesInProcess) {
        // This error show without file name or size in general area
        container = $('' + "<div class=\"container error\">\n          <div class=\"file-row\">\n            <span class=\"status-icon\">\n              <button type=\"button\" class=\"btn-icon action\">\n                ".concat($.createIcon({
          classes: ['icon-close'],
          icon: 'close'
        }), "\n                <span>").concat(s.textBtnCloseError, "</span>\n              </button>\n            </span>\n            <span class=\"msg\">").concat(error, "</span>\n          </div>\n        </div>"));
      } else {
        container = $('' + "<div class=\"container error\">\n          <div class=\"file-row\">\n            <span class=\"status-icon\">\n              <button type=\"button\" class=\"btn-icon action\">\n                ".concat($.createIcon({
          classes: ['icon-close'],
          icon: 'close'
        }), "\n                <span>").concat(s.textBtnCloseError, "</span>\n              </button>\n            </span>\n            <span class=\"description\">").concat(file.name, "</span>\n            <div class=\"l-pull-right\">\n              <span class=\"size\">").concat(this.formatFileSize(file.size), "</span>\n            </div>\n          </div>\n          <div class=\"msg\">\n            <p>").concat(error, "</p>\n          </div>\n        </div>"));
      }

      $('.action', container).button().on('click.fileuploadadvanced', function () {
        container.remove();
      }); // Add this container

      this.dropArea.after(container);
    },

    /**
     * Check if file type allowed
     * @private
     * @param {string} fileName to check types
     * @returns {boolean} true if allowed to uploaded
     */
    isFileTypeAllowed: function isFileTypeAllowed(fileName) {
      var fileExtensions = this.settings.allowedTypes.toLowerCase().split(/[\s|]+/g);
      var ext = fileName.split('.').pop().toLowerCase();

      if (this.settings.allowedTypes !== '*' && $.inArray(ext, fileExtensions) < 0) {
        return false;
      }

      return true;
    },

    /**
     * Helper function that formats the file sizes
     * @private
     * @param {number} bytes to be formated
     * @returns {string} formated to use in ui
     */
    formatFileSize: function formatFileSize(bytes) {
      var scale = {
        GB: 1000000000,
        MB: 1000000,
        KB: 1000
      };

      if (typeof bytes !== 'number') {
        return '';
      }

      if (bytes >= scale.GB) {
        return "".concat((bytes / scale.GB).toFixed(2), " GB");
      }

      if (bytes >= scale.MB) {
        return "".concat((bytes / scale.MB).toFixed(2), " MB");
      }

      return "".concat((bytes / scale.KB).toFixed(2), " KB");
    },

    /**
    * Set component to enabled.
    * @returns {void}
    */
    enable: function enable() {
      this.settings.isDisabled = false;
      this.unbind();
      this.element.find('.fileupload-wrapper').removeClass('is-disabled').find('.fileupload-adv-browse-lbl input[type="file"]').removeAttr('disabled');
      this.handleEvents();
    },

    /**
    * Set component to disabled.
    * @returns {void}
    */
    disable: function disable() {
      this.settings.isDisabled = true;
      this.unbind();
      this.element.find('.fileupload-wrapper').addClass('is-disabled').find('.fileupload-adv-browse-lbl input[type="file"]').attr('disabled', 'disabled');
      this.handleEvents();
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {void}
     */
    unbind: function unbind() {
      this.dropArea.find('.fileupload-adv-browse-lbl input[type="file"]').off('hidefocusremove.fileuploadadvanced hidefocusadd.fileuploadadvanced change.fileuploadadvanced');
      this.dropArea.off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
      $(document).off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
      $('.action', this.element).off('click.fileuploadadvanced');
      var wrapper = $('.fileupload-wrapper', this.element);
      wrapper.off().find('*').off();
      wrapper.remove();
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, FILEUPLOADADVANCED_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $('.fileupload-wrapper', this.element).remove();
      $.removeData(this.element[0], COMPONENT_NAME$R);
    }
  };
  /*
  ERROR
  --------
  https://social.technet.microsoft.com/Forums/ie/en-US/ec3c0be0-0834-4873-8e94-700e9df9c822/edge-browser-drag-and-drop-files-not-working?forum=ieitprocurrentver

  */

  /**
   * jQuery Component Wrapper for FileUpload Advanced
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.fileuploadadvanced = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$R);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$R, new FileUploadAdvanced(this, settings));
      }
    });
  };

  var COMPONENT_NAME$S = 'homepage';
  /**
  * The Homepage handles card layout at multiple breakpoints.
  *
  * @class Homepage
  * @constructor
  * @param {HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.animate] Disable animation during resize
  * @param {number} [settings.columns] Display in 3 (default) or 4 column layout
  * @param {string} [settings.easing]
  * @param {number} [settings.gutterSize]
  * @param {number} [settings.widgetWidth]
  * @param {number} [settings.widgetHeight]
  * @param {number} [settings.timeout]
  */

  var HOMEPAGE_DEFAULTS = {
    animate: true,
    columns: 3,
    editing: false,
    easing: 'blockslide',
    gutterSize: 20,
    widgetWidth: 360,
    widgetHeight: 370,
    useSmall: false,
    timeout: 100
  };

  function Homepage(element, settings) {
    this.settings = utils.mergeSettings(element, settings, HOMEPAGE_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Homepage Methods


  Homepage.prototype = {
    /**
     * @name Homepage#rowsAndCols
     * @type Array
     * @default []
     * @readonly
     * Stores information about the current number of rows and columns that make up the Homepage layout.
     * Each entry in the array
     */

    /**
     * @returns {object} containing information about the current state of the Homepages component.
     */
    get state() {
      var rows = this.rowsAndCols.length;
      var cols = rows ? this.rowsAndCols[0].length : 0;
      var settings = this.settings;
      var lastRow = this.rowsAndCols[rows - 1];

      if (lastRow.indexOf(false) === -1) {
        rows -= 1;
      }

      function getContainerHeight() {
        var topGutter = settings.gutterSize;
        return topGutter + (settings.gutterSize + settings.widgetHeight) * rows;
      }

      if (this.editing === undefined) {
        this.editing = settings.editing;
      }

      return {
        rows: rows,
        cols: cols,
        containerHeight: getContainerHeight(),
        matrix: this.rowsAndCols,
        blocks: this.blocks,
        editing: this.editing
      };
    },

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.isTransitionsSupports = this.supportsTransitions();
      this.setSmall();
      this.setColumns();
      this.initHeroWidget();
      this.handleEvents();
      this.initEdit(); // Initial Sizing

      this.resize(this, false);
    },

    /**
     * Set max number of columns can be shown.
     * @private
     * @returns {void}
     */
    setColumns: function setColumns() {
      var columns = this.settings.columns;
      var columnsByAttr = parseInt(this.element.attr('data-columns'), 10);

      if (!isNaN(columnsByAttr) && columns !== columnsByAttr && columns === HOMEPAGE_DEFAULTS.columns) {
        columns = columnsByAttr;
      }

      this.columns = columns;
    },

    /**
     * Set widget/card default height and width.
     * @private
     * @returns {void}
     */
    setSmall: function setSmall() {
      var s = this.settings;
      var smAttr = this.element.attr('data-use-small');

      if (s.useSmall || smAttr && smAttr.toString().toLowerCase() === 'true') {
        var d = HOMEPAGE_DEFAULTS;
        var small = {
          gutterSize: 24,
          widgetWidth: 260,
          widgetHeight: 260
        };
        s.useSmall = true;

        if (s.gutterSize === d.gutterSize) {
          s.gutterSize = small.gutterSize;
        }

        if (s.widgetWidth === d.widgetWidth) {
          s.widgetWidth = small.widgetWidth;
        }

        if (s.widgetHeight === d.widgetHeight) {
          s.widgetHeight = small.widgetHeight;
        }
      }
    },

    /**
     * Initialize columns.
     * @private
     * @param {number} row to be initialize.
     * @returns {void}
     */
    initColumns: function initColumns(row) {
      row = row || 0;
      this.rowsAndCols[row] = [];

      for (var i = 0, l = this.columns; i < l; i++) {
        this.rowsAndCols[row][i] = true; // Make all columns available in first row[true]
      }
    },

    /**
     * Initialize hero widget.
     * @private
     * @returns {void}
     */
    initHeroWidget: function initHeroWidget() {
      var heroWidget = $('.hero-widget');

      if (heroWidget.length > 1) {
        heroWidget = heroWidget.not(':first').remove();
      }

      this.heroWidget = heroWidget;
    },

    /**
     * Initialize rows and cols.
     * @private
     * @returns {void}
     */
    initRowsAndCols: function initRowsAndCols() {
      this.rowsAndCols = []; // Keeping all blocks as rows and columns

      this.initColumns();
    },

    /**
     * Initialize guide and drag event listeners.
     * @private
     * @returns {void}
     */
    initEdit: function initEdit() {
      var _this = this;

      var homepage = this;
      var cards = homepage.element.find('.card, .widget, .small-widget');

      if (homepage.editing === undefined) {
        homepage.editing = homepage.settings.editing;
      }

      if (homepage.editing) {
        cards.attr('draggable', true);
        cards.css('cursor', 'move');
        homepage.guide = $('<div>').addClass('drop-indicator').append("\n      <div class='edge'></div>\n      <div class='line'></div>\n      <div class='edge'></div>\n      ");
        cards.each(function (index, element) {
          var card = $(element);
          var removeButton = $('<button>').addClass('card-remove').append("\n        <span class=\"audible\">Remove Widget</span>\n          <svg icon=\"close\" soho-icon=\"\" class=\"icon\" aria-hidden=\"true\" focusable=\"false\" role=\"presentation\">\n            <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#icon-close\"></use>\n          </svg>\n        "); // Don't add remove button if the card has the 'no-remove' class

          if (!card.hasClass('no-remove')) {
            // Remove button should be inserted before the header for proper alignment
            var header = card.children('.widget-header');
            removeButton.insertBefore(header).on('click.card-remove', function () {
              if (_this.settings && typeof _this.settings.onBeforeRemoveCard === 'function') {
                var result = _this.settings.onBeforeRemoveCard(card);

                if (result && result.then && typeof result.then === 'function') {
                  // A promise is returned
                  result.then(function () {
                    card.triggerHandler('removecard', [card, homepage.state]);
                    card.remove();
                    homepage.refresh(false);
                    homepage.element.triggerHandler('removecard', [card, homepage.state]);
                  });
                } else if (result) {
                  // Boolean is returned instead of a promise
                  card.triggerHandler('removecard', [card, homepage.state]);
                  card.remove();
                  homepage.refresh(false);
                  homepage.element.triggerHandler('removecard', [card, homepage.state]);
                }
              } else {
                card.triggerHandler('removecard', [card, homepage.state]);
                card.remove();
                homepage.refresh(false);
                homepage.element.triggerHandler('removecard', [card, homepage.state]);
              }
            });
          }
        });
        cards.on('mouseenter.card', function () {
          var card = $(this);
          var eastHandle = $('<div>').addClass('ui-resizable-handle ui-resizable-e').drag({
            axis: 'x'
          }).on('dragstart.handle', function (dragevent) {
            dragevent.stopPropagation();
            dragevent.preventDefault();
            card.addClass('ui-resize-passive');
            card.css({
              opacity: 0.9,
              zIndex: 90
            });
            $(window).on('mousemove.handle', function (mouseevent) {
              var width = mouseevent.clientX - card.offset().left;

              if (width < homepage.settings.widgetWidth / 2) {
                eastHandle.css({
                  left: homepage.settings.widgetWidth / 2
                });
              } else {
                card.width(width);
              }
            }).on('mouseup.handle', function () {
              card.removeClass('ui-resize-passive');
              card.css({
                zIndex: 'auto'
              });
              $(window).off('mousemove.handle').off('mouseup.handle');
              card.removeClass('double-width triple-width quad-width quintuple-width');
              var widthUnits = card.width() / homepage.settings.widgetWidth;

              if (widthUnits > 4.5) {
                card.addClass('quintuple-width');
              } else if (widthUnits > 3.5) {
                card.addClass('quad-width');
              } else if (widthUnits > 2.5) {
                card.addClass('triple-width');
              } else if (widthUnits > 1.5) {
                card.addClass('double-width');
              }

              $('.ui-resizable-handle').remove();
              card.css({
                opacity: 1,
                width: ''
              });
              homepage.refresh(false);
              card.triggerHandler('resizecard', [card, homepage.state]);
              homepage.element.triggerHandler('resizecard', [card, homepage.state]);
            });
          });
          var southHandle = $('<div>').addClass('ui-resizable-handle ui-resizable-s').drag({
            axis: 'y'
          }).on('dragstart.handle', function (dragevent) {
            dragevent.stopPropagation();
            dragevent.preventDefault();
            card.addClass('ui-resize-passive');
            card.css({
              opacity: 0.9,
              zIndex: 90
            });
            $(window).on('mousemove.handle', function (mouseevent) {
              var height = mouseevent.clientY - card.offset().top;

              if (height < homepage.settings.widgetHeight) {
                southHandle.css({
                  top: homepage.settings.widgetHeight
                });
              } else {
                card.height(height);
              }
            }).on('mouseup.handle', function () {
              card.removeClass('ui-resize-passive');
              card.css({
                zIndex: 'auto'
              });
              $(window).off('mousemove.handle').off('mouseup.handle');
              card.removeClass('double-height');
              var heightUnits = card.height() / homepage.settings.widgetHeight;

              if (heightUnits > 1.5) {
                card.addClass('double-height');
              }

              $('.ui-resizable-handle').remove();
              card.css({
                opacity: 1,
                height: ''
              });
              homepage.refresh(false);
              card.triggerHandler('resizecard', [card, homepage.state]);
              homepage.element.triggerHandler('resizecard', [card, homepage.state]);
            });
          });

          if (card.has('.ui-resizable-handle').length === 0) {
            card.append(eastHandle, southHandle);
          }

          card.addClass('editable-hover-border');
        }).on('mouseleave.card', function () {
          var card = $(this);

          if (!card.hasClass('ui-resize-passive')) {
            $('.ui-resizable-handle').remove();
          }

          card.removeClass('editable-hover-border');
        }).on('dragstart.card', function () {
          var card = $(this);
          card.addClass('is-dragging');
        }).on('dragover.card', function (event) {
          // For mac chrome/safari to remove animation
          // https://stackoverflow.com/questions/32206010/disable-animation-for-drag-and-drop-chrome-safari
          event.preventDefault();
        }).on('dragenter.card', function (event) {
          event.preventDefault();
          var card = $(this);
          var draggingCard = $('.is-dragging'); // Ignore intial trigger when current card is dragging over itself

          if (card.is(draggingCard) && $('.drop-indicator').length === 0) {
            return;
          }

          if (draggingCard.index() < card.index()) {
            homepage.guide.css('right', '-14px');
            homepage.guide.css('left', '');
          } else {
            homepage.guide.css('left', '-14px');
            homepage.guide.css('right', '');
          }

          card.append(homepage.guide);
          homepage.refresh(false);
        }).on('dragend.card', function () {
          var card = $(this); // Make sure this is not from a resize event, card should have is-dragging class

          if (card.hasClass('is-dragging')) {
            var cardOver = $(cards).has('.drop-indicator');

            if (card.index() < cardOver.index()) {
              card.insertAfter(cardOver);
            } else {
              card.insertBefore(cardOver);
            }

            card.removeClass('is-dragging');
            homepage.guide.remove();
            homepage.refresh(false);
            card.triggerHandler('reordercard', [card, homepage.state]);
            homepage.element.triggerHandler('reordercard', [card, homepage.state]);
          }
        });
      } else {
        cards.attr('draggable', false);
        cards.css('cursor', 'auto');
        cards.children('.card-remove').remove();
        cards.off('mouseenter.card mouseleave.card dragstart.card dragenter.card dragend.card');
      }
    },

    /**
     * Set edit for rearranging/reordering cards.
     * @param {boolean} edit mode
     * @returns {void}
     */
    setEdit: function setEdit(edit) {
      if (edit !== undefined) {
        this.editing = edit;
        this.initEdit();
        this.refresh(false);
      }
    },

    /**
     * Get availability where we can fit this given block.
     * @private
     * @param {object} block to get availability.
     * @returns {object} [x and y] where we can fit this block
     */
    getAvailability: function getAvailability(block) {
      var abort = false;
      var smallest = {};
      var rows = this.rowsAndCols.length; // Loop thru each row and column soon it found first available spot
      // Then check for if block's width can fit in(yes), asign to [smallest] and break both loops

      for (var i = 0, l = rows; i < l && !abort; i++) {
        for (var j = 0, innerCheck = true, cols = this.rowsAndCols[i].length; j < cols && !abort; j++) {
          if (this.rowsAndCols[i][j] && block.w + j <= cols) {
            if (block.w > 1 && cols > j + 1) {
              for (var n = 0; n < block.w; n++) {
                if (!this.rowsAndCols[i][j + n]) {
                  innerCheck = false;
                  break;
                }
              }
            }

            if (block.h > 1 && rows > i + 1) {
              for (var _n = 0; _n < block.h; _n++) {
                if (!this.rowsAndCols[i + _n][j]) {
                  innerCheck = false;
                  break;
                }
              }
            }

            if (innerCheck) {
              smallest.row = i;
              smallest.col = j;
              abort = true;
            }
          }
        }
      } // If did not found any available spot from previous loops
      // Add new row and asign to [smallest] first column in this new row


      if (!Object.getOwnPropertyNames(smallest).length) {
        this.initColumns(rows);
        smallest.row = rows;
        smallest.col = 0;
      }

      return smallest; // {x:0, y:0}
    },

    /**
     * Make all spots as unavailable, depends on block's width and height
     * Soon we used this block
     * @private
     * @param {number} r as row.
     * @param {number} c as col.
     * @param {number} block to fit.
     * @returns {void}
     */
    fitBlock: function fitBlock(r, c, block) {
      var addRow = true;
      block.x = c;
      block.y = r;

      if (block.w === 1 && block.h === 1) {
        // Single block can fit anywhere
        this.rowsAndCols[r][c] = false;
      } else if (block.w !== 1) {
        // If more then one row or column then loop thru to block's width and height
        // If height is more then current rows then add new row
        // Mark those spots as unavailable[false]
        // Left to right
        for (var i = r, l = block.h + r; i < l; i++) {
          for (var j = c, l2 = block.w + c; j < l2; j++) {
            if (!this.rowsAndCols[i]) {
              this.initColumns(i);
            }

            this.rowsAndCols[i][j] = false;
          }
        }
      } else {
        // Top to bottom
        for (var _i = r, _l = block.h + r; _i < _l; _i++) {
          for (var _j = c, _l2 = block.h + c; _j < _l2; _j++) {
            if (!this.rowsAndCols[_i]) {
              this.initColumns(_i);
            }

            this.rowsAndCols[_i][c] = false;
          }
        }
      } // Check if reach to end of columns then assign flag[addRow]


      for (var _i2 = 0, _l3 = this.rowsAndCols[r].length; _i2 < _l3; _i2++) {
        if (this.rowsAndCols[r][_i2]) {
          addRow = false;
        }
      } // If reach to end of columns and next row is not avaiable then add new row
      // Make all columns available, if not assigned earlier as unavailable


      if (addRow) {
        if (!this.rowsAndCols[r + 1]) {
          this.initColumns(r + 1);
        }
      }
    },

    /**
     * Setup each block sizes, based on classes provided from markup
     * @private
     * @returns {void}
     */
    setBlocks: function setBlocks() {
      var cards = this.element.find('.card, .widget, .small-widget');
      this.blocks = [];

      for (var i = 0, l = cards.length; i < l; i++) {
        var card = $(cards[i]);
        var h = card.hasClass('double-height') ? 2 : 1;
        var w = void 0;

        if (card.hasClass('sextuple-width')) {
          w = 6;
        } else if (card.hasClass('quintuple-width')) {
          w = 5;
        } else if (card.hasClass('quad-width')) {
          w = 4;
        } else if (card.hasClass('triple-width')) {
          w = 3;
        } else if (card.hasClass('double-width')) {
          w = 2;
        } else {
          w = 1;
        }

        this.blocks.push({
          w: w,
          h: h,
          elem: card,
          text: card.text()
        });
      } // Max sized columns brings to top


      if (this.columns > 1) {
        for (var _i3 = 0, j = 0, _w = 0, _l4 = this.blocks.length; _i3 < _l4; _i3++) {
          if (this.blocks[_i3].w >= this.columns && _i3 && _w && _w <= this.columns / 2) {
            this.arrayIndexMove(this.blocks, _i3, j);
          }

          _w += this.blocks[_i3].w;

          if (_w >= this.columns) {
            _w = 0; // reset

            j = this.blocks[j].w >= this.columns ? j + 1 : _i3; // record to move
          }
        }
      }
    },

    /**
     * Move an array element position
     * @private
     * @param {array} arr .
     * @param {number} from index.
     * @param {number} to index.
     * @returns {void}
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    /**
     * Resize Method
     * @private
     * @param {object} self .
     * @param {boolean} animate .
     * @returns {void}
     */
    resize: function resize(self, animate) {
      // Sizes of "breakpoints" is  320, 660, 1000, 1340, 1680 (for 320)
      // or 360, 740, 1120, 1500, 1880 or (for 360)
      var bpXl3 = self.settings.widgetWidth * 6 + self.settings.gutterSize * 5;
      var bpXl2 = self.settings.widgetWidth * 5 + self.settings.gutterSize * 4;
      var bpXl = self.settings.widgetWidth * 4 + self.settings.gutterSize * 3;
      var bpDesktop = self.settings.widgetWidth * 3 + self.settings.gutterSize * 2;
      var bpTablet = self.settings.widgetWidth * 2 + self.settings.gutterSize;
      var bpPhone = self.settings.widgetWidth;
      var bp = bpXl3; // 2260 = ((360 * 6) + (20 * 5))
      // Math min against window.screen.width for single line mobile support

      var elemWidth = self.element.outerWidth(); // Find the Breakpoints

      var xl3 = elemWidth >= bpXl3;
      var xl2 = elemWidth >= bpXl2 && elemWidth <= bpXl3;
      var xl = elemWidth >= bpXl && elemWidth <= bpXl2;
      var desktop = elemWidth >= bpDesktop && elemWidth <= bpXl;
      var tablet = elemWidth >= bpTablet && elemWidth <= bpDesktop;
      var phone = elemWidth <= bpTablet;
      var content = self.element.find('> .content');
      this.setColumns(); // Assign columns as breakpoint sizes

      var columns;

      if (xl3 || self.columns === 6) {
        columns = 6;
        bp = bpXl3;
      }

      if (xl2 || self.columns === 5) {
        columns = 5;
        bp = bpXl2;
      }

      if (xl || self.columns === 4) {
        columns = 4;
        bp = bpXl;
      }

      if (desktop || self.columns === 3) {
        columns = 3;
        bp = bpDesktop;
      }

      if (tablet || self.columns === 2) {
        columns = 2;
        bp = bpTablet;
      }

      if (phone || self.columns === 1) {
        columns = 1;
        bp = bpPhone;
      } // Calculated columns


      self.columns = columns || this.settings.columns;

      if (content.length) {
        content[0].style.marginLeft = "-".concat(bp / 2, "px");
      }

      this.setBlocks(); // setup blocks

      this.initRowsAndCols(); // setup colums
      // Loop thru each block, make fit where available and
      // If block more wider than available size, make as available size
      // Assign new left and top css positions

      for (var i = 0, l = self.blocks.length; i < l; i++) {
        // let left, top, pos, available,
        var block = self.blocks[i]; // Remove extra classes if assigned earlier

        block.elem.removeClass('to-single to-double to-triple to-quad to-quintuple'); // If block more wider than available size, make as available size

        if (block.w > self.columns) {
          block.w = self.columns;

          if (self.columns === 1) {
            block.elem.addClass('to-single');
          } else if (self.columns === 2) {
            block.elem.addClass('to-double');
          } else if (self.columns === 3) {
            block.elem.addClass('to-triple');
          } else if (self.columns === 4) {
            block.elem.addClass('to-quad');
          } else if (self.columns === 5) {
            block.elem.addClass('to-quintuple');
          }
        } // Get Availability


        var available = self.getAvailability(block); // Set positions

        var box = self.settings.widgetWidth + self.settings.gutterSize;
        var totalWidth = box * self.columns;
        var left = Locale.isRTL() ? totalWidth - (box * block.w + box * available.col) : box * available.col; // eslint-disable-line

        var top = (self.settings.widgetHeight + self.settings.gutterSize) * available.row;
        var pos = {
          left: left,
          top: top
        };

        if (animate && !this.editing) {
          var easing = self.settings.easing;
          var blockslide = [0.09, 0.11, 0.24, 0.91];

          if (easing === 'blockslide') {
            if (self.isTransitionsSupports) {
              self.applyCubicBezier(block.elem, blockslide);
              block.elem[0].style.left = "".concat(pos.left, "px");
              block.elem[0].style.top = "".concat(pos.top, "px");
            } else {
              // IE-9
              block.elem.animate(pos, self.settings.timeout);
            }
          } else {
            // Other easing effects ie (linear, swing)
            block.elem.animate(pos, self.settings.timeout, easing);
          }
        } else {
          if (self.isTransitionsSupports) {
            self.applyCubicBezier(block.elem, null);
          }

          block.elem[0].style.left = "".concat(pos.left, "px");
          block.elem[0].style.top = "".concat(pos.top, "px");
        } // Mark all spots as unavailable for this block, as we just used this one


        self.fitBlock(available.row, available.col, block);
      }
      /**
      * Fires after the page is resized and layout is set.
      * Can be used for any special adjustments.
      * @event resize
      * @memberof Homepage
      * @type {object}
      * @param {object} event The jquery event object
      * @param {number} columns The number of columns provided by this instance's settings
      * @param {object} metadata A compilation of current state information from the instance.
      */


      self.element.triggerHandler('resize', [self.columns, self.state]);
    },

    /**
     * Apply cubic-bezier effects
     * @private
     * @param {object} el as element.
     * @param {string} cubicBezier effect to apply.
     * @returns {void}
     */
    applyCubicBezier: function applyCubicBezier(el, cubicBezier) {
      var value = cubicBezier ? "all .3s cubic-bezier(".concat(cubicBezier, ")") : 'none';
      el[0].style['-webkit-transition'] = value;
      el[0].style['-moz-transition'] = value;
      el[0].style['-ms-transition'] = value;
      el[0].style['-o-transition'] = value;
      el[0].style.transition = value;
    },

    /**
     * Check if browser supports transitions
     * @private
     * @returns {boolean} true if supports transitions
     */
    supportsTransitions: function supportsTransitions() {
      var s = document.createElement('p').style;
      var p = 'transition';

      if (typeof s[p] === 'string') {
        return true;
      } // Tests for vendor specific prop


      var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];
      p = p.charAt(0).toUpperCase() + p.substr(1);

      for (var i = 0, l = v.length; i < l; i++) {
        if (typeof s[v[i] + p] === 'string') {
          return true;
        }
      }

      return false;
    },

    /**
     * Refresh resize calculations to update any changes.
     * @param {boolean} animate False will disable animation during refresh
     * @returns {void}
     */
    refresh: function refresh(animate) {
      var _this2 = this;

      setTimeout(function () {
        animate = typeof animate !== 'undefined' ? animate : _this2.settings.animate;

        _this2.resize(_this2, animate);
      }, 0);
    },

    /**
     * Detach events
     * @private
     * @returns {void}
     */
    detachEvents: function detachEvents() {
      $('body').off('resize.homepage');
      $('.application-menu').off('applicationmenuopen.homepage applicationmenuclose.homepage');
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, HOMEPAGE_DEFAULTS);
      }

      return this.detachEvents().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.detachEvents();
      $.removeData(this.element[0], COMPONENT_NAME$S);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this3 = this;

      $('body').on('resize.homepage', function () {
        _this3.resize(_this3, _this3.settings.animate);
      });
      $('.application-menu').on('applicationmenuopen.homepage applicationmenuclose.homepage', function () {
        _this3.resize(_this3, _this3.settings.animate);
      });
    }
  };

  /**
   * jQuery Component Wrapper for Homepage
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.homepage = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$S);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$S, new Homepage(this, settings));
      }
    });
  };

  var COMPONENT_NAME$T = 'pager'; // Selector for Pager elements that should have a tabIndex

  var FOCUSABLE_SELECTOR = ['.pager-first > .btn-icon', '.pager-prev > .btn-icon', '.pager-next > .btn-icon', '.pager-last > .btn-icon', '.pager-no > .btn-icon', '.pager-count input', '.pager-pagesize button'].join(', ');
  /**
  * The Pager Component supports paging on lists.
  * @class Pager
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  *
  * @param {string} [settings.componentAPI]  If defined, becomes the definitive way to call methods on
  * parent component.
  * @param {string} [settings.type = 'list']  Different types of pagers option sets.
  * list - just shows next and previous and a listing of page numbers you can click
  * pageof - for datagrid also shows next and previous and first and last with a page number input and page size selector used optionally for
  * firstlast - for lists shows next and previous and first and last with option to set showPageSizeSelector
  * standalone - lets you control all the options with settings, events and methods. In the future i will refactor the others out.
  * @param {string} [settings.position = 'bottom']  Can be on 'bottom' or 'top'.
  * @param {number} [settings.activePage = 1]  Start on this page
  * @param {boolean} [settings.hideOnOnePage = false]  If true, hides the pager if there is only one page worth of results.
  * @param {Function} [settings.source] Call back function for pager data source
  * @param {number} [settings.pagesize = 15]  Can be calculated or a specific number
  * @param {array} [settings.pagesizes = [15, 25, 50, 75]] Array of numbers of the page size selector
  * @param {boolean} [settings.showPageSizeSelector = true] If false will not show page size selector
  * @param {boolean} [settings.smallPageSizeSelector = false] If true, shows a condensed view of the page size selector
  * @param {string} [settings.pageSizeSelectorText = 'RecordsPerPage'] A string to the key of the translation text for the page size selector.
  * @param {boolean} [settings.onPageSizeChange] Call back function for page change
  * @param {boolean} [settings.showFirstButton = true] If false the first button will be hidden (standalone mode)
  * @param {boolean} [settings.enableFirstButton = true] If false the first button will be disabled (standalone mode)
  * @param {boolean} [settings.onFirstPage] Call back function for first page button click
  * @param {boolean} [settings.showPreviousButton = true] If false the previous button will be hidden (standalone mode)
  * @param {boolean} [settings.enablePreviousButton = true] If false the previous button will be disabled (standalone mode)
  * @param {boolean} [settings.onPreviousPage] Call back function for previous page button click
  * @param {boolean} [settings.showNextButton = true] If false the next button will be hidden (standalone mode)
  * @param {boolean} [settings.enableNextButton = true] If false the next button will be disabled (standalone mode)
  * @param {boolean} [settings.onNextPage] Call back function for next page button click
  * @param {boolean} [settings.showLastButton = true] If false the last button will be hidden (standalone mode)
  * @param {boolean} [settings.enableLastButton = true] If false the last button will be disabled (standalone mode)
  * @param {boolean} [settings.onLastPage] Call back function for next page button click
  * @param {boolean} [settings.indeterminate = false] If true will not show anything that lets you go to a specific page (deprecated for standalone)
  * @param {boolean} [settings.firstPageTooltip = 'First Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.previousPageTooltip = 'Previous Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.nextPageTooltip = 'Next Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.lastPageTooltip = 'Last Page'] Tooltip for the first page, defaults to an internally translated tooltip.
  * @param {boolean} [settings.pageSizeMenuSettings = {}] customizable popupmenu settings for the Page Size Selector.
  * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var PAGER_DEFAULTS = {
    componentAPI: undefined,
    type: 'list',
    position: 'bottom',
    activePage: 1,
    hideOnOnePage: false,
    source: null,
    pagesize: 15,
    pagesizes: [15, 25, 50, 75],
    showPageSizeSelector: true,
    smallPageSizeSelector: false,
    pageSizeSelectorText: 'RecordsPerPage',
    pageSizeSelectorTextNoToken: 'RecordsPerPageNoToken',
    onPageSizeChange: null,
    showFirstButton: true,
    enableFirstButton: true,
    showPreviousButton: true,
    enablePreviousButton: true,
    showNextButton: true,
    enableNextButton: true,
    showLastButton: true,
    enableLastButton: true,
    indeterminate: false,
    onFirstPage: null,
    onPreviousPage: null,
    onNextPage: null,
    onLastPage: null,
    firstPageTooltip: 'FirstPage',
    previousPageTooltip: 'PreviousPage',
    nextPageTooltip: 'NextPage',
    lastPageTooltip: 'LastPage',
    pageSizeMenuSettings: {
      attachToBody: false
    },
    attributes: null
  };

  function Pager(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PAGER_DEFAULTS);
    this.settings.dataset = settings.dataset; // by pass deep copy

    this.element = $(element);
    this.init();
  }

  Pager.prototype = {
    /**
     * Displays the current state of the pager. Replaces `pagingInfo` object.
     * @returns {object} containing various state properties.
     */
    get state() {
      var total = 0;
      var pages = 1;
      var filteredPages;
      var filteredTotal;
      var grandTotal;
      var indeterminate = this.settings.indeterminate;
      var indeterminatePageCount = 999999999;
      var pagesize = this.settings.pagesize;
      var type = this.previousOperation;
      var trigger = this.previousTrigger;
      var ds = this.settings.dataset; // pass in total number of records

      if (!isNaN(this.serverDatasetTotal)) {
        total = this.serverDatasetTotal;
      } else if (ds && ds.length) {
        total = ds.length;

        if (this.isFilteredClientside) {
          var filteredDs = ds.filter(function (i) {
            return !i._isFilteredOut;
          });
          total = filteredDs.length;
        }
      }

      if (this.grandTotal) {
        grandTotal = this.grandTotal;
      } // calculate number of pages


      if (indeterminate) {
        pages = indeterminatePageCount;
      } else if (total < 1) {
        pages = 1;
      } else {
        pages = Math.ceil(total / pagesize);
      } // calculate number of filtered pages, if applicable


      if (!isNaN(this.filteredTotal)) {
        filteredTotal = this.filteredTotal;

        if (indeterminate) {
          pages = indeterminatePageCount;
        } else if (filteredTotal < 1) {
          filteredPages = 1;
        } else {
          filteredPages = Math.ceil(filteredTotal / pagesize);
        }
      }

      return {
        activePage: this.activePage,
        indeterminate: this.settings.indeterminate,
        grandTotal: grandTotal,
        pagesize: pagesize,
        pages: pages,
        trigger: trigger,
        total: total,
        type: type,
        filteredActivePage: this.filteredActivePage,
        filteredTotal: filteredTotal,
        filteredPages: filteredPages
      };
    },

    /**
     * This method is slated to be removed in a future v4.21.0 or v5.0.0.
     * (See https://github.com/infor-design/enterprise/issues/922)
     * @deprecated as of v4.15.0.  Please use the `state` property instead.
     * @returns {object} containing various state properties
     */
    get pagingInfo() {
      warnAboutDeprecation('state', 'pagingInfo');
      return this.state;
    },

    /**
     * @returns {Array} of HTMLElements representing focusable elements in the pager
     */
    get focusableElements() {
      return utils.getArrayFromList(this.pagerBar[0].querySelectorAll(FOCUSABLE_SELECTOR));
    },

    /**
     * @returns {Array|undefined} containing references to numeric paging buttons, if enabled
     */
    get numberButtons() {
      if (this.isTable) {
        return undefined;
      }

      var numberButtonSelector = 'li:not(.pager-prev):not(.pager-next):not(.pager-first):not(.pager-last):not(.pager-pagesize)';
      var buttons = this.pagerBar[0].querySelectorAll(numberButtonSelector);
      return utils.getArrayFromList(buttons);
    },

    /**
     * @returns {HTMLElement|undefined} the input field used for selecting pages, if enabled
     */
    get pageSelectorInput() {
      if (this.isListView) {
        return undefined;
      }

      return this.pagerBar[0].querySelector('.pager-count input');
    },

    /**
     * @returns {HTMLElement|undefined} the button used to select from a list of page sizes, if enabled
     */
    get pageSizeSelectorButton() {
      if (!this.settings.showPageSizeSelector) {
        return undefined;
      }

      return this.pagerBar[0].querySelector('.pager-pagesize button');
    },

    /**
     * @returns {boolean} if true, shows the condensed version of the Page Size
     * Selector Button for smaller viewing areas.
     */
    get showSmallPageSizeSelector() {
      if (!this.settings.showPageSizeSelector) {
        return false;
      }

      if (this.settings.smallPageSizeSelector === true) {
        return true;
      }

      return this.isListView && this.element.parents('.list-detail').length;
    },

    /**
     * Init the pager.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.createPagerBar();
      this.setActivePage(this.settings.activePage, true); // Get First Page

      this.handleEvents();
    },

    /**
     * Setting the internals of the pager.
     * @private
     * @returns {void}
     */
    setup: function setup() {
      // Check for legacy data attributes
      if (this.element.attr('data-pagesize')) {
        var pagesize = Number(this.element.attr('data-pagesize'));

        if (!isNaN(pagesize)) {
          this.settings.pagesize = pagesize;
        }

        this.element.removeAttr('data-pagesize');
      } // Add [pagesize] if not found in [pagesizes]


      if (this.settings.pagesizes.indexOf(this.settings.pagesize) === -1) {
        var sortNumber = function sortNumber(a, b) {
          return a - b;
        };

        this.settings.pagesizes.push(this.settings.pagesize);
        this.settings.pagesizes = this.settings.pagesizes.sort(sortNumber);
      }

      this.handleDeprecatedSettings();
      var widgetContainer = this.element.parents('.card, .widget'); // Adjust for the possibility of the pager being attached to a Table instead
      // of normal grid markup

      if (this.element.is('tbody')) {
        this.isTable = true;
        this.settings.type = 'table';
        this.mainContainer = this.element.closest('.datagrid-container');

        if (!this.settings.componentAPI) {
          this.settings.componentAPI = this.mainContainer.data('datagrid');
        }

        if (widgetContainer.length) {
          widgetContainer[0].classList.add('has-datagrid');
        }
      } // If contained by a widget/card container, build some settings for that


      var listviewContainer = this.element.is('.listview');

      if (listviewContainer) {
        this.isTable = false;
        this.isListView = true;
        this.mainContainer = this.element;

        if (!this.settings.componentAPI) {
          this.settings.componentAPI = this.element.data('listview');
        }
      }

      this.element.attr({
        role: 'region',
        'aria-label': Locale.translate('Pagination')
      });
      return this;
    },

    /**
     * Add the pager dom elements.
     * @private
     */
    createPagerBar: function createPagerBar() {
      if (this.pagerBar) {
        return;
      }

      this.pagerBar = this.element.prev('.pager-toolbar');

      if (this.pagerBar.length === 0) {
        this.pagerBar = $('<ul class="pager-toolbar"></ul>');
      }

      if (this.settings.type === 'standalone') {
        this.pagerBar.addClass('is-standalone');

        if (this.isListView) {
          this.mainContainer.after(this.pagerBar);
        } else {
          this.element.append(this.pagerBar);
        }
      } else if (this.isTable) {
        this.mainContainer.after(this.pagerBar);
      } else if (this.settings.position === 'bottom') {
        this.element.after(this.pagerBar);
      } else {
        this.element.before(this.pagerBar);
      }

      if (this.isListView) {
        this.pagerBar.addClass('is-listview');
      } // Inside of Listviews, place the pager bar inside of the card/widget footer


      var widgetContainer = this.element.closest('.card, .widget');

      if (widgetContainer.length) {
        var self = this;
        var widgetTypes = ['widget', 'card'];
        widgetTypes.forEach(function (type) {
          var widgetContent = self.element.closest(".".concat(type, "-content"));

          if (!widgetContent.length) {
            return;
          }

          var widgetFooter = widgetContent.next(".".concat(type, "-footer"));

          if (!widgetFooter.length) {
            widgetFooter = $("<div class=\"".concat(type, "-footer\"></div>")).insertAfter(widgetContent);
          }

          self.pagerBar.appendTo(widgetFooter);
        });
      }
    },

    /**
     * Handle Deprecated Settings
     * @private
     * @returns {void}
     */
    handleDeprecatedSettings: function handleDeprecatedSettings() {
      // `attachPageSizeMenuToBody` becomes `pageSizeMenuSettings.attachToBody`.
      // The `pageSizeMenuSettings` object represents a Popupmenu settings object.
      if (this.settings.attachPageSizeMenuToBody !== undefined) {
        warnAboutDeprecation('pageSizeMenuSettings.attachToBody (setting)', 'attachPageSizeMenuToBody (setting)');
        this.settings.pageSizeMenuSettings.attachToBody = this.settings.attachPageSizeMenuToBody;
        delete this.settings.attachPageSizeMenuToBody;
      }
    },

    /**
     * Attach All relevant events
     * @private
     */
    handleEvents: function handleEvents() {
      var self = this; // Attach button click and touch

      this.pagerBar.on('click.pager', '.btn-icon', function (e) {
        var btn = e.currentTarget;
        var li = btn.parentNode;
        var dropdown = document.querySelector('.datagrid-cell-wrapper .dropdown');
        var dropdownList = document.querySelector('.datagrid-dropdown-list');
        e.preventDefault();

        if ($(this).attr('disabled')) {
          return false;
        } // If a dropdown is open, remove it on pager click


        if (dropdownList) {
          var triggerCell = dropdown.parentNode.parentNode;
          dropdownList.remove();
          triggerCell.classList.remove('is-editing');
        } // If this is a filtered dataset, use the `filteredTotal` instead


        var state = self.state;
        var currentPage = state.activePage;

        if (state.filteredTotal) {
          currentPage = state.filteredActivePage;
        }

        if (DOM.hasClass(li, 'pager-prev')) {
          self.setActivePage(currentPage - 1, false, 'prev');
          self.triggerPagingEvents(currentPage);
          return false;
        }

        if (DOM.hasClass(li, 'pager-next')) {
          self.setActivePage((currentPage === -1 ? 1 : currentPage) + 1, false, 'next');
          self.triggerPagingEvents(currentPage);
          return false;
        }

        if (DOM.hasClass(li, 'pager-first')) {
          self.setActivePage(1, false, 'first');
          self.triggerPagingEvents(currentPage);
          return false;
        }

        if (DOM.hasClass(li, 'pager-last')) {
          self.setActivePage(self.pageCount(), false, 'last'); // TODO Calculate Last Page?

          self.triggerPagingEvents(currentPage);
          return false;
        } // Go to the page via the applied `data-page` attribute of the button


        var activePageIdx = Number(btn.getAttribute('data-page'));

        if (isNaN(activePageIdx) || activePageIdx < 1) {
          activePageIdx = 1;
        }

        self.setActivePage(activePageIdx, false, 'page');
        self.triggerPagingEvents(currentPage);
        return false;
      });
      self.pagerBar.on('keydown.pager', $(self.focusableElements), function (event) {
        if ($('.popupmenu.is-open').length > 0) {
          return true;
        }

        event = event || window.event;
        var key = event.which || event.keyCode || event.charCode || false;
        var isLeft = key === 37 || key === 40;
        var isRight = key === 39 || key === 38;
        var elem = event.target;

        if (elem.nodeName === 'INPUT') {
          // work on up down key
          isLeft = key === 40;
          isRight = key === 38;
        }

        if (!isLeft && !isRight) {
          return true;
        }

        var parent = elem.nodeName === 'INPUT' ? elem.parentNode.parentNode : elem.parentNode;
        var next = parent.nextSibling;
        var prev = parent.previousSibling;
        var isFirst = prev === null;
        var isLast = next === null;
        event.preventDefault();

        if (isLeft && !isFirst) {
          var link = prev.querySelector('button, input');
          link.removeAttribute('tabindex');
          elem.setAttribute('tabindex', '-1');
          link.focus();
          return false;
        }

        if (isLeft && isFirst) {
          var _link = parent.parentNode.lastChild.querySelector('button, input');

          _link.removeAttribute('tabindex');

          elem.setAttribute('tabindex', '-1');

          _link.focus();

          return false;
        }

        if (isRight && !isLast) {
          var _link2 = next.querySelector('button, input');

          _link2.removeAttribute('tabindex');

          elem.setAttribute('tabindex', '-1');

          _link2.focus();

          return false;
        }

        if (isRight && isLast) {
          var _link3 = parent.parentNode.firstChild.querySelector('button, input');

          _link3.removeAttribute('tabindex');

          elem.setAttribute('tabindex', '-1');

          _link3.focus();
        }

        return false;
      });
    },

    /**
     * Resets the pager to its original settings
     * @param {string} [operation=undefined] optional informational string that describes the purpose of a filtering operation
     * @param {string} [trigger=undefined] optional information string that describes the reason for the reset
     * @returns {void}
     */
    reset: function reset(operation, trigger) {
      this.activePage = this.settings.activePage;
      this.previousOperation = operation;
      this.previousTrigger = trigger;
      this.teardown();
      this.init();
    },

    /**
     * Show page size selector
     * @param  {boolean} toggleOption Toggle vs show
     */
    showPageSizeSelector: function showPageSizeSelector(toggleOption) {
      toggleOption = "".concat(toggleOption).toLowerCase() === 'true';
      this.settings.showPageSizeSelector = toggleOption;

      if (toggleOption) {
        this.isShowPageSizeSelectorCall = toggleOption;
      }
    },

    /**
     * Shows or hides a specified special control button on the Pager.
     * @param {string} [type] the type of button to target.
     * @param {boolean} toggleOption Show vs. Hide
     */
    showButton: function showButton(type, toggleOption) {
      // Determine the correct button
      var types = ['first', 'last', 'next', 'previous'];

      if (types.indexOf(type) === -1) {
        return;
      }

      var selector = ".pager-".concat(type, " .btn-icon");

      if (type === 'previous') {
        selector = '.pager-prev .btn-icon';
      } // Get anchor/option


      var btn = this.pagerBar[0].querySelector(selector);
      toggleOption = "".concat(toggleOption).toLowerCase() === 'true'; // Set the value in the settings

      this.settings["show".concat(stringUtils.capitalize(type), "Button")] = toggleOption; // If the button hasn't been rendered, don't alter the DOM.

      if (!btn) {
        return;
      } // Change the DOM


      if (toggleOption) {
        btn.parentNode.classList.remove('hidden');
      } else {
        btn.parentNode.classList.add('hidden');
      }
    },

    /**
     * Enables or disables a specified special control button on the Pager.
     * @param {string} [type] the type of button to target.
     * @param {boolean} toggleOption Enable vs. Disable
     */
    enableButton: function enableButton(type, toggleOption) {
      // Determine the correct button
      var types = ['first', 'last', 'next', 'previous'];

      if (types.indexOf(type) === -1) {
        return;
      }

      var selector = ".pager-".concat(type, " .btn-icon");

      if (type === 'previous') {
        selector = '.pager-prev .btn-icon';
      } // Get anchor/option


      var btn = this.pagerBar[0].querySelector(selector);
      toggleOption = "".concat(toggleOption).toLowerCase() === 'true'; // Set the value in the settings

      this.settings["enable".concat(stringUtils.capitalize(type), "Button")] = toggleOption; // If the button hasn't been rendered, don't alter the DOM.

      if (!btn) {
        return;
      } // Change the DOM


      if (toggleOption) {
        btn.disabled = false;
        btn.parentNode.classList.remove('is-disabled');
        $(btn).removeAttr('disabled');
      } else {
        btn.disabled = true;
        btn.parentNode.classList.add('is-disabled');
        $(btn).attr('disabled', 'disabled');
      }
    },

    /**
     * Set or Get Current Page.
     * @param {number|object} pagingInfo a number representing a page, or a state object with an `activePage` property
     * @param {boolean} force Force the update
     * @param {string} op The paging operation type.
     * @returns {void}
     */
    setActivePage: function setActivePage(pagingInfo, force, op) {
      var useFiltering = typeof pagingInfo.searchActivePage === 'number' || typeof pagingInfo.filteredActivePage === 'number' || typeof this.filteredActivePage === 'number';
      var pageNum = this.filteredActivePage || this.activePage || this.settings.activePage;

      if (_typeof(pagingInfo) === 'object') {
        if (useFiltering) {
          pageNum = pagingInfo.filteredActivePage || pagingInfo.searchActivePage;
        } else if (pagingInfo.activePage) {
          pageNum = pagingInfo.activePage;
        } else {
          pageNum = 1;
        }
      } else if (!isNaN(pagingInfo)) {
        pageNum = pagingInfo;
      } // Set the active page interally and render the new state.
      // If working against a filtered dataset, use the filtered active page instead of
      // the standard one.


      if (useFiltering) {
        this.filteredActivePage = pageNum;
      } else {
        this.activePage = pageNum;
      }

      this.previousOperation = op;
      this.render(); // If any of the following conditions are met, don't rerender the pages.
      // Only rerender the pager bar.

      if (pageNum === undefined || pageNum === 0 || isNaN(pageNum) || pageNum === this.activePage && !force) {
        return this.activePage;
      } // TODO: This is datagrid specific, need to move this specifically back there


      if (this.settings.componentAPI && this.settings.componentAPI.saveUserSettings) {
        this.settings.componentAPI.saveUserSettings();
      }

      return pageNum;
    },

    /**
     * Adjust an integer representing a Page Number to fit within the boundaries of the page count limits
     * @param {number} [pageNum=1] the incoming number to be analyzed
     * @returns {number} the adjusted value
     */
    adjustPageCount: function adjustPageCount(pageNum) {
      var state = this.state;
      var useFiltering = typeof state.filteredActivePage === 'number' || typeof this.filteredActivePage === 'number'; // Never go above the total number of pages (determined internally by the state,
      // or externally by the incoming `pagingInfo` object)

      var totalPages = state.pages;

      if (useFiltering && state.filteredPages) {
        totalPages = state.filteredPages;
      } // If the page number provided is out of bounds, reset it to the one previously set.


      if (pageNum < 1 || pageNum > totalPages) {
        pageNum = this.filteredActivePage || this.activePage;
      }

      return pageNum;
    },

    /**
    * Fires when the page size changer is used.
    * @event pagesizechange
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */

    /**
     * Get the Total Number of pages
     * @private
     * @param  {object} pages The pages to set.
     * @returns {void}
     */
    pageCount: function pageCount(pages) {
      var isShowPageSizeSelectorCall = this.isShowPageSizeSelectorCall; // Remove call, after cached

      delete this.isShowPageSizeSelectorCall;

      if (pages === undefined && this.settings.indeterminate) {
        this._pageCount = this.settings.pagesize; //eslint-disable-line
      }

      if (pages === undefined && !this.settings.source && !isShowPageSizeSelectorCall) {
        return this._pageCount; //eslint-disable-line
      }

      if (pages !== undefined) {
        this._pageCount = pages; //eslint-disable-line
      }

      this._pageCount = this._pageCount || 1;

      if (this.settings.indeterminate) {
        return 999999999;
      }

      return this._pageCount;
    },

    /**
     * Renders a row of numbers that can be used to select pages (Blockgrid/Listview)
     * @returns {void}
     */
    renderButtons: function renderButtons() {
      // Only certain types of Pages get to have the `last` and `first` buttons
      // const types = ['table', 'pageof', 'firstlast', 'standalone'];
      // const canHaveFirstLastButtons = types.indexOf(this.settings.type) > -1 || !this.isListView;
      var activePage = this.activePage;
      var totalPages = this.state.pages;
      var buttonHTML = '';
      var doRenderFirstButton = false;
      var doRenderPreviousButton = false;
      var doRenderNextButton = false;
      var doRenderLastButton = false;
      var disableFirstButton = !this.settings.enableFirstButton;
      var disablePreviousButton = !this.settings.enablePreviousButton;
      var disableNextButton = !this.settings.enableNextButton;
      var disableLastButton = !this.settings.enableLastButton;
      var disableFirstIndeterminate = this.settings.indeterminate && this.firstPage === true;
      var disableLastIndeterminate = this.settings.indeterminate && this.lastPage === true;
      var hasDataset = this.settings.dataset && this.settings.dataset.length; // If this is a filtered dataset, use the `filteredTotal` instead

      if (this.state.filteredPages) {
        activePage = this.state.filteredActivePage;
        totalPages = this.state.filteredPages;
      }

      if (this.pagerBar) {
        var _this$pagerBar;

        (_this$pagerBar = this.pagerBar) === null || _this$pagerBar === void 0 ? void 0 : _this$pagerBar == null ? void 0 : _this$pagerBar.children('li').find('> .btn-icon, > .btn-icon[disabled] .disabled-tooltip').each(function (i, elem) {
          var el = $(elem);

          if (el.data('tooltip')) {
            el.data('tooltip').destroy();
          }
        });
      } // Determine whether or not special navigation buttons should eventually be rendered
      // First Button


      if (this.settings.showFirstButton) {
        if (disableFirstIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === 1) {
          disableFirstButton = true;
        }

        doRenderFirstButton = true;
      } // Previous Button


      if (this.settings.showPreviousButton) {
        if (disableFirstIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === 1) {
          disablePreviousButton = true;
        }

        doRenderPreviousButton = true;
      } // Next Button


      if (this.settings.showNextButton) {
        if (disableLastIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === totalPages) {
          disableNextButton = true;
        }

        doRenderNextButton = true;
      } // Last Button


      if (this.settings.showLastButton) {
        if (disableLastIndeterminate || !this.settings.indeterminate && this.settings.type !== 'standalone' && activePage === totalPages) {
          disableLastButton = true;
        }

        doRenderLastButton = true;
      }

      var AVG_BUTTON_WIDTH = 40;
      var AVG_PAGESIZESELECTOR_WIDTH = 190;
      var buttonsToRender = [];
      var pageSizeButtonSize = this.settings.showPageSizeSelector ? AVG_PAGESIZESELECTOR_WIDTH : 0;
      var availableButtonWidth = (this.pagerBar.width() - pageSizeButtonSize) / AVG_BUTTON_WIDTH; // `maxAllowedButtons` does not include the Page Size Selector.
      // Subtract an allowed number button for each set of special controls.

      var maxAllowedButtons = Math.floor(availableButtonWidth);
      var maxNumberButtons = maxAllowedButtons;

      if (doRenderPreviousButton || doRenderNextButton) {
        maxNumberButtons -= 1;
      }

      if (doRenderLastButton || doRenderFirstButton) {
        maxNumberButtons -= 1;
      } // Disable first/last if we can display all available page numbers


      if (!this.isTable && this.settings.type !== 'standalone' && hasDataset && maxNumberButtons >= totalPages) {
        disableFirstButton = true;
        disableLastButton = true;
      } // Figure out the distance on either side of the median value of the number button array.
      // If either index goes out of page boundaries, shift the array to fit the same
      // number of pages by adding to the opposite side.


      if (!this.settings.indeterminate) {
        var maxDistanceFromCenter = Math.floor(maxNumberButtons / 2);
        var startIndex = activePage - maxDistanceFromCenter;
        var endIndex = activePage + maxDistanceFromCenter;

        while (startIndex < 1) {
          ++startIndex;

          if (endIndex < totalPages) {
            ++endIndex;
          }
        }

        while (endIndex > totalPages) {
          if (startIndex > 1) {
            --startIndex;
          }

          --endIndex;
        }

        for (var i = startIndex; i < endIndex + 1; i++) {
          buttonsToRender.push(i);
        }
      }

      function renderButton() {
        var visibleContent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var audibleContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var tooltipContent = arguments.length > 2 ? arguments[2] : undefined;
        var targetPageNum = arguments.length > 3 ? arguments[3] : undefined;
        var classAttr = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
        var selected = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
        var disabled = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
        var hidden = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
        var isAriaDisabled = '';
        var isControlDisabled = '';
        var isDisabledTooltip = '';
        var titleAttr = '';
        var pageAttr = '';

        if (targetPageNum) {
          pageAttr = " data-page=\"".concat(targetPageNum, "\"");
        }

        if (tooltipContent) {
          titleAttr = " title=\"".concat(tooltipContent, "\"");
        }

        if (hidden) {
          classAttr += ' hidden';
        }

        if (selected) {
          classAttr += ' selected';
          isAriaDisabled = ' aria-disabled="true"';
        }

        if (disabled) {
          isControlDisabled = ' disabled';
          isAriaDisabled = ' aria-disabled="true"';
          isDisabledTooltip = "<div class=\"disabled-tooltip\"".concat(titleAttr, "></div>");

          if (!targetPageNum) {
            titleAttr = '';
          }
        }

        var html = "<li class=\"".concat(classAttr, "\">\n        <button type=\"button\" class=\"btn-icon\"").concat(titleAttr).concat(pageAttr).concat(isAriaDisabled).concat(isControlDisabled, ">\n          ").concat(isDisabledTooltip, "<span>").concat(audibleContent, "</span>\n          ").concat(visibleContent, "\n        </button>\n      </li>");
        return html;
      } // Remove all existing buttons


      $(this.numberButtons).remove(); // First Button

      if (doRenderFirstButton) {
        buttonHTML += renderButton($.createIcon({
          icon: 'first-page'
        }), Locale.translate('FirstPage'), this.settings.firstPageTooltip, null, 'pager-first', false, disableFirstButton, false);
      } // Previous Button


      if (doRenderPreviousButton) {
        buttonHTML += renderButton($.createIcon({
          icon: 'previous-page'
        }), Locale.translate('PreviousPage'), this.settings.previousPageTooltip, null, 'pager-prev', false, disablePreviousButton, false);
      } // Draw all relevant page numbers, if applicable
      // Page Number Buttons are only rendered if there is visible space available to fit them.


      if (!this.isTable && hasDataset) {
        var numberButtonHTML = '';
        buttonsToRender.forEach(function (i) {
          if (i === (activePage || 1)) {
            numberButtonHTML += renderButton(i, Locale.translate('PageOn'), null, i, 'pager-no', true, false, false);
          } else {
            numberButtonHTML += renderButton(i, Locale.translate('Page'), null, i, 'pager-no', false, false, false);
          }
        });
        buttonHTML += numberButtonHTML;
      } // Next Button


      if (doRenderNextButton) {
        buttonHTML += renderButton($.createIcon({
          icon: 'next-page'
        }), Locale.translate('NextPage'), this.settings.nextPageTooltip, null, 'pager-next', false, disableNextButton, false);
      } // Last Button


      if (doRenderLastButton) {
        buttonHTML += renderButton($.createIcon({
          icon: 'last-page'
        }), Locale.translate('LastPage'), this.settings.lastPageTooltip, null, 'pager-last', false, disableLastButton, false);
      } // Render all elements into the pager container element


      this.pagerBar[0].innerHTML = buttonHTML;

      if (!doRenderLastButton && !doRenderFirstButton && !this.settings.showPageSizeSelector) {
        this.pagerBar[0].classList.add('two-button');
      } else {
        this.pagerBar[0].classList.remove('two-button');
      } // Invoke all sub-components


      this.pagerBar.children('li').find('> .btn-icon').button().tooltip();
      this.pagerBar.children('li').find('> .btn-icon[disabled] .disabled-tooltip').tooltip();
    },

    /**
     * Renders an input-field based page selector (Datagrid only)
     * @returns {void}
     */
    renderPageSelectorInput: function renderPageSelectorInput() {
      if (!this.isTable || this.settings.indeterminate) {
        return;
      }

      var activePage = this.activePage;
      var totalPages = this.state.pages || 1; // If this is a filtered dataset, use the `filteredTotal` instead

      if (this.state.filteredPages) {
        activePage = this.state.filteredActivePage;
        totalPages = this.state.filteredPages;
      }

      if (!this.pageSelectorInput) {
        var text = Locale.translate('PageOf');
        text = text.replace('{0}', "<input class=\"new-mask\" name=\"pager-pageno\" value=\"".concat(activePage, "\" autocomplete=\"off\">"));
        text = text.replace('{1}', "<span class=\"pager-total-pages\">".concat(totalPages, "</span>"));
        $("<li class=\"pager-count\"><label>".concat(text, " </label>")).insertAfter(this.pagerBar.find('.pager-prev'));
      } else {
        // Update the total number of pages
        if (totalPages > 1) {
          this.pagerBar.find('.pager-total-pages').text(totalPages);
        } // Update the input field's number


        this.pagerBar.find('.pager-count input').val(activePage);
      }

      var lastValue = null;
      var pattern = "".concat(totalPages).replace(/\d/g, '#');
      var self = this;
      var maskSettings = {
        pattern: pattern,
        mode: 'number',
        processOnInitialize: false
      };

      function update(elem) {
        var newValue = self.adjustPageCount(parseInt(elem.val(), 10));

        if (lastValue === newValue) {
          elem.val(lastValue);
          return;
        }

        var currentPage = self.activePage;

        if (self.state.filteredPages) {
          currentPage = self.state.filteredActivePage;
        }

        elem.val(self.setActivePage(newValue, false, 'page'));
        self.triggerPagingEvents(currentPage);
      }

      $(this.pageSelectorInput).mask(maskSettings).on('focus', function () {
        lastValue = parseInt($(this).val(), 10);
      }).on('blur', function () {
        update($(this));
        lastValue = null;
      }).on('keydown', function (e) {
        if (e.which === 13) {
          update($(this));
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        return true;
      });
    },

    /**
     * Displays a Page Size Selector button as part of the pager bar
     * @returns {void}
     */
    renderPageSizeSelectorButton: function renderPageSizeSelectorButton() {
      var _this = this;

      if (!this.settings.showPageSizeSelector || this.settings.pagesizes.length < 2) {
        return;
      }

      if (!this.pageSizeSelectorButton) {
        var pageSizeLi = $('<li class="pager-pagesize"></li>');
        var dropdownIcon = $.createIcon({
          icon: 'dropdown'
        });
        var translatedText = Locale.translate(this.settings.pageSizeSelectorText).replace('{0}', this.settings.pagesize);
        var isAudible = '';
        var recordHtml = "<span>".concat(translatedText, "</span>"); // Change to the condensed layout, if applicable

        if (this.showSmallPageSizeSelector) {
          isAudible = ' class="audible"';
          translatedText = Locale.translate(this.settings.pageSizeSelectorTextNoToken);
          recordHtml = "<span class=\"record-count\">".concat(this.settings.pagesize, "</span>\n        <span").concat(isAudible, ">").concat(translatedText, "</span>");
        } // Render the button


        var pageSizeButton = $("<button type=\"button\" class=\"btn-menu\">\n        ".concat(recordHtml, "\n        ").concat(dropdownIcon, "\n      </button>")).appendTo(pageSizeLi);
        pageSizeLi.appendTo(this.pagerBar); // Render menu items that render available records per page

        var menuItems = '';

        if (this.showSmallPageSizeSelector) {
          menuItems = "<li class=\"heading\">".concat(translatedText, "</li>");
        }

        for (var k = 0; k < this.settings.pagesizes.length; k++) {
          var size = this.settings.pagesizes[k];
          menuItems += "<li class=\"".concat(size === this.settings.pagesize ? ' is-checked' : '', "\"><a href=\"#\">").concat(size, "</a></li>");
        }

        var menu = $("<ul class=\"popupmenu is-selectable\">".concat(menuItems, "</ul>"));
        pageSizeButton.after(menu);
      }

      var $pageSizeSelectorButton = $(this.pageSizeSelectorButton); // Invoke/Update the popupmenu instance with new settings

      var popupOpts = utils.extend({}, {
        placementOpts: {
          parent: $pageSizeSelectorButton,
          parentXAlignment: Locale.isRTL() ? 'left' : 'right',
          strategies: ['flip']
        }
      }, this.settings.pageSizeMenuSettings);
      $pageSizeSelectorButton.popupmenu(popupOpts);
      $pageSizeSelectorButton.on('selected.pager', function (e, args) {
        _this.changePageSize(args);
      });
    },

    /**
     * Renders the contents of the pager bar
     * @returns {void}
     */
    render: function render() {
      // Adjust Page count numbers
      var state = this.state;
      var totalPages = state.pages;

      if (state.filteredPages) {
        totalPages = state.filteredPages;
      }

      this.pageCount(totalPages);

      if (this.pageSizeSelectorButton) {
        this.teardownPageSizeSelector();
      }

      this.renderButtons();
      this.renderPageSelectorInput();
      this.renderPageSizeSelectorButton();
      this.renderBar();
    },

    /**
     * Renders the pager bar based on derived or forced settings.
     * @private
     * @param {SohoPagingInfo} pagingInfo - an object containing information on how to render the pager.
     * @returns {undefined}
     */
    renderBar: function renderBar(pagingInfo) {
      var _this$pagerBar$find, _this$pagerBar$find$d;

      var self = this;

      if (!pagingInfo) {
        pagingInfo = this.state;
      } else {
        pagingInfo = utils.extend({}, this.state, pagingInfo);
      }

      var activePage = pagingInfo.activePage;

      if (pagingInfo.filteredActivePage) {
        activePage = pagingInfo.filteredActivePage;
      } // hide buttons feature


      if (!this.settings.showFirstButton) {
        this.showButton('first', false);
      }

      if (!this.settings.enableFirstButton) {
        this.enableButton('first', false);
      }

      if (!this.settings.showPreviousButton) {
        this.showButton('previous', false);
      }

      if (!this.settings.enablePreviousButton) {
        this.enableButton('previous', false);
      }

      if (!this.settings.showNextButton) {
        this.showButton('next', false);
      }

      if (!this.settings.enableNextButton) {
        this.enableButton('next', false);
      }

      if (!this.settings.showLastButton) {
        this.showButton('last', false);
      }

      if (!this.settings.enableLastButton) {
        this.enableButton('last', false);
      }

      if (this.settings.showPageSizeSelector) {
        this.showPageSizeSelector(true);
      } // Explicit true/false when using `firstPage` or `lastPage` will force the state
      // on the specified set of buttons to change.


      if (pagingInfo.firstPage !== undefined) {
        // First/Prev page
        if (pagingInfo.firstPage === false) {
          this.enableButton('first', true);
          this.enableButton('previous', true);
        }

        if (pagingInfo.firstPage === true || activePage === 1) {
          this.enableButton('first', false);
          this.enableButton('previous', false);
        }
      }

      if (pagingInfo.lastPage !== undefined) {
        // Next/Last Page
        if (pagingInfo.lastPage === false) {
          this.enableButton('next', true);
          this.enableButton('last', true);
        }

        if (pagingInfo.lastPage === true || activePage === this.pageCount()) {
          this.enableButton('next', false);
          this.enableButton('last', false);
        }
      }

      var classList = this.pagerBar[0] ? this.pagerBar[0].classList : null;

      if (this.hidePagerBar(pagingInfo) && classList) {
        classList.add('hidden');
      } else if (this.settings.hideOnOnePage && classList && classList.contains('hidden')) {
        classList.remove('hidden');
      }

      this.initTabIndexes(); // Add id's to everything

      utils.addAttributes(this.pagerBar, this, this.settings.attributes);
      utils.addAttributes(this.pagerBar.find('.pager-first button'), this, this.settings.attributes, 'btn-first');
      utils.addAttributes(this.pagerBar.find('.pager-prev button'), this, this.settings.attributes, 'btn-prev');
      utils.addAttributes(this.pagerBar.find('.pager-next button'), this, this.settings.attributes, 'btn-next');
      utils.addAttributes(this.pagerBar.find('.pager-last button'), this, this.settings.attributes, 'btn-last');
      utils.addAttributes(this.pagerBar.find('.pager-pagesize button'), this, this.settings.attributes, 'btn-pagesize');
      utils.addAttributes(this.pagerBar.find('input'), this, this.settings.attributes, 'pagesize-input');
      this.pagerBar.find('.pager-pagesize .popupmenu li').each(function () {
        var link = $(this).find('a');
        var value = link.text();
        utils.addAttributes(link, self, self.settings.attributes, "pagesize-opt-".concat(value));
      }); // Append if using attach to body

      var menu = (_this$pagerBar$find = this.pagerBar.find('.btn-menu')) === null || _this$pagerBar$find === void 0 ? void 0 : (_this$pagerBar$find$d = _this$pagerBar$find == null ? void 0 : _this$pagerBar$find.data('popupmenu')) === null || _this$pagerBar$find$d === void 0 ? void 0 : _this$pagerBar$find$d == null ? void 0 : _this$pagerBar$find$d.menu;

      if (menu) {
        menu.find('li').each(function () {
          var link = $(this).find('a');
          var value = link.text();
          utils.addAttributes(link, self, self.settings.attributes, "pagesize-opt-".concat(value));
        });
      }
    },

    /**
     * Sync the tabindexes
     * @private
     */
    initTabIndexes: function initTabIndexes() {
      var tabbables = $(this.focusableElements);
      tabbables.attr('tabindex', '-1');
      tabbables.filter(':not([disabled])').first().removeAttr('tabindex');
    },

    /**
    * Fires when the first page button is clicked.
    * @event firstpage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */

    /**
    * Fires when the previous page button is clicked.
    * @event previouspage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */

    /**
    * Fires when the next page button is clicked.
    * @event nextpage
    * @memberof Pager
    * @property {object} event - The jquery event object
    * @property {function} request - Various paging info
    */

    /**
     *Fires when the last page button is clicked.
     * @event lastpage
     * @memberof Pager
     * @property {object} event - The jquery event object
     * @property {function} request - Various paging info
     */

    /**
     * @private
     * Triggers the `page` event, along with other special events.  Also runs associated callbacks.
     * @param {number} [previousActivePage=undefined] if defined, sets a previous page value for determining some event triggers
     * @returns {void}
     */
    triggerPagingEvents: function triggerPagingEvents(previousActivePage) {
      var state = this.state;

      if (!previousActivePage) {
        previousActivePage = this.state.activePage;
      } // Trigger events for specific special pages, and always trigger the `page` event
      // containing the new pager state.


      if (state.type === 'first') {
        // First Page
        if (this.settings.onFirstPage) {
          this.settings.onFirstPage(this, state);
        }

        this.element.trigger('firstpage', state);
      }

      if (state.type === 'prev') {
        // Previous Page
        if (this.settings.onPreviousPage) {
          this.settings.onPreviousPage(this, state);
        }

        this.element.trigger('previouspage', state);
      }

      if (state.type === 'next') {
        // Next Page
        if (this.settings.onNextPage) {
          this.settings.onNextPage(this, state);
        }

        this.element.trigger('nextpage', state);
      }

      if (state.type === 'last') {
        // Last Page
        if (this.settings.onLastPage) {
          this.settings.onLastPage(this, state);
        }

        this.element.trigger('lastpage', state);
      }

      if (state.type === 'pageinfo') {
        return;
      }

      this.element.trigger('page', state);
    },

    /**
     * Update the component and optionally apply new settings.
     * @param  {object} settings the settings to update to.
     * @returns {object} The plugin api for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      if (Array.isArray(settings.pagesizes) && settings.pagesizes.length) {
        this.settings.pagesizes = settings.pagesizes;
      } // Limit updated paging info to a specific subset


      var pagingInfo = {
        activePage: this.settings.activePage,
        indeterminate: this.settings.indeterminate,
        pagesize: this.settings.pagesize
      };
      this.handleDeprecatedSettings();
      this.updatePagingInfo(pagingInfo);
      return this;
    },

    /**
     * Changes the size of the visible page
     * @param {jQuery} anchor containing a reference to the jQuery-wrapped popupmenu menu item element that was chosen.
     * @returns {void}
     */
    changePageSize: function changePageSize(anchor) {
      var tag = anchor;
      tag.closest('.popupmenu').find('.is-checked').removeClass('is-checked');
      tag.parent('li').addClass('is-checked');
      this.settings.pagesize = parseInt(tag.text(), 10);

      if (this.settings.componentAPI) {
        this.settings.componentAPI.settings.pagesize = this.settings.pagesize;
      }

      this.setActivePage(1, true, 'first');

      if (this.settings.onPageSizeChange) {
        this.settings.onPageSizeChange(this, {
          tag: anchor,
          pagesize: this.settings.pagesize,
          settings: this.settings
        });
      }

      this.element.trigger('pagesizechange', {
        tag: anchor,
        pagesize: this.settings.pagesize,
        settings: this.settings
      });
    },

    /**
     * Updates this instance of pager with externally-provided settings.
     * @param {object} pagingInfo - contains settings that will change buttons on the pager.
     * @param {number} pagingInfo.pagesize - the number of items visible per page
     * @param {number} pagingInfo.total - the total number of pages
     * @param {number} pagingInfo.activePage - the currently visible page
     * @param {boolean} [pagingInfo.firstPage=false] - passed if the currently visible page is the
     * first one
     * @param {boolean} [pagingInfo.lastPage=false] - passed if the currently visible page is the
     * last one
     * @param {boolean} [pagingInfo.hideDisabledPagers=false] - causes the pager to become completely
     * hidden if all buttons are disabled
     * @param {boolean} [isResponse=false] if true, causes events not to be triggered (avoids infinite loops)
     * @returns {void}
     */
    updatePagingInfo: function updatePagingInfo(pagingInfo, isResponse) {
      if (!pagingInfo) {
        return;
      } // Grab and retain the pagesize


      if (pagingInfo.pagesize) {
        this.settings.pagesize = pagingInfo.pagesize;

        if (this.isTable && this.settings.componentAPI) {
          this.settings.componentAPI.settings.pagesize = pagingInfo.pagesize;
        }
      } // Detect client-side filtering in the other component's API


      if (pagingInfo.isFilteredClientside) {
        this.isFilteredClientside = true;
        delete this.serverDatasetTotal;
      } else if (this.isFilteredClientside) {
        delete this.isFilteredClientside;
      } // Explicitly setting `firstPage` or `lastPage` to true/false will cause pager buttons
      // to be forced enabled/disabled


      delete this.firstPage;
      delete this.lastPage;

      if (pagingInfo.firstPage !== undefined) {
        this.firstPage = pagingInfo.firstPage;
        this.settings.enableFirstButton = !pagingInfo.firstPage;
        this.settings.enablePreviousButton = !pagingInfo.firstPage;
      }

      if (pagingInfo.lastPage !== undefined) {
        this.lastPage = pagingInfo.lastPage;
        this.settings.enableNextButton = !pagingInfo.lastPage;
        this.settings.enableLastButton = !pagingInfo.lastPage;
      } // Track "grandTotal" for all records, including filtered-out, if applicable


      if (!isNaN(pagingInfo.grandTotal)) {
        this.grandTotal = pagingInfo.grandTotal;
      } // For server-side paging, retain a separate "total" for the server dataset.


      if (!this.isFilteredClientside) {
        this.serverDatasetTotal = pagingInfo.total;
      } // If the dataset is filtered, store some extra meta-data for the state.


      if (!isNaN(pagingInfo.filteredTotal)) {
        this.filteredTotal = pagingInfo.filteredTotal;
        this.filteredActivePage = pagingInfo.searchActivePage || pagingInfo.filteredActivePage || 1;
      } else if (this.filteredTotal || this.filteredActivePage) {
        delete this.filteredTotal;
        delete this.filteredActivePage;
      }

      if (!pagingInfo.type) {
        pagingInfo.type = 'pageinfo';
      }

      if (this.settings.source || this.settings.dataset) {
        // Set first and last page if passed
        // If we get a page number as a result, rendering has already happened and
        // we should not attempt to re-render.
        this.setActivePage(pagingInfo, false, pagingInfo.type);

        if (pagingInfo.type !== 'initial' && !isResponse) {
          this.triggerPagingEvents();
        }

        return;
      }

      this.teardown();
      this.render();
      this.handleEvents();
    },

    /**
     * Reclaim the pager height so that datagrid can use it's full container, if only one page.
     * @private
     * @param  {object} pagingInfo The pager states.
     * @returns {void}
     */
    hidePagerBar: function hidePagerBar(pagingInfo) {
      if (this.settings.hideOnOnePage && pagingInfo.total <= pagingInfo.pagesize) {
        return true;
      }

      if (pagingInfo && pagingInfo.firstPage === true && pagingInfo.lastPage === true && pagingInfo.hideDisabledPagers) {
        return true;
      }

      return false;
    },

    /**
     * Removes all event listeners and generated HTML markup from the pager instance
     * @returns {void}
     */
    teardown: function teardown() {
      if (this.numberButtons) {
        this.numberButtons.forEach(function (li) {
          var btn = li.querySelector('.btn-icon');
          var buttonAPI = $(btn).data('button');
          var tooltipAPI = $(btn).data('tooltip');

          if (buttonAPI) {
            buttonAPI.destroy();
          }

          if (tooltipAPI) {
            tooltipAPI.destroy();
          }
        });
      }

      this.pagerBar.off(["click.".concat(COMPONENT_NAME$T), "keydown.".concat(COMPONENT_NAME$T)].join(' '));

      if (this.pageSelectorInput) {
        $(this.pageSelectorInput).off(["focus.".concat(COMPONENT_NAME$T), "blur.".concat(COMPONENT_NAME$T), "keydown.".concat(COMPONENT_NAME$T)].join(' '));
        $(this.pageSelectorInput).data('mask').destroy();
      }

      if (this.pageSizeSelectorButton) {
        $(this.pageSizeSelectorButton).off("selected.".concat(COMPONENT_NAME$T));
        this.teardownPageSizeSelector();
      }

      this.pagerBar[0].innerHTML = '';
      delete this.firstPage;
      delete this.lastPage;
    },

    /**
     * Tears down the Popupmenu associated with the page size selector.
     * This happens here because the Popupmenu component does not remove its own
     * menu markup when being destroyed.
     * @private
     * @returns {void}
     */
    teardownPageSizeSelector: function teardownPageSizeSelector() {
      var $pageSizeSelectorButton = $(this.pageSizeSelectorButton);
      var api = $pageSizeSelectorButton.data('popupmenu');

      if (!api || !api.menu) {
        return;
      }

      var pageSizeSelectorMenu = api.menu;
      api.destroy();
      pageSizeSelectorMenu.remove();
    },

    /**
     * Tear down and detatch all events
     */
    destroy: function destroy() {
      this.teardown();

      if (this.pagerBar) {
        this.pagerBar.remove();
      }

      $.removeData(this.element[0], COMPONENT_NAME$T);
    }
  };

  /**
   * jQuery Component Wrapper for pager
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.pager = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$T);

      if (!instance) {
        instance = $.data(this, COMPONENT_NAME$T, new Pager(this, settings));
      } else {
        instance.updated(settings);
      }
    });
  };

  var COMPONENT_NAME$U = 'listview';
  /**
   * Creates lists of small pieces of relevant, actionable information.
   * @class ListView
   * @constructor
   *
   * @param {jquery[]|htmlelement} element the base element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.dataset] Array of data to feed the template
   * @param {string} [settings.template] Html Template String
   * @param {string} [settings.description] Audible Label (or use parent title)
   * @param {boolean} [settings.paging=false] If true, activates paging
   * @param {number} [settings.pagesize=10] If paging is activated, sets the number of listview items available per page
   * @param {boolean} [settings.searchable=false] If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
   * @param {boolean} [settings.highlight=true] If false the highlighting of text when using searchable is disabled. You may want to disable this on larger lists.
   * @param {string|boolean} [settings.selectable='single'] selection mode, can be false, 'single', 'multiple' or 'mixed'
   * @param {boolean} [settings.allowDeselect=true] If using single select you can set this if you want the rows to not be deSelected.
   * @param {boolean} [settings.selectOnFocus=true] If true the first item in the list will be selected as it is focused.
   * @param {boolean} [settings.showCheckboxes=true] If false will not show checkboxes used with multiple selection mode only
   * @param {boolean} [settings.hoverable=true] If true the list element will show a hover action to indicate its actionable.
   * @param {string} [settings.emptyMessage] Text to go in emptyMessage.
   * @param {function|string} [settings.source] If source is a string then it serves as
    the url for an ajax call that returns the dataset. If its a function it is a call back for getting the data asyncronously.
   * @param {boolean} [settings.forceToRenderOnEmptyDs=false] If true list will render as an empty list with ul tag, but not any li tags in it.
   * @param {boolean} [settings.disableItemDeactivation=false] If true when an item is
    activated the user should not be able to deactivate it by clicking on the activated item. They can only select another row.
   * @param {boolean} [settings.showPageSizeSelector=false] If true the page size select will be shown when paging.
   * @param {object} [settings.listFilterSettings=null] If defined as an object, passes settings into the internal ListFilter component
   * @param {object} [settings.pagerSettings=null] If defined as an object, passes settings into the internal Pager component
   * @param {object} [settings.searchTermMinSize=1] The search term will trigger filtering only when its length is greater than or equals to the value.
   * @param {object} [settings.initializeContents=false] If true the initializer will be run on all internal contents.
   * @param {string} [settings.attributes] Add extra attributes like id's to the listview. For example `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  var LISTVIEW_DEFAULTS = {
    dataset: [],
    template: null,
    description: null,
    paging: false,
    pagesize: 10,
    searchable: false,
    highlight: true,
    selectable: 'single',
    selectOnFocus: true,
    showCheckboxes: true,
    hoverable: true,
    emptyMessage: null,
    source: null,
    forceToRenderOnEmptyDs: false,
    disableItemDeactivation: false,
    allowDeselect: true,
    showPageSizeSelector: false,
    listFilterSettings: null,
    pagerSettings: {
      showFirstButton: false,
      showLastButton: false
    },
    searchTermMinSize: 1,
    initializeContents: false,
    attributes: null
  };

  function ListView(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LISTVIEW_DEFAULTS);
    this.init();
    return this;
  }

  ListView.prototype = {
    /**
     * @returns {Pager|undefined} Pager component instance, if one exists
     */
    get pagerAPI() {
      return this.element.data('pager');
    },

    /**
     * @returns {object} containing valid Pager Component settings
     */
    get pagerSettings() {
      var pagerSettings = {};

      if (this.settings.pagerSettings) {
        pagerSettings = this.settings.pagerSettings;
      }

      pagerSettings.dataset = this.settings.dataset;
      pagerSettings.source = this.settings.source;
      pagerSettings.type = 'list'; // Backwards compatibility for direct pager settings

      var oldSettingTypes = ['pagesize', 'showPageSizeSelector'];

      for (var i = 0; i < oldSettingTypes.length; i++) {
        if (this.settings[oldSettingTypes[i]] !== undefined && !pagerSettings[oldSettingTypes[i]]) {
          pagerSettings[oldSettingTypes[i]] = this.settings[oldSettingTypes[i]];
        }
      }

      return pagerSettings;
    },

    /**
     * Initialize this component.
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup();
      this.handleEvents();
      this.refresh();
      this.selectedItems = [];
      this.lastSelectedItem = 0; // Rember index to use shift key

      this.isSelectedAll = false; // Rember if all selected or not

      this.sortInit('listview', 'click.listview', 'data-sortlist');
      this.handleResize();
    },

    /**
     * Do initial dom and settings setup.
     * @private
     * @returns {void}
     */
    setup: function setup() {
      var _this = this;

      var self = this;
      var card = this.element.closest('.card, .widget');
      var selectable = this.element.attr('data-selectable');
      var selectOnFocus = this.element.attr('data-select-onfocus'); // Check for legacy data attributes

      if (this.element.attr('data-pagesize')) {
        var pagesize = Number(this.element.attr('data-pagesize'));

        if (!isNaN(pagesize)) {
          this.settings.pagesize = pagesize;
        }

        this.element.removeAttr('data-pagesize');
      } // Convert a DOM-based list into a stored dataset (legacy)


      if (!this.settings.dataset.length) {
        if (this.element.is('ul') && this.element.children('li').length) {
          var items = this.element.children('li');

          if (!this.settings.template) {
            this.settings.template = '{{#dataset}}<li>{{text}}</li>{{/dataset}}';
          }

          items.each(function (i, item) {
            _this.settings.dataset.push({
              text: $(item).text()
            });
          });
          items.remove();
        }
      } // Search the global variable space for a dataset variable name, if provided.


      if (this.settings.dataset && typeof this.settings.dataset === 'string') {
        var globalDataset = window[this.settings.dataset];

        if (globalDataset && globalDataset.length) {
          this.settings.dataset = globalDataset;
        }
      }

      if (selectable && selectable.length) {
        this.settings.selectable = selectable;
      }

      if (selectOnFocus && selectOnFocus.length) {
        this.settings.selectOnFocus = JSON.parse(selectOnFocus);
      }

      self.actionButton = card.find('.btn-actions');

      if (self.actionButton.length > 0) {
        // Action Buttons may already be invoked via initialize.js.
        if (!self.actionButton.data('popupmenu')) {
          self.actionButton.popupmenu();
        }
      }

      this.element.attr({
        tabindex: '-1',
        'x-ms-format-detection': 'none'
      }); // Add user-defined attributes

      if (this.settings.attributes) {
        utils.addAttributes(this.element, this, this.settings.attributes, 'listview');
      } // Configure Paging


      if (this.element.is('.paginated') || this.settings.paging === true) {
        this.element.pager(this.pagerSettings);
      }

      var cardWidgetContent = this.element.parent('.card-content, .widget-content');

      if (cardWidgetContent[0]) {
        cardWidgetContent[0].style.overflow = 'hidden';
      } // Associate with an existing searchfield, if applicable


      if (this.settings.searchable) {
        this.searchfield = this.element.parent().find('.searchfield, .autocomplete');

        if (!this.searchfield.length) ; // Setup the ListFilter with externally-defined settings, if applicable


        var listFilterSettings = {
          filterMode: 'contains'
        };

        if (_typeof(this.settings.listFilterSettings) === 'object') {
          listFilterSettings = utils.extend({}, listFilterSettings, this.settings.listFilterSettings);
        }

        this.listfilter = new ListFilter(listFilterSettings);
      }

      if (this.settings.emptyMessage) {
        // Object { title: "No Data Available", info: "", icon: "icon-empty-no-data" }
        self.emptyMessageContainer = $('<div>').emptymessage(this.settings.emptyMessage);
      }
    },

    /**
     * Calculate the totals for totalling examples.
     * This is displayed in the template by referencing {{totals}}.
     * @private
     * @param {array} dataset the incoming dataset
     * @returns {number} the total number of listview items.
     */
    getTotals: function getTotals(dataset) {
      var totals = {
        count: dataset.length
      };
      var property;

      if (!dataset[0]) {
        return undefined;
      }

      for (property in dataset[0]) {
        //eslint-disable-line
        totals[property] = 0;
      }

      for (var i = 0; i < dataset.length; i++) {
        for (property in dataset[i]) {
          //eslint-disable-line
          totals[property] += parseFloat(dataset[i][property]);
        }
      }

      return totals;
    },

    /**
     * Render the template against the dataset.
     * @private
     * @param {array} dataset  The dataset to use
     * @param {object} pagerInfo  Pager instructions
     */
    render: function render(dataset, pagerInfo) {
      var self = this;
      var isServerSide = typeof this.settings.source === 'function';
      var totals = {};
      var displayedDataset = dataset;
      var firstRecordIdx = 0;
      var lastRecordIdx = displayedDataset ? displayedDataset.length : 0;
      var pagesize = this.settings.pagesize;
      var setSize = dataset.length;

      if (pagerInfo) {
        pagesize = pagerInfo.pagesize || pagesize;
        setSize = pagerInfo.filteredTotal || setSize;
      }

      if (!isServerSide && this.pagerAPI) {
        this.renderPager(pagerInfo, true);
        pagerInfo = this.pagerAPI.state;
      } // If the paging information sets limits on the dataset, customize the
      // displayed dataset to fit the conditions.


      if (setSize > pagesize) {
        var pages = this.filteredDataset ? pagerInfo.filteredPages : pagerInfo.pages;

        if (pages > 1) {
          var trueActivePage = pagerInfo.activePage > 0 ? pagerInfo.activePage - 1 : 0;

          if (this.filteredDataset) {
            trueActivePage = pagerInfo.filteredActivePage - 1;
          }

          firstRecordIdx = pagerInfo.pagesize * trueActivePage;
          lastRecordIdx = pagerInfo.pagesize * (trueActivePage + 1);
          displayedDataset = dataset.slice(firstRecordIdx, lastRecordIdx);
        }
      } // Render "mustache" Template


      if (_typeof(Tmpl) === 'object' && displayedDataset && this.settings.template) {
        // create a copy of an inlined template
        if (this.settings.template instanceof $) {
          this.settings.template = "".concat(this.settings.template.html());
        } else if (typeof this.settings.template === 'string') {
          // If a string doesn't contain HTML elments,
          // assume it's an element ID string and attempt to select with jQuery
          if (!stringUtils.containsHTML(this.settings.template)) {
            this.settings.template = $("#".concat(this.settings.template)).html();
          }
        }

        if (this.settings.template.indexOf('{{#totals}}') > -1) {
          totals = this.getTotals(dataset);
        }

        var renderedTmpl = Tmpl.compile(this.settings.template, {
          dataset: displayedDataset,
          totals: totals
        });

        if (this.element.parent().is('.scrollable-flex-content')) {
          this.element.parent().find('.empty-message').remove();
        }

        if (displayedDataset.length > 0 || this.settings.forceToRenderOnEmptyDs) {
          this.element.html(renderedTmpl);
        } else if (self.emptyMessageContainer && this.element.parent().is('.scrollable-flex-content')) {
          this.element.empty();
          DOM.append(this.element.parent(), this.emptyMessageContainer[0].outerHTML, '<div><svg><use><span><b>');
        } else if (self.emptyMessageContainer) {
          this.element.empty();
          DOM.append(this.element, this.emptyMessageContainer[0].outerHTML, '<div><svg><use><span><b>');
        } else if (displayedDataset.length === 0) {
          this.element.html(renderedTmpl || '<ul></ul>');
        }
      } // Add Aria


      var card = this.element.closest('.card, .widget');
      $('ul', this.element).attr({
        role: 'listbox',
        'aria-label': this.settings.description || card.find('.card-title, .widget-title').text() || 'List'
      }); // Add Checkboxes

      var first = this.element.find('li, tbody > tr').first();
      var items = this.element.find('li, tr');
      var isMultiselect = this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed'; // Set Initial Tab Index

      this.focusItem = first.attr('tabindex', 0); // Let the link be focus'd

      if (!this.settings.selectable && first.find('a').length === 1) {
        first.removeAttr('tabindex');
      } // When DOM items are not rendered with "mustache" template, filtered items
      // have to be hidden specifically.


      var hideFlag = items.length > displayedDataset.length;
      items.each(function (i) {
        var item = $(this);
        item.attr('role', 'option'); // Add css class `is-touch` for touch devices

        if (Environment.features.touch) {
          item.addClass('is-touch');
        } // Add user-defined attributes


        if (self.settings.attributes) {
          utils.addAttributes(item, self, self.settings.attributes, "listview-item-".concat(i));
        }

        if (isMultiselect) {
          // Add Selection Checkboxes
          self.element.addClass('is-multiselect'); // Create a Toolbar for the "Selected Items" area

          var selectedToolbar = self.element.prevAll('.toolbar');

          if (selectedToolbar.length && selectedToolbar.data('toolbar')) {
            selectedToolbar.data('toolbar').toggleMoreMenu();
          }

          if (self.settings.showCheckboxes) {
            // Only need one checkbox
            if (item.children('.listview-selection-checkbox').length === 0) {
              // For mixed selection mode primarily append a checkbox object
              item.prepend("<label class=\"listview-selection-checkbox l-vertical-center inline inline-checkbox\">\n              <input tabindex=\"-1\" type=\"checkbox\" class=\"checkbox\">\n              <span class=\"label-text\" role=\"presentation\">\n                <span class=\"audible\">".concat(Locale.translate('Checkbox'), " ").concat(Locale.translate('NotSelected'), ".</span>\n              </span>\n            </label>"));
            }
          }
        } // Hide filtered items


        if (hideFlag) {
          var n = firstRecordIdx + i;

          if (n < self.settings.dataset.length) {
            var data = self.settings.dataset[n];
            item.css('display', data._isFilteredOut === undefined || data._isFilteredOut ? '' : 'none');
          }
        } else {
          item.css('display', '');
        } // Add Aria


        item.attr({
          'aria-posinset': firstRecordIdx + i + 1,
          'aria-setsize': setSize
        }); // Add Aria disabled

        if (item.hasClass('is-disabled')) {
          item.attr('aria-disabled', 'true');
        } // If this dataset is filtered, hightlight the relevant search term inside the element.


        if (self.settings.highlight && self.searchTerm) {
          item.highlight(self.searchTerm);
        }
      }); // Invoke all elements within the list view

      if (self.settings.initializeContents) {
        this.element.find('ul').initialize();
      }
      /**
       * Fires after the listbox is fully rendered.
       *
       * @event rendered
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {array} dataset .
       */


      this.element.trigger('rendered', [displayedDataset]); // Handle refresh

      this.element.off('updated.listview').on('updated.listview', function (e, settings) {
        self.updated(settings);
      });
    },

    /**
     * Add and update the pager (if used)
     * @private
     * @param {object} updatedPagerInfo contains updated paging settings
     * @param {boolean} isResponse represents whether or not this render call was caused by an AJAX response
     * @returns {void}
     */
    renderPager: function renderPager(updatedPagerInfo, isResponse) {
      if (!this.pagerAPI) {
        return;
      }

      this.pagerAPI.updatePagingInfo(updatedPagerInfo, isResponse);
    },

    /**
     * Reliably gets all the pre-rendered elements in the container and returns them for use.
     * @private
     * @returns {array} TThe pagable items
     */
    getPageableElements: function getPageableElements() {
      var elements = this.element.children(); // Adjust for cases where the root is a <ul>

      if (elements.is('ul')) {
        elements = elements.children();
      }

      return elements;
    },

    /**
     * Get the Data Source. Can be an array, Object or Url and render the list.
     * @private
     * @param {array} dataset contains a potential new dataset to display inside the listview.
     * @param {object} [pagingInfo=undefined] information about desired pager state
     */
    refresh: function refresh(dataset, pagingInfo) {
      this.loadData(dataset, pagingInfo);

      if (this.list) {
        this.render(this.list.data);
      }
    },

    /**
     * Load Data from an external API
     * @param {object} ds  The dataset to use or will use settings.dataset.
     * @param {object} pagerInfo  The pager settings to use (see pager api)
     * @param {boolean} isResponse Flag used to avoid dup source calls.
     * @returns {void}
     */
    loadData: function loadData(ds, pagerInfo, isResponse) {
      var ajaxDs = false;
      var self = this;
      ds = ds || this.settings.dataset;

      if (this.filteredDataset) {
        ds = this.filteredDataset;
      }

      if (!pagerInfo) {
        if (this.pagerAPI) {
          if (ds.length !== this.pagerAPI.settings.dataset.length) {
            this.pagerAPI.updated({
              dataset: ds
            });
          }

          pagerInfo = this.pagerAPI.state;
        } else {
          pagerInfo = {
            activePage: 1
          };
        }
      }

      if (this.filteredDataset) {
        pagerInfo.filteredTotal = ds.length;
      } else {
        pagerInfo.total = ds.length;
      }

      if (!Array.isArray(ds)) {
        return;
      }

      function done(response, pagingInfo) {
        self.settings.dataset = response;
        ds = response;
        var activePage = self.pagerAPI ? self.pagerAPI.activePage : 1;

        if (typeof pagingInfo === 'string') {
          pagingInfo = {
            activePage: activePage,
            pagesize: self.settings.pagesize,
            total: ds.length,
            type: pagingInfo
          };
        }

        if (self.pagerAPI) {
          self.renderPager(pagingInfo, true);
          pagingInfo = self.pagerAPI.state;
        }

        self.render(ds, pagingInfo);
      }

      var s = this.settings.source;

      if (typeof ds === 'string' && (ds.indexOf('http') === 0 || ds.indexOf('/') === 0)) {
        s = ds;
        ajaxDs = true;
      } // If paging is not active, and a source is present, attempt to retrieve
      // information from the datasource.
      // TODO: Potentially abstract this datasource concept out for use elsewhere


      if ((s || ajaxDs) && !this.filteredDataset && !isResponse) {
        switch (_typeof(s)) {
          case 'function':
            s(pagerInfo, done);
            break;

          case 'string':
            if (s.indexOf('http') === 0 || s.indexOf('/') === 0) {
              $.getJSON(s, done);
            }

            return;

          default:
            this.settings.dataset = s;
            ds = s;
            this.render(s, pagerInfo);
            break;
        }

        return;
      } // Otherwise, simply render with the existing dataset


      this.render(ds, pagerInfo);
    },

    /**
     * Toggle all items from selected to deselected, useful for multi/mixed selection
     * @returns {void}
     */
    toggleAll: function toggleAll() {
      this[this.isSelectedAll ? 'deselectItemsBetweenIndexes' : 'selectItemsBetweenIndexes']([0, $('li, tbody tr', this.element).length - 1]);
      this.isSelectedAll = !this.isSelectedAll;
    },

    /**
     * Select Items between a set of indexes. Used for shift selection.
     * @private
     * @param {array} indexes an array containing two numeric indicies that will
     *  be used to make a selection.
     * @returns {void}
     */
    selectItemsBetweenIndexes: function selectItemsBetweenIndexes(indexes) {
      utils.clearSelection(); // Clear all currently selected list items.

      indexes.sort(function (a, b) {
        return a - b;
      });

      for (var i = indexes[0]; i <= indexes[1]; i++) {
        var item = $('li, tbody tr', this.element).eq(i);

        if (!item.is('.is-disabled, .is-selected')) {
          this.select(item);
        }
      }
    },

    /**
    * De-Select Items between a set of indexes. Used for shift selection.
    * @private
    * @param {array} indexes an array containing two numeric indicies that will
    *  be used to deselect.
    * @returns {void}
    */
    deselectItemsBetweenIndexes: function deselectItemsBetweenIndexes(indexes) {
      indexes.sort(function (a, b) {
        return a - b;
      });

      for (var i = indexes[0]; i <= indexes[1]; i++) {
        var item = $('li, tbody tr', this.element).eq(i);

        if (!item.is('.is-disabled') && item.is('.is-selected')) {
          this.select(item);
        }
      }
    },

    /**
    * Handle page/form resize
    * @private
    * @returns {void}
    */
    handleResize: function handleResize() {
      var items = $('li .listview-heading, tr .listview-heading', this.element);
      var item1 = items.eq(1);
      var item1W = item1.width();

      if (item1.length && item1W) {
        items[0].style.width = "".concat(item1W, "px");
      }

      if (this.pagerAPI) {
        this.pagerAPI.render();
      }
    },

    /**
     * @private
     * @param {jquery.event} e custom jQuery `contents-checked` event.
     * @param {jquery[]} searchfield the element representing a searchfield.
     * @returns {void}
     */
    handleSearch: function handleSearch(e, searchfield) {
      this.filter(searchfield);
    },

    /**
     * Filters the contents of Listviews that are paired with a Searchfield.
     * @param {jquery[]} searchfield the element representing a searchfield.
     * @returns {void}
     */
    filter: function filter(searchfield) {
      if (!searchfield) {
        return;
      }

      searchfield = $(searchfield); // Get the search string and trim whitespace

      var searchFieldVal = searchfield.val().trim();
      var pagingInfo = {
        searchActivePage: 1
      }; // Clear

      if (!searchFieldVal) {
        if (!this.searchTerm) {
          return;
        }

        this.resetSearch();
        return;
      } // Make sure there is a search term...and its not the
      // same as the previous term


      if (searchFieldVal.length < this.settings.searchTermMinSize) {
        this.resetSearch();
        return;
      }

      if (this.searchTerm === searchFieldVal) {
        return;
      } // Set a global "searchTerm" and get the list of elements


      this.searchTerm = searchFieldVal; // Clean highlight marks before new filter action

      this.element.unhighlight(); // Reset filter status

      this.settings.dataset.forEach(function (item) {
        item._isFilteredOut = false;
      }); // Filter the results and highlight things

      var results = this.listfilter.filter(this.settings.dataset, this.searchTerm);

      if (!results.length) {
        results = [];
      }

      pagingInfo.filteredTotal = results.length;
      pagingInfo.searchActivePage = 1;
      results.forEach(function (result) {
        result._isFilteredOut = true;
      });
      this.filteredDataset = results;
      this.loadData(null, pagingInfo);
      /**
       * Fires after filtering the list.
       * @event filtered
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args.elem The list element
       * @property {array} args.filteredResults The filter list items
       * @property {term} args.term The search term used.
       */

      this.element.trigger('filtered', {
        elem: this.element,
        filteredResults: results,
        term: this.searchTerm
      });
    },

    /**
     * Reset the current search parameters and highlight.
     * @private
     * @returns {void}
     */
    resetSearch: function resetSearch() {
      this.element.unhighlight(); // reset filter status

      this.settings.dataset.forEach(function (item) {
        delete item._isFilteredOut;
      });

      if (this.filteredDataset) {
        delete this.filteredDataset;
      }

      if (this.searchTerm) {
        delete this.searchTerm;
      }

      var pagingInfo = {
        activePage: 1,
        filteredTotal: undefined,
        searchActivePage: undefined
      };
      this.refresh(null, pagingInfo);
    },

    /**
     * Focus the provided list item with the keyboard
     * @private
     * @param {jquery} item  The list item (as jQuery) to focus
     * @returns {void}
     */
    focus: function focus(item) {
      if (item.is(':hidden') || item.is('.is-disabled')) {
        return;
      }

      if (this.focusItem) {
        this.focusItem.removeAttr('tabindex');
      }

      this.focusItem = item.attr('tabindex', 0).focus();

      if (!this.settings.selectable && item.find('a').length === 1) {
        item.find('a').focus();
        item.removeAttr('tabindex');
      }

      if (this.settings.selectOnFocus && this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
        this.select(item);
      }
    },

    /**
     * Remove the given list item.
     * @param {jquery|number} li Either the actually jQuery list element or a zero based index
     * @returns {void}
     */
    remove: function remove(li) {
      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      } // Un-select selected item
      // and donot trigger selected event, sinnce we removeing


      if (li.is('.is-selected')) {
        this.select(li, true);
      }

      li.remove();
    },

    /**
     * Remove all list items.
     * @returns {void}
     */
    clear: function clear() {
      var root = $(this.element.children()[0]);
      root.empty();
    },

    /**
     * Remove all selected items entirely from the list.
     * @returns {void}
     */
    removeAllSelected: function removeAllSelected() {
      var self = this;
      $.each(this.selectedItems, function (index, selected) {
        self.remove(selected);
      });
    },

    /**
     * Deselect all selected items.
     * @returns {void}
     */
    clearAllSelected: function clearAllSelected() {
      var self = this;
      $.each(this.selectedItems, function (index, selected) {
        // Un-select selected item
        self.select(selected);
      });
    },

    /**
     * Initialize the sorted list
     * @private
     * @param {string} control component name
     * @param {string} onEvent the name of the event to sort on
     * @param {string} attr the name of the HTML attribute to retrieve options from.
     * @returns {void}
     */
    sortInit: function sortInit(control, onEvent, attr) {
      if (!attr || $.trim(attr) === '') {
        return;
      }

      $("[".concat(attr, "]")).each(function () {
        var element = $(this);
        var options = $.fn.parseOptions(element, attr);
        element.on(onEvent, function (e) {
          $(options.list).data(control).setSortColumn(options);
          e.preventDefault();
        });
      });
    },

    /**
    * Sort the list with the given options.
    * @private
    * @param {object} [options] incoming sort options
    * @returns {void}
    */
    setSortColumn: function setSortColumn(options) {
      var field = options.orderBy || this.list.sort.field;
      var reverse = options.order;

      if (!this.list.data && !field) {
        return;
      }

      reverse = reverse ? reverse === 'desc' : !(this.list.sort && this.list.sort[field] && this.list.sort[field].reverse); // reload data

      if (options.reloadApi || options.reloadApiNoSort) {
        this.loadData();
      } // reload data but no sort change


      if (options.reloadApiNoSort) {
        field = this.list.sort.field;
        reverse = this.list.sort[field].reverse;
      }

      var sort = this.sortFunction(field, reverse);
      this.list.data.sort(sort);
      this.render(this.list.data);
      this.list.sort = {
        field: field
      };
      this.list.sort[field] = {
        reverse: reverse
      };
      /**
       * Fires after sorting the list.
       *
       * @event sorted
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} this.element
       * @property {string} this.list.sort
       */

      this.element.trigger('sorted', [this.element, this.list.sort]);
    },

    /**
    * Overridable function to conduct sorting
    * @private
    * @param {string} field  The field in the dataset to sort on.
    * @param {string} reverse  If true sort descending.
    * @param {function} primer  A sorting primer function.
    * @returns {function} a customized sorting algorithm
    */
    sortFunction: function sortFunction(field, reverse, primer) {
      if (!primer) {
        primer = function primer(a) {
          a = a === undefined || a === null ? '' : a;

          if (typeof a === 'string') {
            a = a.toUpperCase();

            if (!isNaN(parseFloat(a))) {
              a = parseFloat(a);
            }
          }

          return a;
        };
      }

      var key = primer ? function (x) {
        return primer(x[field]);
      } : function (x) {
        return x[field];
      };
      reverse = !reverse ? 1 : -1;
      return function (a, b) {
        return a = key(a), b = key(b), reverse * ((a > b) - (b > a)); //eslint-disable-line
      };
    },

    /**
    * Deselect the given list item.
    * @param {jquery[]|number} li  Either the actually jQuery list element or a zero based index
    */
    deselect: function deselect(li) {
      if (!this.settings.allowDeselect) {
        return;
      }

      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }

      if (li.is('.is-selected')) {
        this.select(li);
      }
    },

    /**
     * Deselect the given list item.
     * This method is slated to be removed in a future v4.9.0 or v5.0.0.
     * @deprecated as of v4.3.0. Please use `deselect()` instead.
     * @param {jquery[]|number} li a list item
     * @returns {void}
     */
    unselect: function unselect(li) {
      return deprecateMethod(this.deselect, this.unselect).apply(this, [li]);
    },

    /**
     * Select the given list item.
     * @param {jquery|number} li Either the actually jQuery list element or a zero based index
     * @param {boolean} noTrigger Do not trigger the selected event.
     */
    select: function select(li, noTrigger) {
      var self = this;
      var isChecked = false;
      var isMixed = self.settings.selectable === 'mixed';
      self.selectedItems = [];

      if (typeof li === 'number') {
        li = $(this.element.children()[0]).children().eq(li);
      }

      isChecked = li.hasClass('is-selected');

      if (isChecked && !this.settings.allowDeselect) {
        return;
      } // focus


      if (!li.is('[tabindex="0"]')) {
        if (this.focusItem) {
          this.focusItem.removeAttr('tabindex');
        }

        li.attr('tabindex', 0);
      }

      if (this.settings.selectable === false || this.settings.selectable === 'false') {
        return;
      } // Deselect all other items, when items


      if (this.settings.selectable !== 'multiple' && this.settings.selectable !== 'mixed') {
        li.parent().children().removeAttr('aria-selected');
        li.parent().find('.is-selected').removeClass('is-selected');
        self.selectedItems[0] = $(this);
      }

      if (isChecked) {
        self.selectedItems = [];
        li.removeClass('is-selected hide-selected-color');
      } else if (this.settings.selectable) {
        li.addClass("is-selected".concat(isMixed ? ' hide-selected-color' : ''));
        self.lastSelectedItem = li.index(); // Rember index to use shift key
      }

      li.parent().find('.is-selected').each(function (i) {
        self.selectedItems[i] = $(this);
      }); // Reselect just this item
      // NOTE: don't use `aria-selected` on list items when checkboxes aren't involved.

      li.find('.listview-selection-checkbox input').prop('checked', !isChecked);

      if (this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed') {
        var operationText = !isChecked ? 'Selected' : 'NotSelected';
        li.attr('aria-selected', !isChecked);
        li.find('.label-text .audible').text("".concat(Locale.translate('Checkbox'), " ").concat(operationText, "."));
      }

      if (!noTrigger) {
        var triggerStr = isChecked ? 'unselected' : 'selected';
        var selectedData = [];

        for (var i = 0; i < this.selectedItems.length; i++) {
          var posinset = this.selectedItems[i][0].getAttribute('aria-posinset');
          selectedData.push(this.settings.dataset[posinset - 1]);
        }
        /**
         * Fires when a item is selected.
         * @event selected
         * @memberof ListView
         * @property {object} event - The jquery event object
         * @property {object} selected items and item info and item data
         */


        this.element.triggerHandler(triggerStr, {
          selectedItems: this.selectedItems,
          elem: li,
          selectedData: selectedData
        });

        if (triggerStr === 'unselected') {
          /**
           * Fires when a item is deselected.
           *
           * @event deselected
           * @memberof ListView
           * @property {object} event - The jquery event object
           * @property {object} selected items and item info
           */
          this.element.triggerHandler('deselected', {
            selectedItems: this.selectedItems,
            elem: li,
            selectedData: selectedData
          });
        }
      }

      var parent = this.element.closest('.card, .widget');

      if (!parent.length) {
        parent = this.element.parent();
      }

      var toolbar = parent.find('.listview-toolbar, .contextual-toolbar');
      var toolbarControl = toolbar.data('toolbar');

      if (self.selectedItems.length > 0) {
        if (toolbarControl) {
          toolbarControl.toggleMoreMenu();
        } // Order of operations: set up event, change display prop, animate, toggle menu.
        // Menu toggle takes place after the animation starts


        toolbar.one('animateopencomplete', function () {
          self.element.addClass('is-toolbar-open');
          toolbar.trigger('recalculate-buttons').removeClass('is-hidden');
        });

        if (toolbar[0]) {
          toolbar[0].style.display = 'block';
        } // toolbar.animateOpen({distance: 52});


        toolbar.animateOpen({
          distance: 40
        });
        var title = toolbar.find('.title, .selection-count');

        if (!title || !title.length) {
          title = $('<div class="title selection-count"></div>');
          toolbar.prepend(title);
        }

        title.text("".concat(self.selectedItems.length, " ").concat(Locale ? Locale.translate('Selected') : 'Selected'));
      } else {
        toolbar.addClass('is-hidden').one('animateclosedcomplete', function (e) {
          e.stopPropagation();
          this.style.display = 'none';
          self.element.removeClass('is-toolbar-open');
        }).animateClosed();
      }
    },

    /**
     * Toggle acivation state on the list item
     * @private
     * @param {jquery} li The jQuery list element.
     * @returns {void}
     */
    toggleItemActivation: function toggleItemActivation(li) {
      var isActivated = li.hasClass('is-activated');

      if (isActivated) {
        if (!this.settings.disableItemDeactivation) {
          this.deactivateItem(li);
        }

        return;
      }

      this.activateItem(li);
    },

    /**
     * Set item to activated, unactivate others and fire an event.
     * @private
     * @param {jquery|number} li The jQuery list element or the index.
     * @returns {void}
     */
    activateItem: function activateItem(li) {
      var idx = typeof li === 'number' ? li : li.index();
      var active = this.element.find('li.is-activated');
      var elemCanActivate = true;

      if (typeof li === 'number') {
        li = this.element.find('ul').children().eq(li);
      }

      this.deactivateItem(active);
      /**
       * Fires before activate item.
       *
       * @event beforeactivate
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */

      elemCanActivate = this.element.triggerHandler('beforeactivate', [{
        index: idx,
        elem: li,
        data: this.settings.dataset[idx]
      }]);

      if (elemCanActivate === false) {
        return;
      }

      li.addClass('is-activated');
      /**
       * Fires after activate item.
       *
       * @event itemactivated
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */

      this.element.triggerHandler('itemactivated', [{
        index: idx,
        elem: li,
        data: this.settings.dataset[idx]
      }]);
    },

    /**
    * Return an object containing info about the currently activated item.
    * @returns {object} An object containing the active row's index, dom element and data.
    */
    activatedItem: function activatedItem() {
      var active = this.element.find('li.is-activated');
      var idx = active.index();
      return {
        index: idx,
        elem: active,
        data: this.settings.dataset[idx]
      };
    },

    /**
     * Set item to deactivated, and fire an event.
     * @param {jquery|number} li The jQuery list element. The li element or the index.
     *  If null the currently activated one will be deactivated.
     * @returns {void}
     */
    deactivateItem: function deactivateItem(li) {
      if (typeof li === 'number') {
        li = this.element.find('ul').children().eq(li);
      }

      if (li === undefined) {
        li = this.element.find('li.is-activated');
      }

      li.removeClass('is-activated');
      var idx = li.index();

      if (idx < 0) {
        return;
      }
      /**
       * Fires after deactivated item.
       *
       * @event itemdeactivated
       * @memberof ListView
       * @property {object} event - The jquery event object
       * @property {object} args index, elem, data
       */


      this.element.triggerHandler('itemdeactivated', [{
        index: idx,
        elem: li,
        data: this.settings.dataset[idx]
      }]);
    },

    /**
     * @returns {jquery[]} the currently selected ListView item, or an empty jQuery selector
     *  if there are currently no items selected.
     */
    getSelected: function getSelected() {
      return this.element.find('.is-selected');
    },

    /**
     * Handle to update the search data
     * @private
     * @returns {void}
     */
    updateSearch: function updateSearch() {
      if (this.settings.searchable && this.filteredDataset) {
        delete this.filteredDataset;

        if (this.searchTerm) {
          delete this.searchTerm;
        }

        var searchfieldApi = this.searchfield.data('searchfield');

        if (searchfieldApi && searchfieldApi.xButton) {
          searchfieldApi.xButton.trigger('click');
        }
      }
    },

    /**
     * Refresh the list with any optioned options that might have been set.
     * @param {object} [settings] incoming settings
     * @returns {object} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);

        if (settings && settings.dataset) {
          this.settings.dataset = settings.dataset;
        }
      }

      this.updateSearch();
      this.refresh(settings && settings.dataset ? settings.dataset : null);
      return this;
    },

    /**
     * Disables the functionality of a ListView.
     * @returns {void}
     */
    disable: function disable() {
      this.element.addClass('is-disabled');
    },

    /**
    * Enables the functionality of a ListView.
    * @returns {void}
    */
    enable: function enable() {
      this.element.removeClass('is-disabled');
    },

    /**
     * Detatch all bound events.
     * @private
     * @returns {object} component instance
     */
    teardown: function teardown() {
      $('body').off('resize.listview');
      this.element.prev('.listview-header').off('click.listview');

      if (this.searchfield) {
        this.searchfield.off(['contents-checked.searchable-listview', 'cleared.searchable-listview'].join(' '));
      }

      this.element.off('change.selectable-listview', '.listview-checkbox input');
      this.element.off('contextmenu.listview longpress.listview dblclick.listview', 'li, tr');
      this.element.off('click.listview', 'li, tr, input[checkbox]');
      this.element.off('keydown.listview', 'li, tr, a');
      this.element.off('focus.listview', 'li, tbody tr');
      this.element.off('focus.listview click.listview touchend.listview keydown.listview change.selectable-listview updated.listview').empty();

      if (this.filteredDataset) {
        delete this.filteredDataset;
      }

      if (this.searchTerm) {
        delete this.searchTerm;
      }

      return this;
    },

    /**
     * Detatch all events and tear down data object
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      this.element.removeData(COMPONENT_NAME$U);
    },

    /**
      * Attach Events used by the Control
      * @private
      * @returns {void}
      */
    handleEvents: function handleEvents() {
      var self = this;
      var isSelect = false;
      var isFocused = false;
      var isMultiple = self.settings.selectable === 'multiple' || self.settings.selectable === 'mixed';
      this.element.off('focus.listview', 'li, tbody tr').on('focus.listview', 'li, tbody tr', function (evt) {
        var item = $(this); // Ignore favorite clicks

        if (evt.originalEvent && evt.originalEvent.target && $(evt.originalEvent.target).is('.icon-favorite')) {
          return;
        } // First element if disabled


        if (item.is(':first-child') && item.hasClass('is-disabled')) {
          var e = $.Event('keydown.listview');
          e.keyCode = 40; // move down

          isSelect = true;
          item.trigger(e);
        }

        if (!isSelect && !item.hasClass('is-disabled') && self.settings.selectOnFocus && self.settings.selectable !== 'multiple' && self.settings.selectable !== 'mixed') {
          self.select(item);
          isSelect = true;
          isFocused = true;
        }
      }); // Keyboard

      this.element.off('keydown.listview', 'li, tr, a').on('keydown.listview', 'li, tr, a', function (e) {
        var elem = $(this);
        var item = elem.is('a') ? elem.closest('li') : $(this);
        var list = item.is('a') ? item.closest('ul') : item.parent();
        var key = e.keyCode || e.charCode || 0;
        var metaKey = e.metaKey;

        if (item.index() === 0 && e.keyCode === 38) {
          return false;
        }

        if ((key === 40 || key === 38) && !metaKey) {
          // move down or up
          var newItem = e.keyCode === 40 ? item.nextAll(':not(.is-disabled):visible:first') : item.prevAll(':not(.is-disabled):visible:first');

          if (newItem.length && ($(e.target).is(item) || e.shiftKey || elem.is('a'))) {
            self.focus(newItem);
          }

          e.preventDefault();
          e.stopPropagation(); // prevent container from scrolling
        }

        if (key === 35 || key === 40 && metaKey) {
          // end
          var last = list.children().last();
          self.focus(last);
          e.stopPropagation();
          return false;
        }

        if (key === 36 || key === 38 && metaKey) {
          // home
          var first = list.children().first();
          self.focus(first);
          e.stopPropagation();
          return false;
        }

        if (key === 32) {
          // Space to toggle selection
          if ($(e.target).is(item)) {
            if (isMultiple && e.shiftKey) {
              self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
            } else {
              self.select(item);
            }

            e.preventDefault();
          }
        } // If multiSelect is enabled, press Control+A to toggle select all items


        if (isMultiple && (e.ctrlKey || e.metaKey) && key === 65) {
          self.toggleAll();
          self.focus(item);
          e.preventDefault();
        }

        return true;
      }); // Selection View Click/Touch

      if (this.settings.selectable) {
        this.element.addClass('is-selectable');
        var pattern = $(this.element).closest('.list-detail, .builder');
        this.element.off('click.listview', 'li, tr, input[checkbox]').on('click.listview', 'li, tr, input[checkbox]', function (e) {
          var item = $(this);
          var isCheckbox = $(e.target).closest('.listview-selection-checkbox').length > 0;
          var isMixed = self.settings.selectable === 'mixed';
          var target = $(e.target); // ignore clicking favorites element or a hyperlink

          if (target.hasClass('icon-favorite') || target.hasClass('hyperlink')) {
            return;
          }

          if (!isFocused && !item.hasClass('is-disabled') && (!isMixed || isCheckbox)) {
            isSelect = true;

            if (isMultiple && e.shiftKey) {
              self.selectItemsBetweenIndexes([self.lastSelectedItem, item.index()]);
              e.preventDefault();
            } else {
              self.select(item);
            }

            item.focus();
          }

          if (!item.hasClass('is-disabled') && isMixed && !isCheckbox) {
            item.focus();
            self.toggleItemActivation(item);
          }

          if (pattern.length > 0 && $(window).outerWidth() < 767 && !item.hasClass('is-disabled') && !isCheckbox) {
            self.element.trigger('drilldown', [item]);
          }

          isFocused = false;
          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('click', [{
            elem: item,
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
        });
        this.element.off('dblclick.listview', 'li, tr').on('dblclick.listview', 'li, tr', function (e) {
          var item = $(this);
          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('dblclick', [{
            elem: $(this),
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
          return false;
        });
        this.element.off('contextmenu.listview longpress.listview', 'li, tr').on('contextmenu.listview longpress.listview', 'li, tr', function (e) {
          var item = $(this);
          e.preventDefault();
          e.stopPropagation();
          self.element.trigger('contextmenu', [{
            elem: $(this),
            data: self.settings.dataset[item.attr('aria-posinset') - 1],
            index: item.index(),
            originalEvent: e
          }]);
          return false;
        });
      }

      if (!this.settings.hoverable || this.settings.hoverable === 'false') {
        this.element.removeClass('is-selectable');
        this.element.addClass('disable-hover');
      }

      if (!this.settings.selectable || this.settings.selectable === 'false') {
        this.element.removeClass('is-selectable');
        this.element.addClass('disable-hover');
      }

      if (this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed') {
        this.element.off('change.selectable-listview', '.listview-checkbox input').on('change.selectable-listview', '.listview-checkbox input', function (e) {
          $(this).parent().trigger('click');
          e.stopPropagation();
        });
      } // For use with Searchfield


      if (this.settings.searchable) {
        this.searchfield.off('contents-checked.searchable-listview').on('contents-checked.searchable-listview', function (e) {
          self.handleSearch(e, $(this));
        }).off('cleared.searchable-listview').on('cleared.searchable-listview', function () {
          self.resetSearch();
          self.element.trigger('filtered', {
            elem: self.element,
            filteredResults: [],
            term: ''
          });
        });
      } // If used with a Pager Control, listen for the end of the page and scroll
      // the Listview to the top


      if (this.pagerAPI) {
        this.element.off('page.listview').on('page.listview', function (e, pagingInfo) {
          self.handlePageChange(pagingInfo);
        }).off('pagesizechange.listview').on('pagesizechange.listview', function (e, pagingInfo) {
          self.handlePageSizeChange(pagingInfo);
        });
      }

      $('body').off('resize.listview').on('resize.listview', function (e) {
        self.handleResize(e);
      }); // Animate open and Closed from the header

      self.element.prev('.listview-header').off('click.listview').on('click.listview', function () {
        var icon = $(this).find('.plus-minus');

        if (icon.hasClass('active')) {
          icon.removeClass('active');
          self.element.animateClosed();
        } else {
          icon.addClass('active');
          self.element.animateOpen();
        }
      });
    },

    /**
     * Listens for a `pagesizechange` event from the dropdown that recalculates page size
     * @param {object} pagingOpts state information from the pager
     */
    handlePageSizeChange: function handlePageSizeChange(pagingOpts) {
      pagingOpts.activePage = 1;
      this.loadData(undefined, pagingOpts);
    },

    /**
     * Listens for `page` events from the Pager.
     * @param {object} pagingOpts state information from the pager
     */
    handlePageChange: function handlePageChange(pagingOpts) {
      this.loadData(undefined, pagingOpts);
    }
  };

  /**
   * jQuery Component Wrapper for ListView
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */

  $.fn.listview = function (settings) {
    /**
     * NOTE: Much of this is here for backwards-compatibility reasons.  In the future we need to
     * make sure these enhancements make it to the components.
     */
    var cs = $(this);
    var attr = cs.attr('data-dataset');
    var tmpl = cs.attr('data-tmpl');
    var inlineOpts = utils.parseOptions(this) || {};
    inlineOpts.dataset = inlineOpts.dataset || attr;
    inlineOpts.template = inlineOpts.template || tmpl;

    if (window[inlineOpts.dataset]) {
      inlineOpts.dataset = window[inlineOpts.dataset];
    }

    if (inlineOpts.template && inlineOpts.template.length) {
      inlineOpts.template = $("#".concat(inlineOpts.template)).html();
    }

    var combinedSettings = utils.extend({}, settings, inlineOpts);
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$U);

      if (instance) {
        instance.updated(combinedSettings);
      } else {
        instance = $.data(this, COMPONENT_NAME$U, new ListView(this, combinedSettings));
      }
    });
  };

  var COMPONENT_NAME$V = 'listbuilder';
  /**
   * A list of items with add/remove/delete and sort functionality.
   * @class ListBuilder
   * @constructor
   * @param {jQuery[]|HTMLElement} element The base element.
   * @param {object} [settings] incoming settings.
   *
   * @param {array} [settings.dataset]  Array of data
   * @param {string} [settings.handle]  The CSS Class of the handle element
   * @param {string|jQuery[]} [settings.btnAdd]  "Add" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnEdit]  "Edit" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnDelete]  "Delete" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnGoUp]  "GoUp" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|jQuery[]} [settings.btnGoDown]  "GoDown" action button (takes a string representing a
   *  "data-action" attribute, or a jQuery-wrapped element reference).
   * @param {string|array} [settings.attributes = null] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
   * @param {string} [settings.template]  representing HTML content that builds a list
   * @param {string} [settings.templateNewItem]  representing HTML content that builds a single list item
   * @param {string} [settings.templateItemContent]  representing HTML content that replaces the inner content
   *  section of each item.
   */

  var LISTBUILDER_DEFAULTS = {
    dataset: [],
    handle: '.handle',
    btnAdd: 'add',
    btnEdit: 'edit',
    btnDelete: 'delete',
    btnGoUp: 'goup',
    btnGoDown: 'godown',
    attributes: null,
    template: '' + '<ul data-handle=".handle">' + '{{#dataset}}' + '{{#text}}' + '<li' + '{{#value}} data-value="{{value}}"{{/value}}' + '{{#selected}} selected="selected"{{/selected}}' + '{{#disabled}} class="is-disabled"{{/disabled}}' + '>' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="item-content"><p>{{text}}</p></div>' + '</li>' + '{{/text}}' + '{{/dataset}}' + '</ul>',
    templateNewItem: '' + '<li data-value="{{text}}" role="option">' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="item-content"><p>{{text}}</p></div>' + '</li>',
    templateItemContent: '<p>{{text}}</p>'
  };

  function ListBuilder(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LISTBUILDER_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }
    this.init();
  } // ListBuilder Methods


  ListBuilder.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      this.loadListview().initDataset().setElements().handleEvents();
      setTimeout(function () {
        _this.setSelected();
      }, 0);
    },

    /**
     * Load listview
     * @private
     * @returns {this} component instance
     */
    loadListview: function loadListview() {
      var s = this.settings;
      var lv = $('.listview', this.element);
      var attributes;

      if (s.attributes) {
        attributes = this.getLvAutomationAttributes('-listbuilder');
      }

      if (!s.dataset.length && lv.length && $('li', lv).length) {
        this.listApi = lv.listview({
          selectable: 'single',
          attributes: attributes
        }).data('listview');
      } else if (lv.length) {
        this.listApi = lv.listview({
          dataset: s.dataset,
          template: s.template,
          selectable: 'single',
          attributes: attributes
        }).data('listview');
      }

      return this;
    },

    /**
     * Get list view settings for automation attributes
     * @private
     * @param {string} suffix for listbuilder
     * @returns {object|array} attributes with suffix
     */
    getLvAutomationAttributes: function getLvAutomationAttributes(suffix) {
      var _this2 = this;

      var s = this.settings;
      var attributes;

      if (s.attributes && typeof suffix === 'string' && suffix !== '') {
        if (Array.isArray(s.attributes)) {
          attributes = [];
          s.attributes.forEach(function (item) {
            var value = typeof item.value === 'function' ? item.value(_this2) : item.value;
            attributes.push({
              name: item.name,
              value: value + suffix
            });
          });
        } else {
          var value = typeof s.attributes.value === 'function' ? s.attributes.value(this) : s.attributes.value;
          attributes = {
            name: s.attributes.name,
            value: value + suffix
          };
        }
      }

      return attributes;
    },

    /**
     * Update the automation attributes for given list item
     * @private
     * @param {jQuery} li The list item
     * @returns {void}
     */
    updateLvAutomationAttributes: function updateLvAutomationAttributes(li) {
      var s = this.settings;

      if (s.attributes && li) {
        var lastIdx = this.dataset.length - 1;
        var found = true;
        var max = 1000; // max-limit

        var attributes;

        while (found && max > 0) {
          var suffix = "-listbuilder-listview-item-".concat(lastIdx);
          attributes = this.getLvAutomationAttributes(suffix);
          found = this.findAutomationAttributesItem(attributes);
          lastIdx++;
          max--;
        }

        utils.addAttributes(li, this, attributes);
      }
    },

    /**
     * Initialize dataset
     * @private
     * @param {string|array} attributes The list of attributes key/value
     * @returns {boolean} True, if found item
     */
    findAutomationAttributesItem: function findAutomationAttributesItem(attributes) {
      var s = this.settings;
      var r = false;

      if (s.attributes && attributes) {
        if (Array.isArray(attributes)) {
          for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            var el = this.listApi.element.find("[".concat(attr.name, "=\"").concat(attr.value, "\"]"));

            if (el.length) {
              r = true;
              break;
            }
          }
        }
      }

      return r;
    },

    /**
     * Initialize dataset
     * @private
     * @returns {this} component instance
     */
    initDataset: function initDataset() {
      var s = this.settings;
      var nodes = $('.listview li', this.element);
      this.dataset = [];

      for (var i = 0, l = nodes.length; i < l; i++) {
        var data = void 0;
        var li = $(nodes[i]);

        if (s.dataset) {
          // Make sure it's not reference pointer to data object, make copy of data
          data = JSON.parse(JSON.stringify(s.dataset[i]));
          data.node = li;
        } else {
          data = this.extractNodeData(li);
        }

        this.dataset.push(data);
      }

      return this;
    },

    /**
     * Extract node data
     * @private
     * @param {jQuery[]} node element to be checked for data
     * @returns {object} data from the node.
     */
    extractNodeData: function extractNodeData(node) {
      var data = {
        node: node,
        text: $.trim($('.item-content', node).text())
      };
      var value = node.attr('data-value');

      if (typeof value !== 'undefined') {
        data.value = value;
      }

      return data;
    },

    /**
     * Set elements
     * @private
     * @returns {this} component instance
     */
    setElements: function setElements() {
      var _this3 = this;

      var s = this.settings; // Action buttons

      var setAction = function setAction(selector) {
        if (_this3.isjQuery(selector)) {
          return selector;
        }

        if (typeof selector === 'string') {
          return $("[data-action=\"".concat(selector, "\"]"), _this3.element);
        }

        return null;
      };

      s.btnAdd = setAction(s.btnAdd);
      s.btnGoUp = setAction(s.btnGoUp);
      s.btnGoDown = setAction(s.btnGoDown);
      s.btnEdit = setAction(s.btnEdit);
      s.btnDelete = setAction(s.btnDelete); // Add automation attributes

      var suffix = 'listbuilder-btn';
      utils.addAttributes(s.btnAdd, this, s.attributes, "".concat(suffix, "-add"));
      utils.addAttributes(s.btnGoUp, this, s.attributes, "".concat(suffix, "-goup"));
      utils.addAttributes(s.btnGoDown, this, s.attributes, "".concat(suffix, "-godown"));
      utils.addAttributes(s.btnEdit, this, s.attributes, "".concat(suffix, "-edit"));
      utils.addAttributes(s.btnDelete, this, s.attributes, "".concat(suffix, "-delete")); // Init tooltips

      this.topButtons = s.btnAdd.add(s.btnGoUp).add(s.btnGoDown).add(s.btnEdit).add(s.btnDelete);
      this.topButtons.tooltip(); // Make Draggable

      this.ul = $('.listview ul', this.element);
      this.arrangeApi = this.ul.arrange({
        handle: s.handle,
        placeholder: s.templateNewItem
      }).data('arrange');
      return this;
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this4 = this;

      var data;
      var self = this;
      var s = self.settings; // TOP BUTTONS =============================================================

      var topButtonsClick = function topButtonsClick(btn, method) {
        btn.off('click.listbuilder').on('click.listbuilder', function () {
          self[method]();
        });
      };

      topButtonsClick(s.btnAdd, 'addItem');
      topButtonsClick(s.btnGoUp, 'moveItemUp');
      topButtonsClick(s.btnGoDown, 'moveItemDown');
      topButtonsClick(s.btnEdit, 'editItem');
      topButtonsClick(s.btnDelete, 'deleteItem'); // DRAGGABLE ===============================================================

      this.arrangeApi.element.on('beforearrange.listbuilder', function (e, status) {
        var d = _this4.getDataByNode(status.start);

        var str = s.templateItemContent.replace(/{{text}}/g, d.data.text);

        _this4.arrangeApi.placeholders.attr('data-value', d.data.text).find('.item-content').html(str);
      }).on('arrangeupdate.listbuilder', function (e, status) {
        _this4.updateAttributes();

        _this4.arrayIndexMove(_this4.dataset, status.startIndex, status.endIndex);

        data = _this4.getDataByNode(status.end);
        data.indexBeforeMove = status.startIndex;

        _this4.element.triggerHandler('arrangeupdate', [data]);
      });
      $("li:not(.is-disabled) ".concat(this.arrangeApi.handle), this.ul).on('mousedown.listbuilder touchstart.listbuilder', function () {
        var li = $(this);

        if (!li.is('.is-selected')) {
          li.trigger('click');
        }
      });
      $('.listview', this.element).off('selected.listbuilder').on('selected.listbuilder', function (e, args) {
        data = _this4.getDataByNode(args.elem[0]);
        /**
         * Fires when a item is selected.
         * @event selected
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this selected item
         */

        _this4.element.triggerHandler('selected', [data]);
      });
      this.updatedEventsStr = 'arrangeupdate.listbuilder aftergoup.listbuilder aftergodown.listbuilder exiteditmode.listbuilder';
      this.element.off(this.updatedEventsStr).on(this.updatedEventsStr, function (e, updatedData) {
        /**
         * Fires when a item is updated.
         * @event updated
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this item
         */
        _this4.element.triggerHandler('updated', [updatedData]);
      });
      return this;
    },
    // END: Handle Events -----------------------------------------------------

    /**
     * Add an item into edit mode.
     * @private
     * @returns {void}
     */
    addItem: function addItem() {
      var self = this;
      var s = this.settings;
      /**
       * Fires before add new item.
       *
       * @event beforeadd
       * @memberof ListBuilder
       * @type {object}
       * @property {object} event - The jquery event object
       */

      $.when(this.element.triggerHandler('beforeadd')).done(function () {
        var li;
        var data;
        var index = 0;
        var node = self.listApi.selectedItems[0];
        var str = s.templateNewItem.replace(/{{text}}/g, Locale.translate('NewItem'));

        if (node && node.length > 0) {
          data = self.getDataByNode(node);
          index = data.index + 1;
          $(str).insertAfter(node);
          li = $('li', self.ul).eq(index);
        } else {
          self.ul.prepend(str);
          li = $('li:first-child', self.ul);
        }

        self.dataset.push(self.extractNodeData(li));
        self.arrayIndexMove(self.dataset, self.dataset.length - 1, index);
        self.updateAttributes();
        self.updateLvAutomationAttributes(li);
        li.trigger('click');
        self.arrangeApi.updated();
        self.editItem(true);
        data = {
          index: index,
          data: self.dataset[index]
        };
        /**
         * Fires after add new item.
         * @event afteradd
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this new item
         */

        self.element.triggerHandler('afteradd', [data]);
      });
    },

    /**
     * Move the currently selected item up.
     * @private
     * @returns {void}
     */
    moveItemUp: function moveItemUp() {
      var self = this;
      var node = self.listApi.selectedItems[0];

      if (node && node.length > 0) {
        var data = self.getDataByNode(node);

        if (typeof data.index !== 'undefined' && data.index > 0) {
          /**
           * Fires before move up item.
           * @event beforegoup
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforegoup', [data])).done(function () {
            var prev = node.prev();
            node.insertBefore(prev);
            self.updateAttributes();
            self.arrayIndexMove(self.dataset, data.index, data.index - 1);
            data.indexBeforeMove = data.index;
            data.index--;
            /**
             * Fires after move up item.
             * @event aftergoup
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */

            self.element.triggerHandler('aftergoup', [data]);
          });
        }
      }
    },

    /**
     * Move the currently selected item down.
     * @private
     * @returns {void}
     */
    moveItemDown: function moveItemDown() {
      var self = this;
      var node = self.listApi.selectedItems[0];

      if (node && node.length > 0) {
        var data = self.getDataByNode(node);

        if (typeof data.index !== 'undefined' && data.index < self.dataset.length - 1) {
          /**
           * Fires before move down item.
           * @event beforegodown
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforegodown', [data])).done(function () {
            var next = node.next();
            node.insertAfter(next);
            self.updateAttributes();
            self.arrayIndexMove(self.dataset, data.index, data.index + 1);
            data.indexBeforeMove = data.index;
            data.index++;
            /**
             * Fires after move down item.
             * @event aftergodown
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */

            self.element.triggerHandler('aftergodown', [data]);
          });
        }
      }
    },

    /**
     * Edit the selected item
     * @private
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    editItem: function editItem(isNewItem) {
      var node = this.listApi.selectedItems[0];

      if (node && node.length > 0) {
        if (node.is('.is-editing')) {
          this.commitEdit(node, isNewItem);
        } else {
          this.makeEditable(node, isNewItem);
        }
      }
    },

    /**
     * Make the node editable
     * @private
     * @param {object} node  The HTML element to edit
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    makeEditable: function makeEditable(node, isNewItem) {
      var self = this;
      var data = self.getDataByNode(node);
      var container = $('.item-content', node);

      if (typeof data.index !== 'undefined' && data.index < self.dataset.length) {
        /**
         * Fires before edit item.
         * @event beforeedit
         * @memberof ListBuilder
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} data - Data for this item
         */
        $.when(self.element.triggerHandler('beforeedit', [data])).done(function () {
          var origValue = xssUtils.escapeHTML((container.text().trim() || '').toString());
          var editInput = $("<input name=\"edit-input\" class=\"edit-input\" type=\"text\" value=\"".concat(origValue, "\" />"));
          node.addClass('is-editing');
          container.html(editInput);
          setTimeout(function () {
            editInput.focus().select();
          }, 0);
          editInput.on('click.listbuilder', function () {
            return false;
          }).on('blur.listbuilder', function () {
            return self.commitEdit(node, isNewItem);
          }).on('keypress.listbuilder', function (e) {
            var key = e.keyCode || e.charCode || 0;

            if (key === 13) {
              self.commitEdit(node, isNewItem);
              node.focus();
            }
          });
          /**
           * Fires when enter to edit mode.
           * @event entereditmode
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */

          self.element.triggerHandler('entereditmode', [data]);
        });
      }
    },

    /**
     * Commit the changes to item.
     * @private
     * @param {object} node  The HTML element to commit changes
     * @param {boolean} isNewItem  Is it a newly added item?
     * @returns {void}
     */
    commitEdit: function commitEdit(node, isNewItem) {
      var s = this.settings;
      var data = this.getDataByNode(node);
      var container = $('.item-content', node);
      var editInput = $('.edit-input', container);
      editInput.val(xssUtils.escapeHTML((editInput.val() || '').toString()));

      if (isNewItem) {
        data.data.value = editInput.val();
      }

      data.data.text = editInput.val();
      editInput.off('click.listbuilder blur.listbuilder keypress.listbuilder');
      container.html(s.templateItemContent.replace(/{{text}}/g, editInput.val()));
      node.removeClass('is-editing');
      /**
       * Fires when exited to edit mode.
       * @event exiteditmode
       * @memberof ListBuilder
       * @type {object}
       * @property {object} event - The jquery event object
       * @property {object} data - Data for this item
       */

      this.element.triggerHandler('exiteditmode', [data]);
    },

    /**
     * Delete the selected item.
     * @private
     * @returns {void}
     */
    deleteItem: function deleteItem() {
      var self = this;
      var node = self.listApi.selectedItems[0];

      if (node && node.length > 0) {
        var data = self.getDataByNode(node);

        if (typeof data.index !== 'undefined') {
          /**
           * Fires before delete item.
           * @event beforedelete
           * @memberof ListBuilder
           * @type {object}
           * @property {object} event - The jquery event object
           * @property {object} data - Data for this item
           */
          $.when(self.element.triggerHandler('beforedelete', [data])).done(function () {
            self.listApi.removeAllSelected();
            self.updateAttributes();
            self.dataset.splice(data.index, 1);
            /**
             * Fires after delete item.
             * @event afterdelete
             * @memberof ListBuilder
             * @type {object}
             * @property {object} event - The jquery event object
             * @property {object} data - Data for this item
             */

            self.element.triggerHandler('afterdelete', [data]);
          });
        }
      }
    },

    /**
     * Get data from dataset by node
     * @param {jQuery[]} node  The HTML element to get data
     * @returns {object} node data
     */
    getDataByNode: function getDataByNode(node) {
      var data = {};

      for (var i = 0, l = this.dataset.length; i < l; i++) {
        var d = this.dataset[i];

        if ($(d.node).is(node)) {
          data = {
            index: i,
            data: d
          };
          break;
        }
      }

      return data;
    },

    /**
     * Move an array element position
     * @private
     * @param {array} arr .
     * @param {number} from .
     * @param {number} to .
     * @returns {void}
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    /**
     * Check if given object is a jQuery object
     * @private
     * @param {object} obj .
     * @returns {boolean} true if jQuery
     */
    isjQuery: function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },

    /**
     * Move cursor to end
     * http://stackoverflow.com/a/26900921
     * @private
     * @param {object} el as element.
     * @returns {void}
     */
    moveCursorToEnd: function moveCursorToEnd(el) {
      setTimeout(function () {
        if (typeof el.selectionStart === 'number') {
          el.selectionEnd = el.value.length;
          el.selectionStart = el.value.length;
        } else if (typeof el.createTextRange !== 'undefined') {
          var range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }, 100);
    },

    /**
     * Update attributes
     * @private
     * @returns {void}
     */
    updateAttributes: function updateAttributes() {
      var nodes = $('li', this.ul);

      for (var i = 0, l = nodes.length; i < l; i++) {
        $(nodes[i]).attr({
          'aria-posinset': i + 1,
          'aria-setsize': l
        });
      }
    },

    /**
     * Update dataset
     * @private
     * @param {object} ds as dataset.
     * @returns {void}
     */
    updateDataset: function updateDataset(ds) {
      var _this5 = this;

      var nodes = $('li', this.ul);
      var lv = $('.listview', this.element).data('listview');
      lv.deselectItemsBetweenIndexes([0, nodes.length - 1]);
      this.settings.dataset = ds;
      lv.loadData(this.settings.dataset);
      this.initDataset().setElements().handleEvents();
      setTimeout(function () {
        _this5.setSelected();
      }, 0);
    },

    /**
     * Set pre selected items
     * @private
     * @returns {object} this api
     */
    setSelected: function setSelected() {
      var nodes = $('li[selected]', this.ul);

      for (var i = 0, l = nodes.length; i < l; i++) {
        var li = $(nodes[i]);
        li.removeAttr('selected');

        if (!li.is('.is-selected')) {
          li.trigger('click');
        }
      }

      return this;
    },

    /**
     * Make selected
     * @private
     * @param {object} selector .
     * @returns {void}
     */
    select: function select(selector) {
      var li = this.getListItem(selector);

      if (li && !li.is('.is-selected')) {
        li.trigger('click');
      }
    },

    /**
     * Make unselected
     * @private
     * @param {object} selector .
     * @returns {void}
     */
    unselect: function unselect(selector) {
      var li = this.getListItem(selector);

      if (li && li.is('.is-selected')) {
        li.trigger('click');
      }
    },

    /**
     * Get an item from list, selector: can be
     * jQuery, DOM element, zero based index or 'first'|'last' as string
     * @private
     * @param {object} selector .
     * @returns {object} item node
     */
    getListItem: function getListItem(selector) {
      var li = $();

      if (this.isElement(selector) && $.contains(this.ul, selector)) {
        li = this.isjQuery(selector) ? selector : $(selector);
      } else {
        var idx = parseInt(selector, 10);
        var items = $('li', this.ul);

        if (!isNaN(idx) && idx > -1 && idx < items.length) {
          li = items.eq(idx); // zero based index
        } else if ("".concat(selector).toLowerCase() === 'first') {
          li = items.first(); // first
        } else if ("".concat(selector).toLowerCase() === 'last') {
          li = items.last(); // last
        }
      } // Make sure to return only one item -or- null


      if (li.length < 1) {
        return null;
      }

      if (li.length > 1) {
        return li.eq(0);
      }

      return li;
    },

    /**
     * Check if given object is a DOM object
     * @private
     * @param {object} obj .
     * @returns {object} item node
     */
    isElement: function isElement(obj) {
      return this.isjQuery(obj) && obj.get(0) instanceof Element || obj instanceof Element;
    },

    /**
     * Make enable.
     * @returns {void}
     */
    enable: function enable() {
      this.element.removeClass('is-disabled').find('.toolbar .buttonset button').removeAttr('disabled').end().find('.toolbar .buttonset button[data-original-disabled]').attr('disabled', 'disabled').removeAttr('data-original-disabled');
      this.ul.find('li').removeClass('is-disabled').end().find('li[data-original-disabled]').addClass('is-disabled').removeAttr('data-original-disabled');
    },

    /**
     * Make disable.
     * @returns {void}
     */
    disable: function disable() {
      this.element.addClass('is-disabled').find('.toolbar .buttonset button[disabled]').attr('data-original-disabled', 'disabled').end().find('.toolbar .buttonset button').attr('disabled', 'disabled');
      this.ul.find('li.is-disabled').attr('data-original-disabled', 'is-disabled').end().find('li').addClass('is-disabled');
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.element.off(this.updatedEventsStr);
      $('.listview', this.element).off('selected.listbuilder');
      $("li ".concat(this.arrangeApi.handle), this.ul).off('mousedown.listbuilder touchstart.listbuilder');
      this.arrangeApi.element.off('beforearrange.listbuilder arrangeupdate.listbuilder').destroy();
      this.topButtons.off('click.listbuilder');

      if (this.topButtons) {
        for (var i = 0, l = this.topButtons.length; i < l; i++) {
          var tooltipApi = $(this.topButtons[i]).data('tooltip');

          if (tooltipApi && typeof tooltipApi.destroy === 'function') {
            tooltipApi.destroy();
          }
        }
      }

      if (this.listApi && typeof this.listApi.destroy === 'function') {
        this.listApi.destroy();
      }

      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} [settings] incoming settings.
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, LISTBUILDER_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Teardown process for this plugin
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$V);
    }
  };

  /**
   * jQuery Component Wrapper for ListBuilder
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */

  $.fn.listbuilder = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$V);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$V, new ListBuilder(this, settings));
      }
    });
  };

  var COMPONENT_NAME$W = 'modal'; // Possible values for the `trigger` setting

  var MODAL_TRIGGER_SETTINGS = ['click', 'immediate']; // Possible values for the `fullsize` setting

  var MODAL_FULLSIZE_SETTINGS = [false, 'responsive', 'always'];
  /**
  * Responsive and Accessible Modal Control
  * @class Modal
  * @param {string} element The component element.
  * @param {string} settings The component settings.
  *
  * @param {string} [settings.title='Message Title']  Title text or content shown in the modal. An HTML string containing the follow tags may also be used `<div><span><a><small><img><svg><i><b><use><br><strong><em>`.
  * @param {string} [settings.trigger='click'] The method of opening the dialog. Supports click, immediate.
  * @param {array} [settings.buttons=null]  A list of buttons that will sit in the toolbar's Buttonset area.
  * @param {isAlert} [settings.isAlert=false] Adds alertdialog role for message dialogs.
  * @param {content} [settings.content=null] Ability to pass in dialog html content.
  * @param {string} [settings.cssClass=null] Append a css class to top level.
  * @param {boolean} [settings.autoFocus=true] If true, when the modal is opened, the first available input/button in its content area will be focused.
  * @param {string} [settings.id=null] Optionally tag a dialog with an id.
  * @param {number} [settings.frameHeight=180] Optional extra height to add.
  * @param {number} [settings.frameWidth=46] Optional extra width to add.
  * @param {function} [settings.beforeShow=null] A call back function that can be used to return data for the modal.
  * @param {boolean} [settings.useFlexToolbar] If true the new flex toolbar will be used (For CAP)
  * @param {boolean} [settings.showCloseBtn] If true, show a close icon button on the top right of the modal.
  * @param {number} [settings.maxWidth=null] Optional max width to add in pixels.
  * @param {boolean} [settings.fullsize=false] If true, ignore any sizing algorithms and
  * return the markup in the response and this will be shown in the modal. The busy indicator will be shown while waiting for a response.
  * @param {string} [settings.breakpoint='phone-to-tablet'] The breakpoint to use for a responsive change to "fullsize" mode. See `utils.breakpoints` to view the available sizes.
  * @param {string} [settings.overlayOpacity=0.7] Adds the ability to control the opacity of the background overlay.
  * @param {boolean} [settings.noRefocus=false] If true, causes the modal's trigger element not to become focused once the modal is closed.
  * @param {htmlObject|jqueryObject|srting} [settings.triggerButton=null] The modal's trigger element to keep refocused once the modal is closed. This can be html or jquery object or query selector as string
  * @param {boolean} [settings.hideUnderneath=false] if true, causes this modal instance to become hidden when another modal is displayed over top.
  * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var MODAL_DEFAULTS = {
    trigger: 'click',
    buttons: null,
    isAlert: false,
    content: null,
    cssClass: null,
    autoFocus: true,
    id: null,
    frameHeight: 180,
    frameWidth: 46,
    beforeShow: null,
    useFlexToolbar: false,
    showCloseBtn: false,
    maxWidth: null,
    fullsize: MODAL_FULLSIZE_SETTINGS[0],
    breakpoint: 'phone-to-tablet',
    overlayOpacity: 0.7,
    noRefocus: false,
    triggerButton: null,
    hideUnderneath: false
  }; // Resets some string-based Modal settings to their defaults
  // if the provided values are not possible or valid.

  function handleModalDefaults(settings) {
    if (settings.trigger && MODAL_TRIGGER_SETTINGS.indexOf(settings.trigger) === -1) {
      settings.trigger = MODAL_DEFAULTS.trigger;
    } // Reset fullsize setting to default if it's not available


    if (settings.fullsize && MODAL_FULLSIZE_SETTINGS.indexOf(settings.fullsize) === -1) {
      settings.fullsize = MODAL_DEFAULTS.fullsize;
    } // Reset breakpoint setting to default if it's not a valid breakpoint.


    if (settings.breakpoint && breakpoints.available.indexOf(settings.breakpoint) === -1) {
      settings.breakpoint = MODAL_DEFAULTS.breakpoint;
    }

    return settings;
  }

  function Modal(element, settings) {
    this.settings = utils.mergeSettings(element, settings, MODAL_DEFAULTS);
    this.settings = handleModalDefaults(this.settings);
    this.originalElement = $(element);
    this.element = $(element);
    this.init();
    this.reStructure();
  } // Actual Plugin Code


  Modal.prototype = {
    /**
     * @private
     * @returns {boolean} whether or not the Modal is a Contextual Action Panel (CAP)
     */
    get isCAP() {
      return this.element.is('.contextual-action-panel');
    },

    /**
     * @private
     * @returns {ContextualActionPanel|undefined} a reference to a Contextual Action Panel
     * API associated with this modal, if one exists.
     */
    get capAPI() {
      var api;

      if (this.trigger && this.trigger.length) {
        api = this.trigger.data('contextualactionpanel');
      } else if (this.mainContent && this.mainContent.length && this.mainContent.is('body')) {
        api = this.mainContent.data('contextualactionpanel');
      }

      return api;
    },

    /**
     * @returns {boolean} whether or not the body tag is this Modal's trigger element
     */
    get isAttachedToBody() {
      return this.trigger.length && this.trigger.is('body');
    },

    /**
     * @returns {boolean} whether or not this Modal is currently being displayed
     */
    get visible() {
      return this.element.is('.is-visible');
    },

    /**
     * @param {boolean} val whether or not this modal is the active one within the
     * global Modal stack.
     */
    set visible(val) {
      this.element[0].classList[val === true ? 'add' : 'remove']('is-visible');
    },

    /**
     * @param {boolean} val whether or not this modal is the active one within the
     * global Modal stack.
     */
    set active(val) {
      this.element[0].classList[val === true ? 'add' : 'remove']('is-active');
    },

    /**
     * @returns {boolean} whether or not this Modal is currently active
     */
    get active() {
      return this.element[0].classList.contains('is-active');
    },

    /**
     * @returns {boolean} whether or not this Modal instance is the top-level one
     */
    get isOnTop() {
      var max = 0;
      var dialog = this.element;
      $('.modal.is-visible').each(function () {
        if (max < this.style.zIndex) {
          max = this.style.zIndex;
        }
      });
      return max === dialog[0].style.zIndex;
    },

    /**
     * @returns {boolean} whether or not this Modal instance should currently display in
     * full size mode (uses the settings, but determined at runtime)
     */
    get currentlyNeedsFullsize() {
      return this.settings.fullsize === 'always' || this.settings.fullsize === 'responsive' && breakpoints.isBelow(this.settings.breakpoint);
    },

    /**
     * @returns {HTMLElement} type of things.
     */
    get closeBtn() {
      var closeBtn;
      var capAPI = this.capAPI;

      if (capAPI && capAPI.element instanceof $) {
        closeBtn = capAPI.closeButton[0];
      } else {
        closeBtn = this.element[0].querySelector('.modal-content > button.btn-close');
      }

      return closeBtn;
    },

    /**
     * @private
     */
    init: function init() {
      var self = this; // Used for tracking events tied to the Window object

      this.id = this.element.attr('id') || parseInt($('.modal').length, 10) + 1;
      this.namespace = "".concat(COMPONENT_NAME$W, "-").concat(this.id); // Find the button or anchor with same dialog ID

      this.trigger = $("[data-modal=\"".concat(this.element.attr('id'), "\"]"));

      if (this.element.is('body')) {
        this.trigger = this.element;
      }

      this.oldActive = this.settings.triggerButton ? this.useJqEl(this.settings.triggerButton) : this.trigger;

      if (this.settings.trigger === 'click' && !this.isAttachedToBody) {
        this.trigger.on("click.".concat(self.namespace), function (e) {
          if (!$(e.currentTarget).is(self.trigger)) {
            return;
          }

          self.open();
        });
      }

      if (this.settings.trigger === 'immediate') {
        var triggerImmediateTimer = new RenderLoopItem({
          duration: 1,
          timeoutCallback: function timeoutCallback() {
            self.open();
          }
        });
        renderLoop.register(triggerImmediateTimer);
      }

      self.isCancelled = false; // ensure is appended to body for new dom tree

      if (this.settings.content) {
        this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
        this.appendContent();
        var renderFromContentTimer = new RenderLoopItem({
          duration: 1,
          timeoutCallback: function timeoutCallback() {
            self.open();
          }
        });
        renderLoop.register(renderFromContentTimer);
        return;
      }

      if (this.settings.beforeShow) {
        this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
        this.appendContent();
        this.callSource();
        return;
      }

      if (this.isCAP) {
        this.addButtons(this.settings.buttons);
      } else {
        // Adds the modal buttonset, if applicable
        this.renderButtonset();
      } // Decide whether or not this Modal instance should hide when displayed
      // beneath another modal in the stack


      this.element[0].classList[this.settings.hideUnderneath ? 'add' : 'remove']('hide-underneath');
      this.registerModal();
      this.element.appendTo('body');
      this.element[0].style.display = 'none';
    },
    appendContent: function appendContent() {
      var _this = this;

      var isAppended = false;
      var maxWidth = this.settings.maxWidth ? " style=\"max-width: ".concat(this.settings.maxWidth, "px;\"") : '';
      this.element = $("\n      <div class=\"modal\">\n        <div class=\"modal-content\"".concat(maxWidth, ">\n          <div class=\"modal-header\"><h1 class=\"modal-title\"></h1></div>\n          <div class=\"modal-body-wrapper\">\n            <div class=\"modal-body\"></div>\n          </div>\n        </div>\n      </div>\n    ")); // Only draw the close button if we're not in a CAP.
      // CAP has its own rendering process for buttons, which are inside a toolbar and not
      // part of the Modal Buttonset

      if (this.settings.showCloseBtn && !this.isCAP) {
        var closeBtn = $("\n        <button type=\"button\" class=\"btn-icon btn-close\" title=\"".concat(Locale.translate('Close'), "\" aria-hidden=\"true\">\n          ").concat($.createIcon('close'), "\n          <span class=\"audible\">").concat(Locale.translate('Close'), "</span>\n        </button>\n      "));
        this.element.find('.modal-content').append(closeBtn);
        closeBtn.on("click.".concat(this.namespace), function () {
          return _this.close();
        }).tooltip();
      }

      if (this.settings.id) {
        this.element.attr('id', this.settings.id);
        utils.addAttributes(this.element, this, this.settings.attributes, '', true);
      }

      if ($(this.settings.content).is('.modal')) {
        this.element = $(this.settings.content);
        isAppended = this.element.parent().hasClass('modal-wrapper');
      } else if (this.settings.content && this.settings.content.length > 0) {
        if (this.settings.content instanceof jQuery && this.settings.content.parent().is('.modal-body')) {
          isAppended = true;
          this.element = this.settings.content.closest('.modal');
        } else {
          this.element.find('.modal-body').append(this.settings.content);
        }

        if (this.settings.content instanceof jQuery && !this.settings.beforeShow) {
          this.settings.content.removeClass('hidden is-hidden');
          this.settings.content.show();
        }
      }

      if (this.settings.beforeShow) {
        this.busyIndicator = $('<div class="overlay busy"></div>' + '<div class="busy-indicator-container blocked-ui" aria-live="polite" role="status">' + '<div class="busy-indicator active">' + '<div class="bar one"></div>' + '<div class="bar two"></div>' + '<div class="bar three"></div>' + '<div class="bar four"></div>' + '<div class="bar five"></div>' + '</div>' + '<span>Loading...</span>' + '</div>');
        $('body').append(this.busyIndicator);
      }

      if (!isAppended) {
        this.element.appendTo('body');
      }

      if (this.settings.cssClass) {
        this.element.addClass(this.settings.cssClass);
      }

      if (this.settings.title) {
        // Prevent Css on the title
        this.element.find('.modal-title')[0].innerHTML = xssUtils.stripTags(this.settings.title, '<div><span><a><small><img><svg><i><b><use><br><strong><em>');
      }

      if (!isAppended) {
        if (this.isCAP) {
          this.addButtons(this.settings.buttons);
        } else {
          // Adds the modal buttonset, if applicable
          this.renderButtonset();
        }
      }

      this.registerModal();
      utils.fixSVGIcons(this.element);
    },

    /**
     * Registers this modal component with the global Modal Manager, while setting up other links.
     * @private
     * @returns {void}
     */
    registerModal: function registerModal() {
      // If the current `element` is not the original one the component was invoked against,
      // add a second reference to this component API to the new element.
      if (!this.originalElement.is(this.element)) {
        this.originalElement.data('modalElementLink', this.element[0]);
        this.element.data('modal', this);
      } // Register the modal into the global Modal manager


      modalManager.register(this);
    },

    /**
     * Moves around the basic structure of a Modal's HTML Markup for some legacy cases.
     * @private
     * @returns {void}
     */
    reStructure: function reStructure() {
      var body = $('.modal-body', this.element);
      var hr = $('hr:first-child', body);
      var buttonset = $('.modal-buttonset', this.element);

      if (body && body.length && !body.parent().hasClass('modal-body-wrapper')) {
        body.wrap('<div class="modal-body-wrapper"></div>');
      }

      if (hr && hr.length && !hr.parent().hasClass('modal-content')) {
        hr.insertAfter(this.element.find('.modal-header'));
      }

      if (buttonset && buttonset.length && !buttonset.parent().hasClass('modal-content')) {
        buttonset.insertAfter(this.element.find('.modal-body-wrapper'));
      }
    },

    /**
     * Check if the submit button should be disabled based on validation status.
     * @private
     * @returns {void}
     */
    disableSubmit: function disableSubmit() {
      var body = this.element;
      var inlineBtns = body.find('.modal-buttonset button');
      var primaryButton = inlineBtns.filter('.btn-modal-primary').not('.no-validation');
      var dropdowns = body.find('select.dropdown[data-validate]');
      var fields = body.find('[data-validate]:visible');
      dropdowns.each(function () {
        var dropdown = $(this);

        if (dropdown.next('.dropdown-wrapper').is(':visible')) {
          fields = fields.add(this);
        }
      });

      if (fields.length > 0) {
        primaryButton.removeAttr('disabled');
        var allValid = true;
        fields.each(function () {
          var field = $(this);

          if (field.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }

          var isVisible = field.is('.dropdown') && field.next('.dropdown-wrapper').is(':visible') || field[0].offsetParent !== null;

          if (field.is('.required')) {
            if (isVisible && !field.val()) {
              allValid = false;
            }
          } else {
            field.validateField();

            if (isVisible && !field.isValid()) {
              allValid = false;
            }
          }

          if (isVisible && field.is('.error')) {
            allValid = false;
          }

          if (allValid) {
            primaryButton.removeAttr('disabled');
          }
        });

        if (!allValid && !primaryButton.is(':disabled')) {
          primaryButton.attr('disabled', 'true');
        }
      }
    },

    /**
     * Responsible for rendering a Modal Buttonset component
     * @private
     * @returns {void}
     */
    renderButtonset: function renderButtonset() {
      var _this2 = this;

      var buttons = this.settings.buttons;
      var style = 'modal';
      var targetSettings = {
        style: style
      };
      var self = this;

      if (!this.buttonsetElem) {
        var buttonsetElem = this.element.find('.modal-buttonset'); // If the ButtonSet Element doesn't exist (and it should), create it.

        if (!buttonsetElem || !buttonsetElem.length) {
          if (!Array.isArray(buttons) || !buttons.length) {
            return;
          }

          var body = this.element.find('.modal-body');
          var bodywrapper = body.parent();
          var flexText = this.settings.useFlexToolbar ? 'toolbar-section ' : '';
          var buttonsetTmpl = "<div class=\"".concat(flexText, "modal-buttonset\"></div>");
          buttonsetElem = $(buttonsetTmpl);
          buttonsetElem.insertAfter(bodywrapper);
          targetSettings.buttons = buttons;
        } else {
          targetSettings.detectHTMLButtons = true;
        } // Render the Buttonset Component


        this.buttonsetElem = buttonsetElem;
        buttonsetElem.buttonset(targetSettings);
        this.buttonsetAPI = buttonsetElem.data('buttonset'); // Change the buttons JSON used

        buttons = this.buttonsetAPI.toData().buttons;
      }

      var buttonAPIs = this.buttonsetAPI.buttons;
      var $buttons = $();
      var btnPercentWidth = 100 / buttonAPIs.length; // Make modifications to each button

      buttonAPIs.forEach(function (btn, i) {
        // Handle additional settings provided outside the
        // button API for modals, if applicable.
        var settingsJSON = Array.isArray(buttons) && buttons.length ? buttons[i] : undefined;
        var triggeredFunc = false;

        if (settingsJSON) {
          // Set a unique ID attribute if one wasn't predefined.
          btn.element[0].setAttribute('id', buttons[i].id || utils.uniqueId(btn.element, 'button', 'modal')); // Setup a user-defined click handler, if one was provided.
          // Do not attach this handler in some scenarios.

          $(btn.element).on("click.".concat(self.namespace), function (e) {
            var func = settingsJSON.click;

            if (func) {
              func.apply(self.element[0], [e, self]);
              triggeredFunc = true;
            }
          }); // Setup a click handler for specific types of buttons that are valid for
          // closing this modal instance.

          var $validCloseBtns = $(btn.element).not(['[data-ng-click]', '[ng-click]', '[onclick]', ':submit', '.btn-menu', '.btn-actions', '.colorpicker', '.fontpicker'].join(', '));
          $validCloseBtns.on("click.".concat(self.namespace), function (e) {
            if (triggeredFunc) {
              return;
            }

            if ($(e.target).is('.btn-cancel')) {
              self.isCancelled = true;
            }

            self.close();
          }); // Handle Validation

          if (settingsJSON.validate) {
            btn.element[0].classList.add('no-validation');
          }

          utils.addAttributes(btn.element, _this2, settingsJSON.attributes, '', true);
        } // In standard Modal mode, size the buttons to fit after rendering.


        btn.element[0].style.width = "".concat(btnPercentWidth, "%");
        $buttons.add(btn);
      });
    },

    /**
     * Adds buttons to a standard/flex Toolbar component (used in Contextual Action Panels)
     * @private
     * @param {array<object>} buttons an incoming array of button definitions.
     * @returns {void}
     */
    addButtons: function addButtons(buttons) {
      var self = this;
      var body = this.element.find('.modal-body');
      var bodywrapper = body.parent();
      var flexToolbar = this.element.find('.flex-toolbar');
      var btnWidth = 100;
      var isPanel = false;
      var buttonset;
      this.modalButtons = buttons;

      if (!buttons) {
        var inlineBtns = this.element.find('.modal-buttonset button'); // Buttons in markup

        btnWidth = 100 / inlineBtns.length;

        for (var i = 0, l = inlineBtns.length; i < l; i++) {
          inlineBtns[i].style.width = "".concat(btnWidth, "%");
        }

        inlineBtns.button();
        inlineBtns.not('[data-ng-click], [ng-click], [onclick], :submit').on("click.".concat(self.namespace), function (e) {
          if ($(e.target).is('.btn-cancel')) {
            self.isCancelled = true;
          }

          self.close();
        });
        return;
      }

      if (this.isCAP) {
        // CAP is responsible for rendering this part, and will have done so by the
        // time this code runs
        isPanel = true;
        buttonset = this.element.find('.buttonset');
      } else {
        buttonset = this.element.find('.modal-buttonset');

        if (!buttonset.length) {
          buttonset = $('<div class="modal-buttonset"></div>').insertAfter(bodywrapper);
        }
      }

      btnWidth = 100 / buttons.length;

      if (buttons) {
        buttonset.empty();
      }

      var decorateButtons = function decorateButtons(props, cnt) {
        var btn = $("<button type=\"button\">\n        <span></span>\n      </button>");
        var span = btn.find('span');
        span.text(props.text);
        btn.attr('type', props.type || 'button');

        if (props.cssClass === 'separator') {
          btn = $('<div class="separator"></div>');
        }

        if (props.cssClass) {
          btn.attr('class', props.cssClass);
        } else if (props.isDefault) {
          btn.addClass('btn-modal-primary');
        } else {
          btn.addClass('btn-modal');
        }

        if (props.disabled) {
          btn[0].disabled = props.disabled === true;
        }

        if (props.audible) {
          span.addClass('audible');
        }

        if (props.validate !== undefined && !props.validate) {
          btn.addClass('no-validation');
        }

        utils.addAttributes(btn, self, props.attributes, '', true);
        var attrs = {};
        var attrTypes = ['id', 'name', 'text'];

        for (var k = 0; k < attrTypes.length; k++) {
          if (props[attrTypes[k]]) {
            attrs[attrTypes[k]] = props[attrTypes[k]];
          }
        }

        if (props.type === 'input') {
          var label = $("<label class=\"audible\" for=\"filter\">".concat(props.text, "</label>"));
          var input = $('<input class="searchfield">').attr(attrs);

          if (flexToolbar.length) {
            flexToolbar.find('.toolbar-section.search').append(label, input);
          } else {
            buttonset.append(label, input);
          }

          input.searchfield(props.searchfieldSettings);
          return;
        }

        if (props.icon && props.icon.charAt(0) === '#') {
          $.createIconElement({
            classes: [props.icon === '#icon-close' ? 'icon-close' : ''],
            icon: props.icon.substr('#icon-'.length)
          }).prependTo(btn);
        }

        btn[0].setAttribute('id', props.id || utils.uniqueId(self.element, 'button', 'modal'));
        var func = buttons[cnt].click;
        btn.on("click.".concat(self.namespace), function (e) {
          if (func) {
            func.apply(self.element[0], [e, self]);
            return;
          }

          self.close();
        });

        if (!isPanel) {
          btn[0].style.width = "".concat(btnWidth, "%");
        }

        btn.button();

        if ((self.settings.useFlexToolbar || self.settings.centerTitle) && props.align) {
          if (props.align === 'left') {
            flexToolbar.find('.toolbar-section').eq(0).append(btn);
          }

          if (props.align === 'center') {
            flexToolbar.find('.toolbar-section').eq(1).find('h2').append(btn);
          }

          if (props.align === 'right') {
            flexToolbar.find('.toolbar-section').eq(2).append(btn);
          }
        } else {
          buttonset.append(btn);
        }
      };

      for (var cnt = 0; cnt < buttons.length; cnt++) {
        decorateButtons(buttons[cnt], cnt);
      }
    },

    /**
    * Size the inner content on resize.
    * @private
    * @returns {void}
    */
    sizeInner: function sizeInner() {
      var messageArea = this.element.find('.detailed-message'); // Set a max width

      var h = $(window).height() - messageArea.offset().top - 150;
      messageArea[0].style.maxHeight = "".concat(h, "px");
      messageArea[0].style.overflow = 'auto';
      messageArea[0].style.width = "".concat(messageArea.width(), "px");
    },
    callSource: function callSource() {
      if (typeof this.settings.beforeShow !== 'function') {
        return;
      }

      var self = this;

      var response = function response(content) {
        if (content === false) {
          return false;
        }

        $('#modal-busyindicator').trigger('complete.busyindicator'); // Returning `true` from the response will cause a modal area to render to the page,
        // but remain hidden.  In this scenario it will be up to the app developer to reveal
        // the modal when needed.

        if (content === true) {
          if (self.busyIndicator) {
            self.busyIndicator.remove();
            delete self.busyIndicator;
          }

          return true;
        }

        if (!(content instanceof jQuery)) {
          content = $(content);
        }

        self.open(true);
        self.element.find('.modal-body').empty();
        self.element.find('.modal-body').append(content);
        content.show();
        return true;
      };

      var callBackOpts = {};
      this.settings.beforeShow(response, callBackOpts);
    },

    /**
     * Open the modal via the api.
     * @param {boolean} ajaxReturn Flag used internally to denote its an ajax result return.
     */
    open: function open(ajaxReturn) {
      var _this3 = this;

      var messageArea = null;
      var elemCanOpen = true; // close any active tooltips

      $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

      if (this.busyIndicator) {
        this.busyIndicator.remove();
        delete this.busyIndicator;
      }

      if (this.settings.triggerButton) {
        this.oldActive = this.useJqEl(this.settings.triggerButton);
      } else if (!this.trigger || this.trigger.length === 0 || this.trigger.is('body')) {
        this.oldActive = $(':focus'); // Save and restore focus for A11Y
      } // Setup links to Modal Manager elements.


      if (!this.overlay) {
        this.overlay = $(modalManager.overlayElem);
      }

      if (!this.root) {
        this.root = $(modalManager.rootElem);
      } // Check for wrapping markup first.


      var $wrapperElem = this.element.parent();

      if (!$wrapperElem.is('.modal-wrapper')) {
        this.element.wrap('<div class="modal-wrapper"></div>');
        $wrapperElem = this.element.parent();
      } // If the parent element of the wrapper is not the `.modal-page-container`,
      // move the wrapper to the correct place.


      if (!$wrapperElem.parent().is(this.root)) {
        $wrapperElem.insertAfter(this.overlay);
      }

      messageArea = this.element.find('.detailed-message');

      if (messageArea.length === 1) {
        $('body').on("resize.".concat(this.namespace), function () {
          _this3.sizeInner();
        });
        this.sizeInner();
      }
      /**
      * Fires when the modal is about to open. You can return false to abort opening.
      * @event beforeopen
      * @memberof Modal
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */


      elemCanOpen = this.element.triggerHandler('beforeopen', [this]);
      $('body').triggerHandler('beforeopen', [this]);
      this.isCancelled = false;

      if (elemCanOpen === false) {
        return;
      }

      if (!ajaxReturn) {
        this.callSource();

        if (this.settings.beforeShow) {
          return;
        }
      } // Tell the modal manager that this instance is active


      modalManager.currentlyActive = this; // Ensure aria-labelled by points to the id

      if (this.settings.isAlert) {
        var title = this.element.find('#message-title');
        utils.addAttributes(title, this, this.settings.attributes, 'title', true);
        var messageText = this.element.find('#message-text');
        utils.addAttributes(messageText, this, this.settings.attributes, 'message', true);
        this.element.attr('aria-labelledby', title.attr('id'));
        this.element.attr('aria-describedby', messageText.attr('id'));
      } else {
        var h1 = this.element.find('h1:first');
        utils.addAttributes(h1, this, this.settings.attributes, 'title', true);
        utils.addAttributes(this.element.find('.btn-close'), this, this.settings.attributes, 'btn-close', true);
        var id = h1.attr('id');

        if (!id) {
          id = "".concat(this.element.attr('id') ? this.element.attr('id') : 'h1', "-title");
          h1.attr('id', id);
        }

        var body = this.element.find('.modal-body');
        var descById = "".concat(this.element.attr('id') ? this.element.attr('id') : 'message', "-text");
        this.element.attr('aria-labelledby', id);
        utils.addAttributes(this.element, this, this.settings.attributes, '', true); // Contextual Action Panel Case - Has a toolbar

        if (this.element.find('.toolbar .title').length) {
          this.element.find('.toolbar .title').attr('id', descById);
          this.element.attr('aria-describedby', descById);
        } else {
          body.attr('id', descById);
          this.element.attr('aria-describedby', descById);
        }
      }

      this.mainContent = $('body').children('.scrollable-container');

      if (!this.mainContent.length) {
        this.mainContent = $('body');
      }

      this.removeNoScroll = !this.mainContent.hasClass('no-scroll');
      this.mainContent.addClass('no-scroll');
      $('body').on("resize.".concat(this.namespace), function () {
        _this3.resize();
      }); // Center

      this.element[0].style.display = ''; // Stagger the rest of the Modal "show" process in several renderLoop ticks

      var self = this;
      var resizeTimer = new RenderLoopItem({
        duration: 1,
        timeoutCallback: function timeoutCallback() {
          self.resize();
          self.element.attr('role', self.settings.isAlert ? 'alertdialog' : 'dialog');
          self.element.attr('aria-modal', 'true'); // This is a forward thinking approach, since aria-modal isn't actually supported by browsers or ATs yet
        }
      });
      var displayTimer = new RenderLoopItem({
        duration: modalManager.modalFadeDuration,
        timeoutCallback: function timeoutCallback() {
          self.visible = true;
        }
      });
      renderLoop.register(resizeTimer);
      renderLoop.register(displayTimer); // Handle Default button.

      $(this.element).on("keypress.".concat(this.namespace), function (e) {
        var target = $(e.target);

        if (target.is('.editor, .searchfield, textarea, :button') || target.closest('.tab-list').length || $('#dropdown-list').length) {
          return;
        }

        if (e.which === 13 && _this3.isOnTop && !target.closest('form').find(':submit').length && _this3.element.find('.btn-modal-primary:enabled').length) {
          e.stopPropagation();
          e.preventDefault();

          if (!target.hasClass('fileupload') && !$(target).is(':input') || target.hasClass('colorpicker')) {
            _this3.element.find('.btn-modal-primary:enabled').trigger('click');
          }
        }
      }); // Override this page's skip-link default functionality to instead focus the top
      // of this element if it's clicked.

      $('.skip-link').on("focus.".concat(this.namespace), function (e) {
        e.preventDefault();

        _this3.element.find(':focusable').first().focus();
      });

      function callOpenEvent(thisElem) {
        /**
        * Fires when the modal opens.
        * @event open
        * @memberof Modal
        * @property {object} event - The jquery event object
        * @property {object} ui - The dialog object
        */
        self.element.trigger('open', [thisElem]);
      }

      function focusElement(thisElem) {
        if (!self.settings.autoFocus) {
          return;
        } // When changes happen within the subtree on the Modal, rebuilds the internal hash of
        // tabbable elements used for retaining focus.


        self.changeObserver = new MutationObserver(function () {
          self.setFocusableElems();
        });
        self.changeObserver.observe(self.element[0], {
          childList: true,
          subtree: true
        });
        self.setFocusableElems();
        var focusElem = $(self.focusableElems).not('.modal-header .searchfield').first();

        if (focusElem.length === 0) {
          focusElem = thisElem.element.find('.btn-modal-primary');
        }

        if (focusElem.length === 1 && focusElem.is('.btn-modal')) {
          focusElem = thisElem.element.find('.btn-modal-primary');
        } // Making default focus when there's no default button set
        // for non contextual action panel.


        if (!self.capAPI && self.buttonsetAPI) {
          if (thisElem.buttonsetElem.find('.btn-modal-primary').length === 0) {
            var firstBtn = $('.modal-buttonset button')[0];
            focusElem = thisElem.buttonsetElem.find(firstBtn);
          }
        } // If the selected element is anchor, it should focus the element.


        if (focusElem.is('.modal-wrapper a')) {
          focusElem = thisElem.element.find('.modal-content .message a').removeClass('hide-focus');
        } // If the selected element is a tab, actually make sure it's the "selected" tab.


        var selected;
        var tabParent;

        if (focusElem.is('.tab:not(.is-selected) a')) {
          tabParent = focusElem.closest('.tab-container');
          selected = tabParent.find('.is-selected');

          if (selected.length) {
            focusElem = selected;
            tabParent.data('tabs').select(selected.children('a').attr('href'));
            return;
          }
        } // Otherwise, just focus


        focusElem.focus();
      }

      var pagerElem = this.element.find('.paginated');
      pagerElem.on("afterpaging.".concat(this.namespace), function () {
        _this3.resize();
      });
      var disableSubmitTimer = new RenderLoopItem({
        duration: 5,
        timeoutCallback: function timeoutCallback() {
          self.disableSubmit();
        }
      });
      renderLoop.register(disableSubmitTimer);
      var fields = this.element.find('[data-validate]');
      fields.removeClass('disable-validation');
      var focusElementTimer = new RenderLoopItem({
        duration: 20,
        timeoutCallback: function timeoutCallback() {
          callOpenEvent(self);
          focusElement(self);
        }
      });
      renderLoop.register(focusElementTimer);
      /**
      * Fires after the modal has opened.
      * @event afteropen
      * @memberof Modal
      * @property {object} event - The jquery event object
      * @property {object} ui - The dialog object
      */

      var afterOpenTimer = new RenderLoopItem({
        duration: 30,
        timeoutCallback: function timeoutCallback() {
          self.element.trigger('afteropen');
        }
      });
      renderLoop.register(afterOpenTimer);
    },
    resize: function resize() {
      var calcHeight;
      var calcWidth;
      var currentlyNeedsFullsize = this.currentlyNeedsFullsize; // Set the height of the inner frame to fit and accommodate headers/button rows.
      // If `fullsize` is not false, stretch the calculated size accordingly

      if (currentlyNeedsFullsize) {
        this.element[0].classList.add('display-fullsize');
      } else {
        this.element[0].classList.remove('display-fullsize');
        calcHeight = $(window).height() * 0.9 - this.settings.frameHeight;
        calcWidth = $(window).width() * 1 - this.settings.frameWidth;
      }

      var wrapper = this.element.find('.modal-body-wrapper');

      if (wrapper.length) {
        if (currentlyNeedsFullsize) {
          wrapper[0].style.maxHeight = '';
          wrapper[0].style.maxWidth = '';
        } else {
          wrapper[0].style.maxHeight = "".concat(calcHeight, "px");
          wrapper[0].style.maxWidth = "".concat(calcWidth, "px");
        }
      }

      if (this.element.hasClass('lookup-modal')) {
        var table = this.element.find('.datagrid-wrapper');
        var hasPager = this.element.find('.pager-toolbar');
        var container = table.closest('.datagrid-container');
        calcHeight = calcHeight - (container.prev().is('.toolbar') ? 130 : 67) - (container.next().is('.pager-toolbar') ? 35 : 0) + (hasPager.length ? -15 : 0);

        if (currentlyNeedsFullsize) {
          table[0].style.maxHeight = '';
          table[0].style.maxWidth = '';
        } else {
          table[0].style.maxHeight = "".concat(calcHeight, "px");
          table[0].style.maxWidth = "".concat(calcWidth, "px");
        }
      }

      if (this.element.hasClass('datagrid-columns-dialog')) {
        wrapper[0].style.overflow = 'hidden';

        if (calcHeight > 220) {
          this.element.find('.modal-body')[0].style.height = '';
          this.element.find('.listview.alternate-bg')[0].style.maxHeight = '';
          this.element.find('.listview.alternate-bg')[0].style.height = '';
          this.element.find('.listview.alternate-bg')[0].style.minHeight = '';
        } else {
          this.element.find('.modal-body')[0].style.height = "".concat(calcHeight, "px");
          this.element.find('.listview.alternate-bg')[0].style.maxHeight = "".concat(calcHeight - 41, "px");
          this.element.find('.listview.alternate-bg')[0].style.height = "".concat(calcHeight - 41, "px");
          this.element.find('.listview.alternate-bg')[0].style.minHeight = 0;
        }
      }

      var toolbars = this.element.find('.toolbar');

      if (toolbars.length) {
        toolbars.triggerHandler('recalculate-buttons');
      }
    },

    /**
     * This method is slated to be removed in a future v4.20.0 or v5.0.0.
     * @deprecated as of v4.14.0. Please use the `visible` property instead.
     * @returns {boolean} The current state open (true) or closed (false).
     */
    isOpen: function isOpen() {
      warnAboutDeprecation('visible', 'isOpen');
      return this.visible;
    },

    /**
     * Reports to a consumer a list of IDS components contained by this Modal, that are also currently
     * reporting as "open".  This is used to determine if it's OK to close the Modal or not.
     * @returns {array} containing references to IDS subcomponent APIs inside this modal that
     * are currently reporting as "open"
     */
    get openSubComponents() {
      var elems = this.element.find('*');
      var subComponentTypes = ['datepicker', 'dropdown', 'popupmenu', 'timepicker', 'tooltip'];
      var targetProps = ['isOpen', 'visible'];
      var matchedSubComponentAPIs = findComponentsOnElements(elems, targetProps, subComponentTypes);
      var openSubComponents = [];
      matchedSubComponentAPIs.forEach(function (matchObj) {
        var componentAPI = matchObj.control;

        if (typeof componentAPI.isOpen === 'function' && componentAPI.isOpen() || typeof componentAPI.isOpen === 'boolean' && componentAPI.isOpen === true || typeof componentAPI.visible === 'boolean' && componentAPI.visible === true) {
          openSubComponents.push(componentAPI);
        }
      });
      return openSubComponents;
    },

    /**
     * @returns {boolean} whether or not the Modal itself, or a component inside the Modal, currently has focus.
     * In some cases, this needs to get access to child components to determine focus state.
     */
    get isFocused() {
      var componentHasFocus = false;
      var activeElem = document.activeElement;

      if (!this.focusableElems) {
        this.setFocusableElems();
      } // Check each match for IDS components that may have a more complex focus routine
      // NOTE: Some elements that come through may be SVGs, careful which methods are used.


      this.focusableElems.forEach(function (elem) {
        if (componentHasFocus) {
          return;
        } // Check the base element


        var $elem = $(elem);

        if ($elem.is($(activeElem)) || typeof elem.contains === 'function' && elem.contains(activeElem)) {
          componentHasFocus = true;
        } // Dropdown/Multiselect


        if ($elem.is('div.dropdown, div.multiselect')) {
          var _$elem$parent$prev$da;

          componentHasFocus = (_$elem$parent$prev$da = $elem.parent().prev('select').data('dropdown')) === null || _$elem$parent$prev$da === void 0 ? void 0 : _$elem$parent$prev$da == null ? void 0 : _$elem$parent$prev$da.isFocused;
        } // Lookup


        if ($elem.is('.lookup')) {
          var _$elem$data;

          componentHasFocus = (_$elem$data = $elem.data('lookup')) === null || _$elem$data === void 0 ? void 0 : _$elem$data == null ? void 0 : _$elem$data.isFocused;
        } // Popupmenu


        if ($elem.is('.btn-menu, .btn-actions')) {
          var _$elem$data2;

          componentHasFocus = (_$elem$data2 = $elem.data('popupmenu')) === null || _$elem$data2 === void 0 ? void 0 : _$elem$data2 == null ? void 0 : _$elem$data2.isFocused;
        } // Searchfield


        if ($elem.is('.searchfield')) {
          var _$elem$data3;

          componentHasFocus = (_$elem$data3 = $elem.data('searchfield')) === null || _$elem$data3 === void 0 ? void 0 : _$elem$data3 == null ? void 0 : _$elem$data3.isFocused;
        }
      }); // Check to see if a Popover/Tooltip has focus, and if that component's parent
      // element is inside the Modal

      var tooltipParents = $(activeElem).parents('.tooltip, .popover');

      if (tooltipParents.length) {
        tooltipParents.each(function (i, elem) {
          var api = $(elem).data('tooltip');

          if (api && api.isFocused) {
            componentHasFocus = true;
          }
        });
      }

      return componentHasFocus;
    },

    /**
     * Creates an internal reference for all tabbable elements present within the Modal.
     * @private
     * @returns {void}
     */
    setFocusableElems: function setFocusableElems() {
      var extraSelectors = ['div.dropdown', 'div.multiselect'];
      var ignoredSelectors = ['select', 'option'];
      var elems = DOM.focusableElems(this.element[0], extraSelectors, ignoredSelectors);
      this.focusableElems = elems;
      this.focusableElems.first = elems[0];
      this.focusableElems.last = elems[elems.length - 1];
    },

    /**
     * Focuses special elements within the modal.
     * @param {string} place the location to set the Modal's current focus
     */
    setFocus: function setFocus(place) {
      var places = ['last', 'first'];

      if (places.indexOf(place) === -1) {
        return;
      }

      if (!this.focusableElems) {
        this.setFocusableElems();
      }

      var target;

      switch (place) {
        case 'last':
          target = this.focusableElems.last;
          break;

        case 'first':
          target = this.focusableElems.first;
          break;
      }

      if (target) {
        target.focus();
        target.classList.remove('hide-focus');
      }
    },

    /**
     * Close the modal.
     * @param {boolean} destroy Call the destroy method.
     * @param {boolean} [noRefresh=false] if true, prevents the ModalManager from refreshing state when the close is complete.
     * @param {boolean} [force = false] if true, forces the modal closed and ignores open subcomponents/visibility.
     * @returns {boolean} If the dialog was open returns false. If the dialog was closed is true.
     */
    close: function close(destroy, noRefresh) {
      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!force && (!this.visible || this.openSubComponents.length)) {
        return true;
      }

      var elemCanClose = this.element.triggerHandler('beforeclose');

      if (elemCanClose === false) {
        return false;
      }

      var self = this;
      var fields = this.element.find('[data-validate]');
      fields.addClass('disable-validation');

      if (this.changeObserver) {
        this.changeObserver.disconnect();
        delete this.changeObserver;
      }

      if (this.isCAP) {
        this.element.addClass('is-animating');
      }

      if (this.mainContent && this.removeNoScroll) {
        this.mainContent.removeClass('no-scroll');
      }

      $('body').off("resize.".concat(this.namespace, " focusin.").concat(self.namespace));
      this.element.off("keypress.".concat(this.namespace, " keydown.").concat(this.namespace));
      this.visible = false;
      this.active = false;
      delete this.dontCheckFocus; // Fire Events

      self.element.trigger('close', self.isCancelled);

      if (!this.settings.noRefocus && this.isFocused) {
        document.activeElement.blur();
      } // close tooltips


      $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');
      var closeBtn = $(this.closeBtn);
      var closeBtnTooltipAPI = closeBtn.data('tooltip');

      if (closeBtnTooltipAPI) {
        closeBtnTooltipAPI.hide();
        closeBtnTooltipAPI.reopenDelay = true;
      } // remove the event that changed this page's skip-link functionality in the open event.


      $('.skip-link').off("focus.".concat(this.namespace));
      var afterCloseTimer = new RenderLoopItem({
        duration: modalManager.modalFadeDuration,
        timeoutCallback: function timeoutCallback() {
          self.element.trigger('afterclose');

          if (closeBtnTooltipAPI) {
            delete closeBtnTooltipAPI.reopenDelay;
          }

          if (self.settings.trigger === 'immediate' || destroy) {
            if (!self.isCAP || self.isCAP && !self.capAPI) {
              self.destroy();
            }
          }

          if (!noRefresh) {
            modalManager.refresh();
          } // Restore focus to the correct element.


          if (!self.settings.noRefocus) {
            if (!self.oldActive && self.settings.triggerButton) {
              self.oldActive = self.useJqEl(self.settings.triggerButton);
            }

            if (self.oldActive && $(self.oldActive).is('a:visible, button:visible, input:visible, textarea:visible')) {
              self.oldActive.focus();
            } else if (self.trigger.parents('.toolbar, .formatter-toolbar').length < 1) {
              self.trigger.focus();
            }
          }
        }
      });
      renderLoop.register(afterCloseTimer);
      return false;
    },

    /**
     * Use input as jquery element
     * @param {htmlObject|jqueryObject|srting} option This option can be html or jquery object or query selector as string
     * @returns {object} The jquery element.
     */
    useJqEl: function useJqEl(option) {
      return option instanceof jQuery ? option : $(option);
    },

    /**
     * Update the modal
     * @param {settings} settings The settings to update on the modal
     * @returns {object} The modal object for chaining.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
        this.settings = handleModalDefaults(this.settings);
      }

      if (this.settings.trigger === 'immediate') {
        this.open();
      }

      return this;
    },

    /**
     * Destroy the modal.
     */
    destroy: function destroy() {
      var self = this;
      var canDestroy = this.element.trigger('beforedestroy');

      if (!canDestroy) {
        return;
      }

      function destroyCallback() {
        self.trigger.off("click.".concat(self.namespace));
        self.element.off("keypress.".concat(self.namespace, " keydown.").concat(self.namespace, " beforeclose.").concat(self.namespace, " afterclose.").concat(self.namespace));
        self.element.find('button, .btn-close').off("click.".concat(self.namespace));
        self.element.find('.paginated').off("afterpaging.".concat(self.namespace));
        $('.skip-link').off("focus.".concat(self.namespace));
        $('body').off("resize.".concat(self.namespace));
        $(self.element).off("keydown.".concat(self.namespace));

        if (self.element.find('.detailed-message').length === 1) {
          $('body').off("resize.".concat(self.namespace));
        } // Properly teardown contexual action panels


        if (self.isCAP && self.capAPI) {
          self.capAPI.destroy();
        }

        if (self.aboutAPI) {
          self.aboutAPI.destroy(true);
        } // If a buttonset exists, remove events and destroy completely.


        if (self.buttonsetAPI) {
          self.buttonsetAPI.buttons.forEach(function (button) {
            $(button.element).off("click.".concat(self.namespace));
          });
          self.buttonsetAPI.destroy();
          self.buttonsetElem.remove();
          delete self.buttonsetAPI;
          delete self.buttonsetElem;
        }

        delete self.focusableElems;
        self.trigger.off("click.".concat(self.namespace));
        self.element[0].removeAttribute('data-modal');
        var $wrapperElem = self.element.parent('.modal-wrapper');

        if ($wrapperElem.length) {
          $wrapperElem.remove();
        }

        var destroyTimer = new RenderLoopItem({
          duration: 21,
          // should match the length of time needed for the overlay to fade out
          timeoutCallback: function timeoutCallback() {
            var elem = null;
            var modalApi = self.element ? self.element.data(COMPONENT_NAME$W) : null;

            if (modalApi) {
              elem = self.element[0];
            } else {
              modalApi = self.trigger ? self.trigger.data(COMPONENT_NAME$W) : null;

              if (modalApi) {
                elem = self.trigger[0];
              }
            }

            if (elem && modalApi && modalApi.overlay) {
              $.removeData(elem, COMPONENT_NAME$W);
            }
          }
        });
        renderLoop.register(destroyTimer); // Remove this modal instance from the global Modal manager.

        modalManager.unregister(self); // If the current `element` is not the original one the component was invoked against,
        // remove the second reference to this component API on the new element.

        if (self.originalElement instanceof $) {
          $.removeData(self.originalElement[0], 'modalElementLink');
        }

        $.removeData(self.element[0], COMPONENT_NAME$W);
      }

      if (!this.visible) {
        destroyCallback();
        return;
      }

      this.element.one("afterclose.".concat(self.namespace), function () {
        destroyCallback();
      });
      this.close(true);
    }
  };

  /**
   * The Message Component is used to show warning / error messages.
   * @class Message
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @param {string} [settings.title='Message Title']  Title text or content shown in the message. An HTML string containing the follow tags may also be used `<div><span><a><small><img><svg><i><b><use><br><strong><em>`.
   * @param {string} [settings.status='']  Pass a status to style icon and title color ('error', 'alert', 'success')
   * @param {string} [settings.message='Message Summary']  The message content or text
   * @param {number} [settings.width='auto']  Pass a specific with or defaults to auto
   * @param {object} [settings.buttons=null]  Array of buttons to add to the message (see modal examples as well)
   * @param {string} [settings.cssClass=null]  Extra Class to add to the dialog for customization.
   * @param {string} [settings.returnFocus=null]  JQuery Element selector to focus on return.
   * @param {string} [settings.allowedTags='<a><b><br><br/><del><em><i><ins><mark><small><strong><sub><sup>']  String of allowed HTML tags.
   * @param {string} [settings.audibleLabel='']  String to include in message title that is strictly audible.
   * @param {string} [settings.overlayOpacity=0.7] Adds the ability to control the opacity of the background overlay.
   * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
   * @param {boolean} [settings.noRefocus=false] If true, causes the modal's trigger element not to become focused once the modal is closed.
  */

  var MESSAGE_DEFAULTS = {
    title: 'Message Title',
    status: '',
    message: 'Message Summary',
    width: 'auto',
    buttons: null,
    cssClass: null,
    returnFocus: null,
    allowedTags: '<a><b><br><br/><del><em><i><ins><mark><small><strong><sub><sup>',
    audibleLabel: '',
    overlayOpacity: 0.7,
    hideUnderneath: false,
    attributes: null,
    noRefocus: false
  };

  function Message(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(element, settings, MESSAGE_DEFAULTS);
    this.init();
  }

  Message.prototype = {
    init: function init() {
      var self = this;
      var content;
      var tags = this.settings.allowedTags;
      var allowTags = true; // Check for any allowed tags in settings string

      if (!(this.settings.allowedTags.length > 0)) {
        allowTags = false;
      } // Create the Markup


      this.message = $('<div class="modal message"></div>');
      this.messageContent = $('<div class="modal-content"></div>');
      this.title = $("<h1 class=\"modal-title\" id=\"message-title\">".concat(allowTags ? xssUtils.stripTags(this.settings.title, tags) : xssUtils.stripHTML(this.settings.title), "</h1>")).appendTo(this.messageContent).wrap('<div class="modal-header"></div>');
      this.content = $("<div class=\"modal-body\"><div class=\"message\" id=\"message-text\">".concat(allowTags ? xssUtils.stripTags(this.settings.message, tags) : xssUtils.stripHTML(this.settings.message), "</div></div>")).appendTo(this.messageContent);

      if (this.settings.audibleLabel !== '') {
        this.title.prepend("<span class=\"audible\">".concat(Locale.translate(this.settings.audibleLabel), "</span>"));
      } // Append The Content if Passed in


      if (!this.element.is('body')) {
        content = this.element;
        this.content.empty().append(content.show());
      }

      this.message.append(this.messageContent).appendTo('body');
      this.message.modal({
        trigger: 'immediate',
        buttons: this.settings.buttons,
        resizable: this.settings.resizable,
        close: this.settings.close,
        isAlert: true,
        overlayOpacity: this.settings.overlayOpacity,
        hideUnderneath: this.settings.hideUnderneath,
        attributes: this.settings.attributes,
        noRefocus: this.settings.noRefocus
      }); // Adjust Width if Set as a Setting

      if (this.settings.width !== 'auto') {
        this.content.closest('.modal')[0].style.maxWidth = 'none';
        this.content.closest('.modal')[0].style.width = this.settings.width + (/(px|%)/i.test("".concat(this.settings.width)) ? '' : 'px');
      }

      if (this.settings.cssClass) {
        this.message.addClass(this.settings.cssClass);
      } // Setup the destroy event to fire on close.
      // Needs to fire after the "close" event on the modal.


      this.message.on('beforeclose.message', function () {
        var ok = self.element.triggerHandler('beforeclose');
        return ok;
      }).on('beforeopen.message', function () {
        var ok = self.element.triggerHandler('beforeopen');
        return ok;
      }).on('open.message', function () {
        self.element.trigger('open');
      }).on('afterclose.message', function () {
        self.destroy();

        if (self.settings.returnFocus) {
          self.settings.returnFocus.focus();
        }

        $(document).off('keypress.message keydown.message');
      });
      $(document).on('keypress.message keydown.message', function (e) {
        var keyCode = e.which || e.keyCode;

        if (keyCode === 27) {
          setTimeout(function () {
            var modalData = self.message.data('modal');

            if (modalData !== undefined) {
              modalData.close();
            }
          }, 0);
        }
      });

      if (this.settings.status === 'error') {
        this.title.addClass('has-status is-error').prepend($.createIconElement('error'));
      } else if (this.settings.status === 'alert') {
        this.title.addClass('has-status is-alert').prepend($.createIconElement('alert'));
      } else if (this.settings.status === 'success') {
        this.title.addClass('has-status is-success').prepend($.createIconElement('success'));
      } else {
        this.title.removeClass('has-status is-error is-alert is-success').find('svg').remove();
      }
    },
    destroy: function destroy() {
      var modalData = this.message.data('modal');

      if (modalData !== undefined) {
        modalData.destroy();
      }

      this.message.off('beforeclose.message beforeopen.message open.message afterclose.message').remove();
    }
  };

  /**
   * jQuery Component Wrapper for Messages
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.message = function (settings) {
    // Support Chaining and Init the Control or Set Settings
    return this.each(function () {
      return new Message(this, settings);
    });
  };

  /**
  * jQuery Component Wrapper for Modal
  * @param {object} settings The settings to apply.
  * @returns {jQuery[]} The jquery object for chaining.
  */

  $.fn.modal = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$W);
      var elem = $(this);

      if (!elem.is('.modal')) {
        instance = elem.closest('.modal').data(COMPONENT_NAME$W);
      }

      if (instance && settings) {
        instance.updated(settings); // This was added for backwards compatability when using:
        // `$(this).modal('close');`
        // Examples have been updated to not show this.

        if (typeof instance[settings] === 'function') {
          instance[settings]();
        }

        return;
      }

      if (instance && !settings) {
        return;
      }

      instance = $.data(this, COMPONENT_NAME$W, new Modal(this, settings));
    });
  };

  /**
   * jQuery Component Wrapper for MonthView
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.monthview = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$A);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$A, new MonthView(this, settings));
      }
    });
  };

  var COMPONENT_NAME$X = 'multiselect'; // Component Defaults

  var MULTISELECT_DEFAULTS = {
    closeOnSelect: false,
    empty: true,
    filterMode: 'contains',
    maxSelected: undefined,
    moveSelected: 'all',
    multiple: true,
    showEmptyGroupHeaders: false,
    showSelectAll: false,
    showTags: false,
    source: undefined,
    allTextString: null,
    selectedTextString: null
  };
  /**
   * The MultiSelect Component allows selecting multiple items from a list
   * @class MultiSelect
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {string} [settings.filterMode = 'contains']  The search mode to use, can be 'contains' or 'startsWith'
   * @param {number} [settings.maxSelected = null]  The max number of items which can be selected
   * @param {string} [settings.moveSelected = 'all']   Move selected options in each group to just underneath their corresponding group headers.
   * @param {boolean} [settings.showEmptyGroupHeaders = false]  If true groups with no items will still show the empty group header.
   * @param {boolean} [settings.showSelectAll = false]  Show the select all button and text .
   * @param {function} [settings.source]  The calback for ajax.
   * @param {string} [settings.allTextString]  Custom text string for `All` text header.
   * @param {string} [settings.selectedTextString]  Custom text string for `Selected` text header.
   */

  function MultiSelect(element, settings) {
    this.settings = utils.mergeSettings(element, settings, MULTISELECT_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  MultiSelect.prototype = {
    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.build();
    },

    /**
     * @private
     * @returns {void}
     */
    build: function build() {
      this.element.dropdown(this.settings);
      this.dropdown = this.element.data('dropdown');
      return this;
    },

    /**
     * Enable the multiselect input
     * @returns {void}
     */
    enable: function enable() {
      this.dropdown.enable();
    },

    /**
    * Disable the multiselect input
    * @returns {void}
    */
    disable: function disable() {
      this.dropdown.disable();
    },

    /**
    * Trigger a rebuild due to settings change
    * @param {object} [settings] incoming settings
    * @returns {void}
    */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.build();
    },

    /**
     * Remove added markup and events
     * @returns {void}
     */
    destroy: function destroy() {
      this.dropdown.destroy();
      this.element.off();
      $.removeData(this.element[0], COMPONENT_NAME$X);
    }
  };

  /**
   * jQuery Component wrapper for Multiselect
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.multiselect = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$X);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$X, new MultiSelect(this, settings));
      }
    });
  };

  var COMPONENT_NAME$Y = 'notification';
  var NOTIFICATION_DEFAULTS = {
    message: 'Hi! Im a notification message.',
    type: 'alert',
    parent: '.header',
    link: '#',
    linkText: 'Click here to view.',
    attributes: null
  };
  /**
   * Notification - Shows a slide in notifcation banner on the top of the page.
   * @class Notification
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {string} [settings.message] The text message to show in the notification.
   * @param {string} [settings.type] The message type, this influences the icon and color, possible types are 'error', 'alert', 'info' and 'success'
   * @param {string} [settings.parent] The jQuery selector to find where to insert the message into (prepended). By default this will appear under the .header on the page.
   * @param {string} [settings.link] The url to use for the hyperlink
   * @param {string} [settings.linkText] The text to show in the hyperlink. Leave empty for no link.
   * @param {string} [settings.attributes=null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  function Notification(element, settings) {
    this.settings = utils.mergeSettings(element, settings, NOTIFICATION_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  Notification.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The Notification prototype, useful for chaining.
     */
    init: function init() {
      return this.build().handleEvents();
    },

    /**
     * Add any needed markup to the component.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    build: function build() {
      this.notificationEl = document.createElement('div'); // IE 10/11 does not support multiple paramets for classList.add()

      this.notificationEl.classList.add('notification');
      this.notificationEl.classList.add(this.settings.type);
      var htmlIcon = "\n      <svg class=\"icon notification-icon icon-".concat(this.settings.type, "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n        <use href=\"#icon-").concat(this.settings.type, "\"></use>\n      </svg>");
      var htmlText = "<p class=\"notification-text\">".concat(this.settings.message);

      if (this.settings.linkText) {
        htmlText += "<a class=\"notification-link\" href=\"".concat(this.settings.link, "\">").concat(this.settings.linkText, "</a>");
      }

      htmlText += '</p>';
      var htmlButton = "\n      <button type=\"text\" class=\"notification-close\">\n        <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n          <use href=\"#icon-close\"></use>\n        </svg>\n        <span class=\"audible\">".concat(Locale.translate('Close'), "</span>\n      </button>");
      this.notificationEl.innerHTML = htmlIcon.concat(htmlText, htmlButton);
      var parentEl = document.querySelector(this.settings.parent);
      parentEl.parentNode.insertBefore(this.notificationEl, parentEl.nextSibling);
      $(this.notificationEl).animateOpen();
      utils.addAttributes($(this.notificationEl), this, this.settings.attributes);
      utils.addAttributes($(this.notificationEl).find('.notification-icon'), this, this.settings.attributes, 'icon');
      utils.addAttributes($(this.notificationEl).find('.notification-text'), this, this.settings.attributes, 'text');
      utils.addAttributes($(this.notificationEl).find('.notification-text a'), this, this.settings.attributes, 'link');
      utils.addAttributes($(this.notificationEl).find('button.notification-close'), this, this.settings.attributes, 'btn-close');
      utils.addAttributes($(this.notificationEl).find('button.notification-close .icon'), this, this.settings.attributes, 'icon-close');
      return this;
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.element.off("updated.".concat(COMPONENT_NAME$Y)).on("updated.".concat(COMPONENT_NAME$Y), function () {
        self.updated();
      });
      $(this.notificationEl).off("click.".concat(COMPONENT_NAME$Y)).on("click.".concat(COMPONENT_NAME$Y), '.notification-close', function () {
        self.destroy();
      });
      return this;
    },

    /**
     * Handle updated settings and values.
     * @param {object} [settings] incoming settings
     * @returns {object} [description]
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, NOTIFICATION_DEFAULTS);
      }

      return this.teardown().init();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off("updated.".concat(COMPONENT_NAME$Y));
      this.element.off("click.".concat(COMPONENT_NAME$Y), '.notification-close');
      return this;
    },

    /**
     * Destroy and remove added markup and detatch events.
     */
    destroy: function destroy() {
      if (this.notificationEl && this.notificationEl.parentNode) {
        this.notificationEl.parentNode.removeChild(this.notificationEl);
      }

      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$Y);
    }
  };

  /**
   * jQuery Component Wrapper for notification
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.notification = function (settings) {
    return this.each(function () {
      $.data(this, COMPONENT_NAME$Y, new Notification(this, settings));
    });
  };

  var COMPONENT_NAME$Z = 'progress'; // Default Progress Options

  var PROGRESS_DEFAULTS = {
    value: 0
  };
  /**
  * A list of items with add/remove/delete and sort functionality.
  * @class Progress
  * @constructor
  * @param {jQuery[]|HTMLElement} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string|number} [settings.value] The value to set.
  */

  function Progress(element, settings) {
    this.settings = utils.mergeSettings(element, settings, PROGRESS_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Actual Progress Code


  Progress.prototype = {
    /**
     * Init this component.
     * @private
     * @returns {object} The object for chaining.
     */
    init: function init() {
      var _this = this;

      this.update(this.settings.value || this.element.attr('data-value'));
      this.element.off('updated.progress').on('updated.progress', function (e) {
        e.stopPropagation();

        _this.update();
      });
      return this;
    },

    /**
     * Update the aria on this component
     * @private
     * @param  {string} value The progress value.
     */
    updateAria: function updateAria(value) {
      var _this2 = this;

      this.element.attr({
        role: 'progressbar',
        'aria-valuenow': value,
        'aria-valuemax': '100'
      });
      var container = this.element.parent();
      this.tooltipApi = this.tooltipApi || container.data('tooltip');

      if (this.tooltipApi) {
        this.tooltipApi.content = "".concat(value, "%");

        if (this.tooltipApi.visible && value <= 100 && this.tooltipApi.tooltip.hasClass("process".concat(this.tooltipId))) {
          this.tooltipApi.tooltip.find('.tooltip-content').text(this.tooltipApi.content);
        }
      } else {
        container[0].setAttribute('title', "".concat(value, "%"));
        container.tooltip();
        this.tooltipApi = container.data('tooltip');
        this.tooltipId = this.tooltipApi.uniqueId;
        container.on('aftershow.progress', function () {
          _this2.tooltipApi.tooltip.addClass("process".concat(_this2.tooltipId));
        }).on('hide.progress mouseout.progress', function () {
          _this2.tooltipApi.tooltip.removeClass("process".concat(_this2.tooltipId));
        });
      }
    },

    /**
     * Unbind all events.
     * @private
     * @returns {object} The object for chaining.
     */
    unbind: function unbind() {
      var container = this.element.parent();
      container.off('aftershow.progress hide.progress mouseout.progress');
      this.tooltipApi = this.tooltipApi || container.data('tooltip');

      if (this.tooltipApi) {
        this.tooltipApi.destroy();
        delete this.tooltipApi;
      }

      if (this.tooltipId) {
        delete this.tooltipId;
      }

      this.element.off('updated.progress');
      return this;
    },

    /**
    * Update the progress bar.
    * @param {string} value  The percent value to use to fill. 0-100
    * @returns {void}
    */
    update: function update(value) {
      var percent = this.element[0].getAttribute('data-value') || 0;

      if (/number|string/.test(_typeof(value))) {
        this.element[0].setAttribute('data-value', value);
        percent = value;
      }

      this.element[0].style.width = "".concat(percent, "%");
      this.updateAria(percent);
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined' && settings.value) {
        this.settings.value = settings.value;
      }

      return this.unbind().init();
    },

    /**
    * Teardown and remove any added markup and events.
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$Z);
    }
  };

  /**
   * jQuery Component Wrapper for Progress
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.progress = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$Z);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$Z, new Progress(this, settings));
      }
    });
  };

  // Component Name

  var COMPONENT_NAME$_ = 'popdown';
  var loopDuration = 30;
  /**
   * The Popdown Component can be used to open an animated popdown from a button. This may in the future
   * be deprecated to one thing. Popup vs Popdown vs Tooltip.
   * @class Popdown
   * @deprecated as of v4.20.0. Please use the `Popover` component instead.
   * @param {object} element The component element.
   * @param {object} [settings] The component settings.
   * @property {boolean} [settings.keepOpen = false] If true, will keep the Popdown open after clicking out until the Trigger
   * element is clicked, or until another pop-open element is opened.
   * @property {jQuery[]} [settings.trigger] If defined, provides a way to place the popdown against an alternate element.
   * @param {boolean} [settings.autoFocus=false] If true, when the popdown is opened, the first available input/button in its content area will be focused.
   * @param {boolean} [settings.toggleOnFocus=false] If true, popdown will be toggle soon focused on the popdown trigger.
   * @param {function|boolean|object} [settings.firstLastTab=null] it can have three way to tab or shift-tab to first/last input/select/textarea in popdown.
   * If given value is function it will be call back that goes along with first/last tab in/out.
   * If given value is boolean and true it will run the default function `closeAndContinue`.
   * If given value is object it can have key/value `first`, `last`, `callback` as:
   * first - jQuery[]|string, first element to bind with tab in/out.
   * last - jQuery[]|string, last element to bind with tab in/out.
   * callback - function, a call back that goes along with first/last tab in/out.
  */

  var POPDOWN_DEFAULTS = {
    keepOpen: false,
    trigger: undefined,
    autoFocus: false,
    toggleOnFocus: false,
    firstLastTab: null
  };

  function Popdown(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, POPDOWN_DEFAULTS);
    this.init();
    warnAboutDeprecation('Popover', 'Popdown');
  }

  Popdown.prototype = {
    init: function init() {
      return this.setup().build().handleEvents();
    },
    setup: function setup() {
      var self = this;
      this.popdown = $(); // Setup the proper trigger element to use

      this.trigger = this.element;

      if (this.settings.trigger instanceof $ || DOM.isElement(this.settings.trigger)) {
        this.trigger = $(this.settings.trigger);
      } // Force-change the trigger element in some specific scenarios


      if (this.trigger.is('.dropdown, .multiselect')) {
        this.trigger = $("#".concat(this.element.attr('id'), "-shdo"));
      } // Find the correct element to use as the popdown's view.


      function tryPopdownElement(elem) {
        if (!elem) {
          return false;
        }

        if (typeof elem === 'string') {
          if (!elem.match('#') || elem.indexOf('#') !== 0) {
            elem = "#".concat(elem);
          }

          elem = $(elem);
        }

        if (elem.length) {
          self.popdown = elem;
          return true;
        }

        return false;
      }

      var popdownElem = tryPopdownElement(this.trigger.attr('data-popdown'));

      if (!popdownElem) {
        tryPopdownElement(this.trigger.next('.popdown'));
      } // Setup an ID for this popdown if it doesn't already have one


      this.id = this.popdown.attr('id');

      if (!this.id) {
        this.id = "popdown-".concat($('body').find('.popdown').index(this.popdown));
        this.popdown.attr('id', this.id);
      }

      return this;
    },
    build: function build() {
      // Ensure the popdown window is a popdown, and remove any hidden classes from it.
      this.popdown.addClass('popdown').removeClass('hidden'); // Wrap the contents inside for spacing purposes

      var contents = this.popdown.children('.popdown-contents');

      if (!contents.length) {
        this.popdown.children().wrap('<div class="popdown-contents"></div>');
      } // Add the arrow markup if it doesn't already exist


      this.arrow = $('<div class="arrow"></div>').prependTo(this.popdown);
      this.place(); // Expand if necessary

      var ariaExpanded = this.trigger.attr('aria-expanded');

      if (!ariaExpanded || ariaExpanded === undefined) {
        this.trigger.attr('aria-expanded', '');
      }

      if (ariaExpanded === 'true') {
        this.open();
      } // aria-controls for the trigger element


      if (this.trigger) {
        this.trigger[0].setAttribute('aria-controls', this.id);
      }

      return this;
    },
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      this.trigger.on('click.popdown', function () {
        self.toggle();
      }).on('updated.popdown', function () {
        self.updated();
      }); // First and last tab

      this.setFirstLastTab(); // When changes happen within the subtree on the Popdown, rebuilds the internal hash of
      // tabbable elements used for retaining focus.

      this.changeObserver = new MutationObserver(function () {
        _this.setFocusableElems();
      });
      this.changeObserver.observe(this.element[0], {
        childList: true,
        subtree: true
      });
      this.setFocusableElems(); // Toggle on focus for popdown trigger

      if (this.settings.toggleOnFocus) {
        this.trigger.on('focus.popdown', function () {
          _this.toggle();
        });
      }

      return this;
    },
    hasValidTriggerSetting: function hasValidTriggerSetting() {
      return this.settings.trigger instanceof $ || DOM.isElement(this.settings.trigger);
    },

    /**
     * Standard IDS check for focus.
     * @returns {boolean} whether or not the Popdown itself, or a component inside the Popdown, currently has focus.
     * In some cases, this needs to get access to child components to determine focus state.
     */
    get isFocused() {
      return this.hasFocus();
    },

    /**
     * @private
     * @param {HTMLElement} [targetElem=undefined] if defined as an HTMLElement, will be evaluated along with
     * the active element when checking to see if a child element of an IDS component has focus.
     * @returns {boolean} whether or not the Popdown itself, or a component inside the Popdown, currently has focus.
     * In some cases, this needs to get access to child components to determine focus state.
     */
    hasFocus: function hasFocus() {
      var targetElem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var componentHasFocus = false;
      var activeElem = document.activeElement; // If a valid HTMLElement isn't provided, cancel it out.

      if (!(targetElem instanceof HTMLElement)) {
        targetElem = undefined;
      }

      if (this.trigger.is($(activeElem))) {
        return true;
      }

      if (this.popdown[0].contains(activeElem)) {
        return true;
      } // If a target element is passed from an event, check it for some easy types.


      if (targetElem) {
        if (targetElem.classList.contains('overlay')) {
          return true;
        }

        if (this.popdown[0].contains(targetElem)) {
          return true;
        }
      }

      if (!this.focusableElems) {
        this.setFocusableElems();
      } // Check each match for IDS components that may have a more complex focus routine
      // NOTE: Some elements that come through may be SVGs, careful which methods are used.


      this.focusableElems.forEach(function (elem) {
        if (componentHasFocus) {
          return;
        } // Check the base element


        var $elem = $(elem);

        if ($elem.is($(activeElem)) || typeof elem.contains === 'function' && elem.contains(activeElem)) {
          componentHasFocus = true;
        } // Dropdown/Multiselect


        if ($elem.is('div.dropdown, div.multiselect')) {
          var _$elem$parent$prev$da;

          componentHasFocus = (_$elem$parent$prev$da = $elem.parent().prev('select').data('dropdown')) === null || _$elem$parent$prev$da === void 0 ? void 0 : _$elem$parent$prev$da == null ? void 0 : _$elem$parent$prev$da.isFocused;
        } // Lookup


        if ($elem.is('.lookup')) {
          var lookupAPI = $elem.data('lookup');
          componentHasFocus = lookupAPI === null || lookupAPI === void 0 ? void 0 : lookupAPI == null ? void 0 : lookupAPI.isFocused;

          if (!componentHasFocus && targetElem) {
            var _lookupAPI$modal;

            componentHasFocus = lookupAPI === null || lookupAPI === void 0 ? void 0 : (_lookupAPI$modal = lookupAPI == null ? void 0 : lookupAPI.modal) === null || _lookupAPI$modal === void 0 ? void 0 : _lookupAPI$modal == null ? void 0 : _lookupAPI$modal.element[0].contains(targetElem);
          }
        } // Popupmenu


        if ($elem.is('.btn-menu, .btn-actions')) {
          var _$elem$data;

          componentHasFocus = (_$elem$data = $elem.data('popupmenu')) === null || _$elem$data === void 0 ? void 0 : _$elem$data == null ? void 0 : _$elem$data.isFocused;
        } // Searchfield


        if ($elem.is('.searchfield')) {
          var _$elem$data2;

          componentHasFocus = (_$elem$data2 = $elem.data('searchfield')) === null || _$elem$data2 === void 0 ? void 0 : _$elem$data2 == null ? void 0 : _$elem$data2.isFocused;
        }
      }); // Check to see if a Popover/Tooltip has focus, and if that component's parent
      // element is inside the Popdown

      var tooltipParents = $(activeElem).parents('.tooltip, .popover');

      if (tooltipParents.length) {
        tooltipParents.each(function (i, elem) {
          var api = $(elem).data('tooltip');

          if (api && api.isFocused) {
            componentHasFocus = true;
          }
        });
      }

      return componentHasFocus;
    },

    /**
     * Set first last tab action.
     * @private
     * @returns {void}
     */
    setFirstLastTab: function setFirstLastTab() {
      var _this2 = this;

      var s = this.settings;

      if (s.firstLastTab && /function|boolean|object/.test(_typeof(s.firstLastTab))) {
        var first = null;
        var last = null;
        var callback = null;

        if (_typeof(s.firstLastTab) === 'object') {
          if (s.firstLastTab.first) {
            first = s.firstLastTab.first instanceof jQuery ? s.firstLastTab.first : $(s.firstLastTab.first);
            first.first();

            if (!this.popdown[0].contains(first[0])) {
              first = null;
            }
          }

          if (s.firstLastTab.last) {
            last = s.firstLastTab.last instanceof jQuery ? s.firstLastTab.last : $(s.firstLastTab.last);
            last.first();

            if (!this.popdown[0].contains(last[0])) {
              last = null;
            }
          }

          if (typeof s.firstLastTab.callback === 'function') {
            callback = s.firstLastTab.callback;
          }
        } else if (typeof s.firstLastTab === 'function') {
          callback = s.firstLastTab;
        } else if (typeof s.firstLastTab === 'boolean' || s.firstLastTab) {
          callback = this.closeAndContinue;
        }

        if (callback) {
          if (!first || !last || first && !first.length || last && !last.length) {
            // Focusable (only input/select/textarea or with tabindex) elements in popdown
            var focusable = "input:not(:disabled):not([tabindex^=\"-\"]),\n            select:not(:disabled):not([tabindex^=\"-\"]),\n            textarea:not(:disabled):not([tabindex^=\"-\"]),\n            [tabindex]:not(:disabled):not([tabindex^=\"-\"])";
            var focusableElem = this.popdown.find(focusable);

            if (!first || first && !first.length) {
              first = focusableElem.first();
            }

            if (!last || last && !last.length) {
              last = focusableElem.last();
            }
          } // Attach them to self, so later can turn them off


          this.focusableElem = {
            first: first,
            last: last
          }; // First element

          first.on('keydown.popdown', function (e) {
            if (e.keyCode === 9 && e.shiftKey) {
              e.preventDefault();
              callback({
                e: e,
                self: _this2,
                first: first
              });
            }
          }); // Last element

          last.on('keydown.popdown', function (e) {
            if (e.keyCode === 9 && !e.shiftKey) {
              e.preventDefault();
              callback({
                e: e,
                self: _this2,
                last: last
              });
            }
          });
        }
      }
    },

    /**
     * Creates an internal list of focusable items within the Popdown component,
     * which is used for managing tab order.
     * @private
     * @returns {void}
     */
    setFocusableElems: function setFocusableElems() {
      var extraSelectors = ['div.dropdown', 'div.multiselect', '.lookup-wrapper > span.trigger'];
      var ignoredSelectors = ['select', 'option'];
      var elems = DOM.focusableElems(this.popdown[0], extraSelectors, ignoredSelectors);
      this.focusableElems = elems;
      this.focusableElems.first = elems[0];
      this.focusableElems.last = elems[elems.length - 1];
    },

    /**
     * Close the popdown and if available focus to prev/next focusable item.
     * @private
     * @param  {object} args The keydown event, first or last element and popdown reference
     * @returns {void}
     */
    closeAndContinue: function closeAndContinue(args) {
      var focusable = $(document).find(':focusable');
      var index = focusable.index(args.self.trigger);

      if (args.e.shiftKey) {
        index = index - 1 < 0 ? -1 : index - 1;
      } else {
        index = index + 1 >= focusable.length ? -1 : index + 1;
      }

      if (index !== -1) {
        focusable.eq(index).focus();
      }

      args.self.close();
    },

    /**
     * Determines whether or not the popdown is open.
     * @returns {boolean} returns current state.
     */
    isOpen: function isOpen() {
      return this.trigger.attr('aria-expanded') === 'true';
    },

    /**
     * Open the popdown.
     */
    open: function open() {
      if (this.isAnimating) {
        return;
      }

      var self = this;
      this.isAnimating = true;
      this.trigger.attr('aria-expanded', 'true');
      this.position();
      this.popdown.addClass('visible'); // Auto focus

      if (this.settings.autoFocus) {
        var focusElem = this.focusableElems ? this.focusableElems.first : this.popdown.find(':focusable').first();
        focusElem.focus();
      } // Generic function for checking Popdown focus before closing


      function handleFocusOut(e) {
        if (self.focusableElems.includes(e.target) || self.hasFocus(e.target)) {
          self.keyTarget = e.target;
          return;
        } // Using `keydown` sometimes prematurely causes the Popdown to close if elements
        // near the front or back are focused. `keyTarget` detects what was previously clicked
        // and is used as an additional element check in these cases.


        if (e.target.tagName === 'BODY' && self.keyTarget) {
          delete self.keyTarget;
          return;
        }

        self.close();
      } // Setup events that happen on open
      // Needs to be on a timer to prevent automatic closing of popdown.


      if (this.addEventsTimer) {
        this.addEventsTimer.destroy(true);
        delete this.addEventsTimer;
      }

      this.addEventsTimer = new RenderLoopItem({
        duration: loopDuration,
        timeoutCallback: function timeoutCallback() {
          $('body').on('resize.popdown', function (e) {
            handleFocusOut(e);
          }); // Only allow $(document).click() to close the Popdown if `keepOpen` isn't set.
          // Also run this on `focusout` events that occur outside the Popdown, for keyboard access.

          if (!self.settings.keepOpen) {
            $(document).on('click.popdown', function (e) {
              handleFocusOut(e);
            });
          } // Setup a global keydown event that can handle the closing of modals in the proper order.


          $(document).on('keydown.popdown', function (e) {
            var popdownTargetElem = $(e.target).parents('.popdown');
            var keyCode = e.which || e.keyCode;

            switch (keyCode) {
              // Escape Key
              case 27:
                if (popdownTargetElem.length) {
                  self.close();
                }

                break;
              // Tab Key

              case 9:
                handleFocusOut(e);
                break;
            }
          });
          self.isAnimating = false;
        }
      });
      renderLoop.register(this.addEventsTimer);
    },

    /**
     * Close the popdown.
     */
    close: function close() {
      if (this.isAnimating) {
        return;
      }

      if (this.addEventsTimer) {
        this.addEventsTimer.destroy(true);
        delete this.addEventsTimer;
      }

      if (this.keyTarget) {
        delete this.keyTarget;
      }

      var self = this;
      this.isAnimating = true;
      this.trigger.attr('aria-expanded', 'false');
      this.popdown.removeClass('visible'); // Turn off events

      $('body').off('resize.popdown');
      $(document).off('click.popdown focusout.popdown keydown.popdown'); // Sets the element to "display: none" to prevent interactions while hidden.

      if (this.closeTimer) {
        this.closeTimer.destroy(true);
        delete this.closeTimer;
      }

      this.closeTimer = new RenderLoopItem({
        duration: loopDuration,
        timeoutCallback: function timeoutCallback() {
          self.popdown[0].style.display = 'none';
          self.isAnimating = false;
        }
      });
      renderLoop.register(this.closeTimer);
    },

    /**
     * Toggle the popdown.
     */
    toggle: function toggle() {
      if (this.isOpen()) {
        this.close();
        return;
      }

      this.open();
    },

    /**
     * Detaches Popdown Element and places at the body tag root, or at the root of the nearest scrollable parent.
     * @private
     */
    place: function place() {
      this.scrollparent = $('body');
      this.popdown.detach().appendTo(this.scrollparent);
    },

    /**
     * Set the right popdown position.
     * @private
     */
    position: function position() {
      var parent = {
        offset: {
          left: 0,
          top: 0
        },
        scrollDistance: {
          left: 0,
          top: 0
        }
      };
      var winH = window.innerHeight + $(document).scrollTop(); // subtract 2 from the window width to account for the tooltips
      // resizing themselves to fit within the CSS overflow boundary.

      var winW = window.innerWidth - 2 + $(document).scrollLeft(); // Reset adjustments to panel and arrow

      this.popdown.removeAttr('style');
      this.arrow.removeAttr('style'); // Add/subtract offsets if a scrollable parent element is involved

      if (this.scrollparent.length) {
        parent.offset = this.scrollparent.offset();
        parent.scrollDistance.top = this.scrollparent.scrollTop();
        parent.scrollDistance.left = this.scrollparent.scrollLeft();
        winH -= parent.offset.top + parent.scrollDistance.top;
        winW -= parent.offset.left + parent.scrollDistance.left;
      }

      var adjustX = false;
      var adjustY = false;
      var t = this.trigger;
      var to = t.offset(); // Trigger offset

      var arrowHeight = 11;
      var XoffsetFromTrigger = 0;
      var YoffsetFromTrigger = 0;
      var po; // Popover offset
      // Place the popdown below to start

      this.popdown.addClass('bottom');
      this.popdown[0].style.left = "".concat(to.left, "px");
      this.popdown[0].style.top = "".concat(to.top + t.outerHeight(true) + arrowHeight, "px");
      this.arrow[0].style.left = "".concat(t.outerWidth(true) / 2, "px");
      this.arrow[0].style.top = "".concat(0 - arrowHeight, "px"); // Get the newly-set values for the popdown's offset

      po = this.popdown.offset(); // Get deltas for popdown position if the button is off either X edge

      if (po.left < 0) {
        // Checking the left edge
        adjustX = true;
        XoffsetFromTrigger = 0 - po.left;
      }

      var rightEdgePos = po.left + this.popdown.outerWidth(true);

      if (rightEdgePos > winW) {
        // Checking the right edge
        adjustX = true;
        XoffsetFromTrigger = rightEdgePos - winW + (Locale.isRTL() ? 20 : 0);
      }

      if (adjustX) {
        // Adjust the X position based on the deltas
        this.popdown[0].style.left = "".concat(po.left + XoffsetFromTrigger * -1, "px");
        var popdownRect = this.popdown[0].getBoundingClientRect();
        var triggerRect = t[0].getBoundingClientRect();
        var deltaRightEdge = popdownRect.right - triggerRect.right + 10;
        this.arrow[0].style.left = 'auto';
        this.arrow[0].style.right = "".concat(deltaRightEdge, "px"); // Get the newly set values

        po = this.popdown.offset();
      } // Get the deltas for popdown position if the button is off either Y edge


      if (po.top < 0) {
        // Checking top edge
        adjustY = true;
        YoffsetFromTrigger = 0 - po.top;
      }

      var bottomEdgePos = po.top + this.popdown.outerHeight(true);

      if (bottomEdgePos > winH) {
        // Checking the bottom edge
        adjustY = true;
        YoffsetFromTrigger = bottomEdgePos - winH;
      } // Remove the arrow if we need to adjust this, since it won't line up anymore


      if (adjustY) {
        this.arrow[0].style.display = 'none'; // Adjust the Y position based on the deltas

        this.popdown[0].style.top = "".concat(po.top + YoffsetFromTrigger * -1, "px");
        this.arrow[0].style.top = "".concat(parseInt(this.arrow[0].style.top, 10) - YoffsetFromTrigger * -1, "px"); // Get the values again

        po = this.popdown.offset();
      } // One last check of the Y edges.  At this point, if either edge is out of bounds, we need to
      // shrink the height of the popdown, as it's too tall for the viewport.


      if (po.top < 0 || po.top + this.popdown.outerHeight(true) > winH) {
        this.popdown[0].style.top = 0;
        po = this.popdown.offset();
        bottomEdgePos = po.top + this.popdown.outerHeight(true);
        this.popdown[0].style.height = "".concat(parseInt(this.popdown[0].style.height, 10) - (bottomEdgePos - winH), "px");
      }
    },

    /**
     * Update the popdown and refresh with new settings
     * @param  {object} settings The new settings
     * @returns {object} The component api.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      if (this.hasValidTriggerSetting()) {
        this.trigger = $(this.settings.trigger);
      }

      return this;
    },

    /**
     * Release Events
     * @private
     * @returns {object} The component api.
     */
    teardown: function teardown() {
      if (this.isOpen()) {
        this.close();
      }

      if (this.trigger) {
        this.trigger.off('updated.popdown click.popdown focus.popdown').removeAttr('aria-controls').removeAttr('aria-expanded');
      }

      if (this.changeObserver) {
        this.changeObserver.disconnect();
        delete this.changeObserver;
      } // First and last turn off and withdraw


      if (this.focusableElem && this.focusableElem.first instanceof jQuery) {
        this.focusableElem.first.off('keydown.popdown');
        this.focusableElem.last.off('keydown.popdown');
        delete this.focusableElem;
      }

      if (this.focusableElems && this.focusableElems.first instanceof jQuery) {
        this.focusableElems.first.off('keydown.popdown');
        this.focusableElems.last.off('keydown.popdown');
        delete this.focusableElems;
      }

      if (this.originalParent && this.originalParent.length) {
        this.popdown.detach().appendTo(this.originalParent);
      }

      this.arrow.remove();
      return this;
    },

    /**
     * Teardown - Remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$_);
    }
  };

  /**
   * jQuery component wrapper for Popdown
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery selector containing all elements
   */

  $.fn.popdown = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$_);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$_, new Popdown(this, settings));
      }
    });
  };

  var COMPONENT_NAME$$ = 'rating'; // Default Rating Options

  var RATING_DEFAULTS = {};
  /**
   * @class Rating
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object} [settings] The component settings.
   */

  function Rating(element, settings) {
    this.settings = utils.mergeSettings(element, settings, RATING_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Actual Rating Code


  Rating.prototype = {
    init: function init() {
      this.handleEvents();
      this.allInputs = this.element.find('input');
      this.enable();
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var inputs = $('input', this.element);

      var _loop = function _loop(i, l) {
        var thisInput = $(inputs[i]);
        var nextInput = $(inputs[i + 1]);

        var isNotEmpty = function isNotEmpty(el) {
          return el.is('.is-filled') || el.is('.is-half');
        };

        thisInput.on("click.".concat(COMPONENT_NAME$$), function () {
          if (!_this.element.is('.is-readonly')) {
            _this.val(isNotEmpty(thisInput) && !isNotEmpty(nextInput) ? i : i + 1);
          }
        });
      };

      for (var i = 0, l = inputs.length; i < l; i++) {
        _loop(i);
      }
    },

    /**
     * Icon filled star
     * @param {jQuery|HTMLElement} inpt - Input element
     * @param {jQuery|HTMLElement} svg - SVG element
     */
    fillStar: function fillStar(inpt, svg) {
      $(inpt).addClass('is-filled').removeClass('is-half').next(svg).find('svg').changeIcon('star-filled');
    },

    /**
     * Icon empty star
     * @param {jQuery|HTMLElement} inpt - Input element
     * @param {jQuery|HTMLElement} svg - SVG element
     */
    emptyStar: function emptyStar(inpt, svg) {
      $(inpt).removeClass('is-filled').removeClass('is-half').next(svg).find('svg').changeIcon('star-outlined');
    },

    /**
     * Icon half star
     * @param {jQuery|HTMLElement} inpt - Input element
     * @param {jQuery|HTMLElement} svg - SVG element
     */
    halfStar: function halfStar(inpt, svg) {
      $(inpt).addClass('is-half').removeClass('is-filled').next(svg).find('svg').changeIcon('star-half');
    },

    /**
     * Optionally set the value and return the current value
     * @param {number} [value] - A new value
     * @returns {number}- The current value
     */
    val: function val(value) {
      if (arguments.length === 0 || value === '' || isNaN(value) || math.sign(value) === -1) {
        return this.currentValue;
      }

      this.currentValue = parseFloat(value, 10);
      var chkIdx = Math.floor(this.currentValue);

      for (var i = 0, l = this.allInputs.length; i < l; i++) {
        var input = $(this.allInputs[i]);
        var svgSelector = input.parent().is('.inline') ? 'svg' : 'label';
        var valNotAWholeNumber = value % 1 !== 0 && chkIdx === i;

        if (valNotAWholeNumber) {
          this.halfStar(input, svgSelector);
        } else if (i < value) {
          this.fillStar(input, svgSelector);
        } else {
          this.emptyStar(input, svgSelector);
        }

        if (i + 1 === chkIdx) {
          input.prop('checked', true);
        }
      }

      if (chkIdx <= 0 && value > 0) {
        $(this.allInputs[0]).prop('checked', true);
      }

      return this.currentValue;
    },

    /**
    * Set component to readonly.
    * @returns {void}
    */
    readonly: function readonly() {
      var elem = $(this.element);
      elem.addClass('is-readonly');
      elem.find('input').attr('disabled', '');
    },

    /**
    * Set component to enable.
    * @returns {void}
    */
    enable: function enable() {
      var elem = $(this.element);
      elem.removeClass('is-readonly').find('input').removeAttr('disabled');
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.find('input').off("click.".concat(COMPONENT_NAME$$));
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, RATING_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$$);
    }
  };

  /**
   * jQuery Component Wrapper for Rating
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.rating = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$$);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$$, new Rating(this, settings));
      }
    });
  };

  var COMPONENT_NAME$10 = 'signin'; // Default SignIn Options

  var SIGNIN_DEFAULTS = {};
  /**
  * The sign in page component.
  * @class SignIn
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  */

  function SignIn(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SIGNIN_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  SignIn.prototype = {
    init: function init() {
      this.handleKeys();
    },

    /**
     * Checks a keyboard event for a CAPS LOCK modifier.
     * @private
     * @param {object} e jQuery.Event
     * @returns {boolean} true if caps lock
     */
    isCapslock: function isCapslock(e) {
      e = e || window.event;
      var charCode = false;
      var shifton = false;

      if (e.which) {
        charCode = e.which;
      } else if (e.keyCode) {
        charCode = e.keyCode;
      }

      if (e.shiftKey) {
        shifton = e.shiftKey;
      } else if (e.modifiers) {
        shifton = !!(e.modifiers & 4); // eslint-disable-line
      }

      if (charCode >= 97 && charCode <= 122 && shifton) {
        return true;
      }

      if (charCode >= 65 && charCode <= 90 && !shifton) {
        return true;
      }

      return false;
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      $('body').off('keypress.signin blur.signin change.signin');
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SIGNIN_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$10);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      var self = this;
      var cssIcon = $.createIconElement({
        classes: 'icon-capslock',
        icon: 'capslock'
      }); // Disable default [caps lock on] popup in IE

      document.msCapsLockWarningOff = true;
      this.element.on('keypress.signin', '[type="password"]', function (e) {
        var field = $(this);
        var fieldParent = field.parent('.field');
        var iconCapslock = $('.icon-capslock', fieldParent);

        if (self.isCapslock(e) && !field.hasClass('error')) {
          if (!iconCapslock.length) {
            fieldParent.append(cssIcon);
            $('body').toast({
              audibleOnly: true,
              message: Locale.translate('CapsLockOn')
            });
          }
        } else {
          iconCapslock.remove();
        }
      }).on('blur.signin change.signin', '[type="password"]', function () {
        var field = $(this);
        var fieldParent = field.closest('.field');
        var iconCapslock = $('.icon-capslock', fieldParent);
        setTimeout(function () {
          if (iconCapslock && iconCapslock.length) {
            if (field.hasClass('error')) {
              iconCapslock.remove();
            } else {
              fieldParent.append(cssIcon);
            }
          }
        }, 150);
      });
    }
  };

  /**
   * jQuery Component Wrapper for SignIn
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.signin = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$10);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$10, new SignIn(this, settings));
      }
    });
  };

  var COMPONENT_NAME$11 = 'slider'; // The Component Defaults

  var SLIDER_DEFAULTS = {
    value: [50],
    min: 0,
    max: 100,
    range: false,
    step: undefined,
    ticks: [],
    tooltipContent: undefined,
    tooltipPosition: 'top',
    persistTooltip: false,
    attributes: null
  };
  /**
   * Touch Enabled/Responsive and Accessible Slider Control
   * @class Slider
   * @param {jQuery[]|HTMLElement} element The DOM element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.value = [50]] An array with the slider values. Or one if a single value slider.
   * @param {number} [settings.min = 0] The minimum slider value.
   * @param {number} [settings.max = 100] The maximum slider value.
   * @param {boolean} [settings.range = false] If true a range slider with two selectors is formed.
   * @param {undefined|Number} [settings.step] If added will be the number of slider steps to use.
   * @param {array} [settings.ticks = []] An array of the ticks to use for the steps
   * @param {undefined|Array} [settings.tooltipContent] Special customizable tooltip content.
   * @param {string} [settings.tooltipPosition = 'top'] Option to control the position of tooltip. ['top' , 'bottom']
   * @param {boolean} [settings.persistTooltip = false] If true the tooltip will stay visible.
   * @param {string} [settings.attributes=null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
   */

  function Slider(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, SLIDER_DEFAULTS);
    this.init();
  } // Check if is an integer


  function isInt(n) {
    return n % 1 === 0;
  } // Round a non-integer to an integer closest to the nearest increment/decrement.
  // If no increment is provided or the increment is 0, only round to the nearest whole number.


  function roundToIncrement(number, increment) {
    if (!increment || isNaN(increment) || increment === 0) {
      increment = 1;
    }

    return Math.round(number / increment) * increment;
  } // Get the distance between two points.
  // PointA & PointB are both arrays containing X and Y coordinates of two points.
  // Distance Formula:  http://www.purplemath.com/modules/distform.htm


  function getDistance(pointA, pointB) {
    var aX = pointA[0];
    var aY = pointA[1];
    var bX = pointB[0];
    var bY = pointB[1];
    return Math.sqrt(Math.pow(bX - aX, 2) + Math.pow(bY - aY, 2));
  } // Actual Plugin Code


  Slider.prototype = {
    /**
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.buildSettings().addMarkup().bindEvents();
    },

    /**
     * Handles Data Attribute settings, some markup settings
     * @private
     * @returns {this} component instance
     */
    buildSettings: function buildSettings() {
      var self = this; // Add "is-disabled" css class to closest ".field" if element is disabled

      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      if (!this.settings) {
        this.settings = {};
      }

      this.settings.value = this.element.attr('value') !== undefined ? this.element.attr('value') : this.settings.value;
      this.settings.min = this.element.attr('min') !== undefined ? parseInt(this.element.attr('min'), 10) : this.settings.min;
      this.settings.max = this.element.attr('max') !== undefined ? parseInt(this.element.attr('max'), 10) : this.settings.max;
      this.settings.range = this.element.attr('data-range') !== undefined ? this.element.attr('data-range') === 'true' : this.settings.range;
      this.settings.step = !isNaN(this.element.attr('step')) ? Number(this.element.attr('step')) : this.settings.step;

      if (this.settings.value === '') {
        this.settings.value = this.settings.min;
      }

      if (this.settings.step === 1) {
        this.settings.step = undefined;
      } // build tick list


      var parsedTicks;

      if (this.element.attr('data-ticks') !== undefined) {
        try {
          parsedTicks = JSON.parse(self.element.attr('data-ticks'));
        } catch (e) {
          parsedTicks = [];
        }

        if ($.isArray(parsedTicks)) {
          this.settings.ticks = parsedTicks;
        }
      } // build tooltip content


      var isTooltipPersist = this.element.attr('data-tooltip-persist') === 'true' || this.element.attr('data-tooltip-persist') === true;
      this.settings.persistTooltip = this.element.attr('data-tooltip-persist') !== undefined ? isTooltipPersist : this.settings.persistTooltip;
      this.settings.tooltip = this.settings.tooltipContent;

      if (this.element.attr('data-tooltip-content') !== undefined) {
        try {
          self.settings.tooltip = JSON.parse(self.element.attr('data-tooltip-content'));
        } catch (e) {
          self.settings.tooltip = ['', ''];
        }
      }

      if (typeof this.settings.tooltip === 'string') {
        if (this.settings.tooltip.indexOf(',') === -1) {
          this.settings.tooltip = [this.settings.tooltip, ''];
        } else {
          var strings = this.settings.tooltip.split(',');
          this.settings.tooltip = [strings[0]];
          this.settings.tooltip.push(strings[1] ? strings[1] : '');
        }
      }

      if (this.settings.tooltip && this.settings.tooltip.length === 1) {
        this.settings.tooltip.push('');
      } // Build ticks.  All sliders have a tick for minimum and maximum by default.
      // Some will be provided as extra.


      this.ticks = [];
      var minTick = {
        value: this.settings.min,
        description: self.getModifiedTextValue(this.settings.min)
      };
      var maxTick = {
        value: this.settings.max,
        description: self.getModifiedTextValue(this.settings.max)
      };

      if (!this.settings.ticks) {
        this.ticks.push(minTick, maxTick);
      } else {
        // Check the type of the data-ticks.  If it's not a complete array
        // and doesn't have at least one option, ignore it.
        var ticks = self.settings.ticks || [];

        if ($.isArray(ticks) && ticks.length > 0) {
          // Filter through the incoming ticks to figure out if any have been defined
          // That match the values of min and max.
          var equalsMin = ticks.filter(function (obj) {
            return obj.value === self.settings.min;
          });
          var equalsMax = ticks.filter(function (obj) {
            return obj.value === self.settings.max;
          }); // Overwrite description and color for min/max if they've been found.

          if (equalsMin.length > 0) {
            minTick.description = equalsMin[0].description;
            minTick.color = equalsMin[0].color;
            ticks = $.grep(ticks, function (val) {
              return val !== equalsMin[0];
            });
          }

          if (equalsMax.length > 0) {
            maxTick.description = equalsMax[0].description;
            maxTick.color = equalsMax[0].color;
            ticks = $.grep(ticks, function (val) {
              return val !== equalsMax[0];
            });
          }
        } // Push the values of all ticks out to the ticks array


        self.ticks.push(minTick);

        for (var i = 0; i < ticks.length; i++) {
          var tick = {};

          if (ticks[i].value !== undefined) {
            tick.value = ticks[i].value;
            tick.description = ticks[i].description !== undefined ? ticks[i].description : '';
            tick.color = ticks[i].color;
            self.ticks.push(tick);
          }
        }

        self.ticks.push(maxTick);
      } // configure the slider to deal with an array of values, and normalize the
      // values to make sure they are numbers.


      if ($.isArray(this.settings.value)) {
        this.settings.value[0] = isNaN(this.settings.value[0]) ? (this.settings.min + this.settings.max) / 2 : parseInt(this.settings.value[0], 10);
      } else if (typeof this.settings.value === 'number') {
        this.settings.value = [this.settings.value];
      } else if (this.settings.value.indexOf(',') === -1) {
        // String
        this.settings.value = [isNaN(this.settings.value) ? (this.settings.min + this.settings.max) / 2 : parseInt(this.settings.value, 10)];
      } else {
        var vals = this.settings.value.split(',');
        vals[0] = isNaN(vals[0]) ? this.settings.min : parseInt(vals[0], 10);
        vals[1] = isNaN(vals[1]) ? this.settings.max : parseInt(vals[1], 10);
        this.settings.value = vals;
      } // Add a second value to the array if we're dealing with a range.


      if (this.settings.range && !this.settings.value[1]) {
        this.settings.value.push(this.settings.max);
      }

      return this;
    },

    /**
     * Adds pseudo-markup that helps build the component
     * @private
     * @returns {this} component instance
     */
    addMarkup: function addMarkup() {
      var self = this;
      var isVertical = false;

      if (self.element[0].tagName !== 'INPUT') {
        throw new Error("Element with ID \"".concat(self.element.id, "\" cannot invoke a slider;  it's not an Input element."));
      } // store values and attributes on the original element


      self.originalElement = {
        type: self.element.attr('type')
      }; // Hide the input element

      self.element.attr('type', 'hidden'); // Build the slider controls

      self.wrapper = $('<div class="slider-wrapper"></div>').attr('id', "".concat(self.element.attr('id'), "-slider")).insertAfter(self.element);
      self.hitarea = $('<div class="slider-hit-area"></div>').appendTo(self.wrapper);
      self.range = $('<div class="slider-range"></div>').appendTo(self.wrapper); // Set to a vertical slider if the class exists on the input

      if (this.element.hasClass('vertical')) {
        this.wrapper.addClass('vertical');
        isVertical = true;
      } // Set RTL


      this.isRtlHorizontal = Locale.isRTL() && !isVertical;
      this.isRtlVertical = Locale.isRTL() && isVertical; // Retain any width or height size properties from the original range
      // element onto the Pseudo-markup

      var style = this.element.attr('style');

      if (style) {
        if (style.match(/min-height/)) {
          this.wrapper[0].style.minHeight = this.element[0].style.minHeight;
          style = style.replace('min-height', '');
        }

        if (style.match(/height/)) {
          this.wrapper[0].style.height = this.element[0].style.height;
        }

        if (style.match(/min-width/)) {
          this.wrapper[0].style.minWidth = this.element[0].style.minWidth;
          style = style.replace('min-width', '');
        }

        if (style.match(/width/)) {
          this.wrapper[0].style.width = this.element[0].style.width;
        }
      } // Handles


      self.handles = [];
      var labelText = self.element.prev('label').text();
      var handleLower = $("<div class=\"slider-handle".concat(self.settings.range ? ' lower' : '', "\" tabindex=\"0\"></div>")).attr('aria-label', "".concat(self.settings.range ? Locale.translate('SliderMinimumHandle') : Locale.translate('SliderHandle'), " ").concat(labelText));
      self.handles.push(handleLower);

      if (self.settings.range) {
        var handleHigher = $('<div class="slider-handle higher" tabindex="0"></div>').attr('aria-label', "".concat(Locale.translate('SliderMaximumHandle'), " ").concat(labelText));
        self.handles.push(handleHigher);
      }

      $.each(self.handles, function (i, handle) {
        // Add WAI-ARIA to the handles
        handle.attr({
          role: 'slider',
          'aria-orientation': isVertical ? 'vertical' : 'horizontal',
          'aria-valuemin': self.settings.min,
          'aria-valuemax': self.settings.max
        }).hideFocus();
        handle.appendTo(self.wrapper);
      });

      function positionTick(tick) {
        var convertValueToPercentage = self.isRtlHorizontal ? 100 - self.convertValueToPercentage(tick.value) : self.convertValueToPercentage(tick.value);
        var pos = "calc(".concat(convertValueToPercentage, "% - 4px)");
        tick.element = $("<div class=\"tick\" data-value=\"".concat(tick.value, "\"></div>"));
        tick.label = $("<span class=\"label\">".concat(tick.description, "</span>"));
        tick.element[0].style[isVertical ? 'bottom' : 'left'] = pos;
        tick.element.append(tick.label);
        self.wrapper.append(tick.element);

        if (isVertical) {
          return;
        }

        tick.label[0].style.left = "".concat(-(tick.label.outerWidth() / 2 - tick.element.width() / 2), "px");
      } // Ticks


      self.ticks.forEach(function (tick) {
        positionTick(tick);
      });
      self.value(self.settings.value);
      self.updateRange(); // Tooltip on handle needs to update later

      $.each(self.handles, function (i, handle) {
        if (self.settings.tooltip) {
          handle.tooltip({
            content: function content() {
              return "".concat(self.getModifiedTextValue(Math.floor(self.value()[i])));
            },
            placement: isVertical ? 'right' : self.settings.tooltipPosition,
            trigger: 'focus',
            keepOpen: self.settings.persistTooltip
          });
          handle.removeAttr('aria-describedby');
        }
      });

      if (this.element.prop('readonly') === true) {
        this.readonly();
      } else if (this.element.prop('disabled') === true) {
        this.disable();
      }

      utils.addAttributes(this.element, this, this.settings.attributes, '', true);
      utils.addAttributes(this.wrapper, this, this.settings.attributes, 'wrapper', true);
      utils.addAttributes(this.hitarea, this, this.settings.attributes, 'hitarea', true);
      utils.addAttributes(this.range, this, this.settings.attributes, 'range', true);
      utils.addAttributes.apply(utils, _toConsumableArray(this.handles).concat([this, this.settings.attributes, 'handle', true]));

      for (var i = 0, l = this.ticks.length; i < l; i++) {
        var ticks = $(this.ticks[i].element);
        utils.addAttributes(ticks, this, this.settings.attributes, "tick-".concat(i + 1));
      }

      return self;
    },

    /**
     * User is interacting with the Slider Range (not the handle or ticks)
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleRangeClick: function handleRangeClick(e) {
      e.preventDefault();

      if (this.isDisabled()) {
        return;
      }

      var self = this;
      var isVertical = this.wrapper.hasClass('vertical');
      var pageX = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageX : e.pageX;
      var pageY = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageY : e.pageY;
      var mouseX = pageX - self.wrapper.offset().left - $(document).scrollLeft();
      var mouseY = pageY - self.wrapper.offset().top - $(document).scrollTop();
      var clickCoords = [mouseX, mouseY];
      var fhX = self.handles[0].offset().left + self.handles[0].width() / 2 - self.wrapper.offset().left - $(document).scrollLeft();
      var fhY = self.handles[0].offset().top + self.handles[0].height() / 2 - self.wrapper.offset().top - $(document).scrollTop();
      var firstHandleCoords = [fhX, fhY];
      var shX;
      var shY;
      var secondHandleCoords;
      var oldVals = self.value();
      var dLower = getDistance(clickCoords, firstHandleCoords);
      var dHigher;
      var targetOldVal = oldVals[0];
      var targetHandle = self.handles[0];
      targetHandle.addClass('hide-focus');

      function conversion() {
        if (isVertical) {
          var wh = self.wrapper.height();
          return (wh - mouseY) / wh * 100;
        }

        return mouseX / self.wrapper.width() * 100;
      } // Convert the coordinates of the mouse click to a value


      var val = conversion();
      var rangeVal = self.convertPercentageToValue(val); // If the slider is a range, we may use the second handle instead of the first

      if (self.handles[1]) {
        shX = self.handles[1].offset().left + self.handles[1].width() / 2 - self.wrapper.offset().left - $(document).scrollLeft();
        shY = self.handles[1].offset().top + self.handles[1].height() / 2 - self.wrapper.offset().top - $(document).scrollTop();
        secondHandleCoords = [shX, shY];
        dHigher = getDistance(clickCoords, secondHandleCoords);

        if (dLower > dHigher) {
          self.value([undefined, rangeVal]);
          targetHandle = self.handles[1];
          targetOldVal = oldVals[1];
        } else {
          self.value([rangeVal]);
        }
      }

      self.checkHandleDifference(targetHandle, targetOldVal, rangeVal);
      var moveBy = self.settings.step ? self.settings.step : 0;

      if (rangeVal < targetOldVal) {
        self.decreaseValue(e, targetHandle, rangeVal, moveBy);
      } else {
        self.increaseValue(e, targetHandle, rangeVal, moveBy);
      } // Tooltip repositioner will focus the handle after positioning occurs, but if
      // we are clicking a tick on a slider with no tooltip, we need to focus it manually.


      if (!self.settings.tooltip) {
        targetHandle.focus();
      }
    },

    /**
     * Activates one of the slider handles
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    activateHandle: function activateHandle(handle) {
      handle.addClass('is-active');
    },

    /**
     * Deactivates one of the slider handles
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    deactivateHandle: function deactivateHandle(handle) {
      handle.removeClass('is-active');
    },

    /**
     * Enables the ability to drag one of the slider handles.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    enableHandleDrag: function enableHandleDrag(handle) {
      if (this.isDisabled()) {
        return;
      }

      var self = this;
      var draggableOptions = {
        containment: 'parent',
        axis: this.isVertical() ? 'y' : 'x',
        clone: false
      };

      function updateHandleFromDraggable(e, thisHandle, args) {
        if (self.isDisabled()) {
          return;
        }

        function conversion() {
          if (self.isVertical()) {
            var wh = self.wrapper.height(); // Vertical Slider accounts for limits set on the height by IDS Enterprise Drag.js

            var adjustedHeight = wh - thisHandle.outerHeight();
            return (adjustedHeight - args.top) / adjustedHeight * 100;
          }

          return args.left / (self.wrapper.width() - thisHandle.outerWidth()) * 100;
        }

        var val = conversion();
        var rangeVal = self.convertPercentageToValue(val); // Ranged values need to check to make sure that the higher-value handle
        // doesn't drawindowg past the lower-value handle, and vice-versa.

        if (self.settings.range) {
          var originalVal = self.value();

          if (thisHandle.hasClass('higher') && rangeVal <= originalVal[0]) {
            rangeVal = originalVal[0];
          }

          if (thisHandle.hasClass('lower') && rangeVal >= originalVal[1]) {
            rangeVal = originalVal[1];
          }
        } // Round the value to the nearest step, if the step is defined


        if (self.settings.step) {
          rangeVal = Math.round(rangeVal / self.settings.step) * self.settings.step;
        }
        /**
        * Fires while the slider is being slid.
        * @event sliding
        * @memberof Slider
        * @property {object} event The jquery event object
        * @property {object} args Extra event information.
        * @property {HTMLElement} args.handle The slider handle DOM element.
        * @property {number} args.value The current range value.
        */


        if (!e.defaultPrevented) {
          self.value(thisHandle.hasClass('higher') ? [undefined, rangeVal] : [rangeVal]);
          self.updateRange();
          self.updateTooltip(thisHandle);
          self.element.trigger('sliding', thisHandle, rangeVal);
        }
      } // Add/Remove Classes for canceling animation of handles on the draggable's events.

      /**
      * Fires while the slider is being slid.
      * @event slidestart
      * @memberof Slider
      * @property {object} event The jquery event object
      * @property {object} args Extra event information.
      * @property {HTMLElement} args.handle The slider handle DOM element.
      */

      /**
       * Fires while the slider is being slid.
       * @event slidestop
       * @memberof Slider
       * @property {object} event The jquery event object
       * @property {object} args Extra event information.
       * @property {HTMLElement} args.handle The slider handle DOM element.
       */


      handle.drag(draggableOptions).on('drag.slider', function (e, args) {
        updateHandleFromDraggable(e, $(e.currentTarget), args);
      }).on('dragstart', function () {
        $(this).addClass('is-dragging');
        self.range.addClass('is-dragging');
        self.element.trigger('slidestart', handle);
      }).on('dragend', function () {
        $(this).removeClass('is-dragging');
        self.range.removeClass('is-dragging');
        self.element.trigger('slidestop', handle);
      });
    },

    /**
     * Disables the dragging of a handle.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     */
    disableHandleDrag: function disableHandleDrag(handle) {
      handle.off('drag.slider dragstart dragend');
      this.range.removeClass('is-dragging');
      handle.removeClass('is-dragging');
      var dragAPI = handle.data('drag');

      if (dragAPI) {
        dragAPI.destroy();
      }
    },

    /**
     * @private
     * @param {number} value pixel value
     * @returns {number} representing a percentage
     */
    convertValueToPercentage: function convertValueToPercentage(value) {
      return (value - this.settings.min) / (this.settings.max - this.settings.min) * 100;
    },

    /**
     * @private
     * @param {number} percentage percentage value
     * @returns {number} representing a pixel value
     */
    convertPercentageToValue: function convertPercentageToValue(percentage) {
      var val = percentage / 100 * (this.settings.max - this.settings.min) + this.settings.min;
      return this.isRtlHorizontal ? this.settings.max - val + this.settings.min : val;
    },

    /**
     * Gets a 10% increment/decrement as a value within the range of minimum and maximum values.
     * @returns {number} nearest 10% increment
     */
    getIncrement: function getIncrement() {
      var increment = 0.1 * (this.settings.max - this.settings.min);

      if (this.settings.step !== undefined && increment <= this.settings.step) {
        increment = this.settings.step;
      }

      return increment;
    },

    /**
     * Handles Slider Component's keystrokes
     * @private
     * @param {jQuery.Event} e jQuery `keydown` event
     * @param {this} self reference to this component instance
     */
    handleKeys: function handleKeys(e, self) {
      if (self.isDisabled()) {
        return;
      }

      var key = e.which;
      var handle = $(e.currentTarget);
      handle.removeClass('hide-focus'); // If the keycode got this far, it's an arrow key, Page Up, Page Down, HOME, or END.

      switch (key) {
        case 33:
          // Page Up increases the value by 10%
          self.increaseValue(e, handle, undefined, this.getIncrement());
          break;

        case 34:
          // Page Down decreases the value by 10%
          self.decreaseValue(e, handle, undefined, this.getIncrement());
          break;

        case 35:
          // End key sets the handle to its maximum possible value
          self.increaseValue(e, handle, this.settings.max);
          break;

        case 36:
          // Home key sets the handle to its lowest
          // (either minimum value or as low as the "lower" handle)
          self.decreaseValue(e, handle, this.settings.min);
          break;

        case 38:
        case 39:
          // Right and Up increase the spinbox value
          if (self.isRtlHorizontal && key === 39) {
            self.decreaseValue(e, handle);
          } else {
            self.increaseValue(e, handle);
          }

          break;

        case 37:
        case 40:
          // Left and Down decrease the spinbox value
          if (self.isRtlHorizontal && key === 37) {
            self.increaseValue(e, handle);
          } else {
            self.decreaseValue(e, handle);
          }

          break;
      }
    },

    /**
     * Increases the value of one of the slider handles, accounting for step value, percentage, etc.
     * Also visually updates the handle on the visual part of the slider.
     * @param {jQuery.Event} e jQuery `click` or `keydown` event.
     * @param {jQuery[]} handle represents a slider handle element.
     * @param {number} [value] - target value - will be automatically determined if not passed.
     * @param {number} [increment] - an integer that will be used as the amount to increment.
     */
    increaseValue: function increaseValue(e, handle, value, increment) {
      e.preventDefault();
      clearTimeout(handle.data('animationTimeout'));
      var val = this.value().slice(0);
      var incrementBy = increment !== undefined ? increment : this.settings.step !== undefined ? this.settings.step : 1; //eslint-disable-line

      var testVal;
      var updatedVal;
      var finalVal;

      if (handle.hasClass('higher')) {
        testVal = value !== undefined ? value : val[1];
        incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : testVal % incrementBy; //eslint-disable-line

        updatedVal = testVal + incrementBy < this.settings.max ? testVal + incrementBy : this.settings.max;
        finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
        this.value([undefined, finalVal]);
      } else {
        testVal = value !== undefined ? value : val[0];
        var maxValue = val[1] === undefined ? this.settings.max : val[1];
        incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : incrementBy - testVal % incrementBy; //eslint-disable-line

        updatedVal = testVal + incrementBy < maxValue ? testVal + incrementBy : maxValue;
        finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
        this.value([finalVal]);
      }

      this.checkHandleDifference(handle, testVal, finalVal);
      this.updateRange();
      this.updateTooltip(handle);
    },

    /**
     * Decreases the value of one of the slider handles, accounting for step value, percentage, etc.
     * Also visually updates the handle on the visual part of the slider.
     * @param {jQuery.Event} e jQuery `click` or `keydown` event.
     * @param {jQuery[]} handle element representing a slider handle.
     * @param {number} [value] - target value - will be automatically determined if not passed.
     * @param {number} [decrement] - an integer that will be used as the amount to decrement.
     */
    decreaseValue: function decreaseValue(e, handle, value, decrement) {
      e.preventDefault();
      clearTimeout(handle.data('animationTimeout'));
      var val = this.value();
      var decrementBy = decrement !== undefined ? decrement : this.settings.step !== undefined ? this.settings.step : 1; //eslint-disable-line

      var testVal;
      var updatedVal;
      var finalVal;

      if (handle.hasClass('higher')) {
        testVal = value !== undefined ? value : val[1];
        var minValue = val[0] === undefined ? this.settings.min : val[0];
        decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : decrementBy - testVal % decrementBy; //eslint-disable-line

        updatedVal = testVal - decrementBy > minValue ? testVal - decrementBy : minValue;
        finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
        this.value([undefined, finalVal]);
      } else {
        testVal = value !== undefined ? value : val[0];
        decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : testVal % decrementBy; //eslint-disable-line

        updatedVal = testVal - decrementBy > this.settings.min ? testVal - decrementBy : this.settings.min;
        finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
        this.value([finalVal]);
      }

      this.checkHandleDifference(handle, testVal, finalVal);
      this.updateRange();
      this.updateTooltip(handle);
    },

    /**
     * Changes the position of the bar and handles based on their values.
     * @private
     */
    updateRange: function updateRange() {
      var self = this;
      var newVal = this.value();
      var percentages = [];
      var color = this.getColorClosestToValue();
      var isVertical = self.wrapper.hasClass('vertical');

      for (var i = 0; i < this.ticks.length; i++) {
        var condition = !this.settings.range ? this.ticks[i].value <= newVal[0] : newVal[0] < this.ticks[i].value && this.ticks[i].value <= newVal[1];

        if (condition) {
          this.ticks[i].element.addClass('complete');

          if (color) {
            this.ticks[i].element[0].style.backgroundColor = color;
            this.ticks[i].element.addClass('inherit');
          }
        } else {
          this.ticks[i].element.removeClass('complete');

          if (color) {
            this.ticks[i].element[0].style.backgroundColor = '';
            this.ticks[i].element.removeClass('inherit');
          }
        }
      }

      if (color) {
        this.range[0].style.backgroundColor = color;
        $.each(this.handles, function (i, handle) {
          handle[0].style.backgroundColor = color;
          handle[0].style.borderColor = color;
        });
      } // Remove any text colors that already existed.


      $.each(self.ticks, function (i) {
        self.ticks[i].label[0].style.color = '';
      }); // Convert the stored values from ranged to percentage

      percentages[0] = this.convertValueToPercentage(newVal[0]);

      if (newVal[1] !== undefined) {
        percentages[1] = this.convertValueToPercentage(newVal[1]);
      }

      function getPosAttrs() {
        if (isVertical) {
          return ['bottom', 'top'];
        }

        if (self.isRtlHorizontal) {
          return ['right', 'left'];
        }

        return ['left', 'right'];
      }

      var posAttrs = getPosAttrs();
      var cssProps = {}; // If no arguments are provided, update both handles with the latest stored values.

      if (!this.handles[1]) {
        cssProps[posAttrs[0]] = '0%';
        cssProps[posAttrs[1]] = "".concat(100 - percentages[0], "%");
      } else {
        cssProps[posAttrs[0]] = "".concat(percentages[0], "%");
        cssProps[posAttrs[1]] = "".concat(100 - percentages[1], "%");
      }

      this.range.css(cssProps);

      function positionHandle(handle, percentage) {
        var basePosition = isVertical ? posAttrs[1] : posAttrs[0];
        var realPercentage = isVertical ? 100 - percentage : percentage;
        handle.css(basePosition, "calc(".concat(realPercentage, "% - ").concat(handle.outerWidth() / 2, "px)"));
      }

      if (this.handles[0].hasClass('is-animated')) {
        this.handles[0].data('animationTimeout', setTimeout(function () {
          self.handles[0].removeClass('is-animated').trigger('slide-animation-end');
          self.range.removeClass('is-animated');
        }, 201));
      }

      positionHandle(this.handles[0], percentages[0]);

      if (this.handles[1]) {
        if (this.handles[1].hasClass('is-animated')) {
          this.handles[1].data('animationTimeout', setTimeout(function () {
            self.handles[1].removeClass('is-animated').trigger('slide-animation-end');
            self.range.removeClass('is-animated');
          }, 201));
        }

        positionHandle(this.handles[1], percentages[1]); // update the 'aria-valuemin' attribute on the Max handle, and the 'aria-valuemax'
        // attribute on the Min handle for better screen reading compatability

        this.handles[0].attr('aria-valuemax', newVal[1]);
        this.handles[1].attr('aria-valuemin', newVal[0]);
      }
    },

    /**
     * Allows a handle to animate to a new position if the difference in value is greater
     *  than 3% of the size of the range.
     * @private
     * @param {jQuery[]} handle element representing a slider handle
     * @param {number} originalVal the value before it was modified
     * @param {number} updatedVal the target value
     */
    checkHandleDifference: function checkHandleDifference(handle, originalVal, updatedVal) {
      var origPercent = this.convertValueToPercentage(originalVal);
      var updatedPercent = this.convertValueToPercentage(updatedVal);

      if (Math.abs(origPercent - updatedPercent) > 3) {
        handle.addClass('is-animated');
        this.range.addClass('is-animated');
      }
    },

    /**
     * If tooltips are active, updates the current placement and content of the Tooltip.
     * If no handle argument is passed, this method simply hides both handles' tooltips.
     * @param {jQuery[]} [handle] element representing a slider handle.
     */
    updateTooltip: function updateTooltip(handle) {
      if (!this.settings.tooltip) {
        return;
      }

      if (!handle) {
        var tooltipLow = this.handles[0].data('tooltip');
        var tooltipHigh;

        if (this.handles[1]) {
          tooltipHigh = this.handles[1].data('tooltip');
        }

        tooltipLow.hide();

        if (tooltipHigh) {
          tooltipHigh.hide();
        }

        return;
      }

      var tooltip = handle.data('tooltip');

      function update() {
        tooltip.position();
        handle.focus();
      } // NOTE: This is a bit hacky because it depends on the setTimeout() method for
      // animation that is triggered inside the self.updateRange() method to have not
      // fired yet.  If you put a breakpoint anywhere in there you may see strange
      // results with animation.


      if (handle.hasClass('is-animated')) {
        tooltip.hide();
        handle.one('slide-animation-end', function () {
          update();
        });
      } else {
        update();
      }
    },

    /**
     * Gets a string-based hex value for the closest tick's defined color.
     * @private
     * @returns {string} hex value representing a color
     */
    getColorClosestToValue: function getColorClosestToValue() {
      var currentVariant = theme.currentTheme.id.split('-')[2];
      var preColors = {
        light: {
          default: '#000000',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#f2bc41',
          good: '#9cce7c',
          'very-good': '#76b051',
          superior: '#488421'
        },
        dark: {
          default: '#ffffff',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#f2bc41',
          good: '#9cce7c',
          'very-good': '#76b051',
          superior: '#488421'
        },
        contrast: {
          default: '#000000',
          'very-poor': '#a13030',
          poor: '#d66221',
          adequate: '#e4882b',
          good: '#76b051',
          'very-good': '#56932e',
          superior: '#397514'
        }
      };
      var themeColors = preColors[currentVariant];
      var val = this.value()[0];
      var highestTickColor;
      var c;

      for (var i = 0; i < this.ticks.length; i++) {
        c = this.ticks[i].color;

        if (c && val >= this.ticks[i].value) {
          highestTickColor = c;
          highestTickColor = c.indexOf('#') > -1 ? c : themeColors[c] || themeColors.default;
        }
      }

      return highestTickColor;
    },

    /**
     * External Facing Function to set the value. Works as percent for now but need it on ticks.
     * NOTE:  Does not visually update the range.  Use _setValue()_ to do both in one swoop.
     * @param {number} minVal the smaller handle's value
     * @param {number} [maxVal] the larger handle's value, if applicable
     * @returns {array} both currently set handle values
     */
    value: function value(minVal, maxVal) {
      var self = this; // if both options are absent, act as a getter and return the current value

      if (minVal === undefined && maxVal === undefined) {
        return self._value;
      } // if an array is passed as the first argument, break it apart


      if (minVal && $.isArray(minVal)) {
        if (minVal[1] !== undefined) {
          maxVal = minVal[1];
        }

        minVal = minVal[0];
      } // set the values back to the existing one if they aren't passed.


      if (minVal === undefined && $.isArray(self._value) && self._value[0] !== undefined) {
        minVal = self._value[0];
      }

      if (maxVal === undefined && $.isArray(self._value) && self._value[1] !== undefined) {
        maxVal = self._value[1];
      } // set the internal value and the element's retrievable value.


      self._value = [minVal, maxVal];
      self.element.val(maxVal !== undefined ? self._value : self._value[0]);
      $.each(self.handles, function (i, handle) {
        var value = self._value[i];
        var valueText = self.getModifiedTextValue(value);
        $.each(self.ticks, function (a, tick) {
          if (tick.value === value) {
            valueText = tick.description;
          }
        });
        handle.attr({
          'aria-valuenow': self._value[i],
          'aria-valuetext': valueText
        });
      });

      if (this.element.next().find('.slider-handle.is-dragging').length === 0) {
        self.element.trigger('change', {
          element: self.element,
          value: self._value
        });
      }

      return self._value;
    },

    /**
     * Returns a value with prefixed/suffixed text content.
     * Used by the tooltip and default ticks to get potential identifiers like $ and %.
     * @private
     * @param {string} content the original tooltip content
     * @returns {string} prepended/appended text that will be displayed inside the tooltip
     */
    getModifiedTextValue: function getModifiedTextValue(content) {
      if (!this.settings.tooltip) {
        return content;
      }

      return this.settings.tooltip[0] + content + this.settings.tooltip[1];
    },

    /**
     * Enables the slider instance.
     * @returns {this} component instance
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.prop('readonly', false);
      this.wrapper.removeClass('is-readonly');
      this.wrapper.removeClass('is-disabled');
      var self = this;
      $.each(this.handles, function (i, handle) {
        self.enableHandleDrag(handle);
      });
      return this;
    },

    /**
     * Disables the slider instance.
     * @returns {this} component instance
     */
    disable: function disable() {
      var _this = this;

      this.element.prop('disabled', true);
      this.element.prop('readonly', false);
      this.wrapper.removeClass('is-readonly');
      setTimeout(function () {
        _this.wrapper.addClass('is-disabled');

        var self = _this;
        $.each(_this.handles, function (i, handle) {
          self.disableHandleDrag(handle);
        });
      });
      return this;
    },

    /**
     * Sets the slider in a readonly state
     * @returns {this} component instance
     */
    readonly: function readonly() {
      var _this2 = this;

      this.element.prop('disabled', true);
      this.element.prop('readonly', true);
      this.wrapper.removeClass('is-disabled');
      this.wrapper.addClass('is-readonly');
      $.each(this.handles, function (i, handle) {
        _this2.disableHandleDrag(handle);
      });
      return this;
    },

    /**
     * Detects whether or not this slider is disabled
     * @returns {boolean} whether or not this slider is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Detects whether or not this slider is vertical
     * @returns {boolean} whether or not this slider is vertical
     */
    isVertical: function isVertical() {
      return this.wrapper.hasClass('vertical');
    },

    /**
     * Externally-facing function that updates the current values and correctly
     * animates the range handles, if applicable.
     * @param {number} lowVal the value for the lower slider handle.
     * @param {number} [highVal] the value for the upper slider handle, if applicable.
     * @returns {array} the newly set values
     */
    setValue: function setValue(lowVal, highVal) {
      var oldVals = this.value();
      this.checkHandleDifference(this.handles[0], oldVals[0], lowVal);

      if (this.handles[1]) {
        this.checkHandleDifference(this.handles[1], oldVals[1], highVal);
      }

      var vals = this.value(lowVal, highVal);
      this.updateRange();
      this.updateTooltip();
      return vals;
    },

    /**
     * @deprecated in v4.2.0. Please use `setValue()` instead.
     * @param {number} lowVal the value for the lower slider handle.
     * @param {number} [highVal] the value for the upper slider handle, if applicable.
     * @returns {array} the newly set values
     */
    refresh: function refresh(lowVal, highVal) {
      return deprecateMethod(this.setValue, this.refresh).apply(this, [lowVal, highVal]);
    },

    /**
     * Updates the slider instance after a settings change.
     * Settings and markup are complicated in the slider so we just destroy and re-invoke it
     * with fresh settings.
     * @param {object|function} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.element.removeAttr('value');
      return this.teardown().init();
    },

    /**
     * Removes the events and pseudo-markup created by the slider
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var self = this;
      $.each(self.handles, function (i, handle) {
        self.disableHandleDrag(handle);
        handle.off('mousedown.slider click.slider blur.slider keydown.slider keyup.slider');
      });
      this.wrapper.off('click.slider touchend.slider touchcancel.slider').remove();
      this.element.attr('type', xssUtils.ensureAlphaNumeric(this.originalElement.type));
      return this;
    },

    /**
     * Destroys the slider component instance and unlinks it from its base element.
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$11);
    },

    /**
     * Handle component events.
     * @private
     * @returns {void}
     */
    bindEvents: function bindEvents() {
      var self = this;
      $.each(self.handles, function (i, handle) {
        handle.on('mousedown.slider', function () {
          if (self.isDisabled()) {
            return;
          }

          $(this).focus();
        }).on('click.slider', function (e) {
          e.preventDefault(); // Prevent from jumping to top.
        }).on('keydown.slider', function (e) {
          self.activateHandle(handle);
          self.handleKeys(e, self);
        }).on('keyup.slider blur.slider', function () {
          self.deactivateHandle(handle);
        });
        self.enableHandleDrag(handle);
      });
      self.wrapper.on('click.slider touchend.slider touchcancel.slider', function (e) {
        self.handleRangeClick(e);
      }); // Slider Control listens to 'updated' trigger on its base element to update values

      self.element.on('updated.slider', function () {
        self.updated();
      });
      return self;
    }
  };

  /**
   * jQuery Component Wrapper for Slider
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.slider = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$11);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$11, new Slider(this, settings));
      }
    });
  };

  var COMPONENT_NAME$12 = 'spinbox'; // Component Defaults

  var SPINBOX_DEFAULTS = {
    autocorrectOnBlur: true,
    min: -2147483647,
    max: 2147483647,
    step: null,
    maskOptions: null,
    attributes: null
  };
  /**
   * The Spinbox component provides easy access to modification of a numeric input field.
   * @class Spinbox
   * @constructor
   * @param {jQuery[]|HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.autocorrectOnBlur = true] If true the input will adjust to the nearest step on blur.
   * @param {Number} [settings.min = -2147483647] if defined, provides a minimum numeric limit
   * @param {Number} [settings.max = 2147483647]  if defined, provides a maximum numeric limit
   * @param {Number} [settings.maskOptions = null]  if defined this is passed to the internal mask component
   * @param {string} [settings.attributes = null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
   * @param {null|Number} [settings.step = null]  if defined, increases or decreases the spinbox value
   *  by a specific interval whenever the control buttons are used.
   *  the spinbox value after the spinbox has lost focus.
   */

  function Spinbox(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, SPINBOX_DEFAULTS);
    this.init();
  } // Plugin Methods


  Spinbox.prototype = {
    /**
     * @private
     * @returns {boolean} whether or not touch controls are available
     */
    get isTouch() {
      return Environment.features.touch;
    },

    /**
     * @returns {boolean} "true" if this spinbox is inside a wrapper.
     */
    get isWrapped() {
      return this.element.parent().is('.spinbox-wrapper');
    },

    /**
     * @returns {boolean} "true" if this spinbox is part of an inline label.
     */
    get isInlineLabel() {
      return this.element.parent().is('.inline');
    },

    /**
     * @private
     */
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');

      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      this.setInitialValue().addMarkup().bindEvents().setWidth();
    },

    /**
     * Sets the width of the spinbox input field.
     * @private
     * @returns {this} component instance
     */
    setWidth: function setWidth() {
      var style = this.element[0].style;

      if (style.width) {
        this.element.parent()[0].style.width = "".concat(parseInt(style.width, 10) + this.element.parent().find('.down').outerWidth() * 2, "px");
      }

      return this;
    },

    /**
     * Sanitize the initial value of the input field.
     * @private
     * @returns {this} component instance
     */
    setInitialValue: function setInitialValue() {
      var self = this;
      var val = self.checkForNumeric(self.element.val());
      this.element.val(val); // If using Dirty Tracking, reset the "original" value of the dirty tracker to the current value
      // of the input, since it may have changed after re-invoking the input field.

      if (this.element.attr('data-trackdirty')) {
        this.element.data('original', val);
      } // allow numeric input on iOS


      var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);

      if (iOS) {
        this.element.attr('pattern', '\\d*');
      }

      if (this.element.attr('max')) {
        this.settings.max = this.element.attr('max');
      } else if (this.settings.max) {
        this.element.attr('max', this.settings.max);
      }

      if (this.element.attr('step')) {
        this.settings.max = this.element.attr('step');
      } else if (this.settings.step) {
        this.element.attr('step', this.settings.step);
      }

      if (this.element.attr('min')) {
        this.settings.min = this.element.attr('min');
      } else if (this.settings.min) {
        this.element.attr('min', this.settings.min);
      }

      return this;
    },

    /**
     * Appends extra control markup to a Spinbox field.
     * @private
     * @returns {this} component instance
     */
    addMarkup: function addMarkup() {
      var _this = this;

      var self = this;

      if (this.isInlineLabel) {
        this.inlineLabel.addClass('spinbox-wrapper');
      } else if (!this.isWrapped) {
        var spinboxWrapper = '<span class="spinbox-wrapper"></span>';

        if (this.element.is('.field-options')) {
          var field = this.element.closest('.field');
          var fieldOptionsTrigger = field.find('.btn-actions');
          this.element.add(fieldOptionsTrigger).add(fieldOptionsTrigger.next('.popupmenu')).wrapAll(spinboxWrapper);
        } else {
          this.element.wrap(spinboxWrapper);
        }
      }

      if (this.isWrapped) {
        this.buttons = {
          down: this.element.parent().find('.down'),
          up: this.element.parent().find('.up')
        };
      }

      if (!this.buttons.up.length) {
        this.buttons.up = $("<span ".concat(this.isTouch ? '' : 'aria-hidden="true"', " class=\"spinbox-control up\">+</span>")).insertAfter(this.element);
        this.buttons.up.button();
      }

      if (!this.buttons.down.length) {
        this.buttons.down = $("<span ".concat(this.isTouch ? '' : 'aria-hidden="true"', " class=\"spinbox-control down\">-</span>")).insertBefore(this.element);
        this.buttons.down.button();
      }

      var sizes = ['input-xs', 'input-sm', 'input-mm', 'input-md', 'input-lg'];
      var elemClasses = this.element[0].className;
      sizes.forEach(function (size) {
        if (elemClasses.indexOf(size) > -1) {
          var spinboxSize = size.replace('input', 'spinbox');

          if (_this.isWrapped) {
            _this.element.parent('.spinbox-wrapper').addClass(spinboxSize);
          } else if (_this.isInlineLabel) {
            _this.inlineLabel.addClass(spinboxSize);
          }
        }
      }); // Figure out minimum/maximum and data-masking attributes.  The user can provide the spinbox
      // plugin either the min/max or the mask, and the plugin will automatically figure out how to
      // use them.

      var min = this.element.attr('min');
      var max = this.element.attr('max');
      var attributes = {
        role: 'spinbutton'
      }; // Define a default Max value if none of these attributes exist, to ensure the mask plugin will
      // work correctly.  Cannot define a Min value here because the plugin must be able to invoke
      // itself with a NULL value.

      if (!min && !max) {
        max = '9999999';
      } // If no negative symbol exists in the mask, the minimum value must be zero.


      attributes.min = min || 0;
      attributes.max = max; // Destroy the Mask Plugin if it's already been invoked.  We will reinvoke it later
      // on during initialization.  Check to make sure its the actual Mask plugin object,
      // and not the "data-mask" pattern string.

      if (this.element.data('mask') && _typeof(this.element.data('mask')) === 'object') {
        this.element.data('mask').destroy();
      } // Add Aria Properties for valuemin/valuemax


      attributes['aria-valuemin'] = min || 0;
      attributes['aria-valuemax'] = max || 0;
      this.element.attr(attributes); // Set an initial "aria-valuenow" value.

      this.updateAria(self.element.val()); // Invoke the mask plugin

      var maskOptions = {
        process: 'number',
        patternOptions: {
          allowDecimal: false,
          allowThousandsSeparator: false,
          allowNegative: Math.min(this.settings.min, this.settings.max) < 0,
          decimalLimit: 0,
          integerLimit: String(this.settings.max).length
        }
      };
      this.element.mask(this.settings.maskOptions || maskOptions); // Disable in full if the settings have determined we need to disable on init.

      if (this.isDisabled()) {
        this.disable();
      }

      if (this.element.attr('readonly')) {
        this.readonly();
      }

      utils.addAttributes(this.element.parent(), this, this.settings.attributes, 'wrapper', true);
      utils.addAttributes(this.element, this, this.settings.attributes, 'spinbox', true);
      utils.addAttributes(this.buttons.down, this, this.settings.attributes, 'btn-down', true);
      utils.addAttributes(this.buttons.up, this, this.settings.attributes, 'btn-up', true);
      return this;
    },

    /**
     * Enables Long Pressing one of the Spinbox control buttons.
     * @private
     * @param {jQuery.Event} e jQuery `touchstart` or `mousedown` events
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    enableLongPress: function enableLongPress(e, self) {
      self.addButtonStyle(e);
      self.longPressInterval = setInterval(function () {
        if ($(e.currentTarget).is(':hover')) {
          self.handleClick(e);
        }
      }, 250);
    },

    /**
     * Disables Long Pressing one of the Spinbox control buttons.
     * @private
     * @param {jQuery.Event} e jQuery `touchend` or `mouseup` events
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    disableLongPress: function disableLongPress(e, self) {
      self.removeButtonStyle(e);
      clearInterval(self.longPressInterval);
      self.longPressInterval = null;
    },

    /**
     * Event handler for 'click' events
     * @private
     * @param {jQuery.Event} e jQuery `click` event
     * @returns {void}
     */
    handleClick: function handleClick(e) {
      e.preventDefault();

      if (this.isDisabled() || e.which !== 1 || this.isReadonly()) {
        return;
      }

      var target = $(e.currentTarget);

      if (target.hasClass('up')) {
        this.increaseValue();
      } else {
        this.decreaseValue();
      }

      this.element.focus();
    },

    /**
     * Event handler for 'keydown' events
     * @private
     * @param {jQuery.Event} e jQuery `keydown` event
     * @param {Spinbox} self component instance
     */
    handleKeyDown: function handleKeyDown(e, self) {
      var key = e.which;
      var validKeycodes = [35, 36, 37, 38, 39, 40];

      if ($.inArray(key, validKeycodes) === -1) {
        return;
      }

      if (this.isReadonly()) {
        return;
      } // If the keycode got this far, it's an arrow key, HOME, or END.


      switch (key) {
        case 35:
          // End key sets the spinbox to its minimum value
          if (self.element.attr('min')) {
            self.element.val(self.element.attr('min'));
          }

          break;

        case 36:
          // Home key sets the spinbox to its maximum value
          if (self.element.attr('max')) {
            self.element.val(self.element.attr('max'));
          }

          break;

        case 38:
          // Up increases the spinbox value
          self.addButtonStyle(self.buttons.up);
          self.increaseValue();
          break;

        case 40:
          // Down decreases the spinbox value
          self.addButtonStyle(self.buttons.down);
          self.decreaseValue();
          break;
      }
    },

    /**
     * Event handler for 'keyup' events
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleKeyup: function handleKeyup(e, self) {
      if (self.isDisabled() || this.isReadonly()) {
        return;
      }

      var key = e.which; // Spinbox Control Button styles are added/removed on keyup.

      switch (key) {
        case 38:
        case 39:
          if (Locale.isRTL() && key === 39) {
            self.removeButtonStyle(self.buttons.down);
          } else {
            self.removeButtonStyle(self.buttons.up);
          }

          break;

        case 37:
        case 40:
          if (Locale.isRTL() && key === 39) {
            self.removeButtonStyle(self.buttons.up);
          } else {
            self.removeButtonStyle(self.buttons.down);
          }

          break;
      }

      self.updateAria(self.element.val());
    },

    /**
     * Change a newly pasted value to this element's min or max values, if the pasted
     * value goes beyond either of those limits.  Listens to an event emitted by the
     * Mask plugin after pasted content is handled.
     * @private
     * @param {Spinbox} self this component instance
     * @returns {void}
     */
    handleAfterPaste: function handleAfterPaste(self) {
      var min = Number(self.element.attr('min'));
      var max = Number(self.element.attr('max'));
      var val = Number(self.element.val());

      if (val < min) {
        val = min;
      }

      if (val > max) {
        val = max;
      }

      self.updateVal(val);
    },

    /**
     * Fixes a value that may have been entered programmatically, or by paste,
     * if it goes out of the range boundaries.
     * @private
     * @param {jQuery.Event} e jQuery `input` event
     * @returns {void}
     */
    correctValue: function correctValue(e) {
      var num = Number(this.element.val());
      var min = parseInt(this.element.attr('min'), 10);
      var max = parseInt(this.element.attr('max'), 10);

      if (num < min) {
        if (e) {
          e.preventDefault();
        }

        return this.updateVal(min);
      }

      if (num > max) {
        if (e) {
          e.preventDefault();
        }

        return this.updateVal(max);
      }

      return undefined;
    },

    /**
     * Increases the value of the Spinbox field, constrained by the step interval and maximum limit.
     * @returns {void}
     */
    increaseValue: function increaseValue() {
      var max = this.element.attr('max');
      var val = this.checkForNumeric(this.element.val()) + Number(this.element.attr('step') || 1);

      if (max && val > max) {
        return this.updateVal(max);
      }

      return this.updateVal(val);
    },

    /**
     * Decreases the value of the Spinbox field, constrained by the step interval and minimum limit.
     * @returns {void}
     */
    decreaseValue: function decreaseValue() {
      var min = this.element.attr('min');
      var val = this.checkForNumeric(this.element.val()) - Number(this.element.attr('step') || 1);

      if (min && val < min) {
        return this.updateVal(min);
      }

      return this.updateVal(val);
    },

    /**
     * Sets a new spinbox value and focuses the spinbox.
     * @param {Number|String} newVal the value to set on the spinbox
     * @returns {void}
     */
    updateVal: function updateVal(newVal) {
      this.element.val(newVal).trigger('change');
      this.updateAria(newVal);
    },

    /**
     * Sanitizes the value of the input field to an integer if it isn't already established.
     * @private
     * @param {Number|String} val will be converted to a number if it's a string.
     * @returns {number} a numeric version of the value provided, or a corrected value.
     */
    checkForNumeric: function checkForNumeric(val) {
      // Allow for NULL
      if (val === '') {
        return val;
      }

      if ($.isNumeric(val)) {
        return Number(val);
      }

      val = parseInt(val, 10);

      if ($.isNumeric(val)) {
        return Number(val);
      } // Zero out the value if a number can't be made out of it.


      return 0;
    },

    /**
     * Updates the "aria-valuenow" property on the spinbox element if the value is currently set
     * @private
     * @param {number} val the new value to be set on the spinbox
     * @returns {void}
     */
    updateAria: function updateAria(val) {
      var min = this.element.attr('min');
      var max = this.element.attr('max');
      val = this.checkForNumeric(val);
      this.element[0].setAttribute('aria-valuenow', val || '0');
      this.element[0].setAttribute('autocomplete', 'off'); // Toggle min/max buttons

      this.setIsDisabled(this.buttons.up, val !== '' && max && val >= max ? 'disable' : 'enable');
      this.setIsDisabled(this.buttons.down, val !== '' && min && val <= min ? 'disable' : 'enable');
    },

    /**
     * Adds a "pressed-in" styling for one of the spinner buttons.
     * @private
     * @param {jQuery.Event|jQuery[]} e either an incoming event, or a button element to be acted on
     * @returns {void}
     */
    addButtonStyle: function addButtonStyle(e) {
      if (this.isDisabled() || this.isReadonly()) {
        return;
      }

      var target = e;

      if (e.currentTarget) {
        target = $(e.currentTarget);
      }

      target.addClass('is-active');
    },

    /**
     * Removes "pressed-in" styling for one of the spinner buttons
     * @private
     * @param {jQuery.Event|jQuery[]} e either an incoming event, or a button element to be acted on
     * @returns {void}
     */
    removeButtonStyle: function removeButtonStyle(e) {
      if (this.isDisabled() || this.isReadonly()) {
        return;
      }

      var target = e;

      if (e.currentTarget) {
        target = $(e.currentTarget);
      }

      target.removeClass('is-active');
    },

    /**
     * Enables the Spinbox
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false);
      this.element.parent('.spinbox-wrapper').removeClass('is-disabled is-readonly');
      this.element.prop('readonly', false);
    },

    /**
     * Disables the Spinbox
     * @returns {void}
     */
    disable: function disable() {
      var _this2 = this;

      this.element.prop('disabled', true);
      this.element.attr('disabled', 'disabled');
      this.element.parent('.spinbox-wrapper').addClass('is-disabled');
      setTimeout(function () {
        _this2.element.parent('.spinbox-wrapper').addClass('is-disabled');
      });
    },

    /**
     * Makes the Spinbox readonly
     * @returns {void}
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
      this.element.parent('.spinbox-wrapper').addClass('is-readonly');
    },

    /**
     * Checks if the Spinbox is readonly
     * @returns {void}
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },

    /**
     * Determines whether or not the spinbox is disabled.
     * @returns {boolean} whether or not the spinbox is disabled.
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Toggle whther or not the component is disabled.
     * @private
     * @param {jQuery[]} button the button element to be disabled
     * @param {booelan} [isDisabled] whether or not to force a change to the button's state.
     * @returns {void}
     */
    setIsDisabled: function setIsDisabled(button, isDisabled) {
      isDisabled = isDisabled === undefined ? true : !(!isDisabled || isDisabled === 'enable');
      button[isDisabled ? 'addClass' : 'removeClass']('is-disabled');
    },

    /**
     * Updated
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this;
    },

    /**
     * Teardown
     * @returns {void}
     */
    destroy: function destroy() {
      var mask = this.element.data('mask');

      if (mask && typeof mask.destroy === 'function') {
        mask.destroy();
      }

      for (var button in this.buttons) {
        // eslint-disable-line
        var buttonAPI = $(button).data('button');

        if (buttonAPI) {
          buttonAPI.destroy();
        }
      }

      this.buttons.up.off('click.spinbox mousedown.spinbox');
      this.buttons.up.remove();
      this.buttons.down.off('click.spinbox mousedown.spinbox');
      this.buttons.down.remove();
      this.element.off('focus.spinbox blur.spinbox keydown.spinbox keyup.spinbox');
      this.element.unwrap();
      $.removeData(this.element[0], COMPONENT_NAME$12);
    },

    /**
    *  Fires when the input gains focus.
    * @event focus
    * @memberof Spinbox
    * @property {object} event - The jquery event object
    */

    /**
     * Fires when the input looses focus.
     * @event blur
     * @memberof Spinbox
     * @property {object} event - The jquery event object
     */

    /**
      * Fires when a key is pressed down.
      * @event keydown
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */

    /**
      * Fires when a key is pressed.
      * @event keypress
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */

    /**
      * Fires when a key is pressed up.
      * @event keyup
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */

    /**
      * Fires after input is pasted in.
      * @event afterpaste
      * @memberof Spinbox
      * @property {object} event - The jquery event object
    */

    /**
     * Sets up event handlers for this control and its sub-elements
     * @private
     * @returns {void}
     */
    bindEvents: function bindEvents() {
      var self = this;
      var preventClick = false; // Main Spinbox Input

      this.element.on('focus.spinbox', function () {
        self.element.parent('.spinbox-wrapper').addClass('is-focused');
      }).on('blur.spinbox', function () {
        self.element.parent('.spinbox-wrapper').removeClass('is-focused');

        if (self.settings.autocorrectOnBlur) {
          self.correctValue();
        }
      }).on('keydown.spinbox', function (e) {
        self.handleKeyDown(e, self);
      }).on('keyup.spinbox', function (e) {
        self.handleKeyup(e, self);
      }).on('afterpaste.mask', function () {
        self.handleAfterPaste(self);
      }); // Up and Down Buttons

      var buttons = this.buttons.up.add(this.buttons.down[0]);
      buttons.on('touchstart.spinbox mousedown.spinbox', function (e) {
        if (e.which === 1) {
          if (!preventClick) {
            self.handleClick(e);
          }

          if (self.isTouch) {
            return;
          }

          preventClick = true;
          self.enableLongPress(e, self);
          $(document).one('mouseup', function () {
            self.disableLongPress(e, self);
            preventClick = false;
            self.element.focus();
          });
        }
      });
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Spinbox
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.spinbox = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$12);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$12, new Spinbox(this, settings));
      }
    });
  };

  var COMPONENT_NAME$13 = 'splitter'; // Default Splitter Options

  var SPLITTER_DEFAULTS = {
    axis: 'x',
    side: 'left',
    // or right
    resize: 'immediate',
    containment: null,
    // document or parent
    save: true,
    maxWidth: {
      left: 'auto',
      right: 'auto'
    },
    attributes: null
  };
  /**
  * Splitter Component
  * @class Splitter
  * @constructor
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  * @param {string} [settings.axis = 'x'] The axis on which to split x or y
  * @param {string} [settings.side = 'left'] Which side to dock to 'left' or 'right'.
  * @param {string} [settings.resize = 'immediate'] When to resize, during the drag 'immediate' or 'end'
  * @param {HTMLElement|jQuery[]} [settings.containment = null] When to stop the splitter, this can be document, or a parent element
  * @param {boolean} [settings.save = true] If true the split size will automatically be saved for next time
  * @param {object} [settings.maxWidth = {left: 'auto', right: 'auto'}] Ability to stop dragging at a max left or right size.
  * @param {string} [settings.attributes=null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function Splitter(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SPLITTER_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Plugin Methods


  Splitter.prototype = {
    /**
     * Do other init (change/normalize settings, load externals, etc)
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.build().handleEvents();
    },

    /**
     * Build the Control and Events
     * @private
     * @returns {void}
     */
    build: function build() {
      var _this = this;

      var self = this;
      var s = this.settings;
      var splitter = this.element;
      var parent = splitter.parent();
      var direction = s.axis === 'x' ? 'left' : 'top';
      var thisSide = parent.is('.content') ? parent.parent() : parent;
      var dragHandle = $("<div class=\"splitter-drag-handle\">".concat($.createIcon('drag'), "</div>"));
      var defaultOffset = 299;
      var w = parent.width();
      var parentHeight;
      this.isRTL = Locale.isRTL();
      setTimeout(function () {
        parentHeight = parent.height();
      }, 0);
      this.docBody = $('body');
      this.isSplitterRightSide = splitter.is('.splitter-right') || s.axis === 'x' && s.side === 'right';
      this.isSplitterHorizontal = splitter.is('.splitter-horizontal') || s.axis === 'y';
      s.uniqueId = utils.uniqueId(this.element, 'splitter');
      dragHandle.appendTo(splitter);
      dragHandle.prepend("<span class=\"audible\">".concat(Locale.translate('SplitterDragHandle'), "</span>"));

      var handleCollapseButton = function handleCollapseButton() {
        var savedOffset = 0;
        var isClickedOnce = false;

        var splitAndRotate = function splitAndRotate(splitVal, el, isRotate) {
          self.splitTo(splitVal, parentHeight);
          $(el)[isRotate ? 'addClass' : 'removeClass']('rotate');
        };

        _this.splitterCollapseButton = $("<button type=\"button\" class=\"splitter-btn\" id=\"splitter-collapse-btn\"><span class=\"audible\">".concat(Locale.translate('SplitterCollapseButton'), "</span><svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-double-chevron\"></use></svg></button>"));

        _this.splitterCollapseButton.appendTo(splitter);

        if (splitter[0].offsetLeft > 10) {
          _this.splitterCollapseButton.addClass('rotate');
        }

        _this.splitterCollapseButton.click(function () {
          var isDragging = splitter.is('is-dragging');

          if (isDragging) {
            return;
          }

          if (self.isRTL && !self.isSplitterHorizontal || !self.isSplitterRightSide && s.side === 'left' || self.isSplitterRightSide && s.side === 'right') {
            var containerWidth = self.getContainerWidth() - splitter.outerWidth();
            var x = containerWidth;

            if (!isClickedOnce) {
              savedOffset = containerWidth - savedOffset;
              defaultOffset = containerWidth - defaultOffset;
            }

            var left = splitter[0].offsetLeft;

            if (self.isSplitterRightSide && s.side === 'right') {
              left = splitter[0].offsetLeft + 1;
            }

            if (savedOffset >= x) {
              if (left >= containerWidth) {
                splitAndRotate(defaultOffset, this, true);
              } else {
                savedOffset = left;
                splitAndRotate(x, this, false);
              }
            } else if (left < containerWidth) {
              savedOffset = left;
              splitAndRotate(x, this, false);
            } else {
              splitAndRotate(savedOffset, this, true);
              savedOffset = x;
            }
          } else {
            var _left = splitter[0].offsetLeft;

            if (savedOffset <= 0) {
              if (_left <= 10) {
                splitAndRotate(defaultOffset, this, true);
              } else {
                savedOffset = _left;
                splitAndRotate(0, this, false);
              }
            } else if (_left > 10) {
              savedOffset = _left;
              splitAndRotate(0, this, false);
            } else {
              splitAndRotate(savedOffset, this, true);
              savedOffset = 0;
            }
          }

          isClickedOnce = true;
        });
      };

      if (this.isSplitterRightSide) {
        var thisPrev = thisSide.prev();

        if (thisPrev.is('.main')) {
          this.leftSide = thisPrev;
          w = thisSide.parent().outerWidth() - w;
        } else {
          this.leftSide = thisSide;
          splitter.addClass('splitter-right');
        }

        thisSide.addClass('is-right-side').next().addClass('flex-grow-shrink is-right-side').parent().addClass('splitter-container');

        if (s.collapseButton) {
          handleCollapseButton();
        }

        this.setSplitterContainer(thisSide.parent());
      } else if (this.isSplitterHorizontal) {
        this.topPanel = splitter.prev();
        w = this.topPanel.height();
        parent.addClass('splitter-container is-horizontal');
        splitter.next().addClass('flex-grow-shrink');
        splitter.addClass('splitter-horizontal');
      } else {
        this.rightSide = thisSide;
        this.leftSide = thisSide.prev().parent();
        thisSide.prev().addClass('flex-grow-shrink').parent().addClass('splitter-container');

        if (s.collapseButton) {
          handleCollapseButton();
        }

        this.setSplitterContainer(thisSide.parent());
      }

      if (this.isRTL && !this.isSplitterHorizontal) {
        var containerWidth = this.getContainerWidth();
        w = containerWidth >= w ? containerWidth - w : w;
      } // Restore from local storage


      if (localStorage && s.save && !isNaN(parseInt(localStorage[s.uniqueId], 10))) {
        w = localStorage[s.uniqueId];
      }

      w = parseInt(w, 10);

      if (this.isSplitterHorizontal) {
        splitter[0].style.top = "".concat(w, "px");
      } else {
        splitter[0].style.top = 0;
      }

      this.splitTo(w, parentHeight);

      if (w <= 10 && this.splitterCollapseButton) {
        this.splitterCollapseButton.removeClass('rotate');
      } // Add the Splitter Events


      this.documentWidth = 0;
      this.element.drag({
        axis: s.axis,
        containment: s.containment || s.axis === 'x' ? 'document' : 'parent',
        containmentOffset: {
          left: 0,
          top: 0
        }
      }).on('dragstart.splitter', function () {
        var iframes = thisSide.parent().find('iframe');
        self.documentWidth = $(document).width();

        if (iframes.length > 0) {
          for (var i = 0, l = iframes.length; i < l; i++) {
            var frame = $(iframes[i]); // eslint-disable-next-line

            var width = "".concat(parseInt(getComputedStyle(frame.parent()[0]).width, 10), "px");
            var overlay = $('<div class="overlay splitter-overlay"></div>');
            overlay.css('width', width);
            frame.before(overlay);
          }
        }
      }).on('dragend.splitter', function (e, args) {
        thisSide.parent().find('.splitter-overlay').remove();
        var splitRect = splitter[0].getBoundingClientRect();
        var splitOffset = window.innerWidth - splitRect.left;
        var isRightSide = _this.isSplitterRightSide && _this.settings.side === 'right' || !_this.isSplitterRightSide && _this.settings.side === 'left'; // Prevent splitter content area to remain open if splitter is dragged rapidly.
        // Make sure the width is reset when splitter is flush left.

        if (splitRect.left === 0) {
          thisSide[0].style.width = '0px';
          args[direction] = 10;
        }

        if (s.collapseButton) {
          if (args[direction] <= 10 || isRightSide && splitOffset <= 21) {
            $('#splitter-collapse-btn').removeClass('rotate');
          } else {
            $('#splitter-collapse-btn').addClass('rotate');
          }
        }

        if (s.resize === 'end') {
          self.splitTo(args[direction], parentHeight);
        } // Run here on `dragend` and `drag` because it take some time to apply, which leaving some gap in between especially with case zero or less value.


        if (s.resize === 'immediate' && _this.isRTL && !_this.isSplitterHorizontal) {
          setTimeout(function () {
            var left = parseInt(_this.element.css('left'), 10);
            self.splitTo(left, parentHeight);
          }, 0);
        }
      }).on('drag.splitter', function (e, args) {
        if (args.left <= 0) {
          return false;
        }

        if (s.resize === 'immediate') {
          self.splitTo(args[direction], parentHeight);
        }

        return true;
      }); // Horizontal Splitter

      if (s.axis === 'y') {
        this.element.addClass('splitter-horizontal');
      } // Aria


      this.element.attr({
        'aria-dropeffect': 'move',
        tabindex: '0',
        'aria-grabbed': 'false'
      });
      utils.addAttributes(this.element, this, this.settings.attributes, '', true);
      utils.addAttributes(this.element.find('.splitter-drag-handle'), this, this.settings.attributes, 'handle', true);
      utils.addAttributes(this.element.find('.splitter-drag-handle svg.icon'), this, this.settings.attributes, 'icon', true);
      return this;
    },

    /**
     * Set the splitter container
     * @private
     * @param {jQueryElement} parentEl The main parent container element.
     * @returns {void}
     */
    setSplitterContainer: function setSplitterContainer(parentEl) {
      this.container = this.element.closest('.splitter-container');

      if (!this.container.length && parentEl && parentEl.length) {
        parentEl.addClass('splitter-container');
        this.container = this.element.closest('.splitter-container');
      }
    },

    /**
     * Get splitter container width
     * @private
     * @returns {number} Container width
     */
    getContainerWidth: function getContainerWidth() {
      var _this$container;

      return ((_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container == null ? void 0 : _this$container.outerWidth()) || 0;
    },

    /**
     * Toggle selection
     * @private
     * @returns {void}
     */
    toggleSelection: function toggleSelection() {
      this.element.toggleClass('is-dragging');
    },

    /**
     * Resize the panel vertically
     * @private
     * @param {object} splitter element.
     * @param {number} top value.
     * @param {number} parentHeight value.
     * @returns {void}
     */
    resizeTop: function resizeTop(splitter, top, parentHeight) {
      if (top > parentHeight || top < 0) {
        top = parseInt(parentHeight, 10) / 2;
      }

      this.topPanel[0].style.height = "".concat(top, "px");
    },

    /**
     * Resize the panel to the Left
     * @private
     * @param {object} splitter element.
     * @param {number} leftArg value.
     * @returns {void}
     */
    resizeLeft: function resizeLeft(splitter, leftArg) {
      var left = this.isRTL ? leftArg + 20 : this.leftSide.outerWidth() - leftArg; // Adjust Left and Right Side

      this.rightSide[0].style.width = "".concat(left, "px"); // Reset the Width

      splitter[0].style.left = '';
    },

    /**
     * Resize the panel to the Right
     * @private
     * @param {object} splitter element.
     * @param {number} w - width value.
     * @returns {void}
     */
    resizeRight: function resizeRight(splitter, w) {
      var parent = splitter.parent();
      var thisSide = parent.is('.content') ? parent.parent() : parent;
      var width = w;
      var left = w - 1;

      if (this.isRTL && !this.isSplitterHorizontal) {
        var containerWidth = this.getContainerWidth();
        width = containerWidth >= w ? containerWidth - w - 20 : w;
        left = w;
      }

      if (!this.isSplitterRightSide && this.settings.side === 'left' || this.isSplitterRightSide && this.settings.side === 'right') {
        thisSide[0].style.width = '0px';
      } // Adjust Left and Right Side


      this.leftSide[0].style.width = "".concat(width, "px");
      splitter[0].style.left = "".concat(left, "px");
    },

    /**
     * Split to
     * @private
     * @param {number} split value.
     * @param {number} parentHeight value.
     * @returns {void}
     */
    splitTo: function splitTo(split, parentHeight) {
      var self = this;
      var s = this.settings;
      var splitter = this.element;

      if (this.isSplitterRightSide) {
        if (!this.isRTL && split > s.maxWidth.right || this.isRTL && split < s.maxWidth.right) {
          split = s.maxWidth.right;
        }

        this.resizeRight(splitter, split);
      } else if (this.isSplitterHorizontal) {
        this.resizeTop(splitter, split, parentHeight);
      } else {
        if (!this.isRTL && split > s.maxWidth.left || this.isRTL && split < s.maxWidth.left) {
          split = s.maxWidth.left;
        }

        this.resizeLeft(splitter, split);
      }
      /**
      * Fires when after the split occurs. Allowing you to sync any ui.
      * @event split
      * @memberof Splitter
      * @property {object} event The jquery event object
      * @property {number} split value
      */


      this.element.trigger('split', [split]);
      this.docBody.triggerHandler('resize', [self]); // Save to local storage

      if (localStorage) {
        localStorage[this.settings.uniqueId] = split;
      }

      this.split = split;
      this.parentHeight = parentHeight;
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.off("updated.".concat(COMPONENT_NAME$13));
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SPLITTER_DEFAULTS);
        return this.destroy().init();
      }

      return this;
    },

    /**
    * Destroy and remove added markup, all events
    * @returns {void}
    */
    destroy: function destroy() {
      this.unbind();

      if (this.splitterCollapseButton) {
        this.splitterCollapseButton.remove();
      }

      $.removeData(this.element[0], COMPONENT_NAME$13);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element
      /**
      * Fires when the component updates.
      *
      * @event updated
      * @memberof Splitter
      * @type {object}
      * @property {object} event - The jquery event object
      */
      .on("updated.".concat(COMPONENT_NAME$13), function () {
        _this2.updated();
      })
      /**
      * Fires when a key is pressed while the component is focused.
      *
      * @event keydown
      * @memberof Splitter
      * @type {object}
      * @property {object} event - The jquery event object
      */
      .on("keydown.".concat(COMPONENT_NAME$13), function (e) {
        // Space will toggle selection
        if (e.which === 32) {
          _this2.toggleSelection();

          e.preventDefault();
        }

        if (e.which === 37) {
          _this2.splitTo(_this2.split - 15, _this2.parentHeight);
        }

        if (e.which === 39) {
          _this2.splitTo(_this2.split + 15, _this2.parentHeight);
        }
      });
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Splitter
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.splitter = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$13);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$13, new Splitter(this, settings));
      }
    });
  };

  var COMPONENT_NAME$14 = 'swaplist'; // The Component Defaults

  var SWAPLIST_DEFAULTS = {
    // Searchable
    searchable: false,
    // Datasets
    available: null,
    selected: null,
    additional: null,
    // Main containers
    availableClass: '.available',
    selectedClass: '.selected',
    additionalClass: '.full-access',
    // Action buttons
    availableBtn: '.btn-moveto-selected',
    selectedBtnLeft: '.btn-moveto-left',
    selectedBtnRight: '.btn-moveto-right',
    additionalBtn: '.btn-moveto-selected',
    draggable: {
      available: true,
      selected: true,
      additional: true
    },
    attributes: null,
    // Template HTML
    template: '' + '<ul data-swap-handle=".handle">' + '{{#dataset}}' + '{{#text}}' + '<li data-id="{{id}}"' + '{{#value}} data-value="{{value}}"{{/value}}' + '{{#selected}} selected="selected"{{/selected}}' + '{{#disabled}} class="is-disabled"{{/disabled}}' + '>' + '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>' + '<div class="swaplist-item-content"><p>{{text}}</p></div>' + '</li>' + '{{/text}}' + '{{/dataset}}' + '</ul>'
  };
  /**
  * The SwapList Component creates a list of options that can be picked and organized.
  * @class SwapList
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.searchable = false] If true, associates itself with a Searchfield/Autocomplete
  *  and allows itself to be filtered
  * @param {array} [settings.available] An array containing items for the available bucket.
  * @param {array} [settings.selected] An array containing items for the selected bucket.
  * @param {array} [settings.additional] An array containing items for the additional bucket.
  * @param {string} [settings.availableClass = '.available'] A class name linking the available root element.
  * @param {string} [settings.selectedClass = '.selected'] A class name linking the selected root element.
  * @param {string} [settings.additionalClass = '.full-access'] A class name linking the additional root element.
  * @param {string} [settings.availableBtn = '.btn-moveto-selected'] A class name linking the available button element.
  * @param {string} [settings.selectedBtnLeft = '.btn-moveto-left'] A class name linking the move left button element.
  * @param {string} [settings.selectedBtnRight = '.btn-moveto-right'] A class name linking the move right button element.
  * @param {string} [settings.additionalBtn = '.btn-moveto-selected'] A class name linking the additional button element.
  * @param {string|array} [settings.attributes = null] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  * @param {string} [settings.template] An Html String with the mustache template for the view.
  * @param {object} [settings.draggable] An object containing boolean key/value to make container/s
  *  disable for dragging and moving items. Supported keys with draggable are "available",
  *  "selected", "additional".
  */

  function SwapList(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SWAPLIST_DEFAULTS);
    this.element = $(element);
    this.init();
  } // SwapList Methods


  SwapList.prototype = {
    init: function init() {
      var _this = this;

      var s = this.settings;
      s.draggable = $.extend(true, SWAPLIST_DEFAULTS.draggable, s.draggable);
      this.isTouch = Environment.features.touch;
      this.isAdditional = $("".concat(s.additionalClass, " .listview"), this.element).length > 0;

      if (this.isTouch) {
        this.element.addClass('is-touch');
      }

      this.loadListview();
      this.initDataset();
      this.setElements();
      this.isMultiSelectClass();
      setTimeout(function () {
        // Wait for Listview availability
        _this.makeDraggable();

        _this.handleEvents();

        _this.initSelected(s.availableClass);

        _this.initSelected(s.additionalClass);
      }, 0);
    },

    /**
     * Load listview
     * @private
     */
    loadListview: function loadListview() {
      var s = this.settings;
      var containers = [{
        dataset: s.available,
        class: s.availableClass,
        draggable: s.draggable.available
      }, {
        dataset: s.selected,
        class: s.selectedClass,
        draggable: s.draggable.selected
      }, {
        dataset: s.additional,
        class: s.additionalClass,
        draggable: s.draggable.additional
      }];

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var lv = $("".concat(c.class, " .listview"), this.element);
        var list = lv.data('listview');
        var options = {
          dataset: c.dataset || [],
          selectable: 'multiple',
          showCheckboxes: false
        };
        var isSearchable = (s.searchable === true || s.searchable === 'true') && $("".concat(c.class, " .searchfield"), this.element).length > 0;

        if (isSearchable) {
          options.searchable = true;
        } // Initialize listview


        if (!c.dataset && lv.length && $('li', lv).length) {
          lv.listview(options);
        } else if (lv.length) {
          // Remove any previous listview instance
          if (list) {
            list.destroy();
          } // Force to have id attribute


          if (s.template.indexOf('data-id="{{id}}"') === -1) {
            s.template = s.template.replace('<li', '<li data-id="{{id}}"');
          }

          options.template = s.template;
          options.dataset = c.dataset || []; // Generate unique id

          options.dataset.forEach(function (node) {
            if (!/string|number/.test(_typeof(node.id)) || node.id === '') {
              node.id = "sw".concat((Date.now().toString(36) + Math.round(Math.random() * Math.pow(36, 12)).toString(36).substr(2, 5)).toLowerCase());
            }
          });

          if (options.dataset.length === 0) {
            options.forceToRenderOnEmptyDs = true;
          }

          options.attributes = this.getLvAutomationAttributes(c.class);
          lv.listview(options);
        } // Add css class('is-not-droppable') to ul in this container


        if (!c.draggable) {
          $('ul', lv).addClass('is-not-droppable');
        }
      }
    },

    /**
     * Get list view settings for automation attributes
     * @private
     * @param {string} cssClass class name
     * @returns {object|array} attributes with suffix
     */
    getLvAutomationAttributes: function getLvAutomationAttributes(cssClass) {
      var _this2 = this;

      var s = this.settings;
      var attributes;

      if (s.attributes && typeof cssClass === 'string' && cssClass.length > 1) {
        var suffix = "-swaplist-".concat(cssClass.substring(1)); // remove first dot

        if (Array.isArray(s.attributes)) {
          attributes = [];
          s.attributes.forEach(function (item) {
            var value = typeof item.value === 'function' ? item.value(_this2) : item.value;
            attributes.push({
              name: item.name,
              value: value + suffix
            });
          });
        } else {
          var value = typeof s.attributes.value === 'function' ? s.attributes.value(this) : s.attributes.value;
          attributes = {
            name: s.attributes.name,
            value: value + suffix
          };
        }
      }

      return attributes;
    },

    /**
     * Set elements
     * @private
     */
    setElements: function setElements() {
      var _this3 = this;

      var s = this.settings;
      var disabledBtnStr = '';
      this.offset = null;
      this.containers = $("".concat(s.availableClass, ",").concat(s.selectedClass, ",").concat(s.additionalClass), this.element);
      this.actionButtons = $("".concat(s.availableBtn, ",").concat(s.additionalBtn, ",").concat(s.selectedBtnLeft, ",").concat(s.selectedBtnRight), this.element);
      this.selectedButtons = $("".concat(s.selectedBtnLeft, ",").concat(s.selectedBtnRight), this.element);
      this.tabButtonsStr = "".concat(s.availableBtn, ", ").concat(s.additionalBtn, ", ").concat(this.selectedButtons.length > 1 ? s.selectedBtnRight : s.selectedBtnLeft);
      this.dragElements = 'ul:not(.is-not-droppable), ul:not(.is-not-droppable) li:not(.is-disabled)';
      this.dragStart = 'dragstart.swaplist touchstart.swaplist gesturestart.swaplist';
      this.dragEnterWhileDragging = 'dragenter.swaplist';
      this.dragOverWhileDragging = 'dragover.swaplist touchmove.swaplist gesturechange.swaplist';
      this.dragEnd = 'dragend.swaplist touchend.swaplist touchcancel.swaplist gestureend.swaplist';
      this.selections = {
        items: [],
        owner: null,
        related: null,
        droptarget: null,
        isInSelection: null,
        isHandle: null,
        placeholder: null,
        placeholderTouch: null,
        dragged: null,
        draggedIndex: null
      }; // Dragging time placeholder

      s.numOfSelectionsClass = 'num-of-selections';
      s.itemContentClass = 'swaplist-item-content';
      s.itemContentTempl = $("<div><p><span class=\"".concat(s.numOfSelectionsClass, "\">###</span>\n      <span class=\"").concat(s.numOfSelectionsClass, "-text\">&nbsp;</span></p><div/>")); // Add automation attributes to header buttons

      if (s.attributes) {
        var autoAttr = [{
          btn: $("".concat(s.availableClass, " ").concat(s.availableBtn), this.element),
          suffix: (s.availableClass || '').substring(1) // available

        }, {
          btn: $("".concat(s.selectedClass, " ").concat(s.selectedBtnLeft), this.element),
          suffix: "".concat((s.selectedClass || '').substring(1), "-left") // selected-left

        }, {
          btn: $("".concat(s.selectedClass, " ").concat(s.selectedBtnRight), this.element),
          suffix: "".concat((s.selectedClass || '').substring(1), "-right") // selected right

        }, {
          btn: $("".concat(s.additionalClass, " ").concat(s.additionalBtn), this.element),
          suffix: (s.additionalClass || '').substring(1) // additional

        }];
        autoAttr.forEach(function (x) {
          x.suffix = "swaplist-btn-".concat(x.suffix);
        });
        autoAttr.forEach(function (x) {
          return utils.addAttributes(x.btn, _this3, s.attributes, x.suffix);
        });
      } // Make top buttons disabled if not draggable


      if (!s.draggable.available) {
        disabledBtnStr = "".concat(s.availableClass, " ").concat(s.availableBtn, ",").concat(s.selectedBtnLeft);
        $(disabledBtnStr, this.element).prop('disabled', true);
      }

      if (!s.draggable.selected) {
        disabledBtnStr = "".concat(s.selectedBtnLeft, ",").concat(s.selectedBtnRight);

        if (!s.draggable.available) {
          disabledBtnStr += ",".concat(s.additionalClass, " ").concat(s.additionalBtn);
        }

        if (!this.isAdditional || !s.draggable.additional) {
          disabledBtnStr += ",".concat(s.availableClass, " ").concat(s.availableBtn);
        }

        $(disabledBtnStr, this.element).prop('disabled', true);
        $("".concat(s.additionalClass, " ").concat(s.additionalBtn), this.element).addClass('is-rotate');
      }

      if (!s.draggable.additional) {
        $("".concat(s.additionalClass, " ").concat(s.additionalBtn, ",").concat(s.selectedBtnRight), this.element).prop('disabled', true);
      }
    },

    /**
     * When list is Empty force to add css class "is-multiselect"
     * @private
     */
    isMultiSelectClass: function isMultiSelectClass() {
      var s = this.settings;
      var containers = [s.availableClass, s.selectedClass, s.additionalClass];

      for (var i = 0, l = containers.length; i < l; i++) {
        var lv = $("".concat(containers[i], " .listview"), this.element);

        if (!$('li', lv).length) {
          lv.addClass('is-multiselect');
        }
      }
    },

    /**
     * Initialize pre selected items
     * @private
     * @param {jQuery|HTMLElement} container container element
     * @returns {void}
     */
    initSelected: function initSelected(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);

      if (container.length) {
        var list = $('.listview', container).data('listview');
        var selected = $('li[selected]', container);

        for (var i = 0, l = selected.length; i < l; i++) {
          var li = $(selected[i]);
          li.removeAttr('selected');
          list.select(li); // Select this item
        }

        this.moveElements(container, this.settings.selectedClass);
      }
    },

    /**
     * Move Elements
     * @private
     * @param {jQuery[]|HTMLElement} from beginning container
     * @param {jQuery[]|HTMLElement} to ending contaner
     * @returns {void}
     */
    moveElements: function moveElements(from, to) {
      if (to === null) {
        return;
      }

      from = typeof from !== 'string' ? from : $(from, this.element);
      to = typeof to !== 'string' ? to : $(to, this.element);
      var list = $('.listview', from).data('listview');
      this.clearSelections();
      this.selections.owner = from;
      this.selections.droptarget = to;

      if (this.isTouch) {
        if (list.selectedItems) {
          for (var i = 0, l = list.selectedItems.length; i < l; i++) {
            this.selections.items[i] = list.selectedItems[i].closest('li');
          }
        }
      } else {
        this.selections.items = list.selectedItems;
      }

      this.setSelectionsItems(this.selections.owner);
      this.unselectElements(list);

      if (this.selections.items.length) {
        this.selections.move = {
          items: this.selections.itemsData,
          from: this.getContainer(this.selections.itemsData)
        };
        var result = this.element.triggerHandler('beforeswap', [this.selections.move]);

        if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
          return;
        }

        var ul = $('ul', to);
        var currentSize = $('li', ul).length;
        var size = this.selections.items.length + currentSize;

        if (this.selections.items) {
          for (var _i = 0, _l = this.selections.items.length; _i < _l; _i++) {
            var val = $(this.selections.items[_i]);
            val.attr({
              'aria-posinset': currentSize + _i + 1,
              'aria-setsize': size
            }).find('mark.highlight').contents().unwrap();
            ul.append(val);
          }
        }

        this.afterUpdate($('.listview', to).data('listview'));
      }
    },

    /**
     * Get container info from given list items
     * @private
     * @param {Array} items to get container info.
     * @returns {Object} container info (jQuery container element, css-class)
     */
    getContainer: function getContainer(items) {
      var s = this.settings;

      if (_typeof(items[0]) === 'object' && items[0].node) {
        var container = items[0].node.closest('.card');
        var cssClass = '';

        if (container.is(s.availableClass)) {
          cssClass = s.availableClass;
        } else if (container.is(s.selectedClass)) {
          cssClass = s.selectedClass;
        } else if (container.is(s.additionalClass)) {
          cssClass = s.additionalClass;
        }

        return {
          container: container,
          class: cssClass
        };
      }

      return null;
    },

    /**
     * Un-select Elements
     * @private
     * @param {jQuery|HTMLElement} list the list
     */
    unselectElements: function unselectElements(list) {
      if (list.selectedItems) {
        for (var i = 0, l = list.selectedItems.length; i < l; i++) {
          list.select($(list.selectedItems[i]));
        }
      }

      if (list && list.element) {
        list.element.find('li').attr('aria-selected', false).removeClass('is-selected');
      }
    },

    /**
     * Detect browser support for drag-n-drop
     * @private
     * @returns {boolean} whether or not drag-n-drop is supported
     */
    isDragAndDropSupports: function isDragAndDropSupports() {
      var div = document.createElement('div');
      return 'draggable' in div || 'ondragstart' in div && 'ondrop' in div;
    },

    /**
     * Detect browser support for match-media
     * @private
     * @returns {boolean} whether or not matchMedia is supported in this browser
     */
    isMatchMediaSupports: function isMatchMediaSupports() {
      return typeof window.matchMedia !== 'undefined' || typeof window.msMatchMedia !== 'undefined';
    },

    /**
     * Detect browser viewport
     * @private
     * @returns {object} contains width and height
     */
    viewport: function viewport() {
      var e = window;
      var a = 'inner';

      if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
      }

      return {
        width: e["".concat(a, "Width")],
        height: e["".concat(a, "Height")]
      };
    },

    /**
     * Check given [max-width] is true/false
     * @private
     * @param {number} w the current page width
     * @returns {boolean} whether or not the max-width has been matched
     */
    isMaxWidth: function isMaxWidth(w) {
      return this.isMatchMediaSupports() && window.matchMedia("(max-width: ".concat(w, "px)")).matches || this.viewport().width <= w;
    },

    /**
     * Make Draggable
     * @private
     */
    makeDraggable: function makeDraggable() {
      var _this4 = this;

      var self = this;
      var ul = $('ul', this.element);

      if (this.isDragAndDropSupports) {
        // Use Handle if available
        this.handle = ul.first().attr('data-swap-handle');
        this.handle = !this.isTouch && $(this.handle, ul).length > 0 ? this.handle : null;
        $(this.handle, ul).addClass('draggable').off('mousedown.swaplist touchstart.swaplist').on('mousedown.swaplist touchstart.swaplist', function () {
          _this4.selections.isHandle = true;
        }).off('mouseup.swaplist touchend.swaplist').on('mouseup.swaplist touchend.swaplist', function () {
          _this4.selections.isHandle = false;
        });
        this.targets = ul.attr({
          'aria-dropeffect': 'none'
        });
        this.items = $('li:not(.is-disabled)', this.element).not('a[href], img').off('selectstart.swaplist').on('selectstart.swaplist', function () {
          if (this.dragDrop) {
            this.dragDrop();
          } // ie9


          return false;
        }).end().attr({
          draggable: true
        }).addClass(self.handle ? '' : 'draggable');
      }
    },

    /**
     * Get Element By Touch In List
     * @private
     * @param {jQuery|HTMLElement} list the list element
     * @param {number} x touch event's x coordinate
     * @param {number} y touch event's y coordinate
     * @returns {jQuery[]} component that was tapped
     */
    getElementByTouchInList: function getElementByTouchInList(list, x, y) {
      var returns = false;
      var listJq = $(list);

      for (var i = 0, l = listJq.length; i < l; i++) {
        var item = $(listJq[i]);
        var offset = item.offset();

        if (!(x <= offset.left || x >= offset.left + item.outerWidth() || y <= offset.top || y >= offset.top + item.outerHeight())) {
          returns = item;
        }
      }

      return returns;
    },

    /**
     * Drag touch element
     * @private
     * @param {jQuery.Event} e jquery-wrapped `touch` event
     * @param {jQuery[]} elm the element being dragged
     */
    draggTouchElement: function draggTouchElement(e, elm) {
      var orig = e.originalEvent.changedTouches[0];
      elm[0].style.top = "".concat(orig.pageY - this.offset.y, "px");
      elm[0].style.left = "".concat(orig.pageX - this.offset.x, "px");
    },

    /**
     * Shorctut for testing whether a modifier key is pressed
     * @private
     * @param {jQuery.Event} e the keypress event
     * @returns {boolean} whether or not a modifier key is pressed
     */
    hasModifier: function hasModifier(e) {
      return e.ctrlKey || e.metaKey || e.shiftKey;
    },

    /**
     * Applying dropeffect to the target containers
     * @private
     */
    addDropeffects: function addDropeffects() {
      if (this.targets) {
        for (var i = 0, l = this.targets.length; i < l; i++) {
          $(this.targets[i]).attr({
            'aria-dropeffect': 'move',
            tabindex: 0
          });
        }
      }

      if (this.selections && this.selections.items) {
        for (var _i2 = 0, _l2 = this.selections.items.length; _i2 < _l2; _i2++) {
          $(this.selections.items[_i2]).attr({
            'aria-grabbed': true,
            tabindex: 0
          });
        }
      }
    },

    /**
     * Removing dropeffect from the target containers
     * @private
     */
    clearDropeffects: function clearDropeffects() {
      this.targets.attr({
        'aria-dropeffect': 'none'
      }).removeAttr('tabindex');

      if (this.selections && this.selections.items) {
        for (var i = 0, l = this.selections.items.length; i < l; i++) {
          var val = $(this.selections.items[i]);
          val.removeAttr("aria-grabbed".concat(!val.is(':focus') ? ' tabindex' : ''));
        }
      }
    },

    /**
     * Clear selections
     * @private
     */
    clearSelections: function clearSelections() {
      this.selections.items = [];
      this.selections.itemsData = [];
      this.selections.owner = null;
      this.selections.related = null;
      this.selections.droptarget = null;
      this.selections.isInSelection = null;
      this.selections.dragged = null;
      this.selections.placeholder = null;
      this.selections.placeholderTouch = null;
      $('ul, li', this.element).removeClass('over');
      $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
    },

    /**
     * Set selections items
     * @private
     * @param {jQuery[]|HTMLElement} container the container element
     */
    setSelectionsItems: function setSelectionsItems(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      var nodes = $('.listview li', container);
      var containerAPI = container.find('.listview').data('listview');
      var dataList = this.getDataList(container);
      var isFiltered = false;

      if (containerAPI && containerAPI.filteredDataset) {
        dataList = _toConsumableArray(containerAPI.filteredDataset);
        isFiltered = true;
      }

      for (var i = 0, l = nodes.length; i < l; i++) {
        var li = $(nodes[i]);
        var itemData = dataList[i];

        if (isFiltered) {
          itemData.node = li;
          delete itemData._isFilteredOut;
        }

        if (li.is('.is-selected')) {
          this.selections.itemsData.push(itemData);
        }
      }
    },

    /**
     * Init dataset
     * @private
     */
    initDataset: function initDataset() {
      var s = this.settings;
      var containers = [{
        type: 'available',
        dataset: s.available,
        class: s.availableClass
      }, {
        type: 'selected',
        dataset: s.selected,
        class: s.selectedClass
      }, {
        type: 'additional',
        dataset: s.additional,
        class: s.additionalClass
      }];
      this.dataset = {
        available: [],
        selected: []
      };

      if (this.isAdditional) {
        this.dataset.additional = [];
      }

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var nodes = $("".concat(c.class, " .listview li"), this.element);

        for (var nodeIndex = 0, l2 = nodes.length; nodeIndex < l2; nodeIndex++) {
          var data = void 0;
          var value = void 0;
          var li = $(nodes[nodeIndex]);

          if (c.dataset) {
            // Make sure it's not reference pointer to data object, make copy of data
            data = JSON.parse(JSON.stringify(c.dataset[nodeIndex]));
            delete data.selected;
          } else {
            data = {
              text: $.trim($('.swaplist-item-content', li).text())
            };
            value = li.attr('data-value');

            if (value) {
              data.value = value;
            }
          }

          if (this.dataset[c.type]) {
            data.node = li;
            this.dataset[c.type].push(data);
          }
        }
      }
    },

    /**
     * Get data list
     * @private
     * @param {jQuery[]|HTMLElement} container the container element
     * @returns {object|array} the subset of the dataset desired
     */
    getDataList: function getDataList(container) {
      var s = this.settings;
      var d = this.dataset;
      container = this.isjQuery(container) ? container : $(container, this.element);

      if (container.is(s.additionalClass)) {
        return d.additional;
      }

      if (container.is(s.selectedClass)) {
        return d.selected;
      }

      if (container.is(s.availableClass)) {
        return d.available;
      }

      return [];
    },

    /**
     * Move an array element position
     * @private
     * @param {array} arr target array to manipulate
     * @param {number} from index to pull from
     * @param {number} to index to move to
     */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    /**
     * Sync dataset
     * @private
     * @param {jQuery[]} owner element that currently contains the dataset
     * @param {jQuery[]} droptarget element that will receive the dataset
     */
    syncDataset: function syncDataset(owner, droptarget) {
      var droptargetNodes = $('.listview li', droptarget);
      var ownerAPI = owner.find('.listview').data('listview');
      var dropTargetAPI = droptarget.find('.listview').data('listview');
      var ownerDataList = this.getDataList(owner);
      var dtDataList = this.getDataList(droptarget);

      var isMoved = function isMoved(mOwner, mItem) {
        if (mOwner && mItem) {
          var id = {
            owner: mOwner.getAttribute('data-id'),
            item: mItem.getAttribute('data-id')
          };
          return typeof id.owner !== 'undefined' && typeof id.item !== 'undefined' && id.owner === id.item;
        }

        return false;
      };

      if (owner.is(droptarget)) {
        var syncedList = [];

        for (var i = 0, l = droptargetNodes.length; i < l; i++) {
          var item = droptargetNodes[i];

          for (var ownerIndex = 0, l2 = ownerDataList.length; ownerIndex < l2; ownerIndex++) {
            var ownerItem = ownerDataList[ownerIndex];

            if (isMoved(ownerItem.node[0], item)) {
              syncedList.push(ownerItem);
              break;
            }
          }
        }

        ownerDataList.splice(0, ownerDataList.length);

        for (var _i3 = 0, _l3 = syncedList.length; _i3 < _l3; _i3++) {
          ownerDataList.push(syncedList[_i3]);
        }
      } else {
        for (var _i4 = 0, _l4 = this.selections.items.length; _i4 < _l4; _i4++) {
          var _item = this.selections.items[_i4];
          var canLoop = true;

          for (var dtIndex = 0, _l5 = droptargetNodes.length; dtIndex < _l5 && canLoop; dtIndex++) {
            if ($(droptargetNodes[dtIndex]).is(_item)) {
              for (var _ownerIndex = 0, l3 = ownerDataList.length; _ownerIndex < l3; _ownerIndex++) {
                var _ownerItem = ownerDataList[_ownerIndex];

                if (isMoved(_ownerItem.node[0], _item[0])) {
                  dtDataList.push(_ownerItem);
                  ownerDataList.splice(_ownerIndex, 1);
                  this.arrayIndexMove(dtDataList, dtDataList.length - 1, dtIndex);
                  canLoop = false;
                  break;
                }
              }
            }
          }
        }
      }

      ownerAPI.updated({
        dataset: ownerDataList
      });
      dropTargetAPI.updated({
        dataset: dtDataList
      });
      this.makeDraggable();
    },

    /**
     * Check if a object is jQuery object
     * @private
     * @param {object} obj the object being checked
     * @returns {boolean} whether or not the object is a jQuery selector
     */
    isjQuery: function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },

    /**
     * Update attributes
     * @private
     * @param {jQuery[]} list the target element to update
     */
    updateAttributes: function updateAttributes(list) {
      var items = $('li', list);

      for (var i = 0, l = items.length; i < l; i++) {
        $(items[i]).attr({
          'aria-posinset': i + 1,
          'aria-setsize': l
        });
      }
    },

    /**
     * After update
     * @private
     * @param {jQuery[]} list the target element to change after an update
     */
    afterUpdate: function afterUpdate(list) {
      var focusIdx = this.selections.droptarget.find('li:focus').index();
      var focusClass = ".card.".concat(this.selections.droptarget[0].classList[1], " li");

      if (list) {
        if (this.selections.placeholder) {
          list.select(this.selections.placeholder);
          this.selections.placeholder.focus();
        }

        this.unselectElements(list);
        this.syncDataset(this.selections.owner, this.selections.droptarget);
        this.updateAttributes($('.listview', this.selections.owner));
        this.updateAttributes($('.listview', this.selections.droptarget));

        if (this.selections.items.length) {
          this.selections.move = $.extend(true, this.selections.move, {
            to: this.getContainer([{
              node: this.selections.droptarget.find('li:first')
            }])
          });
          /**
          * Fires when any bucket has its content changed.
          * @event swapupdate
          * @memberof SwapList
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {array} items - List of items data
          */

          this.element.triggerHandler('swapupdate', [this.selections.move]);
        }
      }

      this.selections.items.forEach(function (elem) {
        elem.show();
      });
      this.clearDropeffects();
      this.clearSelections();
      this.items.removeClass('is-dragging is-dragging-touch');

      if (focusIdx >= 0) {
        this.element.find(focusClass).eq(focusIdx).focus();
      }
    },

    /**
     * Get items from provided container
     * @private
     * @param {jQuery[]|HTMLElement} container the container being checked
     * @returns {object|array} dataset
     */
    getItems: function getItems(container) {
      container = this.isjQuery(container) ? container : $(container, this.element);
      return this.getDataList(container);
    },

    /**
     * Get the current representative dataset with only the available elements in it.
     * @returns {object|array} dataset
     */
    getAvailable: function getAvailable() {
      return this.getDataList(this.settings.availableClass);
    },

    /**
     * Get the current representative dataset with only the selected elements in it.
     * @returns {object|array} dataset
     */
    getSelected: function getSelected() {
      return this.getDataList(this.settings.selectedClass);
    },

    /**
     * Get the current representative dataset with only the additional elements in it.
     * @returns {object|array} dataset
     */
    getAdditional: function getAdditional() {
      return this.getDataList(this.settings.additionalClass);
    },

    /**
     * Make selected if dragged element was not selected
     * @private
     * @param {object} list the list to manipulate
     * @param {jQuery[]} target the target to give a "selected" state
     * @returns {boolean} whether or not an item was made selected
     */
    draggedMakeSelected: function draggedMakeSelected(list, target) {
      var isInSelection = false;

      if (!this.selections.isInSelection) {
        // Check if dragged element was selected or not
        if (list.selectedItems) {
          for (var i = 0, l = list.selectedItems.length; i < l; i++) {
            if (target.is(list.selectedItems[i])) {
              isInSelection = true;
              return false;
            }
          }
        }

        if (!isInSelection) {
          list.select(target); // Make selected

          this.selections.isInSelection = true;
        }
      }

      return true;
    },

    /**
     * Updates the internal datasets and refresh the ui.
     * @param {object} ds The updated dataset(s) of the form.
     *  `{available: [], selected: [], additional: []}`
     * @returns {void}
     */
    updateDataset: function updateDataset(ds) {
      var s = this.settings;
      var containers = [{
        type: 'available',
        dataset: ds.available,
        class: s.availableClass
      }, {
        type: 'selected',
        dataset: ds.selected,
        class: s.selectedClass
      }, {
        type: 'additional',
        dataset: ds.additional,
        class: s.additionalClass
      }];

      for (var i = 0, l = containers.length; i < l; i++) {
        var c = containers[i];
        var lv = $("".concat(c.class, " .listview"), this.element);
        var api = lv.data('listview');

        if (api) {
          api.deselectItemsBetweenIndexes([0, $('li', lv).length - 1]);
          s[c.type] = c.dataset || [];
          api.loadData(s[c.type]);
        }
      }

      this.initDataset();
      this.makeDraggable();
      this.initSelected(s.availableClass);
      this.initSelected(s.additionalClass);
    },

    /**
     * Removes event bindings from the swaplist instance.
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      this.actionButtons.off('click.swaplist');
      this.containers.off('keydown.swaplist', '.listview');
      this.selectedButtons.off('keydown.swaplist');
      this.element.off('keydown.swaplist', this.tabButtonsStr);
      this.element.off("".concat(this.dragStart, " ").concat(this.dragEnterWhileDragging, " ").concat(this.dragOverWhileDragging, " ").concat(this.dragEnd), this.dragElements);
      $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
      return this;
    },

    /**
     * Updates this instance of the swaplist component with new settings.
     * @private
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SWAPLIST_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroys this instance of the swaplist component and removes its link to its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$14);
    },
    // Handle Events
    handleEvents: function handleEvents() {
      var self = this;
      var settings = self.settings;
      var selections = self.selections; // TOP BUTTONS =============================================================================

      self.actionButtons.off('click.swaplist').on('click.swaplist', function () {
        var actionButton = $(this);
        var container = actionButton.closest('.card'); // Current list clicked from

        var moveTo = null;

        if (container.is(settings.availableClass)) {
          // Move from Available to Selected or Additional
          if (settings.draggable.selected) {
            moveTo = settings.selectedClass;
          } else {
            moveTo = self.isAdditional && settings.draggable.additional ? settings.additionalClass : null;
          }

          self.moveElements(settings.availableClass, moveTo);
        } else if (container.is(settings.additionalClass)) {
          // Move from Additional to Selected or Available
          if (settings.draggable.selected) {
            moveTo = settings.selectedClass;
          } else {
            moveTo = settings.draggable.available ? settings.availableClass : null;
          }

          self.moveElements(settings.additionalClass, moveTo);
        } else if (container.is(settings.selectedClass)) {
          // Move from Selected
          if (actionButton.is(settings.selectedBtnLeft)) {
            // to Available
            self.moveElements(settings.selectedClass, settings.availableClass);
          } else if (actionButton.is(settings.selectedBtnRight)) {
            // to Additional
            self.moveElements(settings.selectedClass, settings.additionalClass);
          }
        }
      }); // KEYSTROKE ===============================================================================
      // Keydown event to implement selections

      self.containers.on('keydown.swaplist', '.listview', function (e) {
        var container = $(this).closest(self.containers);
        e = e || window.event;

        if (e.keyCode === 77 && self.hasModifier(e)) {
          // Modifier + M
          if (!container.is(settings.selectedClass) || container.is(settings.selectedClass) && self.selectedButtons.length === 1) {
            container.find(self.actionButtons).trigger('click.swaplist');
          } else {
            self.selectedButtons.first().focus();
          }

          e.preventDefault();
        }
      }); // Keydown event to handle selected container

      self.selectedButtons.on('keydown.swaplist', function (e) {
        var btn = $(this);
        var index;
        var move;
        e = e || window.event;

        if (e.keyCode === 13 || e.keyCode === 32) {
          // Enter or Space
          btn.trigger('click.swaplist');
          e.preventDefault();
        } // Left or Right arrow


        if ((e.keyCode === 37 || e.keyCode === 39) && self.selectedButtons.length > 1) {
          index = self.selectedButtons.index(this);

          if (e.keyCode === 37) {
            move = index > 0 ? index - 1 : self.selectedButtons.length - 1;
          } else {
            move = index < self.selectedButtons.length - 1 ? index + 1 : 0;
          }

          self.selectedButtons[move].focus();
        }
      });
      self.element.on('keydown.swaplist', self.tabButtonsStr, function (e) {
        var btn = $(this);
        var keyCode = e.keyCode || e.which;

        if (keyCode === 9 && !e.shiftKey) {
          // Tab key
          var card = btn.closest('.card')[0];
          var items = [].slice.call(card.querySelectorAll('li[tabindex]'));
          var itemsLen = items.length;
          var found = false;

          if (itemsLen) {
            items.forEach(function (item) {
              var tabindex = parseInt(item.getAttribute('tabindex'), 10);

              if (tabindex !== -1) {
                found = true;
              }
            });
          }

          if (!found) {
            var item = card.querySelector('li');

            if (item) {
              item.setAttribute('tabindex', 0);
            }
          }
        }
      }); // SEARCHFIELD =============================================================================

      self.containers.on('filtered.swaplist', '.listview', function () {
        self.makeDraggable();
      }); // DRAGGABLE ===============================================================================

      self.element.on('mousedown.swaplist', self.dragElements, function (e) {
        if (self.handle) {
          var target = $(e.target).closest('li');
          target.attr({
            draggable: $(e.target).is('.draggable')
          });
        }

        e.stopPropagation();
      }) // Dragstart - initiate dragging
      .on(self.dragStart, self.dragElements, function (e) {
        e.stopImmediatePropagation();

        if (self.handle && !selections.isHandle) {
          e.stopPropagation();
          return;
        }

        var rect;
        var touch;
        var placeholderContainer;
        var target = $(e.target).closest('li');
        var list = $('.listview', target.closest('.card')).data('listview'); // Not in draging area

        if (!list) {
          return;
        }

        if (!self.isTouch) {
          self.draggedMakeSelected(list, target);
        }

        self.clearSelections(); // Clear selection before fill

        selections.owner = target.closest('.card');
        selections.dragged = target;
        selections.draggedIndex = target.index();
        selections.placeholder = target.clone(true);
        selections.placeholder.attr('id', 'sl-placeholder');
        self.setSelectionsItems(selections.owner);
        selections.items = list.selectedItems;
        self.selections.move = {
          items: self.selections.itemsData,
          from: self.getContainer(self.selections.itemsData)
        };
        /**
          * Fires before moving an element allowing you to access the draggable item.
          * @event beforeswap
          * @memberof SwapList
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {array} items - List of selected items data
          */

        var result = self.element.triggerHandler('beforeswap', [self.selections.move]);

        if (typeof result === 'boolean' && !result || typeof result === 'string' && result.toLowerCase() === 'false') {
          selections.dragged = null;
          return;
        }

        $(".".concat(settings.numOfSelectionsClass), settings.itemContentTempl).html(selections.items.length);
        $(".".concat(settings.numOfSelectionsClass, "-text"), settings.itemContentTempl).text(Locale.translate('ItemsSelected'));
        self.addDropeffects();

        if (!self.isTouch) {
          selections.dragged.addClass('is-dragging');
          e.originalEvent.dataTransfer.setData('text', '');

          if (selections.items.length > 1) {
            $(".".concat(settings.itemContentClass), selections.dragged).html(settings.itemContentTempl.html());
          }
        } else {
          rect = target[0].getBoundingClientRect();
          touch = e.originalEvent.changedTouches[0]; // Save offset

          self.offset = {
            x: touch.pageX - rect.left,
            y: touch.pageY - rect.top
          };

          for (var i = 0, l = self.containers.length; i < l; i++) {
            self.containers[i].style.zIndex = '1';
          }

          selections.placeholderTouch = selections.dragged.clone(true);

          if (selections.items.length > 1 && !$('#sl-placeholder-touch2').length) {
            selections.dragged.clone().addClass('is-dragging-touch').attr('id', 'sl-placeholder-touch2').insertBefore(selections.dragged).hide();
          }

          selections.placeholderTouch.attr('id', 'sl-placeholder-touch').removeClass('is-selected').hide(); // Mobile view with three container(available, selected, additional) prepend to parent

          placeholderContainer = self.element.is('.one-third') && self.isMaxWidth(766) ? self.element.parent() : self.element;
          placeholderContainer.prepend('<ul id="sl-placeholder-container"></ul>');
          $('#sl-placeholder-container').append(selections.placeholderTouch);
          $('#sl-placeholder-container')[0].style.width = "".concat(selections.owner.width(), "px");
          $('#sl-placeholder-touch')[0].style.width = "".concat(selections.owner.width(), "px");
          self.draggTouchElement(e, selections.placeholderTouch);
        }

        e.stopPropagation();
      }) // Dragenter - set that related/droptarget
      .on(self.dragEnterWhileDragging, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }

        self.element.triggerHandler('draggingswap', [selections.move]);
        selections.related = e.target;
        $('ul, li', self.element).removeClass('over');
        $(e.target).closest('ul, li').addClass('over');
        selections.droptarget = $(selections.related).closest('.card');
        $('[aria-grabbed="true"]', self.element).not(selections.dragged).slideUp();
        e.stopPropagation();
      }) // Dragover - allow the drag by preventing default, for touch set related/droptarget
      .on(self.dragOverWhileDragging, self.dragElements, function (e) {
        if (!selections.dragged) {
          return;
        }

        var touch;
        var overItem = $(this);
        var list = $('.listview', selections.dragged.closest('.card')).data('listview');

        if (self.isTouch) {
          if (!!self.handle && !selections.isHandle) {
            return;
          }

          if (!selections.isInSelection) {
            self.draggedMakeSelected(list, selections.dragged);
            selections.items = list.selectedItems;
            $(".".concat(settings.numOfSelectionsClass), settings.itemContentTempl).html(selections.items.length);
          }

          touch = e.originalEvent.touches[0];
          overItem = self.getElementByTouchInList($('ul, li', self.element), touch.pageX, touch.pageY) || overItem;
          selections.dragged.addClass('is-dragging');
          selections.placeholderTouch.addClass('is-dragging is-dragging-touch');
          selections.placeholderTouch.show();
          $('[aria-grabbed="true"]', self.element).not(selections.dragged).not(selections.placeholderTouch).not('#sl-placeholder-touch2').slideUp();

          if (selections.items.length > 1) {
            $(".".concat(settings.itemContentClass), selections.placeholderTouch.add('#sl-placeholder-touch2')).html(settings.itemContentTempl.html());
            $('#sl-placeholder-touch2').show();
            selections.dragged.hide();
          }

          self.draggTouchElement(e, selections.placeholderTouch);
          self.element.triggerHandler('draggingswap', [selections.move]);
          selections.related = overItem;
          $('ul, li', this.element).removeClass('over');
          overItem.closest('ul, li').addClass('over');
          selections.droptarget = selections.related.closest('.card');
        }

        e.preventDefault();
        e.stopPropagation();
      }) // Dragend - implement items being validly dropped into targets
      .on(self.dragEnd, self.dragElements, function (e) {
        if (!selections.dragged || !selections.droptarget) {
          return;
        }

        var related = $(selections.related).closest('li');
        var ul = $('ul', selections.droptarget);
        var currentSize = $('li', ul).length;
        var size = selections.items.length + currentSize;
        self.unselectElements($('.listview', selections.owner).data('listview'));
        $.each(selections.items, function (index, val) {
          val = $(val);
          val.find('mark.highlight').contents().unwrap();

          if (currentSize && !$(selections.related).is('ul')) {
            var isLess = related.index() < selections.draggedIndex && selections.owner.is(selections.droptarget);
            var el = isLess ? val : $(selections.items[selections.items.length - 1 - index]);
            var posinset = related.index() + (isLess ? index + 1 : index + 2);
            val.attr({
              'aria-posinset': posinset,
              'aria-setsize': size
            });
            related[isLess ? 'before' : 'after'](el);
          } else {
            val.attr({
              'aria-posinset': currentSize + index + 1,
              'aria-setsize': size
            });
            ul.append(val);
          }

          val.focus();
        });

        if (selections.items.length > 1) {
          $(".".concat(settings.itemContentClass), selections.dragged).html($(".".concat(settings.itemContentClass), selections.placeholder).html());

          if (self.isTouch) {
            selections.dragged.show();
          }
        }

        if (self.isTouch) {
          for (var i = 0, l = self.containers.length; i < l; i++) {
            self.containers[i].style.zIndex = '';
          }
        }

        self.makeDraggable();
        selections.isHandle = null;
        $('[aria-grabbed="true"]', self.element).show();
        self.afterUpdate($('.listview', selections.droptarget).data('listview'));
        e.preventDefault();
        e.stopPropagation();
      });
    } // END: Handle Events ---------------------------------------------------------------------

  };

  /**
   * jQuery Component Wrapper for SwapList
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.swaplist = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$14);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$14, new SwapList(this, settings));
      }
    });
  };

  var COMPONENT_NAME$15 = 'scrollaction'; // Default ScrollAction Options

  var SCROLLACTION_DEFAULTS = {
    scrollActionTarget: '.js-scroll-target',
    // The element to add a class to based on scrolling logic
    classToAdd: 'scrolled-down' // The class added to the target element

  };
  /**
  * A component that applies a class based on scroll direction
  * @class ScrollAction
  * @param {string} element The component element.
  * @param {object} [settings] The component settings.
  * @param {string} [scrollActionTarget='.js-scroll-target'] The selector of the element to add the class to.
  * @param {string} [classToAdd ='scrolled-down'] The class name to use when toggling.
  */

  function ScrollAction(element, settings) {
    this.settings = utils.mergeSettings(element, settings, SCROLLACTION_DEFAULTS);
    this.element = $(element);
    this.init();
  } // ScrollAction Methods


  ScrollAction.prototype = {
    init: function init() {
      this.handleEvents();
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      var s = this.settings;
      this.element.off('scroll.scrollaction');

      if (s) {
        $(s.scrollActionTarget).removeClass(s.classToAdd);
      }

      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, SCROLLACTION_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$15);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var s = this.settings;
      this.lastScrollTop = 0;
      this.element.on('scroll.scrollaction', function () {
        var scrollTop = _this.element.scrollTop();

        if (scrollTop > _this.lastScrollTop) {
          $(s.scrollActionTarget).addClass(s.classToAdd);
        } else {
          $(s.scrollActionTarget).removeClass(s.classToAdd);
        }

        _this.lastScrollTop = scrollTop;
      });
    }
  };

  /**
   * jQuery Component Wrapper for ScrollAction
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.scrollaction = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$15);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$15, new ScrollAction(this, settings));
      }
    });
  };

  var COMPONENT_NAME$16 = 'stepchart'; // Default component options

  var DEFAULT_STEPCHART_OPTIONS = {
    steps: null,
    completed: null,
    inProgress: null,
    iconType: null,
    completedText: null,
    extraText: '',
    completedColor: null,
    allCompletedColor: null,
    inProgressColor: null,
    attributes: null
  };
  /**
   * The Step Chart Component is displays visual info on step completion.
   * @class StepChart
   * @constructor
   * @param {jQuery[]|HTMLElement} element The base element
   * @param {object} [settings] incoming settings
   * @param {number} [settings.steps = null] The number of steps to show.
   * @param {number} [settings.completed = null] The number of steps complete (linear).
   * @param {number} [settings.inProgress = null] The number of the in progress step (linear).
   * @param {boolean} [settings.iconType = null] The icon to display fx. 'icon-error', 'icon-success'
   * @param {string} [settings.completedText = null] The completed text or uses a localized 'N of N Steps complete'.
   *  You can use {0} and {1} to replace n of n in the string.
   * @param {boolean} [settings.extraText = ''] The additional text to show on the right. Defaults to none. You
   *  can use {0} to replace with the steps remaining count and {1} to replace the number of steps.
   * @param {string} [settings.completedColor = null] The color to show completed steps. Defaults to primary color.
   * @param {string} [settings.allCompletedColor = null] The color to steps when all are completed. Defaults to primary color.
   * @param {string} [settings.inProgressColor = null] The color to show in-progress steps. Defaults to ruby02.
   * @param {string|array} [settings.attributes = null] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function StepChart(element, settings) {
    return this.init(element, settings);
  }

  StepChart.prototype = {
    /**
     * Initialize and render the chart
     * @private
     * @param {jQuery[]|HTMLElement} element The base element
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    init: function init(element, settings) {
      if (!this.element && element instanceof HTMLElement) {
        this.element = $(element);
      }

      if (_typeof(settings) === 'object' || this.settings === undefined) {
        var previousSettings = this.settings || DEFAULT_STEPCHART_OPTIONS;
        this.settings = utils.mergeSettings(this.element[0], settings, previousSettings);
      }

      return this.render();
    },

    /**
     * Initialize and render the from the options
     * @private
     * @returns {this} component instance
     */
    render: function render() {
      var container = $('<div class="step-chart-steps"></div>');
      var icon = "\n      <svg class=\"icon {icon-name}\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n        <use href=\"#icon-success\"></use>\n      </svg>\n    ";
      var isEmpty = this.settings.completed === null && this.settings.steps === null;

      if (isEmpty) {
        this.settings.completed = 0;
        this.settings.steps = 1;
      }

      if (this.element.attr('data-options')) {
        this.settings = utils.parseSettings(this.element);
      }

      if (this.element.children().length > 0) {
        return this;
      }

      for (var i = 0; i < this.settings.steps; i++) {
        var step = $('<div class="step-chart-step"></div>');
        utils.addAttributes(step, this.settings, this.settings.attributes, "step".concat(i)); // Set up ticks

        if (i < this.settings.completed) {
          step.addClass('is-complete');

          if (this.settings.completedColor) {
            step.css('background-color', this.settings.completedColor);
          }
        }

        if (i === this.settings.inProgress - 1) {
          step.addClass('is-inprogress');

          if (this.settings.inProgressColor) {
            step.css('background-color', this.settings.inProgressColor);
          }
        }

        container.append(step);
      } // Set up labels and alerts


      var completedText = this.settings.completedText || Locale.translate('StepsCompleted');
      completedText = completedText.replace('{0}', this.settings.completed);
      completedText = completedText.replace('{1}', this.settings.steps);

      if (isEmpty) {
        completedText = Locale ? Locale.translate('NoData') : 'No Data Available';
      }

      var label = $("<span class=\"step-chart-label\">".concat(completedText, "</span>"));

      if (this.settings.steps === this.settings.completed) {
        container.addClass('is-complete');
        label.append(icon.replace('{icon-name}', 'icon-success'));
      }

      if (this.settings.iconType) {
        label.append(icon.replace('{icon-name}', this.settings.iconType));
      }

      if (this.settings.extraText) {
        var extraText = this.settings.extraText;
        extraText = extraText === '{0} Days Remaining' ? Locale.translate('DaysRemaining') : extraText;
        extraText = extraText === '{1} Days Overdue' ? Locale.translate('DaysOverdue') : extraText;
        extraText = extraText.replace('{0}', this.settings.steps - this.settings.completed);
        extraText = extraText.replace('{1}', this.settings.completed);
        label.append("<span class=\"step-chart-label-small\">".concat(extraText, "</span>"));
      }

      this.element.append(label, container); // Adjust completed color

      if (this.settings.steps === this.settings.completed && this.settings.allCompletedColor) {
        container.find('.step-chart-step').css('background-color', this.settings.allCompletedColor);
        label.find('.icon').attr('style', "fill: ".concat(this.settings.allCompletedColor, "!important"));
      } // Add automation attributes


      utils.addAttributes(label, this.settings, this.settings.attributes, 'label');
      utils.addAttributes(label.find('.icon'), this.settings, this.settings.attributes, 'icon');
      utils.addAttributes(label.find('.step-chart-label-small'), this.settings, this.settings.attributes, 'label-small');
      return this;
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);
      this.element.empty();
      return this.render();
    },

    /**
     * Tear down and remove.
     * @returns {this} component instance
     */
    destroy: function destroy() {
      this.element.empty();
      this.settings = null;
      $.removeData(this.element[0], COMPONENT_NAME$16);
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for StepChart
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.stepchart = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$16);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$16, new StepChart(this, settings));

        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$16);
        };
      }
    });
  };

  var COMPONENT_NAME$17 = 'tabs'; // Types of possible Tab containers

  var tabContainerTypes = ['horizontal', 'vertical', 'module-tabs', 'header-tabs'];
  /**
   * @class Tabs
   * @constructor
   * @param {HTMLElement|jQuery[]} element the base element for this component
   * @param {object} settings incoming settings
   *
   * @param {boolean} [settings.addTabButton=false] If set to true, creates a button at the end
   * of the tab list that can be used to add an empty tab and panel
   * @param {function} [settings.addTabButtonCallback=null] if defined as a function, will
   * be used in-place of the default Tab Adding method
   * @param {boolean} [settings.appMenuTrigger=false] If set to true, will force an App Menu
   * trigger to be present on Non-Vertical Tabs implementatations.
   * @param {string} [settings.appMenuTriggerText] If defined, replaces the default "Menu" text used
   * in the app menu trigger.
   * @param {boolean} [settings.appMenuTriggerTextAudible = false] if true, causes an app menu trigger's
   * text content to be visually hidden (but still exists for accessiblity purposes)
   * @param {object} [settings.ajaxOptions] if defined, will be used by any internal
   * Tabs AJAX calls as the desired request settings.
   * @param {function} [settings.beforeActivate] If defined as a function, fires
   * this before a tab is activated to allow a possible "veto" of the tab swap (SOHO-5250).
   * @param {string|jQuery} [settings.containerElement=null] Defines a separate element
   * to be used for containing the tab panels.  Defaults to a `.tab-panel-container`
   * element that is created if it doesn't already exist.
   * @param {boolean} [settings.changeTabOnHashChange=false] If true, will change the selected
   * tab on invocation based on the URL that exists after the hash.
   * @param {function} [settings.hashChangeCallback=null] If defined as a function,
   * provides an external method for adjusting the current page hash used by these tabs.
   * @param {boolean} [settings.lazyLoad=true] if true, when using full URLs in tab HREFs,
   * or when using Ajax calls, tabs will be loaded as needed instead of the markup
   * all being established at once.
   * @param {boolean} [settings.moduleTabsTooltips=false] if true, will display a tooltip on
   * Module Tabs with cut-off text content.
   * @param {boolean} [settings.multiTabsTooltips=false] if true, will display a tooltip on
   * Multi Tabs with cut-off text content.
   * @param {function} [settings.source=null] If defined, will serve as a way of pulling
   * in external content to fill tabs.
   * @param {object} [settings.sourceArguments={}] If a source method is defined, this
   * flexible object can be passed into the source method, and augmented with
   * parameters specific to the implementation.
   * @param {boolean} [settings.tabCounts=false] If true, Displays a modifiable count above each tab.
   * @param {boolean} [settings.verticalResponsive=false] If Vertical Tabs & true, will automatically
   * switch to Horizontal Tabs on smaller breakpoints.
   * @param {Array} [settings.attributes=null] If set, adds additional attributes to some tabs and elements.
   */

  var TABS_DEFAULTS = {
    addTabButton: false,
    addTabButtonCallback: null,
    appMenuTrigger: false,
    appMenuTriggerText: undefined,
    appMenuTriggerTextAudible: false,
    ajaxOptions: null,
    beforeActivate: undefined,
    containerElement: null,
    changeTabOnHashChange: false,
    hashChangeCallback: null,
    lazyLoad: true,
    moduleTabsTooltips: false,
    multiTabsTooltips: false,
    source: null,
    sourceArguments: {},
    tabCounts: false,
    verticalResponsive: false,
    attributes: null
  };

  function Tabs(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TABS_DEFAULTS);
    this.init();
  }

  Tabs.prototype = {
    /**
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      return this.setup().build().setupEvents();
    },

    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      // Used by the $(body).resize event to correctly identify the tabs container element
      this.tabsIndex = $('.tab-container').index(this.element);
      this.settings.multiTabsTooltips = this.element.closest('.multitabs-container').length > 0;
      return this;
    },

    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      var _this = this;

      var self = this;
      var tabPanelContainer;
      var moveTabPanelContainer = false; // Check for a tab panel container immediately after the `.tab-container`
      // element (default as of IDS Enterprise 4.3.0)

      tabPanelContainer = this.element.next('.tab-panel-container'); // Auto-detect and move existing tab-panel containers in key areas, if applicable.
      // Check inside the container first

      if (!tabPanelContainer.length) {
        tabPanelContainer = this.element.children('.tab-panel-container');

        if (!this.isVerticalTabs()) {
          moveTabPanelContainer = true;
        }
      } // Special case for Header Tabs, find the page container and use that as the container


      var bodyPageContainer = $('body > .page-container, .application-menu + .page-container');

      if (this.element.closest('.header').length > 0 && bodyPageContainer.length) {
        tabPanelContainer = bodyPageContainer;
      } // Special case for Module Tabs, where it's possible for layout reasons for there to be
      // an application menu element adjacent between the Tab list and the Tab Panel container


      if (this.element.next('.application-menu').length) {
        tabPanelContainer = this.element.next().next('.page-container');
        moveTabPanelContainer = false;
      } // Defining `this.settings.containerElement` ultimately overrides any internal
      // changes to the tab panel container.


      if (this.settings.containerElement && $(this.settings.containerElement).length) {
        tabPanelContainer = $(this.settings.containerElement);
        moveTabPanelContainer = false;
      } // If a `.tab-panel-container` still doesn't exist, create one.


      if (!tabPanelContainer || !tabPanelContainer.length) {
        tabPanelContainer = $('<div class="tab-panel-container"></div>');
        moveTabPanelContainer = true;
      }

      if (!tabPanelContainer[0].classList.contains('tab-panel-container')) {
        tabPanelContainer[0].classList.add('tab-panel-container');
      }

      if (moveTabPanelContainer) {
        tabPanelContainer.insertAfter(this.element);
      }

      this.container = tabPanelContainer; // Detect the existence of a "tab-list-container" element, if applicable.
      // Tab List containers are optional for all tab container types, but mandatory for
      // Composite Form tabs.

      var tablistContainer = this.element.children('.tab-list-container');

      if (!tablistContainer.length && this.isScrollableTabs()) {
        tablistContainer = $('<div class="tab-list-container"></div>').prependTo(this.element);
      }

      if (tablistContainer.length) {
        this.tablistContainer = tablistContainer;
      } // Add a default tabs class of "horizontal" if it doesn't already exist


      var noClass = true;
      var closestHeader = this.element.closest('.header');
      tabContainerTypes.forEach(function (val, i) {
        if (_this.element.hasClass(tabContainerTypes[i])) {
          noClass = false;
        }
      });

      if (noClass) {
        if (closestHeader.length) {
          self.element.addClass('header-tabs');
        } else {
          self.element.addClass('horizontal');
        }
      } // Build Tab Counts


      if (self.settings.tabCounts) {
        self.element.addClass('has-counts');
      } // Attach Tablist role and class to the tab headers container


      this.tablist = this.element.children('.tab-list');

      if (!this.tablist.length) {
        // If we have a `.tab-list-container` element, check that before creating markup
        if (this.tablistContainer) {
          this.tablist = this.tablistContainer.children('.tab-list');
        } // Create and append the `.tab-list` if it still doesn't exist.


        if (!this.tablist.length) {
          this.tablist = $('<ul class="tab-list"></ul>');

          if (this.tablistContainer) {
            this.tablist.appendTo(this.tablistContainer);
          } else {
            this.tablist.appendTo(this.element);
          }
        }
      } // Double-check that the `.tab-list-container` actually contains the `.tab-list`.
      // Move it if necessary.


      if (this.tablistContainer) {
        if (!this.tablist.parent().is(this.tablistContainer)) {
          this.tablistContainer.append(this.tablist);
        }

        this.tablistContainer.on('mousewheel.tabs', function (e) {
          if (e.deltaY) {
            this.scrollLeft += e.deltaY;
          }
        });
      }

      self.tablist.attr({
        class: 'tab-list',
        role: 'tablist',
        'aria-multiselectable': 'false'
      }); // Conditionally Change layout classes if veritcal tabs is in responsive
      // mode, and breakpoints match.

      this.checkResponsive(false); // Handle Focus State, Animated Bar, More Button, Add Tabs Button, and
      // App Menu Button.

      this.renderHelperMarkup(); // for each item in the tabsList...

      self.anchors = self.tablist.children('li:not(.separator)').children('a');
      self.anchors.each(function prepareAnchor() {
        var a = $(this);
        var attrPart = a[0].textContent.toLowerCase().trim().split(' ').join('-');
        a.attr({
          role: 'tab',
          'aria-expanded': 'false',
          'aria-selected': 'false',
          tabindex: '0'
        }).parent().attr('role', 'presentation').addClass('tab');
        var dismissibleIcon;

        if (a.parent().hasClass('dismissible') && !a.parent().children('.icon').length) {
          dismissibleIcon = $.createIconElement({
            icon: 'close',
            classes: 'icon close'
          });
          dismissibleIcon.insertAfter(a);
        } // If attributes are defined, add them to various things


        if (self.settings.attributes) {
          utils.addAttributes(a, self, self.settings.attributes, "".concat(attrPart, "-a"));

          if (dismissibleIcon) {
            utils.addAttributes(dismissibleIcon, self, self.settings.attributes, "".concat(attrPart, "-close-btn"));
          }
        } // Find and configure dropdown tabs


        var dd = a.nextAll('ul').first();

        if (dd.length > 0) {
          dd.addClass('dropdown-tab');
          var li = a.parent();
          li.addClass('has-popupmenu').popupmenu({
            menu: dd,
            trigger: 'click',
            attachToBody: true,
            attributes: self.settings.attributes
          });
          a.removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected');

          if (!a.parent().children('.icon.icon-more').length) {
            $.createIconElement({
              classes: 'icon-more',
              icon: 'dropdown'
            }).insertAfter(a);
          }
        }

        if (self.settings.tabCounts && $(this).find('.count').length === 0) {
          $(this).prepend('<span class="count">0 </span>');
        } // Make it possible for Module Tabs to display a tooltip containing their contents
        // if the contents are cut off by ellipsis.


        if (self.settings.moduleTabsTooltips || self.settings.multiTabsTooltips) {
          a.on('beforeshow.toolbar', function () {
            return a.data('cutoffTitle') === 'yes';
          }).tooltip({
            content: "".concat(a.text().trim())
          });
        }
      }); // Build/manage tab panels

      function associateAnchorWithPanel() {
        var a = $(this);
        var li = a.parent();
        var popup = li.data('popupmenu');
        var panel; // Associated the current one

        var href = a.attr('href');

        if (href.substr(0, 1) !== '#') {
          // is an outbound Link
          return;
        }

        if (href.substr(0, 2) === '#/') {
          // uses angular LocationStrategy
          // Just to find the panel but these are handled by angular
          href = href.replace('#/', '#');
        }

        if (href !== undefined && href !== '#') {
          panel = $(href);

          if (li.is(':not(.has-popupmenu)') && !panel.length) {
            return;
          }

          if (self.settings.attributes) {
            var attrPart = a[0].textContent.toLowerCase().trim().split(' ').join('-');
            utils.addAttributes(panel, self, self.settings.attributes, "".concat(attrPart, "-panel"));
          }

          a.data('panel-link', panel);
          panel.data('tab-link', a);
          self.panels = self.panels.add(panel);
        } // If dropdown tab, add the contents of the dropdown
        // NOTE: popupmenu items that represent dropdown tabs shouldn't have children,
        // so they aren't accounted for here.


        if (popup) {
          popup.menu.children('li').each(function () {
            var popupLi = $(this);
            var popupA = popupLi.children('a');
            var popupHref = popupA.attr('href');
            var popupPanel = $(popupHref);
            popupA.data('panel-link', popupPanel);
            popupPanel.data('tab-link', popupA);
            self.panels = self.panels.add(popupPanel);
            self.anchors = self.anchors.add(popupA);

            if (!popupLi.hasClass('dismissible')) {
              return;
            }

            var popupIcon = popupLi.children('.icon');

            if (!popupIcon.length) {
              popupIcon = $.createIconElement({
                icon: 'close',
                classes: 'icon close'
              });
            }

            popupIcon.detach().appendTo(popupA);
          }).on('click.popupmenu', '.icon', function iconClickHandler(e) {
            var popupIcon = $(this);
            var popupLi = popupIcon.closest('li');

            if (popupLi.is('.dismissible') && popupIcon.is('.icon')) {
              e.preventDefault();
              e.stopPropagation();
              self.closeDismissibleTab(popupLi.children('a').attr('href'));
            }
          });
        }
      }

      self.panels = $();
      self.anchors.each(associateAnchorWithPanel);
      self.panels.addClass('tab-panel').attr({
        role: 'tabpanel'
      }).find('h3:first').attr('tabindex', '0');
      self.panels.each(function () {
        var panel = $(this);

        if (!panel.parent().is(self.container)) {
          self.container.append(panel);
        }
      });
      var excludes = ':not(.separator):not(.is-disabled):not(.is-hidden)';
      var tabs = this.tablist.children("li".concat(excludes));
      var selected = this.tablist.children("li.is-selected".concat(excludes));
      var selectedAnchor = selected.children('a');
      var hash;
      var matchingTabs; // Setup a hash for nested tab controls

      self.nestedTabControls = self.panels.find('.tab-container');

      if (tabs.length) {
        // If the hashChange setting is on, change the selected tab to the one referenced by the hash
        if (this.settings.changeTabOnHashChange) {
          hash = window.location.hash;

          if (hash && hash.length) {
            matchingTabs = tabs.find("a[href=\"".concat(hash, "\"]"));

            if (matchingTabs.length) {
              selected = matchingTabs.first().parent();
              selectedAnchor = selected.children('a');
            }
          }
        } // If there is no selected tab, try to find the first available tab (if there are any present)


        if (!selected.length) {
          selected = tabs.not('.add-tab-button, .application-menu-trigger').first();
          selectedAnchor = selected.children('a');
        } // If there are tabs present, activate the first one


        if (selected.length) {
          this.activate(selectedAnchor.attr('href'), selectedAnchor);
        }
      }

      if (this.isModuleTabs() && this.element.children('.toolbar').length) {
        this.element.addClass('has-toolbar');
      }

      this.setOverflow();
      this.positionFocusState(selectedAnchor);

      if (this.hasAnimatedBar()) {
        this.animatedBar.addClass('no-transition');
        this.focusBar(undefined, function () {
          setTimeout(function () {
            _this.animatedBar.removeClass('no-transition');
          }, 0);
        });
      } // Setup Edge Fades


      if (this.tablistContainer) {
        this.tablistContainer.on('scroll.tabs', function () {
          _this.renderEdgeFading();
        });
        this.renderEdgeFading();
      } // Setup a resize observer on both the tab panel container and the tab list container (if applicable)
      // to auto-refresh the state of the Tabs on resize.  ResizeObserver doesn't work in IE.


      if (typeof ResizeObserver !== 'undefined') {
        this.ro = new ResizeObserver(function () {
          $('body').triggerHandler('resize');
        });
        this.ro.observe(this.element[0]);

        if (this.containerElement) {
          this.ro.observe(this.containerElement[0]);
        }
      }

      return this;
    },

    /**
     * Adds/removes helper buttons and accessibility-centric markup, based on Tabs' configuration
     * Designed to be run at any point in the Tabs lifecycle.
     * @private
     * @returns {this} component instance
     */
    renderHelperMarkup: function renderHelperMarkup() {
      var _this$moreButton, _this$addTabButton;

      var auxilaryButtonLocation = this.tablistContainer || this.tablist;

      if (this.isModuleTabs()) {
        auxilaryButtonLocation = this.tablist;
      }

      this.focusState = this.element.find('.tab-focus-indicator');

      if (!this.focusState.length) {
        this.focusState = $('<div class="tab-focus-indicator" role="presentation"></div>').insertBefore(this.tablist);
      } // Animated Bar


      if (this.hasAnimatedBar()) {
        this.animatedBar = this.element.find('.animated-bar');

        if (!this.animatedBar.length) {
          this.animatedBar = $('<div class="animated-bar" role="presentation"></div>');
        }

        this.animatedBar.insertBefore(this.tablist);
      } else if (this.animatedBar && this.animatedBar.length) {
        this.animatedBar.off().removeData().remove();
        this.animatedBar = undefined;
      } // Add the markup for the "More" button if it doesn't exist.


      if (!this.moreButton) {
        this.moreButton = $();
      }

      if (!this.isVerticalTabs()) {
        if (!this.moreButton.length) {
          this.moreButton = auxilaryButtonLocation.next('.tab-more');
        } // If we still don't have a More Button, create one


        if (!this.moreButton.length) {
          this.moreButton = $('<div>').attr({
            class: 'tab-more'
          });
          this.moreButton.append($('<span class="more-text">').text(Locale.translate('More')));
          this.moreButton.append($.createIconElement({
            classes: 'icon-more',
            icon: 'dropdown'
          }));
        } // Append in the right place based on configuration


        auxilaryButtonLocation.after(this.moreButton);
      } else if (this.moreButton.length) {
        this.moreButton.off().removeData().remove();
        this.moreButton = $();
      } // Add extra attributes to the more button, if applicable


      if ((_this$moreButton = this.moreButton) !== null && _this$moreButton !== void 0 && (_this$moreButton == null ? void 0 : _this$moreButton.length) && this.settings.attributes) {
        utils.addAttributes(this.moreButton, this, this.settings.attributes, 'btn-more');
      } // Add the application menu Module Tab, if applicable


      var appMenuTrigger = this.tablist.find('.application-menu-trigger');

      if (this.settings.appMenuTrigger === true) {
        // Backwards Compatibility for the original Application Menu codepath.
        if (this.isModuleTabs()) {
          if (!appMenuTrigger.length) {
            var audibleClass = this.settings.appMenuTriggerTextAudible ? ' class="audible"' : '';
            appMenuTrigger = $("\n            <li class=\"tab application-menu-trigger\">\n              <a href=\"#\">\n                <span class=\"icon app-header\">\n                  <span class=\"one\"></span>\n                  <span class=\"two\"></span>\n                  <span class=\"three\"></span>\n                </span>\n                <span".concat(audibleClass, ">").concat(this.settings.appMenuTriggerText || Locale.translate('AppMenuTriggerText'), "</span>\n              </a>\n            </li>\n          "));
            this.tablist.prepend(appMenuTrigger);
          }
        } else if (this.isVerticalTabs() && appMenuTrigger.length) {
          appMenuTrigger.off().removeData().remove();
        }
      } else if (appMenuTrigger.length) {
        if (this.isVerticalTabs()) {
          appMenuTrigger.off().removeData().remove();
        } else {
          this.tablist.prepend(appMenuTrigger);
        }
      }

      if (appMenuTrigger.length) {
        // Add extra attributes to the App Menu Trigger button, if applicable
        if (this.settings.attributes) {
          utils.addAttributes(appMenuTrigger, this, this.settings.attributes, 'appmenu-trigger-btn');
        } // Add it to the App Menu's list of triggers to adjust on open/close


        $('#application-menu').data('applicationmenu').modifyTriggers([appMenuTrigger.children('a')]);
      } // Add Tab Button


      if (this.settings.addTabButton) {
        if (!this.addTabButton || !this.addTabButton.length) {
          this.addTabButton = $("\n          <div class=\"add-tab-button\" tabindex=\"0\" role=\"button\">\n            <span aria-hidden=\"true\" role=\"presentation\">+</span>\n            <span class=\"audible\">".concat(Locale.translate('AddNewTab'), "</span>\n          </div>\n        "));
          this.addTabButton.insertAfter(this.moreButton);
          this.element.addClass('has-add-button');
        }
      } else if (this.addTabButton && this.addTabButton.length) {
        this.addTabButton.off().removeData().remove();
        this.addTabButton = undefined;
        this.element.removeClass('has-add-button');
      } // Add extra attributes to the add button, if applicable


      if ((_this$addTabButton = this.addTabButton) !== null && _this$addTabButton !== void 0 && (_this$addTabButton == null ? void 0 : _this$addTabButton.length) && this.settings.attributes) {
        utils.addAttributes(this.addTabButton, this, this.settings.attributes, 'btn-add');
      } // Find a More Actions button, if applicable


      var moreActionsButton = this.element.find('.more-actions-button .btn-actions');

      if (moreActionsButton.length) {
        this.moreActionsBtn = moreActionsButton;
      }

      return this;
    },

    /**
     * Establishes the bound event listeners on all tabs elements
     * @private
     * @returns {this} component instance
     */
    setupEvents: function setupEvents() {
      var _this2 = this;

      var self = this; // Set animation bar if tabs under modal

      var modal = self.element.closest('.modal');

      if (modal.length) {
        modal.on('afteropen.tabs', function () {
          if (self.hasAnimatedBar()) {
            var selected = $('.tab.is-selected');
            self.focusBar(selected);
          }
        });
      } // Clicking the 'a' triggers the click on the 'li'


      function routeAnchorClick(e) {
        var a = $(e.currentTarget);

        if (this.wasTapped === true) {
          this.wasTapped = false;
          return;
        }

        if (e.type === 'touchend') {
          this.wasTapped = true;
        }

        if (a.attr('href').substr(0, 1) !== '#') {
          // is an outbound Link
          return;
        }

        e.preventDefault();
      } // Some tabs have icons that can be clicked and manipulated


      function handleIconClick(e) {
        var elem = $(this);

        if (elem.is('[disabled]') || elem.parent().hasClass('is-disabled')) {
          return;
        }

        var li = $(elem).parent();

        if (li.hasClass('dismissible')) {
          e.preventDefault();
          e.stopPropagation();
          self.closeDismissibleTab(li.children('a').attr('href'));
        }
      }

      function handleTabBlur() {
        $(this).parent().removeClass('is-focused');
      } // Any events bound to individual tabs (li) and their anchors (a) are bound
      // to the tablist element so that tabs can be added/removed/hidden/shown without
      // needing to change event bindings.


      this.tablist.on('mousedown.tabs', '> li', function (e) {
        self.handleAddFocusData(e, $(this));

        if ($(e.target).hasClass('close') && $(e.target).parent().hasClass('has-popupmenu')) {
          var menu = $(this).data('popupmenu').menu;
          var hrefs = [];
          $.each(menu[0].children, function (i, li) {
            hrefs.push(li.children[0].href);
          });
          self.closeDismissibleTabs(hrefs);
        } // let right click pass through


        if (e.which !== 3) {
          return self.handleTabClick(e, $(this));
        }

        return false;
      }).on('click.tabs', 'a', routeAnchorClick).on('click.tabs', '.icon', handleIconClick).on('focus.tabs', 'a', function (e) {
        return self.handleTabFocus(e, $(this));
      }).on('blur.tabs', 'a', handleTabBlur).on('keydown.tabs', 'a', function (e) {
        return _this2.handleTabKeyDown(e);
      }); // Setup events on Dropdown Tabs

      function dropdownTabEvents(i, tab) {
        var li = $(tab);
        var a = li.children('a');
        var menu = li.data('popupmenu').menu; // Alt+Del or Alt+Backspace closes a dropdown tab item

        function closeDropdownMenuItem(e) {
          if (!e.altKey || !li.is('.dismissible')) {
            return;
          }

          self.closeDismissibleTab(a.attr('href'));
        }

        menu.on('keydown.popupmenu', 'a', function (e) {
          switch (e.which) {
            case 27:
              // escape
              li.addClass('is-selected');
              a.focus();
              break;

            case 8:
              // backspace (delete on Mac)
              closeDropdownMenuItem(e);
              break;

            case 46:
              // The actual delete key
              closeDropdownMenuItem(e);
              break;
          }
        });
        li.on('selected.tabs', function (e, anchor) {
          var popupLi = $(this);
          var href = $(anchor).attr('href');

          if (!self.activate(href, $(anchor))) {
            return false;
          }

          self.positionFocusState(a);

          if (self.hasAnimatedBar()) {
            self.focusBar(popupLi);
          }

          a.focus();
          self.scrollTabList(popupLi);
          popupLi.addClass('is-selected');
          return false;
        });
      }

      var ddTabs = self.tablist.find('li').filter('.has-popupmenu');
      ddTabs.each(dropdownTabEvents);

      function dismissibleTabEvents(i, tab) {
        var li = $(tab);
        var a = li.children('a');
        a.on('keydown.tabs', function (e) {
          self.handleDismissibleTabKeydown(e);
        });
      }

      var dismissible = self.tablist.find('li').filter('.dismissible');
      dismissible.each(dismissibleTabEvents);
      this.setupHelperMarkupEvents();
      this.panels.on('keydown.tabs', function (e) {
        self.handlePanelKeydown(e);
      }); // Check whether or not all of the tabs + more button are de-focused.
      // If true, the focus-state and animated bar need to revert positions
      // back to the currently selected tab.

      this.element.on('focusout.tabs', function () {
        var noFocusedTabs = !$.contains(self.element[0], document.activeElement);
        var noPopupMenusOpen = self.tablist.children('.has-popupmenu.is-open').length === 0;

        if (noFocusedTabs && noPopupMenusOpen && !self.moreButton.is('.is-selected, .popup-is-open')) {
          self.hideFocusState();
        }
      }).on('updated.tabs', function (e, settings) {
        self.updated(settings);
      }).on('activated.tabs', function (e) {
        // Stop propagation of the activate event from going higher up into the DOM tree
        e.stopPropagation();
      }).on('add.tabs', function (e, newTabId, newTabOptions, newTabIndex) {
        self.add(newTabId, newTabOptions, newTabIndex);
      }).on('remove.tabs', function (e, tabId) {
        self.remove(tabId);
      }); // Check to see if we need to add/remove the more button on resize

      $('body').on("resize.tabs".concat(this.tabsIndex), function () {
        self.handleResize();
      });
      self.handleResize(true); // Resize the tab to show the error

      $('.tab-panel input').on('error.tabs, valid.tabs', function () {
        var currentLi = $('.tab.is-selected');
        self.focusBar(currentLi);
      });
      return this;
    },

    /**
     * Adds events associated with elements that are re-renderable during the Tabs lifecycle
     * @private
     */
    setupHelperMarkupEvents: function setupHelperMarkupEvents() {
      var _this$moreActionsBtn;

      var self = this; // Setup the "more" function

      this.moreButton.on('click.tabs', function (e) {
        self.handleMoreButtonClick(e);
      }).on('keydown.tabs', function (e) {
        self.handleMoreButtonKeydown(e);
      }).on('focus.tabs', function (e) {
        self.handleMoreButtonFocus(e);
      }).on('mousedown.tabs', function (e) {
        self.handleAddFocusData(e, $(this));
      });

      if (this.settings.addTabButton) {
        this.addTabButton.on('click.tabs', function () {
          self.handleAddButton();
        }).on('keydown.tabs', function (e) {
          self.handleAddButtonKeydown(e);
        }).on('focus.tabs', function (e) {
          self.handleAddButtonFocus(e);
        });
      }

      if ((_this$moreActionsBtn = this.moreActionsBtn) !== null && _this$moreActionsBtn !== void 0 && (_this$moreActionsBtn == null ? void 0 : _this$moreActionsBtn.length)) {
        this.moreActionsBtn.on('keydown.tabs', function (e) {
          self.handleMoreActionsButtonKeydown(e);
        });
      }
    },

    /**
     * Removes events associated with elements that are re-renderable during the Tabs lifecycle
     * @private
     * @returns {this} component instance
     */
    removeHelperMarkupEvents: function removeHelperMarkupEvents() {
      if (this.moreButton && this.moreButton.length) {
        this.moreButton.off('click.tabs keydown.tabs focus.tabs mousedown.tabs');
      }

      if (this.addTabButton && this.addTabButton.length) {
        this.addTabButton.off('click.tabs keydown.tabs focus.tabs');
      }

      return this;
    },

    /**
     * Setup a mousedown event on tabs to determine in the focus handler whether
     * or a not a keystroked cause a change in focus, or a click.  Keystroke focus
     * changes cause different visual situations
     * @private
     * @param {$.Event} e incoming focus event
     * @param {jQuery[]} elem element
     * @returns {undefined}
     */
    handleAddFocusData: function handleAddFocusData(e, elem) {
      var tab = elem;

      if (tab.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      if (!tab.is(this.moreButton)) {
        tab = tab.children('a');
      }

      this.hideFocusState();
      tab.data('focused-by-click', true);
      return true;
    },

    /**
     * Handler for Tab Click
     * @private
     * @param {jQuery.Event} e incoming click event
     * @param {jQuery[]} li list item representing the clicked tab
     * @returns {boolean|undefined} ? // TODO: why?
     */
    handleTabClick: function handleTabClick(e, li) {
      if (this.element.is('.is-disabled') || li && (li.is('.is-disabled') || li.is('.separator'))) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      var appMenuResult = this.handleAppMenuTabKeydown(e);

      if (!appMenuResult) {
        return true;
      }

      var a = li.children('a');
      a.data('focused-by-click', true);

      if (this.popupmenu && this.popupmenu.element.hasClass('is-open')) {
        this.popupmenu.close();
      } // Don't activate a dropdown tab.  Clicking triggers the Popupmenu Control attached.


      if (li.is('.has-popupmenu')) {
        this.positionFocusState(a);
        return true;
      }

      var href = a.attr('href');

      if (li.is('.add-tab-button')) {
        a = this.handleAddButton();
        li = a.parent();
        href = a.attr('href');
        this.element.trigger('tab-added', [a]);
      } // close tab on middle click


      if (e.which === 2) {
        if (li.is('.dismissible') && $(e.target).is('.close')) {
          this.closeDismissibleTab(href);
        }

        e.preventDefault();
        return true;
      }

      if (!this.activate(href, a)) {
        return true;
      }

      this.changeHash(href);
      this.focusState.removeClass('is-visible');
      a.focus();

      if (this.isScrollableTabs()) {
        this.scrollTabList(li);
      } // Hide these states


      this.focusBar(li);
      this.positionFocusState(a);

      if (this.settings.lazyLoad === true && this.isURL(href)) {
        return false;
      }

      return true;
    },

    /**
     * Handler for click events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e Event
     * @returns {boolean|undefined} ?
     */
    handleMoreButtonClick: function handleMoreButtonClick(e) {
      if (this.element.is('.is-disabled') || this.moreButton.is('.is-disabled')) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }

      this.moreButton.data('focused-by-click', true);

      if (!this.hasMoreButton()) {
        e.stopPropagation();
      }

      if (this.moreButton.hasClass('popup-is-open')) {
        this.popupmenu.close();
        this.moreButton.removeClass('popup-is-open');
      } else {
        this.buildPopupMenu();
      }

      this.hideFocusState();
      return true;
    },

    /**
     * @returns {boolean} true if the "More Actions" button is present
     */
    hasMoreActions: function hasMoreActions() {
      var moreActionsBtn = this.element.find('.more-actions-button > .btn-actions');
      return moreActionsBtn && moreActionsBtn.length > 0;
    },

    /**
     * Handler for keydown events on the optional "More Actions" button, if it's present.
     * @private
     * @param {jQuery.event} e Event
     * @returns {boolean|undefined} ?
     */
    handleMoreActionsButtonKeydown: function handleMoreActionsButtonKeydown(e) {
      if (this.element.is('.is-disabled') || this.moreActionsBtn.is('.is-disabled')) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }

      var self = this;

      function openMenu(oldHref) {
        e.preventDefault(); // setTimeout is used to bypass triggering of the keyboard when
        // self.buildPopupMenu() is invoked.

        setTimeout(function () {
          self.buildPopupMenu(oldHref);
          self.positionFocusState(self.moreButton, true);
        }, 0);
      }

      var hasAddButton = this.addTabButton && this.addTabButton.length;
      var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)';
      var tabs = this.tablist.children("li".concat(allExcludes));
      var targetLi;

      switch (e.which) {
        case 37: // left

        case 38:
          // up
          if (hasAddButton) {
            this.addTabButton.focus();
          } else {
            var last = this.findLastVisibleTab();

            if (this.hasMoreButton()) {
              openMenu(last.attr('href'));
            } else {
              targetLi = last;
            }
          }

          break;

        case 39: // right

        case 40:
          // down
          targetLi = tabs.first();
          break;
      }

      if (targetLi) {
        e.preventDefault();
        targetLi.children('a').focus();

        if (this.isScrollableTabs()) {
          this.scrollTabList(targetLi);
        }
      }

      return true;
    },

    /**
     * Handler for click events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e Event
     * @param {jQuery[]} a represents an anchor tag
     * @returns {boolean|undefined} ?
     */
    handleTabFocus: function handleTabFocus(e, a) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var li = a.parent();
      var dataFocusedClick = a.data('focused-by-click');
      var focusedByKeyboard = dataFocusedClick === undefined || dataFocusedClick && dataFocusedClick === false;
      $.removeData(a[0], 'focused-by-click');

      if (this.isTabOverflowed(li)) {
        this.buildPopupMenu(a.attr('href'));
        this.moreButton.addClass('is-focused');
        this.positionFocusState(this.moreButton);
      } else {
        li.addClass('is-focused');
        this.positionFocusState(a, focusedByKeyboard);
      }

      return true;
    },

    /**
     * Handler for focus events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming focus event
     * @returns {void}
     */
    handleMoreButtonFocus: function handleMoreButtonFocus(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return;
      }

      var dataFocusedClick = this.moreButton.data('focused-by-click');
      var focusedByKeyboard = dataFocusedClick && dataFocusedClick === false;
      $.removeData(this.moreButton[0], 'focused-by-click');
      this.focusState.removeClass('is-visible');
      this.positionFocusState(this.moreButton, focusedByKeyboard);
    },

    /**
     * Handler for keydown events on Tabs in the list
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean|undefined} ?
     */
    handleTabKeyDown: function handleTabKeyDown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey && e.which !== 8) {
        return true;
      }

      var self = this;
      var passableKeys = [8, 13, 32];

      function isPassableKey() {
        return $.inArray(e.which, passableKeys) > -1;
      }

      if (e.which < 32 && !isPassableKey() || e.which > 46) {
        return true;
      }

      if (isPassableKey()) {
        var appMenuResult = this.handleAppMenuTabKeydown(e);

        if (!appMenuResult) {
          return true;
        }
      }

      function openMenu(oldHref) {
        e.preventDefault(); // setTimeout is used to bypass triggering of the keyboard when
        // self.buildPopupMenu() is invoked.

        setTimeout(function () {
          self.buildPopupMenu(oldHref);
        }, 0);
      }

      var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)';
      var currentLi = $(e.currentTarget).parent();
      var currentA = currentLi.children('a');
      var targetLi;
      var tabs = self.tablist.children("li".concat(allExcludes));
      var isRTL = Locale.isRTL();

      function previousTab() {
        var i = tabs.index(currentLi) - 1;

        while (i > -1 && !targetLi) {
          if (tabs.eq(i).is(allExcludes)) {
            return tabs.eq(i);
          }

          i -= 1;
        }

        if (self.hasMoreActions()) {
          return self.moreActionsBtn;
        }

        if (self.settings.addTabButton) {
          return self.addTabButton;
        }

        var last = self.tablist.children("li".concat(allExcludes)).last();

        if (self.hasMoreButton() && self.isScrollableTabs()) {
          openMenu(last.find('a').attr('href'));
        }

        return last;
      }

      function nextTab() {
        var i = tabs.index(currentLi) + 1;

        while (i < tabs.length && !targetLi) {
          if (tabs.eq(i).is(allExcludes)) {
            return tabs.eq(i);
          }

          i++;
        }

        var first = self.tablist.children("li".concat(allExcludes)).first();

        if (self.hasMoreButton() && self.isScrollableTabs()) {
          openMenu(first.find('a').attr('href'));
          return first;
        }

        if (self.settings.addTabButton) {
          return self.addTabButton;
        }

        if (self.hasMoreActions()) {
          return self.moreActionsBtn;
        }

        return first;
      }

      function checkAngularClick() {
        if (currentA.attr('ng-click') || currentA.attr('data-ng-click')) {
          // Needed to fire the "Click" event in Angular situations
          currentA.click();
        }
      }

      function activate() {
        if (currentLi.hasClass('has-popupmenu')) {
          currentLi.data('popupmenu').open();
          return;
        }

        var href = currentA.attr('href');

        if (currentLi.is('.add-tab-button')) {
          currentA = self.handleAddButton();
          currentLi = currentA.parent();
          href = currentA.attr('href');
          self.element.trigger('tab-added', [currentA]);
        }

        if (!self.activate(href)) {
          return;
        }

        self.changeHash(href);
        self.focusBar(currentLi);
        checkAngularClick();
        currentA[0].focus();
        self.hideFocusState(); // In the event that the activated tab is a full link that should be followed,
        // the keystroke events need to manually activate the link change.  Clicks are handled
        // automatically by the browser.

        self.handleOutboundLink(href);
      }

      switch (e.which) {
        case 8:
          if (e.altKey && currentLi.is('.dismissible')) {
            e.preventDefault();
            self.closeDismissibleTab(currentA.attr('href'));
          }

          return true;

        case 13:
          // Enter
          activate();
          return false;

        case 32:
          // Spacebar
          activate();
          return false;

        case 38:
          targetLi = previousTab();
          e.preventDefault();
          break;

        case 37:
          targetLi = isRTL ? nextTab() : previousTab();
          e.preventDefault();
          break;

        case 40:
          targetLi = nextTab();
          e.preventDefault();
          break;

        case 39:
          targetLi = isRTL ? previousTab() : nextTab();
          e.preventDefault();
          break;
      }

      if (targetLi) {
        var isAddTabButton = targetLi.is('.add-tab-button');
        var isMoreActionsButton = targetLi.is('.btn-actions');
        var focusStateTarget = isAddTabButton || isMoreActionsButton ? targetLi : targetLi.children('a'); // Use the matching option in the popup menu if the target is hidden by overflow.

        if (this.isTabOverflowed(targetLi)) {
          return openMenu(targetLi.children('a').attr('href'));
        }

        if (isAddTabButton) {
          self.addTabButton.focus();
        } else if (isMoreActionsButton) {
          self.moreActionsBtn.focus();
        } else {
          focusStateTarget.focus();

          if (this.isScrollableTabs()) {
            this.scrollTabList(focusStateTarget);
            self.positionFocusState(focusStateTarget, true);
          }
        }
      }

      return true;
    },

    /**
     * Handler for keydown events on Dismissible tabs
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {void}
     */
    handleDismissibleTabKeydown: function handleDismissibleTabKeydown(e) {
      var key = e.which;
      var tab = $(e.target);

      if (tab.is('a')) {
        tab = tab.parent();
      }

      if (e.altKey && key === 46) {
        // Alt + Del
        if (tab.children('a').is('[disabled]') || tab.hasClass('is-disabled')) {
          return;
        }

        e.preventDefault();
        this.closeDismissibleTab(tab.children('a').attr('href'));
      }
    },

    /**
     * Handler for keydown events on the "App Menu" tab (trigger button for the App Menu)
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean} ?
     */
    handleAppMenuTabKeydown: function handleAppMenuTabKeydown(e) {
      var target = $(e.target);
      var li = target.parent();

      if (!(li.is('.application-menu-trigger') || target.is('.application-menu-trigger'))) {
        return true;
      } // If the tab is an application-menu trigger, open the app menu
      // Used by Module Tabs


      var menu = $('#application-menu');

      if (!menu.length) {
        return false;
      }

      e.preventDefault();
      this.hideFocusState();

      if (menu.hasClass('is-open')) {
        menu.trigger('close-applicationmenu');
        return false;
      }

      menu.trigger('open-applicationmenu');
      return false;
    },

    /**
     * Handler for keydown events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {boolean|undefined} ?
     */
    handleMoreButtonKeydown: function handleMoreButtonKeydown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var self = this;
      var isRTL = Locale.isRTL();

      function openMenu() {
        e.preventDefault();
        self.buildPopupMenu(self.tablist.find('.is-selected').children('a').attr('href'));
        self.positionFocusState(self.moreButton, true);
      }

      function lastTab() {
        e.preventDefault();
        self.findLastVisibleTab();
      }

      switch (e.which) {
        case 37:
          // left
          if (isRTL) {
            openMenu();
            break;
          }

          lastTab();
          break;

        case 38:
          // up
          lastTab();
          break;

        case 13: // enter

        case 32:
          // spacebar
          e.preventDefault();
          break;

        case 39:
          // right
          if (isRTL) {
            lastTab();
            break;
          }

          openMenu();
          break;

        case 40:
          // down
          openMenu();
          break;
      }

      return true;
    },

    /**
     * Handler for keydown events on the "More Tabs" popupmenu trigger
     * @private
     * @param {jQuery.event} e incoming keydown event
     * @returns {void}
     */
    handlePanelKeydown: function handlePanelKeydown(e) {
      var key = e.which;
      var panel = $(e.target);
      var a = this.anchors.filter("#".concat(panel.attr('id')));
      var tab = this.anchors.filter("#".concat(panel.attr('id'))).parent();

      if (tab.is('.dismissible')) {
        // Close a Dismissible Tab
        if (e.altKey && key === 46) {
          // Alt + Delete
          e.preventDefault();
          return this.closeDismissibleTab(a.attr('href'));
        }
      } // Takes focus away from elements inside a Tab Panel and brings focus to its corresponding Tab


      if (e.ctrlKey && key === 38 && $.contains(document.activeElement, panel[0])) {
        // Ctrl + Up Arrow
        e.preventDefault();
        return this.activate(a.attr('href'), a);
      }

      return undefined;
    },

    /**
     * Handles the Add Tab button being clicked
     * @private
     * @returns {boolean|undefined} ?
     */
    handleAddButton: function handleAddButton() {
      var self = this;
      var cb = this.settings.addTabButtonCallback;

      if (cb && typeof cb === 'function') {
        var newTabId = cb();
        return this.anchors.filter("[href=\"#".concat(newTabId, "\"]"));
      }

      function makeId() {
        self.idCounter = typeof self.idCounter === 'number' ? self.idCounter : -1;
        self.idCounter++;
        return "new-tab-".concat(self.idCounter);
      }

      function makeName(id) {
        var nameParts = id.toString().split('-');
        nameParts.forEach(function (val, i) {
          nameParts[i] = val.charAt(0).toUpperCase() + val.slice(1);
        });
        return nameParts.join(' ');
      }

      var newIndex = this.tablist.children().index(this.addTabButton);
      var newId = makeId();
      var newName = makeName(newId);
      var settings = {
        name: newName,
        content: '&nbsp;',
        isDismissible: true
      };

      if (newIndex < 0) {
        newIndex = this.tablist.find('li:not(.separator)').length;
      } // Allow the opportunity to pass in external settings for the new tab control


      var externalSettings = this.element.triggerHandler('before-tab-added', [newId, settings, newIndex]);

      if (!externalSettings) {
        this.add(newId, settings, newIndex);
        return this.anchors.filter("[href=\"#".concat(newId, "\"]"));
      }

      if (externalSettings.newId && externalSettings.newId.length && typeof externalSettings.newId === 'string') {
        newId = externalSettings.newId;
      }

      if (externalSettings.settings && _typeof(externalSettings.settings) === 'object') {
        settings = externalSettings.settings;
      }

      if (!isNaN(externalSettings.newIndex)) {
        newIndex = externalSettings.newIndex;
      }

      this.add(newId, settings, newIndex);
      return this.anchors.filter("[href=\"#".concat(newId, "\"]"));
    },

    /**
     * @private
     * @param {jQuery.Event} e incoming keydown event
     * @returns {undefined|boolean} ?
     */
    handleAddButtonKeydown: function handleAddButtonKeydown(e) {
      if (this.element.is('.is-disabled')) {
        e.preventDefault();
        return false;
      }

      var validKeys = [13, 32, 37, 38, 39, 40];
      var key = e.which;

      if (validKeys.indexOf(key) < 0) {
        return false;
      }

      var self = this;
      var isRTL = Locale.isRTL();
      var targetLi;
      var filter = 'li:not(.separator):not(.is-disabled):not(:hidden)';

      function openMenu() {
        e.preventDefault();
        targetLi = self.tablist.find(filter).last(); // setTimeout is used to bypass triggering of the keyboard when
        // self.buildPopupMenu() is invoked.

        setTimeout(function () {
          self.buildPopupMenu(targetLi.children('a').attr('href'));
          self.positionFocusState(self.moreButton, true);
        }, 0);
      }

      function firstTab() {
        if (self.hasMoreActions()) {
          self.moreActionsBtn.focus();
          return;
        }

        targetLi = self.tablist.find(filter).first();
      }

      switch (key) {
        case 37:
          // left
          if (isRTL) {
            firstTab();
            break;
          }

          openMenu();
          break;

        case 38:
          // up
          openMenu();
          break;

        case 13: // enter

        case 32:
          // spacebar
          e.preventDefault();
          return this.handleAddButton();

        case 39:
          // right
          if (isRTL) {
            openMenu();
            break;
          }

          firstTab();
          break;

        case 40:
          // down
          firstTab();
          break;
      }

      if (targetLi) {
        targetLi.children('a').focus();

        if (this.isScrollableTabs) {
          e.preventDefault();
          this.scrollTabList(targetLi);
        }
      }

      return true;
    },

    /**
     * @private
     * @returns {void}
     */
    handleAddButtonFocus: function handleAddButtonFocus() {
      var tabs = this.tablist.find('li:not(.separator)');
      tabs.add(this.moreButton).removeClass('is-focused');
      this.addTabButton.addClass('is-focused');
      this.positionFocusState(this.addTabButton, true);
    },

    /**
     * Resets the visual state of the Tab List and Tab Panel Container to match current width/height and responsive.
     * @param {boolean} ignoreResponsiveCheck if true, doesn't run `this.checkResponsive()`
     * @returns {void}
     */
    handleResize: function handleResize(ignoreResponsiveCheck) {
      if (!ignoreResponsiveCheck) {
        this.checkResponsive(true);
      }

      this.setOverflow();
      var selected = this.tablist.find('.is-selected');

      if (!selected.length || this.moreButton.is('.is-selected') || this.isTabOverflowed(selected)) {
        selected = this.moreButton;
      }

      if (!selected.length) {
        this.defocusBar();
        this.hideFocusState();
      } else {
        this.focusBar(selected);
        this.positionFocusState(selected);
      }

      this.handleVerticalTabResize();
      this.renderVisiblePanel();
      this.renderEdgeFading();
    },

    /**
     * Checks the window size to determine if a responsive-mode switch is needed.
     * @private
     * @returns {void}
     * @param  {boolean} handleRebuild Do a rebuild after handling.
     */
    checkResponsive: function checkResponsive(handleRebuild) {
      var self = this;
      var classList = self.element[0].classList;

      function rebuild() {
        self.removeHelperMarkupEvents();
        self.renderHelperMarkup();
        self.setupHelperMarkupEvents();
      }

      function makeResponsive() {
        if (!classList.contains('is-in-responsive-mode')) {
          classList.add('is-in-responsive-mode');
          classList.add('header-tabs');
          if (!classList.contains('is-personalizable')) classList.add('alternate');
          classList.remove('vertical');

          if (handleRebuild) {
            rebuild();
          }
        }
      }

      function makeVertical() {
        if (classList.contains('is-in-responsive-mode')) {
          classList.add('vertical');
          classList.remove('is-in-responsive-mode');
          classList.remove('header-tabs');
          classList.remove('alternate');

          if (handleRebuild) {
            rebuild();
          }
        }
      } // Check for responsive mode for Vertical tabs


      if (this.isResponsiveVerticalTabs()) {
        if (breakpoints.isBelow('phone-to-tablet')) {
          makeResponsive();
        } else {
          makeVertical();
        }
      } else {
        makeVertical();
      }
    },

    /**
     * Causes a vertical tabs container to stretch to the height of its parent container
     * @private
     * @returns {void}
     */
    handleVerticalTabResize: function handleVerticalTabResize() {
      if (!this.isVerticalTabs()) {
        return;
      } // When tabs are full-size (part of a layout) CSS rules should handle this better
      // due to less strange sizing constraints.  JS resizing is necessary for nesting.


      if (!this.isNested() || this.isNestedInLayoutTabs() || this.isHidden()) {
        return;
      }

      var elemStyle = window.getComputedStyle(this.element[0]);
      var elemOuterHeight = elemStyle.getPropertyValue('height') + elemStyle.getPropertyValue('margin-top') + elemStyle.getPropertyValue('margin-bottom');
      this.tablist[0].style.height = elemOuterHeight;
    },

    /**
     * Changes the location in the browser address bar to force outbound links.
     * @param {string} href incoming href link
     * @param {boolean} useRelativePath don't prepend the full domain, port,
     * protocol, etc. to the HREF.
     * @returns {void}
     */
    handleOutboundLink: function handleOutboundLink(href, useRelativePath) {
      if (href.charAt(0) === '#') {
        return;
      }

      if (href.charAt(0) === '/' && (!useRelativePath || useRelativePath === false)) {
        href = window.location.origin + href;
      }

      window.location = href;
    },

    /**
     * Determines whether or not this tabset's tab list should display an animated selected state on a tab.
     * @returns {boolean} whether or not the animated selected state should display.
     */
    hasAnimatedBar: function hasAnimatedBar() {
      return !this.isModuleTabs() && !this.isVerticalTabs();
    },

    /**
     * Determines whether or not this tabset currently has a "More Tabs" spillover button.
     * @returns {boolean} whether or not the "More Tabs" button is currently displayed.
     */
    hasMoreButton: function hasMoreButton() {
      return this.element[0].classList.contains('has-more-button');
    },

    /**
     * Determines whether or not this normally "vertical" tabset is in an optional "horizontal" responsive mode
     * @returns {boolean} whether or not the responsive mode is active.
     */
    isInResponsiveMode: function isInResponsiveMode() {
      return this.element[0].classList.contains('is-in-responsive-mode');
    },

    /**
     * Determines whether or not this tabset is currently operating as Module Tabs
     * @returns {boolean} whether or not this is a Module tabset.
     */
    isModuleTabs: function isModuleTabs() {
      return this.element.hasClass('module-tabs');
    },

    /**
     * Determines whether or not this tabset is currently operating as Vertical Tabs
     * @returns {boolean} whether or not this is a Vertical tabset.
     */
    isVerticalTabs: function isVerticalTabs() {
      return this.element.hasClass('vertical');
    },

    /**
     * Determines whether or not this tabset is Vertical Tabs with a responsive, horizontal capability
     * @returns {boolean} whether or not this is a Vertical tabset.
     */
    isResponsiveVerticalTabs: function isResponsiveVerticalTabs() {
      return this.settings.verticalResponsive === true;
    },

    /**
     * Determines whether or not this tabset is currently operating as Header Tabs
     * @returns {boolean} whether or not this is a Header tabset.
     */
    isHeaderTabs: function isHeaderTabs() {
      return this.element.hasClass('header-tabs');
    },

    /**
     * Determines whether or not this tabset is showing tabs that allow for selection via horizontal scrolling.
     * @returns {boolean} whether or not horizontal scrolling is possible.
     */
    isScrollableTabs: function isScrollableTabs() {
      return !this.isModuleTabs() && !this.isVerticalTabs();
    },

    /**
     * Determines whether or not this tabset is currently hidden
     * @returns {boolean} whether or not this tabset is hidden.
     */
    isHidden: function isHidden() {
      return this.element.is(':hidden');
    },

    /**
     * Determines whether or not this tabset is nested inside a parent Tab Panel
     * @returns {boolean} whether or not this tabset is nested.
     */
    isNested: function isNested() {
      return this.element.closest('.tab-panel').length;
    },

    /**
     * Determines whether or not a particular tab panel is currently the active (displayed) tab panel
     * @param {string} href representing the HTML "id" attribute of a corresponding tab panel
     * @returns {boolean} whether or not the tab panel is active.
     */
    isActive: function isActive(href) {
      if (!href || !href.length || href.length === 1 && href.indexOf('#') < 1) {
        return false;
      }

      var panel = this.getPanel(href);
      return panel[0].classList.contains('can-show');
    },

    /**
     * Determines whether or not this tabset is nested inside a "Layout"-style of Tab container
     * @returns {boolean} whether or not this tabset is nested.
     */
    isNestedInLayoutTabs: function isNestedInLayoutTabs() {
      var nestedInModuleTabs = this.element.closest('.module-tabs').length;
      var nestedInHeaderTabs = this.element.closest('.header-tabs').length;
      var hasTabContainerClass = this.element.closest('.tab-panel-container').length;
      return nestedInModuleTabs > 0 || nestedInHeaderTabs > 0 || hasTabContainerClass > 0;
    },

    /**
     * Determines if an object is an HTML List Item representing a tab
     * @param {object} obj incoming object
     * @returns {boolean} whether or not the item is a tab
     */
    isTab: function isTab(obj) {
      return obj instanceof jQuery && obj.length && obj.is('li.tab');
    },

    /**
     * Determines if an object is an HTML Anchor Tag representing a tab's actionable element
     * @param {object} obj incoming object
     * @returns {boolean} whether or not the item is an anchor tag
     */
    isAnchor: function isAnchor(obj) {
      return obj instanceof jQuery && obj.length && obj.is('a');
    },

    /**
     * Gets a reference to an Anchor tag.
     * @param {string|jQuery} href either a string that can be used as a Tab ID, or an actual jQuery wrapped Anchor Tag.
     * @returns {jQuery} the Anchor tag
     */
    getAnchor: function getAnchor(href) {
      if (this.isAnchor(href)) {
        return href;
      }

      if (href.indexOf('#') === -1 && href.charAt(0) !== '/') {
        href = "#".concat(href);
      }

      return this.anchors.filter("[href=\"".concat(href, "\"]"));
    },

    /**
     * Gets a reference to a Tab panel.
     * @param {string|jQuery} href either a string that can be used as a Tab ID, or an actual jQuery wrapped Anchor Tag.
     * @returns {jQuery} the Anchor tag
     */
    getPanel: function getPanel(href) {
      if (this.isTab(href)) {
        href = href.children('a');
      }

      if (this.isAnchor(href)) {
        href = href.attr('href');
      }

      if (!href || href === '' || href === '#') {
        return $();
      } // uses angular LocationStrategy


      if (href.substr(0, 2) === '#/') {
        href = href.replace('#/', '#');
      }

      return this.panels.filter("[id=\"".concat(href.replace(/#/g, ''), "\"]"));
    },
    getMenuItem: function getMenuItem(href) {
      if (this.isAnchor(href)) {
        href = href.attr('href');
      }

      if (href.indexOf('#') === -1) {
        href = "#".concat(href);
      }

      return this.moreMenu.children().children().filter("[data-href=\"".concat(href, "\"]")).parent();
    },

    /**
     * Takes a tab ID and returns a jquery object containing the previous available tab
     * @param {string} tabId the tab ID
     * @returns {jQuery[]} jQuery-wrapped element reference for the tab
     */
    getPreviousTab: function getPreviousTab(tabId) {
      var tab = this.getTab(null, tabId);
      var filter = 'li:not(.separator):not(:hidden):not(.is-disabled)';
      var tabs = this.tablist.find(filter);
      var idx = tabs.index(tab);
      var target = tabs.eq(idx === 0 ? 1 : idx - 1);

      while (target.length && !target.is(filter)) {
        target = tabs.eq(tabs.index(target) - 1);
      } // Top-level Dropdown Tabs don't have an actual panel associated with them.
      // Get a Dropdown Tab's first child as the target.


      if (target.is('.has-popupmenu')) {
        var menuAPI = target.data('popupmenu');

        if (menuAPI) {
          target = menuAPI.menu.children('li').first();
        }
      }

      return target;
    },

    /**
     * Takes a tab ID and activates an adjacent available tab
     * @param {object} e event object
     * @param {string} tabId the tab ID
     */
    activateAdjacentTab: function activateAdjacentTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);

      if (typeof e === 'string') {
        tabId = e;
      }

      if (tab.is('.is-selected')) {
        if (tab.prevAll('li.tab').not('.hidden').not('.is-disabled').length > 0) {
          this.select($(tab.prevAll('li.tab').not('.hidden').not('.is-disabled')[0]).find('a')[0].hash, true);
        } else if (tab.nextAll('li.tab').not('.hidden').length > 0) {
          this.select($(tab.nextAll('li.tab').not('.hidden').not('.is-disabled')[0]).find('a')[0].hash, true);
        }
      } else {
        this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash, true);
      }
    },

    /**
     * Takes a tab ID and returns a jquery object containing the previous available tab
     * If an optional target Tab (li) is provided, use this to perform activation events
     * @param {string} tabId the tab ID
     * @param {jQuery[]} [target] a reference to the previous tab in the list (before this one)
     * @returns {jQuery[]} potentially-updated target
     */
    activatePreviousTab: function activatePreviousTab(tabId, target) {
      var tab = this.getTab(null, tabId);

      if (!target || !(target instanceof jQuery)) {
        target = this.getPreviousTab(tabId);
      }

      if (!target.length) {
        this.hideFocusState();
        this.defocusBar();
        return target;
      }

      var a = target.children('a');

      if (tab.is('.is-selected')) {
        if (!this.activate(a.attr('href'), a)) {
          return target;
        }

        a.focus();
      }

      this.positionFocusState(a);
      this.focusBar(target);
      return target;
    },

    /**
     * Determines whether or not a string has an outbound URL, instead of a hash (#) that would match up to a Tab ID.
     * @param {string} href a string that may or may not contain a URL
     * @returns {boolean} whether or not the incoming string is a URL
     */
    isURL: function isURL(href) {
      if (!href || href.indexOf('#') === 0) {
        return false;
      }

      return true;
    },

    /**
     * Causes a new tab panel to become active.  Will also trigger AJAX calls on unloaded tab panels, if necessary.
     * @param {string} href a string that either matches up to a Tab ID, or an outbound link to grab AJAX content from.
     * @param {object} anchor in addition to the ref the anchor object may be passed to avoid extra querying.
     * @returns {void}
     */
    activate: function activate(href, anchor) {
      var self = this;

      if (self.isURL(href)) {
        return this.callSource(href, anchor, true);
      }

      var a = self.getAnchor(href);
      var targetTab = a.parent();
      var targetPanel = self.getPanel(href);
      var targetPanelElem = targetPanel[0];
      var oldTab = self.anchors.parents().filter('.is-selected');
      var oldPanel;
      var selectedStateTarget;
      var activeStateTarget; // Avoid filter(:visible)

      for (var i = 0; i < self.panels.length; i++) {
        if (self.panels[i].classList.contains('is-visible')) {
          oldPanel = $(self.panels[i]);
        }
      }

      if (!oldPanel) {
        oldPanel = self.panels;
      } // NOTE: Breaking Change as of 4.3.3 - `beforeactivate` to `beforeactivated`
      // See SOHO-5994 for more details

      /**
       * Fires when an attempt at activating a tab is started
       *
       * @event beforeactivated
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} a the tab anchor attempting to activate
       */


      var isCancelled = self.element.trigger('beforeactivated', [a]);

      if (!isCancelled) {
        return false;
      }

      function completeActivate(vetoResult) {
        if (targetPanel.length < 1) {
          if (self.settings.source) {
            self.callSource(href, a);
            return true;
          }
        } else {
          oldPanel[0].classList.remove('can-show');
          oldPanel[0].classList.remove('is-visible');
          oldPanel.closeChildren();
          /**
           * Fires when a new tab has been activated
           *
           * @event activated
           * @memberof Tabs
           * @param {jQuery.Event} e event object
           * @param {jQuery} a the tab anchor attempting to activate
           */

          self.element.trigger('activated', [a]);
          targetPanelElem.classList.add('can-show');
          self.renderVisiblePanel(); // trigger reflow as display property is none for animation
          // eslint-disable-next-line

          targetPanelElem.offsetHeight; // Register an `afteractivated` event trigger as a renderLoop callback

          var timer = new RenderLoopItem({
            duration: math.convertDelayToFPS(150),
            timeoutCallback: function timeoutCallback() {
              /**
               * Fires when a new tab has been completely activated, and the activation process is done
               *
               * @event afteractivated
               * @memberof Tabs
               * @param {jQuery.Event} e event object
               * @param {jQuery} a the tab anchor attempting to activate
               */
              self.element.trigger('afteractivated', [a]);
            }
          });
          renderLoop.register(timer); // Triggers the CSS Animation

          targetPanelElem.classList.add('is-visible');
        } // Update the currently-selected tab


        self.updateAria(a);
        oldTab.add(self.moreButton).removeClass('is-selected');

        if (targetTab[0]) {
          if (targetTab[0].classList.contains('tab')) {
            selectedStateTarget = targetTab;
            activeStateTarget = targetTab;
          }
        }

        var ddMenu = targetTab.parents('.popupmenu');
        var ddTab;

        if (ddMenu.length) {
          ddTab = ddMenu.data('trigger');

          if (ddTab.length) {
            selectedStateTarget = ddTab;
            activeStateTarget = ddTab;
          }
        }

        if (self.isTabOverflowed(activeStateTarget)) {
          activeStateTarget = self.moreButton;
          selectedStateTarget = self.moreButton;
        }

        self.focusBar(activeStateTarget);

        if (selectedStateTarget) {
          selectedStateTarget.addClass('is-selected');
        } // Fires a resize on any invoked child toolbars inside the tab panel.
        // Needed to fix issues with Toolbar alignment, since we can't properly detect
        // size on hidden elements.


        var childToolbars = targetPanel.find('.toolbar');

        if (childToolbars.length) {
          childToolbars.each(function () {
            var api = $(this).data('toolbar');

            if (api && typeof api.handleResize === 'function') {
              api.handleResize();
            }
          });
        } // Automatically refresh all icons inside Tab panels on activation.
        // See SOHO-7313


        utils.fixSVGIcons(targetPanel[0]);
        return vetoResult || false;
      } // Handle an optional, veto-able "beforeActivate" callback.


      if (this.settings.beforeActivate && typeof this.settings.beforeActivate === 'function') {
        return this.settings.beforeActivate(oldTab, targetTab, completeActivate);
      } // Otherwise, simply continue


      return completeActivate(true);
    },

    /**
     * Shows/Hides some tabsets' faded edges based on scrolling position, if applicable.
     * @private
     * @returns {undefined}
     */
    renderEdgeFading: function renderEdgeFading() {
      if (!this.isScrollableTabs() || !this.tablistContainer) {
        return;
      }

      var isRTL = Locale.isRTL();
      var tablistContainerElem = this.tablistContainer[0];
      var scrollLeft = tablistContainerElem.scrollLeft;
      var scrollWidth = tablistContainerElem.scrollWidth;
      var containerWidth = parseInt(window.getComputedStyle(tablistContainerElem).getPropertyValue('width'), 10);

      if (isRTL) {
        this.element[0].classList[scrollLeft > 0 ? 'add' : 'remove']('scrolled-left');
        this.element[0].classList[scrollWidth - scrollLeft <= containerWidth ? 'remove' : 'add']('scrolled-right');
      } else {
        this.element[0].classList[scrollLeft > 0 ? 'add' : 'remove']('scrolled-right');
        this.element[0].classList[scrollWidth - scrollLeft <= containerWidth ? 'remove' : 'add']('scrolled-left');
      }
    },

    /**
     * Calls an options-provided source method to fetch content that will be displayed inside a tab.
     * @param {string} href - string representing the target tab to load content under.
     * @param {object} anchor - Reference to the dom object anchor tag.
     * @param {boolean} isURL detects whether or not the URL is actually an external /
     * call, or an ID for an existing tab in the page.
     * @returns {boolean|$.Deferred} true if source call was successful, false for failure/ignore,
     * or a promise object that will fire callbacks in either "success" or "failure" scenarios.
     */
    callSource: function callSource(href, anchor, isURL) {
      var _this3 = this;

      if ((isURL === undefined || isURL === null || isURL === false) && !this.settings.source) {
        return false;
      }

      if (this.settings.lazyLoad !== true) {
        return false;
      }

      var sourceType = _typeof(this.settings.source);

      var response = function response(htmlContent) {
        if (htmlContent === undefined || htmlContent === null) {
          return;
        }

        htmlContent = xssUtils.sanitizeHTML(htmlContent); // Get a new random tab ID for this tab if one can't be derived from the URL string

        if (isURL) {
          var containerId = _this3.element[0].id || '';
          var id = utils.uniqueId(anchor, 'tab', containerId);
          href = "#".concat(id); // Replace the original URL on this anchor now that we've loaded content.

          anchor[0].setAttribute('href', href);
        }

        _this3.createTabPanel(href, htmlContent, true);

        _this3.activate(href);

        _this3.element.triggerHandler('complete'); // For Busy Indicator


        _this3.element.trigger('requestend', [href, htmlContent]);
      };

      this.container.triggerHandler('start'); // For Busy Indicator

      this.container.trigger('requeststart');

      function handleStringSource(url, options) {
        var opts = $.extend({
          dataType: 'html'
        }, options, {
          url: url
        });
        var request = $.ajax(opts);
        request.done(response);
        return request;
      }

      if (isURL) {
        return handleStringSource(href, this.ajaxOptions);
      } // return _true_ from this source function on if we're just loading straight content
      // return a promise if you'd like to setup async handling.


      if (sourceType === 'function') {
        return this.settings.source(response, href, this.settings.sourceArguments);
      }

      if (sourceType === 'string') {
        // Attempt to resolve source as a URL string.  Make an $.ajax() call with the URL
        var safeHref = href.replace(/#/g, '');
        var sourceURL = this.settings.source.toString();
        var hasHref = sourceURL.indexOf(safeHref) > -1;

        if (!hasHref) {
          var param = "tab=".concat(safeHref);
          var paramIndex = sourceURL.indexOf('?');
          var hashIndex = sourceURL.indexOf('#');
          var insertIndex = sourceURL.length;

          if (paramIndex < 0) {
            param = "?".concat(param);

            if (hashIndex > -1) {
              insertIndex = hashIndex + 1;
            }
          } else {
            param += '&';
            insertIndex = paramIndex + 1;
          }

          sourceURL = stringUtils.splice(sourceURL, insertIndex, 0, param);
        }

        return handleStringSource(sourceURL, this.ajaxOptions);
      }

      return false;
    },

    /**
     * @private
     */
    renderVisiblePanel: function renderVisiblePanel() {
      // Recalculate all components inside of the visible tab to adjust
      // widths/heights/display if necessary
      this.resizeNestedTabs(); // TJM: Prioritizing performance fix.
      // this.panels.filter(':visible').handleResize();
    },

    /**
     *
     * Update the hash in the link.
     * @private
     * @param  {HTMLElement} href The Dom Element.
     * @returns {void}
     */
    changeHash: function changeHash(href) {
      if (!this.settings.changeTabOnHashChange) {
        return;
      }

      if (!href) {
        href = '';
      }

      href.replace(/#/g, '');
      var cb = this.settings.hashChangeCallback;

      if (cb && typeof cb === 'function') {
        cb(href);
      } else {
        window.location.hash = href;
      }
      /**
       * @event hash-change
       * @memberof Tabs
       * @param {jQuery.Event} e the jQuery event object
       * @param {string} href the new hash fragment for the URL
       */


      this.element.triggerHandler('hash-change', [href]);
    },

    /**
     * Updates the aria-related markup on all tab elements
     * @private
     * @param {jQuery} a the 'selected' tab anchor
     */
    updateAria: function updateAria(a) {
      if (!a) {
        return;
      } // hide old tabs


      this.anchors.attr({
        'aria-selected': 'false',
        'aria-expanded': 'false',
        tabindex: '0'
      });
      this.moreButton.attr({
        tabindex: '0'
      }); // show current tab

      if (a.length && this.element.is(':not(.is-disabled)')) {
        a.parent().removeClass('is-selected');

        if (!this.isTabOverflowed(a.parent())) {
          a.attr({
            'aria-selected': 'true',
            'aria-expanded': 'true',
            tabindex: '0'
          }).parent().addClass('is-selected');
        } else {
          this.moreButton.attr({
            tabindex: '0'
          });
        }
      }
    },

    /**
     * Causes `handleResize()` to be fired on any Tab components that are nested inside of this tab component's panels.
     * @returns {void}
     */
    resizeNestedTabs: function resizeNestedTabs() {
      this.nestedTabControls.each(function (i, container) {
        var c = $(container);
        var api = c.data('tabs');

        if (api && api.handleResize && typeof api.handleResize === 'function') {
          api.handleResize(true);
        }
      });
    },

    /**
     * Adds a new tab into the list and properly binds all of its events
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {object} options incoming options for the new tab.
     * @param {string} [options.name] the text title of the new tab.
     * @param {Array} [options.attributes] additional attributes needed for the new tab.
     * @param {boolean} [options.doActivate=false] if true, causes the newly-added tab to become activated and focused.
     * @param {boolean} [options.isDismissible=false] if true, causes the tab to become dismissible (closable) with an "X" button.
     * @param {boolean} [options.isDropdown=false] if true, causes the tab to become a dropdown tab.
     * @param {string} [options.content] representing HTML markup that will be added inside of the new tab panel.
     * @param {number} [atIndex] if defined, inserts the tab at a particular number index in the tab list.  Defaults to the last tab in the list.
     * @returns {this} component instance
     */
    add: function add(tabId, options, atIndex) {
      if (!tabId) {
        return this;
      }

      if (!options) {
        options = {};
      }

      var startFromZero = this.tablist.find('li').not('.application-menu-trigger, .add-tab-button').length === 0; // Sanitize

      tabId = "".concat(tabId.replace(/#/g, ''));
      options.name = options.name ? options.name.toString() : '&nbsp;';
      options.isDismissible = options.isDismissible ? options.isDismissible === true : false;
      options.isDropdown = options.isDropdown ? options.isDropdown === true : false;

      function getObjectFromSelector(sourceString) {
        var contentType = _typeof(sourceString);

        var hasId;

        switch (contentType) {
          case 'string':
            hasId = sourceString.match(/^#/g); // Text Content or a Selector.

            if (hasId !== null) {
              var obj = $(sourceString);
              sourceString = obj.length ? obj : sourceString;
            } // do nothing if it's just a string of text.


            break;
        }

        return sourceString;
      }

      if (options.content) {
        options.content = getObjectFromSelector(options.content);
      }

      if (options.dropdown) {
        options.dropdown = getObjectFromSelector(options.dropdown);
      } // Build


      var tabHeaderMarkup = $('<li role="presentation" class="tab"></li>');
      var anchorMarkup = $("<a href=\"#".concat(tabId, "\" role=\"tab\" aria-expanded=\"false\" aria-selected=\"false\" tabindex=\"0\">").concat(xssUtils.escapeHTML(options.name), "</a>"));
      var tabContentMarkup = this.createTabPanel(tabId, options.content);
      var iconMarkup;
      tabHeaderMarkup.html(anchorMarkup);

      if (options.isDismissible) {
        iconMarkup = $.createIconElement({
          icon: 'close',
          classes: 'close icon'
        });
        utils.addAttributes(iconMarkup, this, options.attributes, 'close-btn');
        tabHeaderMarkup.addClass('dismissible');
        tabHeaderMarkup.append(iconMarkup);
      }

      if (this.settings.tabCounts) {
        anchorMarkup.prepend('<span class="count">0 </span>');
      }

      if (options.dropdown) ; // Add additional attributes, if applicable.
      // NOTE: Do not add IDs this way.


      var attrs = this.settings.attributes || [];

      if (Array.isArray(options.attributes)) {
        attrs = attrs.concat(options.attributes);
      }

      if (attrs.length) {
        utils.addAttributes(anchorMarkup, this, attrs, "".concat(tabId, "-a"));
        utils.addAttributes(tabContentMarkup, this, attrs, "".concat(tabId, "-panel"));
      }

      function insertIntoTabset(self, targetIndex) {
        var method;
        var tabs = self.tablist.children('li');
        var nonSpecialTabs = tabs.not('.application-menu-trigger, .add-tab-button');
        var finalIndex = tabs.length - 1;

        if (!tabs.length) {
          tabHeaderMarkup.appendTo(self.tablist);
          tabContentMarkup.appendTo(self.container);
          return;
        }

        var addTabButton = tabs.filter('.add-tab-button');
        var appMenuTrigger = tabs.filter('.application-menu-trigger'); // NOTE: Cannot simply do !targetIndex here because zero is a valid index

        if (targetIndex === undefined || targetIndex === null || isNaN(targetIndex)) {
          targetIndex = tabs.length;
        }

        function pastEndOfTabset(index) {
          return index > tabs.length - 1;
        }

        function atBeginningOfTabset(index) {
          return index <= 0;
        }

        if (tabs.length > nonSpecialTabs.length) {
          if (pastEndOfTabset(targetIndex) && addTabButton && addTabButton.length) {
            targetIndex -= 1;
          }

          if (atBeginningOfTabset(targetIndex) && appMenuTrigger && appMenuTrigger.length) {
            targetIndex += 1;
          }
        }

        var conditionInsertTabBefore = tabs.eq(targetIndex).length > 0;
        finalIndex = conditionInsertTabBefore ? targetIndex : finalIndex;
        method = 'insertAfter';

        if (conditionInsertTabBefore) {
          method = 'insertBefore';
        }

        tabHeaderMarkup[method](tabs.eq(finalIndex));
        tabContentMarkup.appendTo(self.container);
      }

      insertIntoTabset(this, atIndex); // Add each new part to their respective collections.

      this.panels = $(this.panels.add(tabContentMarkup));
      this.anchors = $(this.anchors.add(anchorMarkup)); // Link the two items via data()

      anchorMarkup.data('panel-link', tabContentMarkup);
      tabContentMarkup.data('tab-link', anchorMarkup); // TODO: When Dropdown Tabs can be added/removed, add that here
      // Make it possible for Module Tabs to display a tooltip containing their contents
      // if the contents are cut off by ellipsis.

      if (this.settings.moduleTabsTooltips || this.settings.multiTabsTooltips) {
        anchorMarkup.on('beforeshow.toolbar', function () {
          return anchorMarkup.data('cutoffTitle') === 'yes';
        }).tooltip({
          content: "".concat(anchorMarkup.text().trim())
        });
      } // Recalc tab width before detection of overflow


      if (this.isModuleTabs()) {
        this.adjustModuleTabs();
      } // Adjust tablist height


      this.setOverflow(); // If started from zero, position the focus state/bar and activate the tab

      if (startFromZero) {
        this.positionFocusState(anchorMarkup);
        this.focusBar(tabHeaderMarkup);

        if (!this.activate(anchorMarkup.attr('href'))) {
          return this;
        }

        anchorMarkup.focus();
      }

      if (options.doActivate) {
        this.activate(anchorMarkup.attr('href'));
      }

      return this;
    },

    /**
     * Removes a tab from the list and cleans up properly
     * NOTE: Does not take advantage of _activatePreviousTab()_ due to specific needs
     * of selecting certain Tabs/Anchors at certain times.
     * @param {string} tabId tab ID that corresponds to a `.tab-panel` element's ID attribute
     * @param {boolean} disableBeforeClose whether or not tab closing can become veteoed
     * @returns {boolean|this} component instance
     */
    remove: function remove(tabId, disableBeforeClose) {
      var self = this;
      var targetLi = this.doGetTab(null, tabId);

      if (!targetLi || !targetLi.length) {
        return false;
      }

      var targetAnchor = targetLi.children('a');
      var targetPanel = this.getPanel(tabId);
      var hasTargetPanel = targetPanel && targetPanel.length;
      var targetLiIndex = this.tablist.children('li').index(targetLi);
      var notATab = '.application-menu-trigger, .separator, .is-disabled';
      var prevLi = targetLi.prev();

      if (!disableBeforeClose) {
        var canClose = this.element.triggerHandler('beforeclose', [targetLi]);

        if (canClose === false) {
          return false;
        }
      }

      var wasSelected = false;

      if (targetLi.hasClass('is-selected')) {
        wasSelected = true;
      } else {
        prevLi = $(this.tablist.children('li').not(notATab).filter('.is-selected'));
      } // Remove these from the collections


      if (hasTargetPanel) {
        this.panels = $(this.panels.not(targetPanel));
      }

      this.anchors = $(this.anchors.not(targetAnchor)); // Destroy Anchor tooltips, if applicable

      if (this.settings.moduleTabsTooltips || this.settings.multiTabsTooltips) {
        targetAnchor.off('beforeshow.toolbar').data('tooltip').destroy();
      } // Close Dropdown Tabs in a clean fashion


      var popupAPI = targetLi.data('popupmenu');

      if (targetLi.hasClass('has-popupmenu')) {
        if (popupAPI) {
          popupAPI.menu.children('li').each(function () {
            self.remove($(this).children('a').attr('href'));
          });
          popupAPI.destroy();
        }
      } // If this tab is inside of a Dropdown Tab's menu, detect if it was the last one
      // remaining, and if so, close the entire Dropdown Tab.
      // The actual check on these elements needs to be done AFTER the targetLi is removed
      // from a Dropdown Tab, to accurately check the number of list items remaining.
      // See: _isLastDropdownTabItem()_


      var parentMenu = targetLi.closest('.dropdown-tab');
      var trigger = parentMenu.data('trigger'); // Kill associated events

      targetLi.find('.icon').off().removeData().remove();
      targetLi.off();
      targetAnchor.off(); // Remove Markup

      targetLi.removeData().remove();

      if (hasTargetPanel) {
        targetPanel.removeData().remove();
      }

      var menuItem = targetAnchor.data('moremenu-link');

      if (menuItem) {
        menuItem.parent().off().removeData().remove();
        targetAnchor.removeData();
      }

      function isLastDropdownTabItem(menu) {
        return menu.length && menu.children('li:not(.separator)').length === 0;
      }

      if (isLastDropdownTabItem(parentMenu)) {
        prevLi = this.getPreviousTab(trigger);
        setTimeout(function () {
          self.remove(trigger);
        }, 1);
      } // Close dropdown tab's menu


      if (trigger && trigger.length) {
        trigger.data('popupmenu').close();
      } // Recalc tab width before detection of overflow


      if (this.isModuleTabs()) {
        this.adjustModuleTabs();
      } // Adjust tablist height


      this.setOverflow();
      /**
       * Fires when a tab is removed from the tabset
       *
       * @event close
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} targetLi the tab list item being closed
       */

      this.element.trigger('close', [targetLi]); // If any tabs are left in the list, set the first available tab as the currently selected one.

      var count = targetLiIndex - 1;

      while (count > -1) {
        count = -1;

        if (prevLi.is(notATab)) {
          prevLi = this.tablist.children('li').not(notATab)[0];
          count -= 1;
        }
      } // If we find nothing, search for ANY available tab


      if (!prevLi || !prevLi.length) {
        prevLi = this.tablist.children('li').not(notATab).first();
      } // If there's really nothing, kick on out and defocus everything.


      if (!prevLi.length) {
        this.hideFocusState();
        this.defocusBar();
        this.element.trigger('afterclose', [targetLi]);
        return this;
      }

      var a = prevLi.children('a');
      var activateTargetA = a;
      this.positionFocusState(a);

      if (wasSelected) {
        if (prevLi.is('.has-popupmenu') && prevLi.data('popupmenu')) {
          activateTargetA = prevLi.data('popupmenu').menu.children().first().children('a');
        }

        if (!this.activate(activateTargetA.attr('href'))) {
          return this;
        }
      }

      this.focusBar(prevLi);
      a.focus();
      /**
       * Fires after a tab is completely removed from the tabset, and the close process has completed.
       *
       * @event afterclose
       * @memberof Tabs
       * @param {jQuery.Event} e event object
       * @param {jQuery} targetLi the tab list item being closed
       */

      this.element.trigger('afterclose', [targetLi]);
      return this;
    },

    /**
     * Adds a new tab into the list and properly binds all of its events
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {string} [content] representing HTML markup that will be added inside of the new tab panel.
     * @param {boolean} [doInsert=false] if true, actually appends the new content to the tab panel.
     * @returns {this} component instance
     */
    createTabPanel: function createTabPanel(tabId, content, doInsert) {
      tabId = tabId.replace(/#/g, ''); // If a jQuery-wrapped element is provided, actually append the element.
      // If content is text/string, simply inline it.

      var markup = $("<div id=\"".concat(xssUtils.stripTags(tabId), "\" class=\"tab-panel\" role=\"tabpanel\"></div>"));

      if (content instanceof $) {
        content = content[0];
      }

      DOM.html(markup[0], content || '', '*');

      if (doInsert === true) {
        this.container.append(markup);
      }

      this.panels = $(this.panels.add(markup));
      return markup;
    },

    /**
     * @param {jQuery} tab the tab to be checked for popupmenu items.
     * @returns {jQuery[]} a list of avaiable popupmenu items
     */
    checkPopupMenuItems: function checkPopupMenuItems(tab) {
      function getRemainingMenuItems(popupAPI) {
        if (!popupAPI || !popupAPI.menu) {
          return $();
        }

        var menu = popupAPI.menu;
        var items = menu.children('li');

        if (!items.length) {
          popupAPI.destroy();
          return $();
        }

        return items;
      }

      if (tab.is('.has-popupmenu')) {
        return getRemainingMenuItems(tab.data('popupmenu'));
      }

      var ddTab = tab.closest('.dropdown-tab');

      if (!ddTab.length) {
        return $();
      }

      return getRemainingMenuItems(ddTab.data('popupmenu'));
    },
    // @private
    getTab: function getTab(e, tabId) {
      var self = this;
      var tab = $();

      function getTabFromEvent(ev) {
        var t = $(ev.currentTarget);

        if (t.is('.tab')) {
          return t;
        }

        if (t.closest('.tab').length) {
          return t.closest('.tab').first();
        }

        return null;
      }

      function getTabFromId(id) {
        if (!id || id === '' || id === '#') {
          return null;
        }

        if (id.indexOf('#') === -1) {
          id = "#".concat(id);
        }

        var anchor = self.anchors.filter("[href=\"".concat(id, "\"]"));

        if (!anchor.length) {
          return null;
        }

        return anchor.parent();
      } // TabId can also be a jQuery object containing a tab.


      if (tabId instanceof $ && tabId.length > 0) {
        if (tabId.is('a')) {
          return tabId.parent();
        }

        return tabId;
      }

      if (e) {
        return getTabFromEvent(e);
      }

      if (tabId) {
        return getTabFromId(tabId);
      }

      return tab;
    },
    // @private
    doGetTab: function doGetTab(e, tabId) {
      if (!e && !tabId) {
        return $();
      }

      if (e && !(e instanceof $.Event) && typeof e !== 'string') {
        return $();
      }

      if (e) {
        if (typeof e !== 'string') {
          // jQuery Event
          return this.getTab(e);
        }

        return this.getTab(null, e); // String containing a selector
      } // Straight to the TabID


      return this.getTab(null, tabId);
    },

    /**
     * Hides a tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    hide: function hide(e, tabId) {
      var tab = this.doGetTab(e, tabId);
      this.activateAdjacentTab(e, tabId);
      tab.addClass('hidden');
      this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash);
      this.focusBar();
      this.positionFocusState();
      return this;
    },

    /**
     * Shows a tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    show: function show(e, tabId) {
      var tab = this.doGetTab(e, tabId);
      tab.removeClass('hidden');
      this.select($(this.element.find('li.tab.is-selected')[0]).find('a')[0].hash);
      this.focusBar();
      this.positionFocusState();
      return this;
    },

    /**
     * Disables an individual tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    disableTab: function disableTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);
      this.activateAdjacentTab(e, tabId);
      tab.addClass('is-disabled');
      this.focusBar();
      this.positionFocusState();
      return this;
    },

    /**
     * Enables an individual tab
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @returns {this} component instance
     */
    enableTab: function enableTab(e, tabId) {
      var tab = this.doGetTab(e, tabId);
      tab.removeClass('is-disabled');
      this.focusBar();
      this.positionFocusState();
      return this;
    },

    /**
     * Renames a tab and resets the focusable bar/animation.
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {string} name the new tab name
     * @returns {void}
     */
    rename: function rename(e, tabId, name) {
      // Backwards compatibility with 4.2.0
      if (e && typeof e === 'string') {
        name = tabId;
        tabId = e;
      }

      if (!name) {
        return;
      }

      var tab = this.doGetTab(e, tabId);
      var hasCounts = this.settings.tabCounts;
      var hasTooltip = this.settings.moduleTabsTooltips || this.settings.multiTabsTooltips;
      var anchor = tab.children('a');
      var count;

      if (hasCounts) {
        count = anchor.find('.count').clone();
      }

      anchor.text(name.toString());

      if (hasCounts) {
        anchor.prepend(count);
      }

      if (hasTooltip) {
        anchor.data('tooltip').setContent(name.trim());
      }

      var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;
      this.positionFocusState(doesTabExist);
      this.focusBar(doesTabExist);
    },

    /**
     * For tabs with counts, updates the count and resets the focusable bar/animation
     * @param {jQuery.Event} e the jQuery Event
     * @param {string} tabId a string representing the HTML `id` attribute of the new tab panel.
     * @param {number|string} count the new tab count
     * @returns {void}
     */
    updateCount: function updateCount(e, tabId, count) {
      // Backwards compatibility with 4.2.0
      if (e && typeof e === 'string') {
        count = tabId;
        tabId = e;
      }

      if (!this.settings.tabCounts || !count) {
        return;
      }

      var tab = this.doGetTab(e, tabId);
      tab.children('a').find('.count').text("".concat(count.toString(), " "));
      var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;
      this.positionFocusState(doesTabExist);
      this.focusBar(doesTabExist);
    },

    /**
     * returns the currently active tab
     * @returns {jQuery} the currently active tab anchor
     */
    getActiveTab: function getActiveTab() {
      var visible = this.panels.filter(':visible');
      return this.anchors.filter("[href=\"#".concat(visible.first().attr('id'), "\"]"));
    },

    /**
     * returns all visible tabs
     * @returns {jQuery[]} all visible tabs
     */
    getVisibleTabs: function getVisibleTabs() {
      var self = this;
      var tabHash = $();
      this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)').each(function tabOverflowIterator() {
        var tab = $(this);

        if (!self.isTabOverflowed(tab)) {
          tabHash = tabHash.add(tab);
        }
      });
      return tabHash;
    },

    /**
     * returns a list of all tabs that are currently in the "More..." overflow menu.
     * @returns {jQuery[]} all overflowed tabs
     */
    getOverflowTabs: function getOverflowTabs() {
      var self = this;
      var tabHash = $();
      this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)').each(function tabOverflowIterator() {
        var tab = $(this);

        if (self.isTabOverflowed(tab)) {
          tabHash = tabHash.add(tab);
        }
      });
      return tabHash;
    },

    /**
     * @private
     * @returns {void}
     */
    setOverflow: function setOverflow() {
      var self = this;
      var elem = this.element[0];
      var tablist = this.tablist[0];
      var HAS_MORE = 'has-more-button';
      var hasMoreIndex = this.hasMoreButton();
      var isScrollableTabs = this.isScrollableTabs();

      function checkModuleTabs() {
        if (self.isModuleTabs()) {
          self.adjustModuleTabs();
        }
      } // Recalc tab width before detection of overflow


      checkModuleTabs();
      var tablistStyle;
      var tablistHeight;
      var tablistContainerScrollWidth;
      var tablistContainerWidth;
      var overflowCondition;

      if (isScrollableTabs) {
        tablistContainerScrollWidth = this.tablistContainer[0].scrollWidth;
        tablistContainerWidth = this.tablistContainer[0].offsetWidth;
        overflowCondition = tablistContainerScrollWidth > tablistContainerWidth;
      } else {
        tablistStyle = window.getComputedStyle(tablist, null);
        tablistHeight = parseInt(tablistStyle.getPropertyValue('height'), 10) + 1; // +1 to fix an IE bug

        overflowCondition = tablist.scrollHeight > tablistHeight; // Normal tabs check the height
      } // Add "has-more-button" class if we need it, remove it if we don't
      // Always display the more button on Scrollable Tabs


      if (overflowCondition) {
        if (!hasMoreIndex) {
          elem.classList.add(HAS_MORE);
          checkModuleTabs();
        }
      } else if (hasMoreIndex) {
        elem.classList.remove(HAS_MORE);
        checkModuleTabs();
      }

      this.adjustSpilloverNumber();
    },

    /**
     * @private
     * @returns {void}
     */
    adjustModuleTabs: function adjustModuleTabs() {
      var self = this;
      var sizeableTabs = this.tablist.find('li:not(.separator):not(.application-menu-trigger):not(:hidden)');
      var appTrigger = this.tablist.find('.application-menu-trigger');
      var hasAppTrigger = appTrigger.length > 0;
      var tabContainerW = this.tablist.outerWidth();
      var defaultTabSize = 120;
      var visibleTabSize = 120;
      var appTriggerSize = hasAppTrigger ? appTrigger.outerWidth() : 0; // Remove overflowed tabs

      sizeableTabs.children('a').removeAttr('style');
      sizeableTabs.removeAttr('style').each(function () {
        var t = $(this);

        if (self.isTabOverflowed(t)) {
          sizeableTabs = sizeableTabs.not(t);
        }
      }); // Resize the more button to fit the entire space if no tabs can show
      // Math: +101 is the padding of the <ul class="tab-list"> element

      if (!sizeableTabs.length) {
        visibleTabSize = tabContainerW - appTriggerSize + 101;
        this.moreButton[0].style.width = "".concat(visibleTabSize, "px");
        return;
      }

      var anchorStyle = window.getComputedStyle(sizeableTabs.eq(0).children()[0]);
      var anchorPadding = parseInt(anchorStyle.paddingLeft, 10) + parseInt(anchorStyle.paddingRight, 10);

      if (this.moreButton[0].hasAttribute('style')) {
        this.moreButton[0].removeAttribute('style');
      } // Math explanation:
      // Width of tab container - possible applcation menu trigger
      // Divided by number of visible tabs
      // (doesn't include app menu trigger which shouldn't change size).
      // Minus one (for the left-side border of each tab)


      visibleTabSize = (tabContainerW - appTriggerSize) / sizeableTabs.length - 1;

      if (visibleTabSize < defaultTabSize) {
        visibleTabSize = defaultTabSize;
      }

      var a;
      var prevWidth;
      var cutoff = 'no';
      var isSideBySide = this.element.closest('.side-by-side').length === 1;

      for (var i = 0; i < sizeableTabs.length; i++) {
        a = sizeableTabs.eq(i).children('a');
        a[0].style.width = '';

        if (this.settings.moduleTabsTooltips === true || this.settings.multiTabsTooltips) {
          cutoff = 'no';
          prevWidth = parseInt(window.getComputedStyle(sizeableTabs[i]).width, 10);

          if (prevWidth > visibleTabSize - anchorPadding) {
            cutoff = 'yes';
          }

          a.data('cutoffTitle', cutoff);
        }

        var diff = 0;

        if (Environment.os.name === 'ios' && Environment.devicespecs.isMobile && isSideBySide) {
          diff = 25;
        }

        sizeableTabs[i].style.width = "".concat(visibleTabSize - diff, "px");
        a[0].style.width = "".concat(visibleTabSize - diff, "px");
      }

      this.adjustSpilloverNumber();
    },

    /**
     * @private
     * @returns {void}
     */
    adjustSpilloverNumber: function adjustSpilloverNumber() {
      var moreDiv = this.moreButton.find('.more-text');
      var tabs = this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)');
      var overflowedTabs = this.getOverflowTabs();

      if (tabs.length <= overflowedTabs.length) {
        moreDiv.text("".concat(Locale.translate('Tabs')));
      } else {
        moreDiv.text("".concat(Locale.translate('More')));
      }

      var countDiv = this.moreButton.find('.count');

      if (!countDiv.length) {
        countDiv = $('<span class="count"></span>');
        this.moreButton.children('span').first().prepend(countDiv);
      }

      countDiv.text("".concat(overflowedTabs.length, " "));
    },

    /**
     * Selects a Tab
     * @param {string} href a string representing the HTML `id` attribute of the new tab panel.
     * @param {boolean} noFocus true to prevent focus.
     * @returns {void}
     */
    select: function select(href, noFocus) {
      var modHref = href.replace(/#/g, '');
      var anchor = this.getAnchor(modHref);
      this.positionFocusState(undefined, false);
      this.focusBar(anchor.parent());

      if (!this.activate(anchor.attr('href'))) {
        return;
      }

      this.changeHash(modHref);

      if (!noFocus) {
        anchor.focus();
      }
    },

    /**
     * Builds tab popupmenu
     * @param {string} startingHref a string representing the HTML `href` attribute of the popupmenu item to be selected.
     * @returns {void}
     */
    buildPopupMenu: function buildPopupMenu(startingHref) {
      var self = this;

      if (self.popupmenu) {
        self.popupmenu.destroy();
        $('#tab-container-popupmenu').off('focus.popupmenu').removeData().remove();
        $(document).off('keydown.popupmenu');
      } // Build the new markup for the popupmenu if it doesn't exist.
      // Reset it if it does exist.


      var menuHtml = $('#tab-container-popupmenu');
      var shouldBeSelectable = '';

      if (this.isScrollableTabs()) {
        shouldBeSelectable = ' is-selectable';
      }

      if (menuHtml.length === 0) {
        menuHtml = $("<ul id=\"tab-container-popupmenu\" class=\"tab-list-spillover".concat(shouldBeSelectable, "\">")).appendTo('body');
      } else {
        menuHtml.html('');
      } // Build menu options from overflowed tabs


      var tabs = self.tablist.children('li');
      var isRTL = Locale.isRTL();

      function buildMenuItem(item) {
        var $item = $(item);
        var $itemA = $item.children('a');

        if ($item.is(':hidden')) {
          return;
        }

        if (!self.isScrollableTabs() && !self.isTabOverflowed($item)) {
          return;
        }

        if ($item.is('.separator')) {
          $item.clone().appendTo(menuHtml);
          return;
        }

        var popupLi = $item.clone();
        var popupA = popupLi.children('a');
        popupLi[0].classList.remove('tab');

        if (popupLi[0].classList.contains('is-selected')) {
          popupLi[0].classList.remove('is-selected');

          if (self.isScrollableTabs()) {
            popupLi[0].classList.add('is-checked');
          }
        }

        popupLi[0].removeAttribute('style');
        popupLi.children('.icon').off().appendTo(popupA);
        popupLi.appendTo(menuHtml); // Link tab to its corresponding "More Tabs" menu option

        $item.data('moremenu-link', popupA);
        popupA.find('.icon-more').removeData().remove(); // Link "More Tabs" menu option to its corresponding Tab.
        // Remove onclick methods from the popup <li> because they are called
        // on the "select" event in context of the original button

        popupA.data('original-tab', $itemA);
        popupA.onclick = undefined;

        if (!$item.is('.has-popupmenu')) {
          return;
        } // If this is a Dropdown Tab, clone its menu and add it to the "More Tabs" menu
        // As a submenu of the "popupLi".


        var submenu = $("#".concat(item.getAttribute('aria-controls')));
        var clone = submenu.clone();
        var cloneLis = clone.children('li');
        clone[0].classList.remove('has-popupmenu');
        cloneLis.each(function (i) {
          var li = $(this);
          var a = li.children('a');
          var originalLi = submenu.children('li').eq(i);
          var originalA = originalLi.children('a');
          a.data('original-tab', originalA);
          originalA.data('moremenu-link', a);
        });
        clone.insertAfter(popupA);
      } // Build spillover menu options


      for (var i = 0; i < tabs.length; i++) {
        buildMenuItem(tabs[i]);
      }

      self.tablist.children('li:not(.separator)').removeClass('is-focused');
      var xOffset = 1;

      if (!this.isScrollableTabs()) {
        xOffset = 3;
      }

      var attributes = self.settings.attributes; // Invoke the popup menu on the button.

      self.moreButton.popupmenu({
        autoFocus: false,
        attachToBody: true,
        menu: 'tab-container-popupmenu',
        trigger: 'immediate',
        offset: {
          x: xOffset
        },
        attributes: attributes
      });
      self.moreButton.addClass('popup-is-open');
      self.popupmenu = self.moreButton.data('popupmenu');
      self.positionFocusState(self.moreButton);

      function closeMenu() {
        $(this).off('close.tabs selected.tabs');
        self.moreButton.removeClass('popup-is-open');
        self.positionFocusState(undefined);
        self.focusBar();
      }

      function selectMenuOption(e, anchor) {
        var href = anchor.attr('href');
        var id = href.substr(1, href.length);
        var tab = self.doGetTab(id) || $();
        var a = tab ? tab.children('a') : $();
        var originalTab = anchor.data('original-tab').parent();

        if (originalTab.is('.add-tab-button')) {
          a = self.handleAddButton();
          originalTab = a.parent();
          href = a.attr('href');
          self.element.trigger('tab-added', [a]);
        }

        self.activate(href); // Fire an onclick event associated with the original tab from the spillover menu

        if (tab.length && a.length && typeof a[0].onclick === 'function') {
          a[0].onclick.apply(a[0]);
        } // Focus the More Button
        // NOTE: If we switch the focusing-operations back to how they used to be
        // (blue bar moving around with the focus state)
        // remove the line below.


        self.moreButton.focus();
        self.scrollTabList(tab);
      }

      self.moreButton.on('close.tabs', closeMenu).on('selected.tabs', selectMenuOption);
      var menu = self.popupmenu.menu;

      function handleDestroy() {
        menu.off();
        self.hideFocusState();
        $('#tab-container-popupmenu').removeData().remove();
      }

      function handleDismissibleIconClick(e) {
        var icon = $(this);
        var li = icon.closest('li');

        if (!li.is('.dismissible') || !icon.is('.close')) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (li.is('.dismissible') && li.is('.has-popupmenu') && li.is('.submenu')) {
          var listMenu = li.find('.wrapper').children().children();
          var hrefs = [];
          $.each(listMenu, function (i, item) {
            hrefs.push(item.children[0].href);
          });
          self.closeDismissibleTabs(hrefs);
        } else {
          self.closeDismissibleTab(li.children('a').attr('href'));
        }

        self.popupmenu.close();
      }

      menu.on('destroy.popupmenu', handleDestroy).on('touchend.popupmenu touchcancel.popupmenu', '.icon', handleDismissibleIconClick).on('click.popupmenu', '.icon', handleDismissibleIconClick); // If the optional startingIndex is provided, focus the popupmenu on the matching item.
      // Otherwise, focus the first item in the list.

      if (startingHref) {
        self.popupmenu.highlight(menu.find("a[href=\"".concat(startingHref, "\"]")));
      } else if (self.tablist.children('.is-selected').length > 0) {
        self.popupmenu.highlight(menu.find("a[href=\"".concat(self.tablist.children('.is-selected').children('a').attr('href'), "\"]")));
      } else {
        self.popupmenu.highlight(menu.find('li:first-child > a'));
      } // Overrides a similar method in the popupmenu code that controls escaping of
      // this menu when pressing certain keys.  We override this here so that the
      // controls act in a manner as if all tabs are still visible (for accessiblity
      // reasons), meaning you can use left and right to navigate the popup menu options
      // as if they were tabs.


      $(document).bindFirst('keydown.popupmenu', function (e) {
        var key = e.which;
        var currentMenuItem = $(e.target);

        function isFocusedElement() {
          return this === document.activeElement;
        }

        function prevMenuItem() {
          // If the first item in the popup menu is already focused, close the menu and focus
          // on the last visible item in the tabs list.
          var first = menu.find('li:first-child > a');

          if (first.filter(isFocusedElement).length > 0) {
            e.preventDefault();
            $(document).off(e);
            self.popupmenu.close();
            self.findLastVisibleTab();
          }
        }

        function nextMenuItem() {
          // If the last item in the popup menu is already focused, close the menu and focus
          // on the first visible item in the tabs list.
          var last = menu.find('li:last-child > a');

          if (last.filter(isFocusedElement).length > 0 && last.parent().is(':not(.submenu)')) {
            e.preventDefault();
            $(document).off(e);
            self.popupmenu.close();

            if (self.settings.addTabButton) {
              self.addTabButton.focus();
              return;
            }

            if (self.hasMoreActions()) {
              self.moreActionsBtn.focus();
              return;
            }

            self.focusFirstVisibleTab();
          }
        } // Alt+Del or Alt+Backspace closes a dropdown tab item


        function closeDropdownMenuItem() {
          if (!e.altKey || !currentMenuItem.parent().is('.dismissible')) {
            return;
          } // self.popupmenu.close();


          self.closeDismissibleTab(currentMenuItem.attr('href'));
        }

        var pseudoKeycode;

        switch (key) {
          case 8:
          case 46:
            closeDropdownMenuItem();
            break;

          case 37:
            // left
            pseudoKeycode = isRTL ? 40 : 38;

            if (currentMenuItem.is('a')) {
              if (currentMenuItem.parent().is(':not(:first-child)')) {
                e.preventDefault(); // Prevent popupmenu from closing on left key
              }

              $(document).trigger({
                type: 'keydown.popupmenu',
                which: pseudoKeycode
              });
            }

            break;

          case 38:
            // up
            prevMenuItem();
            break;

          case 39:
            // right
            pseudoKeycode = isRTL ? 38 : 40;

            if (currentMenuItem.is('a') && !currentMenuItem.parent('.submenu').length) {
              $(document).trigger({
                type: 'keydown.popupmenu',
                which: pseudoKeycode
              });
            }

            break;

          case 40:
            // down
            nextMenuItem();
            break;
        }
      });
    },

    /**
     * Used for checking if a particular tab (in the form of a jquery-wrapped list item)
     * is spilled into the overflow area of the tablist container <UL>.
     * @param {jQuery} li tab list item
     * @returns {boolean} whether or not the tab is overflowed.
     */
    isTabOverflowed: function isTabOverflowed(li) {
      if (this.isVerticalTabs() || this.isScrollableTabs()) {
        return false;
      }

      if (this.tablist.scrollTop() > 0) {
        this.tablist.scrollTop(0);
      }

      var liTop = Math.round(li[0].getBoundingClientRect().top);
      var tablistTop = Math.round(this.tablist[0].getBoundingClientRect().top + 1); // +1 to compensate for top border on Module Tabs

      if (this.isModuleTabs()) {
        tablistTop += 1;
      }

      return liTop > tablistTop;
    },

    /**
     * @returns {jQuery} representing the last visible tab.
     */
    findLastVisibleTab: function findLastVisibleTab() {
      var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
      var targetFocus = tabs.first(); // if Scrollable Tabs, simply get the last tab and focus.

      if (this.isScrollableTabs()) {
        return tabs.last().find('a').focus();
      }

      while (!this.isTabOverflowed(targetFocus)) {
        targetFocus = tabs.eq(tabs.index(targetFocus) + 1);
      }

      return tabs.eq(tabs.index(targetFocus) - 1).find('a').focus();
    },

    /**
     * @returns {void}
     */
    focusFirstVisibleTab: function focusFirstVisibleTab() {
      var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
      tabs.eq(0).find('a').focus();
    },

    /**
     * Moves the animated "selected" state bar to a new tab
     * @param {jQuery} li the new tab list item
     * @param {function} callback fires after the animation is completed.
     * @returns {void}
     */
    focusBar: function focusBar(li, callback) {
      if (!this.hasAnimatedBar()) {
        return;
      }

      if (!(li instanceof $) || !li.length) {
        return;
      }

      var self = this;
      var target = li;
      this.animatedBar.removeClass('no-transition');

      if (!target || target === undefined || !target.length || !self.anchors.length) {
        this.animatedBar.removeClass('visible');
        return;
      }

      clearTimeout(self.animationTimeout);
      this.animatedBar.addClass('visible');

      function animationTimeout(cb) {
        self.sizeBar(target);

        if (cb && typeof cb === 'function') {
          cb();
        }
      }

      animationTimeout(callback);
    },

    /**
     * Recalculate the sizes on the animated bar
     * @param {jQuery} target The target tab element
     * @private
     * @returns {void}
     */
    sizeBar: function sizeBar(target) {
      if (!this.animatedBar || this.animatedBar && !this.animatedBar[0]) {
        return;
      }

      target = target || this.element.find('.tab.is-selected');
      var style = this.animatedBar[0].style;
      var scrollingTablist = this.tablistContainer;
      var tablistScrollLeft = scrollingTablist[0].scrollLeft;
      var tablistScrollWidth = scrollingTablist[0].scrollWidth;
      var tabListDifferWidth = tablistScrollWidth - this.tablistContainer[0].offsetWidth;
      var targetStyle = window.getComputedStyle(target[0], null);
      var paddingRight = parseInt(targetStyle.getPropertyValue('padding-right'), 10) || 0;
      var width = parseInt(targetStyle.getPropertyValue('width'), 10) || 0;

      if (target.is('.tab')) {
        var anchorStyle = window.getComputedStyle(target.children('a')[0]);
        paddingRight += parseInt(anchorStyle.getPropertyValue('padding-right'), 10) || 0;
      }

      var left = Locale.isRTL() ? paddingRight + target.position().left + target.outerWidth(true) : target.position().left;

      if (Locale.isRTL()) {
        style.right = "".concat(tablistScrollWidth + paddingRight - (left + tablistScrollLeft) - tabListDifferWidth, "px");
      } else {
        style.left = "".concat(left + tablistScrollLeft, "px");
      }

      style.width = "".concat(width, "px");
      this.focusState[0].style.width = "".concat(width, "px");
    },

    /**
     * Clears the animated "selected" state bar away.
     * @returns {void}
     */
    defocusBar: function defocusBar() {
      if (!this.hasAnimatedBar()) {
        return;
      }

      var self = this;
      var left = Locale.isRTL() ? 0 : self.animatedBar.position().left + self.animatedBar.outerWidth() / 2;
      clearTimeout(self.animationTimeout);
      this.animatedBar[0].style.left = "".concat(left, "px");
      this.animatedBar[0].style.width = 0;
      this.animationTimeout = setTimeout(function () {
        if (self.animatedBar && self.animatedBar.length) {
          self.animatedBar.removeClass('visible').removeAttr('style');
        }
      }, 350);
    },

    /**
     * Wrapper for the Soho behavior _smoothScrollTo()_ that will determine scroll distance.
     * @param {jQuery[]} target - the target <li> or <a> tag
     * @param {number} duration - the time it will take to scroll
     * @returns {undefined}
     */
    scrollTabList: function scrollTabList(target) {
      if (!this.tablistContainer || !target || !(target instanceof $) || !target.length) {
        return;
      }

      var tabCoords = DOM.getDimensions(target[0]);
      var tabContainerDims = DOM.getDimensions(this.tablistContainer[0]);
      var d;
      var FADED_AREA = 40; // the faded edges on the sides of the tabset

      var adjustedLeft = tabCoords.left;
      var adjustedRight = tabCoords.right;

      if (adjustedLeft < tabContainerDims.left + FADED_AREA) {
        d = Math.round(Math.abs(tabContainerDims.left - adjustedLeft)) * -1 - FADED_AREA;
      }

      if (adjustedRight > tabContainerDims.right - FADED_AREA) {
        d = Math.round(Math.abs(adjustedRight - tabContainerDims.right)) + FADED_AREA;
      }

      if (d === 0) {
        d = undefined;
      } // Scroll the tablist container


      this.tablistContainer.smoothScroll(d, 250);
    },

    /**
     * Hides the focus state, if it's visible.
     * @returns {void}
     */
    hideFocusState: function hideFocusState() {
      this.focusState.removeClass('is-visible');
    },

    /**
     * Updates the position of the focus state, to the tab/button that currently has focus.
     * @param {jQuery[]|HTMLElement} target the element that will receive the focus state
     * @param {boolean} [unhide] if true, unhides the focus state if it's previously been hidden.
     * @returns {void}
     */
    positionFocusState: function positionFocusState(target, unhide) {
      var self = this; // TODO: Recheck this and improve

      if (target !== undefined) {
        target = $(target);
      } else if (self.moreButton.hasClass('is-selected')) {
        target = self.moreButton;
      } else if (self.tablist.children('.is-selected').length > 0) {
        target = self.tablist.children('.is-selected').children('a');
      }
      /*
      NOTE: this used to replace the code directly above
      target = target !== undefined ? $(target) :
        self.moreButton.hasClass('is-selected') ? self.moreButton :
        self.tablist.children('.is-selected').length > 0 ?
        self.tablist.children('.is-selected').children('a') : undefined;
      */


      if (!target || target === undefined || !target.length || target.is(this.moreButton) && this.isScrollableTabs()) {
        this.focusState.removeClass('is-visible');
        return;
      } // Use the parent <li> for anchors to get their dimensions.


      if (target.is('a')) {
        target = target.parent();
      } // Move the focus state from inside the tab list container, if applicable.
      // Put it back into the tab list container, if not.


      if (target.is('.add-tab-button, .tab-more')) {
        if (!this.focusState.parent().is(this.element)) {
          this.focusState.prependTo(this.element);
        }
      } else if (!this.focusState.parent().is(this.tablistContainer)) {
        this.focusState.prependTo(this.tablistContainer);
      }

      var focusStateElem = this.focusState[0];
      var targetPos = DOM.getDimensions(target[0]);
      var targetClassList = target[0].classList;
      var isNotHeaderTabs = !this.isHeaderTabs() || this.isHeaderTabs() && this.element[0].classList.contains('alternate');
      var isVerticalTabs = this.isVerticalTabs();
      var isRTL = Locale.isRTL();
      var tabMoreWidth = !isVerticalTabs ? this.moreButton.outerWidth(true) : 0;
      var parentContainer = this.element;
      var scrollingTablist = this.tablistContainer;
      var accountForPadding = scrollingTablist && this.focusState.parent().is(scrollingTablist);

      function adjustForParentContainer(targetRectObj, parentElement, tablistContainer) {
        var parentRect = parentElement[0].getBoundingClientRect();
        var parentPadding;
        var tablistScrollWidth;
        var tablistScrollLeft; // Adjust from the top

        targetRectObj.top -= parentRect.top;

        if (isVerticalTabs) {
          targetRectObj.top += parentElement[0].scrollTop;
        }

        if (isRTL) {
          targetRectObj.right = parentRect.right - targetRectObj.right;
        } else {
          targetRectObj.left -= parentRect.left;
        } // If inside a scrollable tablist, account for the scroll position


        if (tablistContainer) {
          tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
          tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;

          if (isRTL && !isVerticalTabs) {
            // TODO: Improve this calculation because there's something off
            var tmpLeft = targetRectObj.left;

            if (isNotHeaderTabs) {
              tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
              tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;
            } else {
              targetRectObj.left = tablistScrollWidth - (targetRectObj.right + tablistScrollLeft + tabMoreWidth + 32);
              targetRectObj.right = tablistScrollWidth - (tmpLeft + tablistScrollLeft + tabMoreWidth + 32);
            }
          } else {
            targetRectObj.left += tablistScrollLeft;
            targetRectObj.right += tablistScrollLeft;
          }

          if (accountForPadding) {
            parentPadding = parseInt(window.getComputedStyle(parentElement[0])["padding".concat(isRTL ? 'Right' : 'Left')], 10);
            targetRectObj.left += isRTL ? parentPadding : parentPadding * -1;
            targetRectObj.right += isRTL ? parentPadding : parentPadding * -1;
          }
        } // Alternate Header Tabs have 1px removed from bottom to prevent overlap
        // onto the bottom border


        if (isNotHeaderTabs && !isVerticalTabs) {
          targetRectObj.height -= 1;
        }

        return targetRectObj;
      } // Adjust the values one more time if we have tabs contained inside of a
      // page-container, or some other scrollable container.


      targetPos = adjustForParentContainer(targetPos, parentContainer, scrollingTablist); // build CSS string containing each prop and set it:

      var targetPosString = '';
      Object.keys(targetPos).forEach(function (key) {
        if (targetPosString.length) {
          targetPosString += ' ';
        }

        targetPosString += "".concat(key, ": ").concat(targetPos[key], "px;");
      });
      focusStateElem.style.cssText = targetPosString;
      var selected = targetClassList.contains('is-selected') ? 'add' : 'remove';
      focusStateElem.classList[selected]('is-selected');
      var doHide = unhide === true ? 'add' : 'remove';
      focusStateElem.classList[doHide]('is-visible');
    },

    /**
     * Causes the entire tabset to reset with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      return this.teardown().init();
    },

    /**
     * Disables all non-active tabs in the list
     * @returns {void}
     */
    disableOtherTabs: function disableOtherTabs() {
      return this.disable(true);
    },

    /**
     * Disables the entire Tab Component
     * @param {boolean} isPartial whether or not this disable call is a partial
     *  disabling of the tabset
     * @returns {void}
     */
    disable: function disable(isPartial) {
      if (!isPartial) {
        this.element.prop('disabled', true).addClass('is-disabled');
      }

      if (!this.disabledElems) {
        this.disabledElems = [];
      }

      var self = this;
      var tabs = this.tablist.children('li:not(.separator)');

      if (isPartial) {
        tabs = tabs.filter(':not(.application-menu-trigger)');
      }

      tabs.each(function () {
        var li = $(this);
        var a = li.children('a');

        if (isPartial && self.isActive(a.attr('href'))) {
          return;
        }

        if (li.is('.is-disabled') || a.prop('disabled') === true) {
          self.disabledElems.push({
            elem: li,
            originalTabindex: li.attr('tabindex'),
            originalDisabled: a.prop('disabled')
          });
        }

        li.addClass('is-disabled');
        a.prop('disabled', true);

        if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
          return;
        }

        var panel = $(a.attr('href'));
        panel.addClass('is-disabled');
        panel.find('*').each(function () {
          var t = $(this); // These are shadow inputs.  They are already handled by virtue of running
          // .disable() on the original select tag.

          if (t.is('input.dropdown, input.multiselect')) {
            return;
          }

          if (t.attr('tabindex') === '-1' || t.attr('disabled')) {
            self.disabledElems.push({
              elem: t,
              originalTabindex: t.attr('tabindex'),
              originalDisabled: t.prop('disabled')
            });
          }

          t.disable();
        });
      });
      this.moreButton.addClass('is-disabled');

      if (this.isModuleTabs() && !isPartial) {
        this.element.children('.toolbar').disable();
      }

      this.updateAria($());
    },

    /**
     * Enables the entire Tabs component
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false).removeClass('is-disabled');
      var self = this;
      var tabs = this.tablist.children('li:not(.separator)');
      tabs.each(function () {
        var li = $(this);
        var a = li.children('a');
        li.removeClass('is-disabled');
        a.prop('disabled', false);

        if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
          return;
        }

        var panel = $(a.attr('href'));
        panel.removeClass('is-disabled');
        panel.find('*').each(function () {
          var t = $(this);

          if (t.enable && typeof t.enable === 'function') {
            t.enable();
          }
        });
        $.each(self.disabledElems, function (i, obj) {
          var attrTarget = obj.elem.is('.tab') ? obj.elem.children('a') : obj.elem;

          if (obj.elem.disable && typeof obj.elem.disable === 'function') {
            obj.elem.disable();
          }

          if (obj.elem.is('li')) {
            obj.elem.addClass('is-disabled');
            return;
          } // These are shadow inputs.  They are already handled by virtue of
          // running .disable() on the original select tag.


          if (obj.elem.is('input.dropdown, input.multiselect')) {
            return;
          }

          obj.elem.attr('tabindex', obj.originalTabindex);
          attrTarget.prop('disabled', obj.originalDisabled);
        });
      });
      this.moreButton.removeClass('is-disabled');

      if (this.isModuleTabs()) {
        this.element.children('.toolbar').enable();
      }

      this.disabledElems = [];
      this.updateAria(this.tablist.find('.is-selected > a'));
    },

    /**
     * Pass-through for the `remove()` method, which gets used for removing a dismissible tab.
     * @param {string} tabId the ID of the target tab panel
     * @returns {this} component instance
     */
    closeDismissibleTab: function closeDismissibleTab(tabId) {
      return this.remove(tabId);
    },

    /**
     * Remove top level dismissible tab with dropdown
     * @param {array} tabUrlArray the Array of urls from the target popupmenu
     */
    closeDismissibleTabs: function closeDismissibleTabs(tabUrlArray) {
      var _this4 = this;

      tabUrlArray.forEach(function (tabUrl) {
        var tabId = tabUrl.match(/#.*/);
        return _this4.remove(tabId[0]);
      });
    },

    /**
     * Tears down this instance of the tabs component by removing events,
     * other components, and extraneous markup.
     * @returns {this} component instance
     */
    teardown: function teardown() {
      this.panels.removeAttr('style');
      this.tablist.off().removeAttr('role').removeAttr('aria-multiselectable');
      var tabs = this.tablist.children('li');
      tabs.off().removeAttr('role').removeClass('is-selected');
      var dds = tabs.filter('.has-popupmenu');
      dds.each(function () {
        var popup = $(this).data('popupmenu');

        if (popup) {
          popup.menu.children('li:not(.separator)').each(function () {
            var li = $(this);
            var a = li.children('a');
            var panel = a.data('panel-link');
            $.removeData(a[0], 'panel-link');

            if (panel && panel.length) {
              $.removeData(panel[0], 'tab-link');
            }
          });
          popup.destroy();
        }
      });
      this.panels.off();
      this.anchors.off().removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected').removeAttr('tabindex');

      if (this.ro) {
        this.ro.disconnect();
        delete this.ro;
      }

      if (this.settings.moduleTabsTooltips || this.settings.multiTabsTooltips) {
        this.anchors.each(function () {
          var api = $(this).data('tooltip');

          if (api && typeof api.destroy === 'function') {
            api.destroy();
          }
        });
      }

      this.element.off('focusout.tabs updated.tabs activated.tabs');
      $('body').off("resize.tabs".concat(this.tabsIndex));
      this.tabsIndex = undefined;

      if (this.moreButton.data('popupmenu')) {
        var popup = this.moreButton.data('popupmenu');
        popup.menu.find('li:not(.separator)').each(function () {
          var li = $(this);
          var a = li.children('a');

          if (a.data('original-tab')) {
            $.removeData(a[0], 'original-tab');
          }
        });
        popup.destroy();
      }

      this.removeHelperMarkupEvents();

      if (this.tablistContainer) {
        this.tablistContainer.off('mousewheel.tabs');
      }

      this.focusState.removeData().remove();
      this.focusState = undefined;

      if (this.hasAnimatedBar()) {
        this.animatedBar.removeData().remove();
        this.animatedBar = undefined;
      }

      $('.tab-panel input').off('error.tabs valid.tabs');

      if (this.addTabButton) {
        this.addTabButton.remove();
        this.addTabButton = undefined;
      }

      this.element.find('.close.icon').remove();
      return this;
    },

    /**
     * Destroys this component instance, removing its attachment from its parent element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$17);
    }
  };

  /**
   * jQuery component wrapper for Tabs Component
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.tabs = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$17);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$17, new Tabs(this, settings));
      }
    });
  }; // Deprecated the old Vertical Tabs code in favor of using the Tabs class.


  $.fn.verticaltabs = $.fn.tabs;

  $.fn.tag = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$t);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$t, new Tag(this, settings));
      }
    });
  };

  $.fn.taglist = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$u);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$u, new TagList(this, settings));
      }
    });
  };

  var COMPONENT_NAME$18 = 'textarea'; // Component Options

  var TEXTAREA_DEFAULTS = {
    autoGrow: false,
    autoGrowMaxHeight: null,
    characterCounter: true,
    maxLength: null,
    printable: true,
    charRemainingText: null,
    charMaxText: null,
    attributes: null
  };
  /**
  * The Textarea Component wraps a standard HTML Textarea element and provides additional features.
  * @class Textarea
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {boolean} [settings.autoGrow = false] Will automatically expand the textarea to fit the contents when typing.
  * @param {number} [settings.autoGrowMaxHeight = null] The Max Height of the textarea when autoGrow is enabled.
  * @param {boolean} [settings.characterCounter = true] Displays a counter that counts down from the maximum.
  * @param {boolean} [settings.maxLength = number] Maximum characters allowed in textarea.
  * length allowed.
  * @param {boolean} [settings.printable = true] Determines whether or not the text area can be displayed on a
  * printed page.
  * @param {null|String} [settings.charRemainingText = 'Characters Left']  Text that will be used in place of the "remaining"
  * text defaulting to a localized 'Characters Left'.
  * @param {null|String} [settings.charMaxText = 'Character count maximum of']  Text that will be used in place of the "Max" text.
  * Defaults to a localized Version of 'Character count maximum of'.
  * @param {string} [settings.attributes = null] Add extra attributes like id's to the element. e.g. `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function Textarea(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TEXTAREA_DEFAULTS);
    this.element = $(element);
    this.init();
  }

  Textarea.prototype = {
    /**
     * @private
     */
    init: function init() {
      // Add "is-disabled" class to greyed-out the field
      if (this.element.is(':disabled')) {
        this.element.closest('.field').addClass('is-disabled');
      }

      this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
      this.isSafari = navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1 && navigator.userAgent.indexOf('Android') === -1;
      this.element.addClass(this.element.is('.textarea-xs') ? 'input-xs' : //eslint-disable-line
      this.element.is('.textarea-sm') ? 'input-sm' : //eslint-disable-line
      this.element.is('.textarea-lg') ? 'input-lg' : ''); //eslint-disable-line

      if (this.settings.characterCounter && this.getMaxLength()) {
        this.counter = $('<span class="textarea-wordcount">Chars Left..</span>').insertAfter(this.element);
      }

      if (this.settings.printable) {
        this.printarea = $('<span class="textarea-print"></span>').insertBefore(this.element);
      }

      if (this.element.hasClass('autogrow')) {
        this.settings.autoGrow = true;
      }

      this.setupAutoGrow();
      this.handleEvents();
      this.updateCounter();
    },

    /**
     * Determines if the text is selected.
     * @private
     * @param  {object}  input The input dom element (jQuery)
     * @returns {boolean} True if the text is selected in the input.
     */
    isSelected: function isSelected(input) {
      if (typeof input.selectionStart === 'number') {
        return input.selectionStart === 0 && input.selectionEnd === input.value.length;
      }

      if (typeof document.selection !== 'undefined') {
        return document.selection.createRange().text === input.value;
      }

      return false;
    },

    /**
     * Checks a keycode value and determines if it belongs to a printable character.
     * @private
     * @param {number} keycode - a number representing an ASCII keycode value
     * @param {boolean} shiftKey - a boolean set to true if shift key is being pressed
     * @returns {boolean} Returns true if the key is a printable one.
     */
    isPrintable: function isPrintable(keycode, shiftKey) {
      // (keycode > 47 && keycode < 58) || // number keys
      // (keycode > 64 && keycode < 91) || // letter keys
      // (keycode > 95 && keycode < 112) || // numpad keys
      // (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
      // (keycode > 218 && keycode < 223); // [\]' (in order)
      var valid = false;

      if (shiftKey) {
        valid = keycode > 64 && keycode < 91 || // letter keys
        keycode >= 33 && keycode <= 38 || keycode >= 40 && keycode <= 43 || keycode === 126 || keycode === 58 || keycode === 60 || keycode >= 123 && keycode <= 125 || keycode === 94 || keycode === 95 || keycode >= 62 && keycode <= 64;
      } else {
        valid = keycode === 13 || // enter key
        keycode >= 48 && keycode <= 57 || // number keys
        keycode >= 97 && keycode <= 122 || // letter keys
        keycode === 59 || keycode === 61 || keycode >= 44 && keycode <= 47 || keycode === 96 || // ;=,-./` (in order)
        keycode >= 91 && keycode <= 93 || keycode === 39; // [\]' (in order)
      }

      return valid;
    },

    /**
    * Setup the auto grow functionality.
    * @private
    */
    setupAutoGrow: function setupAutoGrow() {
      if (this.settings.autoGrow && this.element.length) {
        var elem = this.element[0];

        if (this.settings.autoGrowMaxHeight) {
          elem.style.maxHeight = "".concat(this.settings.autoGrowMaxHeight, "px");
        }

        elem.style.overflow = 'hidden';
        this.autoGrow();
      }
    },

    /**
    * Activate the auto grow functionality from a change.
    * @private
    */
    autoGrow: function autoGrow() {
      if (!this.settings.autoGrow) {
        return;
      }

      var elem = this.element[0];
      var oldHeight = elem.offSetHeight;
      var maxHeight = this.settings.autoGrowMaxHeight || 0;
      var newHeight = elem.scrollHeight;

      if (maxHeight > 0 && maxHeight < newHeight) {
        newHeight = maxHeight;
        elem.style.overflow = '';

        if (oldHeight === newHeight) {
          return;
        }
      } else {
        elem.style.overflow = 'hidden';
      }

      elem.style.height = '5px';
      elem.style.height = "".concat(elem.scrollHeight + 2, "px");
    },

    /**
     * Counts the number of line breaks in a string
     * @private
     * @param {string} s The string to test.
     * @returns {number} The number of found line countLinebreaks
     */
    countLinebreaks: function countLinebreaks(s) {
      return (s.match(/\n/g) || []).length;
    },

    /**
     * Updates the descriptive markup (counter, etc) to notify the user how many
     * characters can be typed.
     * @private
     * @param {object} self The current object.
     */
    updateCounter: function updateCounter() {
      var self = this;
      var value = self.element.val();
      var isExtraLinebreaks = this.isChrome || this.isSafari;
      var length = value.length + (isExtraLinebreaks ? this.countLinebreaks(value) : 0);
      var max = self.getMaxLength();
      var remaining = parseInt(max, 10) - length;
      var text = (self.settings.charRemainingText ? self.settings.charRemainingText : //eslint-disable-line
      Locale.translate('CharactersLeft') === 'CharactersLeft' ? 'Characters Left' : Locale.translate('CharactersLeft')).replace('{0}', remaining.toString());

      if (self.counter) {
        if (length >= max) {
          text = self.settings.charMaxText ? self.settings.charMaxText.replace('{0}', max) : Locale.translate('CharactersMax') + max;
          self.counter.text(text);
          self.counter.removeClass('almost-empty');
        } else {
          self.counter.text(text);

          if (remaining < 10) {
            self.counter.addClass('almost-empty');
          } else {
            self.counter.removeClass('almost-empty');
          }
        }
      }

      self.printarea.text(self.element.val());
    },

    /**
     * Enables this component instance.
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
    },

    /**
     * Disables this component instance.
     */
    disable: function disable() {
      this.enable();
      this.element.prop('disabled', true);
    },

    /**
     * Returns true if the texarea is disabled
     * @returns {boolean} True if the elemet is disabled.
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Sets this component instance to "readonly"
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
    },

    /**
     * Call whenever the plugin's settings are changed
     * @param {object} settings The settings object.
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.destroy();
      this.init();
    },

    /**
     * Returns max length if setting exists
     * @private
     * @returns {number} maxLength property in settings if exist otherwise maxlength attribute is returned if exist
     */
    getMaxLength: function getMaxLength() {
      if (this.settings.maxLength) {
        return this.settings.maxLength;
      }

      if (this.element.attr('maxlength')) {
        return parseInt(this.element.attr('maxlength'), 10);
      }

      return undefined;
    },

    /**
     * Destroys this component instance and unlinks it from its element.
     */
    destroy: function destroy() {
      if (this.printarea && this.printarea.length) {
        this.printarea.remove();
      }

      if (this.counter && this.counter.length) {
        this.counter.remove();
      }

      this.element.off();
    },

    /**
     * Handle key events for functionality like counter and autoGrow.
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.element.on('keyup.textarea', function (e) {
        var value = self.element.val();
        var isExtraLinebreaks = self.isChrome || self.isSafari;
        var length = value.length + (isExtraLinebreaks ? self.countLinebreaks(value) : 0);
        var max = self.getMaxLength();
        self.updateCounter();

        if (length >= max) {
          e.preventDefault();
          return false;
        }

        if (self.settings.autoGrow) {
          self.autoGrow();
        }

        return true;
      }).on('focus.textarea', function () {
        if (self.counter) {
          self.counter.addClass('focus');
        }
      }).on('updated.textarea', function () {
        self.updated();
      }).on('keypress.textarea', function (e) {
        var value = self.element.val();
        var isExtraLinebreaks = self.isChrome || self.isSafari;
        var length = value.length + (isExtraLinebreaks ? self.countLinebreaks(value) : 0);
        var max = self.getMaxLength();

        if ([97, 99, 118, 120].indexOf(e.which) > -1 && (e.metaKey || e.ctrlKey)) {
          self.updateCounter();
          return;
        }

        if (!self.isPrintable(e.which, e.shiftKey)) {
          return;
        }

        if (length >= max && !self.isSelected(this)) {
          e.preventDefault();
        }
      }).on('blur.textarea', function () {
        self.updateCounter();

        if (self.counter) {
          self.counter.removeClass('focus');
        }
      });
    }
  };

  /**
   * jQuery Component wrapper for Textarea
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} textarea elements being acted on.
   */

  $.fn.textarea = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$18);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$18, new Textarea(this, settings));
      }
    });
  };

  /**
   * jQuery Component Wrapper for Toolbar Searchfield
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.toolbarsearchfield = $.fn.searchfield;

  var COMPONENT_NAME$19 = 'trackdirty'; // Default Trackdirty Options

  var TRACKDIRTY_DEFAULTS = {};
  /**
  * Track changes on the inputs passed in the jQuery selector and show a dirty indicator
  * @class Trackdirty
  * @param {string} element The component element.
  * @param {string} [settings] The component settings.
  */

  function Trackdirty(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TRACKDIRTY_DEFAULTS);
    this.element = $(element);
    this.init();
  } // Trackdirty Methods


  Trackdirty.prototype = {
    init: function init() {
      this.isIe = Environment.browser.name === 'ie';
      this.isIeEdge = Environment.browser.name === 'edge';
      this.handleEvents();
    },

    /**
     * Get the value or checked if checkbox or radio
     * @private
     * @param {object} element .
     * @param {boolean} isOriginal .
     * @returns {string} element value
     */
    valMethod: function valMethod(element, isOriginal) {
      switch (element.attr('type')) {
        case 'checkbox':
        case 'radio':
          return element.prop('checked');

        case 'file':
          {
            if (typeof isOriginal === 'boolean' && isOriginal) {
              var original = element.attr('original');
              return original !== undefined ? original : '';
            }

            var el = element.parent().find('[type="text"]');
            return el.val();
          }

        default:
          {
            if (element.is('textarea') && element.closest('.editor-source').length === 1) {
              var value = element.is(':visible') ? element.val() : element.text();
              return this.trimEditorText(value);
            }

            return element.val();
          }
      }
    },

    /**
     * Trim out the editor spaces for comparison.
     * @private
     * @param  {string} text The starting text.
     * @returns {string} The trimmed text.
     */
    trimEditorText: function trimEditorText(text) {
      return text.trim().replace(/>\s+</g, '><').replace(/\s+/g, ' ').replace(' has-tooltip', '').replace(/<br(\s+)?\/?>/g, '<br>\n').replace(/<\/p>(\s+)/g, '</p>\n\n').replace(/<\/blockquote>(\s+)?/g, '</blockquote>\n\n');
    },

    /**
     * Get absolute position for an element
     * @private
     * @param {object} element .
     * @returns {object} position for given element
     */
    getAbsolutePosition: function getAbsolutePosition(element) {
      var pos = element.position(); // eslint-disable-next-line

      element.parents().each(function () {
        var el = this;

        if (window.getComputedStyle(el, null).position === 'relative') {
          return false;
        }

        pos.left += el.scrollLeft;
        pos.top += el.scrollTop;
      });
      return {
        left: pos.left,
        top: pos.top
      };
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.element.removeClass('dirty').off('resetdirty.dirty change.dirty doresetdirty.dirty');

      if (this.settings && _typeof(this.settings.d) === 'object') {
        var d = this.settings.d;
        $('.icon-dirty, .msg-dirty', d.field).add(d.icon).add(d.msg).remove();
      }

      $.removeData(this.element[0], 'original');
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TRACKDIRTY_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$19);
    },

    /**
     * Attach Events used by the Control
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var input = this.element;

      if (input.is('.editor')) {
        var textArea = input.parent().find('textarea');
        textArea.data('original', this.valMethod(textArea));
      }

      input.data('original', this.valMethod(input, true)).on('resetdirty.dirty', function () {
        if (input.is('.editor')) {
          var _textArea = input.parent().find('textarea');

          _textArea.data('original', _this.valMethod(_textArea));
        }

        input.data('original', _this.valMethod(input)).triggerHandler('doresetdirty.dirty');
      }).on('change.dirty doresetdirty.dirty', function (e) {
        var el = input;
        var field = input.closest('.field, .radio-group');
        var label = $('label:visible', field);
        var d = {
          class: '',
          style: ''
        };

        if (field.is('.field-fileupload')) {
          el = field.find('input.fileupload-background-transparent');
        }

        if (field.is('.editor-container')) {
          el = field.find('.editor-source');
        } // Used element without .field wrapper


        if (!label[0]) {
          label = input.next('label');
        }

        if (input.attr('data-trackdirty') !== 'true') {
          return;
        } // Add class to element


        input.addClass('dirty'); // Set css class

        if (input.is('[type="checkbox"], [type="radio"]')) {
          d.class += " dirty-".concat(input.attr('type'));
          d.class += input.is(':checked') ? ' is-checked' : '';
        }

        if (input.is('select')) {
          d.class += ' is-select';
          el = input.next('.dropdown-wrapper').find('.dropdown');
        } // Add class and icon


        d.icon = el.prev();

        if (!d.icon.is('.icon-dirty')) {
          if (input.is('.colorpicker') && !Locale.isRTL()) {
            d.rect = _this.getAbsolutePosition(input);
            d.style = "left:".concat(d.rect.left, "px; top:").concat(d.rect.top, "px;");
          }

          d.icon = "<span class=\"icon-dirty".concat(d.class, "\"></span>");
          d.msg = Locale.translate('MsgDirty') || '';
          d.msg = "<span class=\"audible msg-dirty\">".concat(d.msg, "</span>"); // Add icon and msg

          var firstInput = $($(el[0].parentElement).find('input')[0]);
          el = input.is('[type="radio"]') ? firstInput : el;

          if ($(el[0].parentElement).find('.icon-dirty').length === 0) {
            el.before(d.icon);
            label.append(d.msg);

            if (d.style && el.prev('.icon-dirty')[0]) {
              el.prev('.icon-dirty')[0].style.cssText = d.style;
            }
          } // Cache icon and msg


          d.icon = el.prev();
          d.msg = label.find('.msg-dirty');
        } // Handle resetting value back


        var original = input.data('original');

        var current = _this.valMethod(input);

        d.field = field;
        _this.settings.d = d;

        if (field.is('.editor-container')) {
          // editors values are further down it's tree in a textarea,
          // so get the elements with the value
          var _textArea2 = field.find('textarea');

          original = _textArea2.data('original');

          if (field.find('.editor-source').is(':visible')) {
            current = _textArea2.val();
          } else {
            current = _this.isIe || _this.isIeEdge ? input[0].innerHTML : _textArea2.text();
          }

          current = _this.trimEditorText(current);
        }

        if (current === original || input.attr('multiple') && utils.equals(current, original)) {
          input.removeClass('dirty');
          $('.icon-dirty, .msg-dirty', field).add(d.icon).add(d.msg).remove();
          input.trigger(e.type === 'doresetdirty' ? 'afterresetdirty' : 'pristine');
          return;
        }
        /**
        * Fires when an inout becomes dirty.
        * @event resetdirty
        * @memberof Trackdirty
        * @property {object} event - The jquery event object
        */


        input.trigger('dirty');
      });
    }
  };

  /**
   * jQuery Component Wrapper for TrackDirty
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.trackdirty = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$19);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$19, new Trackdirty(this, settings));
      }
    });
  };

  var COMPONENT_NAME$1a = 'tree';
  /**
  * The tree Component displays a hierarchical list.
  * @class Tree
  * @constructor
  *
  * @param {object} element The component element.
  * @param {object} [settings] The component settings.
  * @param {array} [settings.dataset] Array of data objects to feed the template
  * @param {array} [settings.dataset[index].children] Array of data objects as child nodes
  * @param {null|function} [settings.source] Call back for getting the data asyncronously.
  * @param {string} [settings.selectable = 'single'] 'single' or 'multiple'.
  * @param {boolean} [settings.hideCheckboxes = false] Only applies when `selectable` is set to 'multiple'.
  * @param {null|string} [settings.menuId] if defined, will be used to identify a Context Menu by ID attribute in which to add nodes.
  * @param {boolean} [settings.useStepUI = false] if `true`, turns this tree instance into a "Stepped" tree.
  * @param {string} [settings.folderIconOpen = 'open-folder']  the icon used when a tree folder node is open.
  * @param {string} [settings.folderIconClosed = 'closed-folder'] the icon used when a tree folder node is closed.
  * @param {boolean} [settings.sortable = false] if `true`, allows nodes to become sortable.
  * @param {null|function} [settings.onBeforeSelect] If defined as a function, fires that function as a callback before the selection on a node occurs.
  * @param {null|function} [settings.onExpand] If defined as a function, fires that function as a node is expanded.
  * @param {null|function} [settings.onCollapse] If defined as a function, fires that function as a node is collapsed.
  * @param {string} [settings.expandTarget = 'node'] 'node' or 'icon', if set to `icon` this will allows to toggle when clicking only the icon portion of the tree node.
  * @param {boolean} [settings.useExpandTarget = false] if `true`, allows separate icon button to expand/collapse.
  * @param {string} [settings.expandIconOpen = 'plusminus-folder-open'] the icon used for expand target icon button when a tree folder node is open.
  * @param {string} [settings.expandIconClosed = 'plusminus-folder-closed'] the icon used for expand target icon button when a tree folder node is closed.
  * @param {boolean} [settings.expandPlusminusRotate = true] if `true`, will rotate expand target plus-minus icon.
  * @param {boolean} [settings.showChildrenCount = false] if `true`, allows show children count beside the node name text.
  * @param {boolean} [settings.childrenAutoCount = true] if `true`, allows to auto count the children.
  */

  var TREE_DEFAULTS = {
    dataset: null,
    // array of data objects
    source: null,
    // callback for data asyncronously
    selectable: 'single',
    // ['single'|'multiple']
    hideCheckboxes: false,
    // [true|false] -apply only with [selectable: 'multiple']
    menuId: null,
    // Context Menu to add to nodes
    useStepUI: false,
    // When using the UI as a stepped tree
    folderIconOpen: 'open-folder',
    folderIconClosed: 'closed-folder',
    sortable: false,
    // Allow nodes to be sortable
    onBeforeSelect: null,
    onExpand: null,
    onCollapse: null,
    expandTarget: 'node',
    useExpandTarget: false,
    expandIconOpen: 'plusminus-folder-open',
    expandIconClosed: 'plusminus-folder-closed',
    expandPlusminusRotate: true,
    showChildrenCount: false,
    childrenAutoCount: true
  };

  function Tree(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, TREE_DEFAULTS);
    this.init();
  } // Tree Methods


  Tree.prototype = {
    /**
     * @private
     * @returns {undefined}
     */
    init: function init() {
      this.isIe11 = Environment.browser.name === 'ie' && Environment.browser.version === '11';
      this.initTree();
      this.handleKeys();
      this.setupEvents();

      if (this.loadData(this.settings.dataset) === -1) {
        this.syncDataset();
        this.initSelected();
        this.focusFirst();
        this.attachMenu(this.settings.menuId);
        this.createSortable();
        this.childrenCountInit();
      }
    },

    /**
     * Init Tree from ul, li, a markup structure in DOM
     * @private
    */
    initTree: function initTree() {
      var self = this;
      var s = this.settings;
      var links = this.element.find('a');
      var selectableAttr = this.element.attr('data-selectable');

      if (s.useExpandTarget) {
        s.expandTarget = 'icon';
      } // Set attribute "data-selectable"


      s.selectable = typeof selectableAttr !== 'undefined' && (selectableAttr.toLowerCase() === 'single' || selectableAttr.toLowerCase() === 'multiple') ? selectableAttr : s.selectable; // Set isMultiselect and checkboxes show/hide

      this.isMultiselect = s.selectable === 'multiple';
      s.hideCheckboxes = s.hideCheckboxes || !this.isMultiselect;
      this.element.addClass(this.isMultiselect ? ' is-multiselect' : '');
      links.each(function () {
        var a = $(this);
        self.decorateNode(a);
      });
    },

    /**
     * Init selected notes
     * @private
    */
    initSelected: function initSelected() {
      var _this = this;

      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        li.setAttribute('role', 'none');

        _this.setNodeStatus($(li.querySelector('a')));
      });
      this.syncDataset();
    },

    /**
     * Focus the first tree node
     * @private
     */
    focusFirst: function focusFirst() {
      var a = this.element[0].querySelector('a');

      if (a) {
        a.setAttribute('tabindex', '0');
      }
    },

    /**
     * Set focus
     * @private
     * @param {object} node .
     * @returns {void}
     */
    setFocus: function setFocus(node) {
      node = this.isjQuery(node) ? node[0] : node;

      if (!node) {
        return;
      }

      node.focus();
      DOM.removeClass(node, 'hide-focus');
    },

    /**
     * From the LI, Read props and add stuff
     * @private
     * @param {object} a an anchor tag reference wrapped in a jQuery object.
     * @param {string} iconToSet icon for tree node.
     * @param {bool} hideCheckbox to show or hide checkbox for tree node.
     * @param {object} nodeData the data relative to given node.
     * @returns {void}
     */
    // Added parameters - To show check box and icon on demand for particular node
    decorateNode: function decorateNode(a, iconToSet, hideCheckbox, nodeData) {
      a = this.isjQuery(a) ? a : $(a);
      var parentCount = 0;
      var badgeData = a[0].getAttribute('data-badge');
      var alertIcon = a[0].getAttribute('data-alert-icon');
      var isParentsDisabled = a.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;
      var isDisabled = DOM.hasClass(a[0], 'is-disabled') || isParentsDisabled;

      if (typeof badgeData !== 'undefined') {
        badgeData = utils.parseSettings(a, 'data-badge');
      } // Set initial 'role', 'tabindex', and 'aria selected' on each link (except the first)


      a[0].setAttribute('role', 'treeitem');
      a[0].setAttribute('tabindex', '-1');
      a[0].setAttribute('aria-selected', 'false'); // Add Aria disabled

      if (isDisabled) {
        DOM.addClass(a[0], 'is-disabled');
        a[0].setAttribute('aria-disabled', 'true');
        var childSection = a.next();

        if (childSection[0] && childSection[0].tagName.toLowerCase() === 'ul' && DOM.hasClass(childSection[0], 'is-open')) {
          var childLinks = [].slice.call(childSection[0].querySelectorAll('a'));
          childLinks.forEach(function (link) {
            DOM.addClass(link, 'is-disabled');
            link.setAttribute('aria-disabled', 'true');
          });
          var parentUls = [].slice.call(a[0].parentNode.querySelectorAll('ul'));
          parentUls.forEach(function (ul) {
            return DOM.addClass(ul, 'is-disabled');
          });
        }
      } // ParentCount 'aria-level' to the node's level depth


      parentCount = a.parentsUntil(this.element, 'ul').length - 1;
      a[0].setAttribute('aria-level', parentCount + 1); // Set the current tree item node position relative to its aria-setsize

      var posinset = a.parent().index();
      a[0].setAttribute('aria-posinset', posinset + 1); // Set the current tree item aria-setsize

      var listCount = a.closest('li').siblings().length + 1;
      a[0].setAttribute('aria-setsize', listCount); // Set the current tree item node expansion state

      var subNode = a.next('ul');
      var subNodeOpen = false;

      if (subNode[0] && subNode.children().length > 0) {
        subNodeOpen = DOM.hasClass(subNode[0], 'is-open');
        a[0].setAttribute('aria-expanded', subNodeOpen ? 'true' : 'false');
      } // Inject Icons


      var text = a.contents().filter(function () {
        return !$(this).is('.tree-badge, .tree-children-count'); // Do not include badge text
      }).text();
      a[0].textContent = '';

      if (a.children('svg.icon-tree').length === 0) {
        // Show provided icon if any, if empty string provided then show empty icon otherwise show document icon.
        if (iconToSet || iconToSet === '') {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({
            icon: iconToSet,
            classes: ['icon-tree']
          }));
        } else {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({
            icon: 'tree-node',
            classes: ['icon-tree']
          }));
        }

        if (this.settings.useStepUI) {
          a[0].insertAdjacentHTML('afterbegin', $.createIcon({
            icon: alertIcon,
            classes: ['step-alert', "icon-".concat(alertIcon)]
          }));
        }
      } // Inject expand target


      if (subNode[0]) {
        a[0].insertAdjacentHTML('beforeend', this.getExpandTargetHtml(subNodeOpen));
      } // Inject checkbox
      // Show check box for particular node on demand


      if (this.isMultiselect && (!this.settings.hideCheckboxes || hideCheckbox === false)) {
        a[0].insertAdjacentHTML('beforeend', '<span class="tree-checkbox"></span>');
      } // Inject badge


      var badgeHtml = this.getBadgeHtml(badgeData);

      if (badgeHtml !== '') {
        a[0].insertAdjacentHTML('beforeend', badgeHtml);
      }

      var span = document.createElement('span');
      DOM.addClass(span, 'tree-text');
      span.textContent = text;

      if (span.innerHTML.indexOf('&lt;svg') > 0) {
        span.innerHTML = xssUtils.unescapeHTML(span.innerHTML);
      }

      a[0].appendChild(span); // Inject children count

      if (subNode[0]) {
        a[0].insertAdjacentHTML('beforeend', this.getChildrenCountHtml(nodeData));
      }

      if (this.hasIconClass(a)) {
        // CreateIconPath
        this.setTreeIcon(a.find('svg.icon-tree'), a[0].getAttribute('class'));
      } // Adds role=group' to all subnodes


      if (subNode[0] && subNode[0].tagName.toLowerCase() === 'ul') {
        var aClass = a[0].getAttribute('class');

        if (this.settings.useExpandTarget && aClass && !nodeData) {
          var icon = aClass.match(/(icon-)[^\s]+/g);

          if (icon) {
            nodeData = {
              icon: icon[0]
            };
          }
        }

        subNode[0].setAttribute('role', 'group');
        DOM.addClass(subNode[0].parentNode, 'folder');
        this.setFolderIcon(a, DOM.hasClass(subNode[0], 'is-open'), nodeData);

        if (aClass && aClass.indexOf('open') === -1 && aClass.indexOf('closed') === -1) {
          if (isDisabled) {
            DOM.addClass(a[0], 'is-disabled');
          }

          this.setFolderIcon(a, DOM.hasClass(subNode[0], 'is-open'), nodeData);
        }

        if (this.hasIconClass(a)) {
          aClass = a[0].getAttribute('class');

          if (/open|close/g.test(aClass) || !subNode[0] || this.settings.useExpandTarget) {
            this.setTreeIcon(a.find('svg.icon-tree'), DOM.hasClass(subNode[0], 'is-open') ? aClass : aClass.replace('open', 'closed'));
          }
        }
      }

      a.hideFocus();
    },

    /**
     * Sets the correct icon to use on a particular SVG element.
     * @private
     * @param {object} svg an SVG element reference wrapped in a jQuery object
     * @param {string} icon the ID of a Soho Icon type.
     * @returns {void}
     */
    setTreeIcon: function setTreeIcon(svg, icon) {
      if (!svg || typeof icon !== 'string') {
        return;
      }

      svg = this.isjQuery(svg) ? svg : $(svg); // Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing

      var iconStr = icon.replace(/#?icon-|hide-focus|is-selected|is-active|\s?/gi, '');
      svg.changeIcon(iconStr);
    },

    /**
     * Expands a collection of tree nodes.
     * @param {object} nodes - a jQuery-wrapped collection of tree node elements.
     If left undefined, this will automatically use all `ul[role=group]` elements.
     * @returns {void}
     */
    expandAll: function expandAll(nodes) {
      var _this2 = this;

      var groups = nodes;

      if (typeof groups !== 'undefined') {
        groups = this.isjQuery(groups) ? $.makeArray(groups) : groups;
      } else {
        groups = [].slice.call(this.element[0].querySelectorAll('ul[role=group]'));
      }

      groups.forEach(function (group) {
        var prev = group.previousElementSibling;
        DOM.addClass(group.parentNode, 'is-open');
        DOM.addClass(group, 'is-open');
        group.style.height = '';

        if (prev && prev.tagName.toLowerCase() === 'a') {
          var svg = prev.querySelector('svg.icon-tree');

          _this2.setTreeIcon(svg, _this2.settings.folderIconOpen);

          prev.setAttribute('aria-expanded', true);

          if (_this2.hasIconClass(prev)) {
            _this2.setTreeIcon(svg, prev.getAttribute('class'));
          }
        }
      });
    },

    /**
     * Collapses a collection of tree nodes.
     * @param {object} nodes - a jQuery-wrapped collection of tree node elements.
     If left undefined, this will automatically use all `ul[role=group]` elements.
     * @returns {void}
     */
    collapseAll: function collapseAll(nodes) {
      var _this3 = this;

      var groups = nodes;

      if (typeof groups !== 'undefined') {
        groups = this.isjQuery(groups) ? $.makeArray(groups) : groups;
      } else {
        groups = [].slice.call(this.element[0].querySelectorAll('ul[role=group]'));
      }

      groups.forEach(function (group) {
        var prev = group.previousElementSibling;
        DOM.removeClass(group.parentNode, 'is-open');
        DOM.removeClass(group, 'is-open');
        group.style.height = 0;

        if (prev && prev.tagName.toLowerCase() === 'a') {
          var svg = prev.querySelector('svg.icon-tree');

          _this3.setTreeIcon(svg, _this3.settings.folderIconClosed);

          prev.setAttribute('aria-expanded', false);
          DOM.removeClass(prev, 'is-selected');

          if (_this3.hasIconClass(prev)) {
            _this3.setTreeIcon(svg, prev.getAttribute('class').replace('open', 'closed'));
          }
        }
      });
    },

    /**
     * Check if an object is an instance of a jQuery object
     * @private
     * @param {object} obj the object being tested.
     * @returns {boolean} true if jQuery
     */
    isjQuery: function isjQuery(obj) {
      // TODO: Move this to a Soho utility object?
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    },

    /**
     * Selects a tree node specifically using it's ID attribute.
     * @param {string} id - the ID string to use.
     * @returns {void}
     */
    selectNodeById: function selectNodeById(id) {
      this.selectNodeByJquerySelector("#".concat(id));
    },

    /**
     * Selects a tree node by [jquery selector] -or- [jquery object]
     * @private
     * @param {object} selector uses a string that represents a jQuery-wrapped
     element's ID attribute, or a jQuery-wrapped reference to the element itself.
     * @returns {void}
     */
    selectNodeByJquerySelector: function selectNodeByJquerySelector(selector) {
      var target = this.isjQuery(selector) ? selector : $(selector);

      if (target.length && !target.is('.is-disabled')) {
        var nodes = target.parentsUntil(this.element, 'ul[role=group]');
        this.expandAll(nodes);
        this.selectNode(target, true);
      }
    },

    /**
     * Deselects a tree node
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @returns {void}
     */
    unSelectedNode: function unSelectedNode(node, focus) {
      if (node.length === 0) {
        return;
      }

      var self = this;
      var aTags = $('a', this.element);
      aTags.attr('tabindex', '-1');
      node.attr('tabindex', '0');
      $('a:not(.is-disabled)', node.parent()).attr('aria-selected', 'false').parent().removeClass('is-selected');
      this.syncNode(node);
      this.setNodeStatus(node);

      if (focus) {
        node.focus();
      } // Set active css class


      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return DOM.removeClass(li, 'is-active');
      });
      DOM.addClass(node[0].parentNode, 'is-active');
      setTimeout(function () {
        var jsonData = node.data('jsonData') || {};
        /**
        * Fires when the node is deselected.
        * @memberof Tree
        * @event unselected
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {object} args for node element, item
        * @property {HTMLElement} args.node The DOM Element.
        * @property {HTMLElement} args.data The JSON data attached to the node.
        */

        self.element.triggerHandler('unselected', {
          node: node,
          data: jsonData
        });
      }, 0);
    },

    /**
     * Selects a tree node
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @returns {void}
     */
    selectNode: function selectNode(node, focus) {
      var self = this;
      var s = this.settings;

      if (node.length === 0) {
        return;
      } // Possibly Call the onBeforeSelect


      var result;

      if (typeof s.onBeforeSelect === 'function') {
        result = s.onBeforeSelect(node);

        if (result && result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode) {
            if (continueSelectNode) {
              self.selectNodeFinish(node, focus);
            }
          });
        } else if (result) {
          // Boolean is returned instead of a promise
          self.selectNodeFinish(node, focus);
        }
      } else {
        // No Callback specified
        self.selectNodeFinish(node, focus);
      }
    },

    /**
     * Select the node when finished
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} focus - if defined, causes the node to become focused.
     * @param {object} e - jquery event.
     * @returns {void}
     */
    selectNodeFinish: function selectNodeFinish(node, focus, e) {
      // Don't do selection for toggle type only
      if ((this.isMultiselect || this.settings.expandTarget === 'icon') && e) {
        if (e.type === 'click' || e.type === 'touch') {
          if (DOM.hasClass(e.target, 'icon') && DOM.hasClass(node[0].parentNode, 'folder')) {
            return;
          }
        } else if (e.type === 'keydown') {
          var charCode = e.charCode || e.keyCode;

          if (charCode === 37 || charCode === 39) {
            return;
          }
        }
      }

      var self = this;
      var links = [].slice.call(this.element[0].querySelectorAll('a'));
      links.forEach(function (a) {
        return a.setAttribute('tabindex', '-1');
      });
      node[0].setAttribute('tabindex', '0');

      if (this.isMultiselect) {
        var links2 = [].slice.call(node[0].parentNode.querySelectorAll('a:not(.is-disabled)'));
        links2.forEach(function (a) {
          a.setAttribute('aria-selected', 'true');
          DOM.addClass(a, 'is-selected');
          DOM.addClass(a.parentNode, 'is-selected');
        });
      } else {
        if (DOM.hasClass(node[0], 'is-selected')) {
          return;
        }

        links.forEach(function (a) {
          var link = $(a);
          var data = link.data('jsonData');

          if (data) {
            delete data.selected;
            link.data('jsonData', data);
          }

          a.setAttribute('aria-selected', 'false');
          DOM.removeClass(a, 'is-selected');
          DOM.removeClass(a.parentNode, 'is-selected');
        });
        node[0].setAttribute('aria-selected', 'true');
        DOM.addClass(node[0], 'is-selected');
        DOM.addClass(node[0].parentNode, 'is-selected');
      }

      this.syncNode(node);

      if (!this.loading) {
        this.setNodeStatus(node);
      }

      if (focus) {
        node.focus();
      } // Set active css class


      var listItems = [].slice.call(this.element[0].querySelectorAll('li'));
      listItems.forEach(function (li) {
        return DOM.removeClass(li, 'is-active');
      });
      DOM.addClass(node[0].parentNode, 'is-active');
      setTimeout(function () {
        var jsonData = node.data('jsonData') || {};
        /**
         * Fires when the node is selected.
         * @memberof Tree
         * @event selected
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} args for node element, item
         * @property {HTMLElement} args.node The DOM Element.
         * @property {HTMLElement} args.data The JSON data attached to the node.
         */

        self.element.triggerHandler('selected', {
          node: node,
          data: jsonData
        });
      }, 0);
    },

    /**
     * Set current node status
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @returns {void}
     */
    setNodeStatus: function setNodeStatus(node) {
      var self = this;
      var data = node.data('jsonData');
      var nodes; // Not multiselect

      if (!this.isMultiselect) {
        var a = node[0];
        var li = a.parentNode;

        if (data && data.selected) {
          DOM.addClass(li, 'is-selected');
          DOM.addClass(a, 'is-selected');
          a.setAttribute('aria-selected', true);
        } else {
          DOM.removeClass(li, 'is-selected', 'is-partial');
          DOM.removeClass(a, 'is-selected', 'is-partial');
          a.setAttribute('aria-selected', false);
        }

        return;
      }

      var setStatus = function setStatus(thisNodes, isFirstSkipped) {
        thisNodes.forEach(function (li) {
          var a = $(li.querySelector('a'));
          var status = self.getSelectedStatus(a, isFirstSkipped);

          if (status === 'mixed') {
            DOM.removeClass(li, 'is-selected', 'is-partial');
            DOM.addClass(li, 'is-partial');
          } else if (status) {
            DOM.removeClass(li, 'is-selected', 'is-partial');
            DOM.addClass(li, 'is-selected');
          } else {
            DOM.removeClass(li, 'is-selected', 'is-partial');
          }

          self.syncNode(a);
        });
      }; // Multiselect


      var isFirstSkipped = false;
      nodes = [].slice.call(node[0].parentNode.querySelectorAll('li.folder'));
      setStatus(nodes, isFirstSkipped);
      isFirstSkipped = !(!nodes.length && data && !data.selected);
      nodes = node.parentsUntil(this.element, 'li.folder');
      nodes = [].slice.call(nodes.toArray());
      setStatus(nodes, isFirstSkipped);
    },

    /**
     * Get's a tree node's current 'selected' status
     * @private
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {boolean} isFirstSkipped - ?
     * @returns {boolean} status as true|false|'mixed'
     */
    getSelectedStatus: function getSelectedStatus(node, isFirstSkipped) {
      var total = 0;
      var selected = 0;
      var unselected = 0;
      var data;
      node.parent().find('a').each(function (i) {
        if (isFirstSkipped && i === 0) {
          return;
        }

        total++;
        data = $(this).data('jsonData');

        if (data && data.selected) {
          selected++;
        } else {
          unselected++;
        }
      });
      var status;

      if (total === selected) {
        status = true;
      } else if (total === unselected) {
        status = false;
      } else {
        status = 'mixed';
      }

      return status;
    },

    /**
     * Changes a node's open/close status to its opposite form.
     * @param {object} node - a jQuery-wrapped element reference to a tree node.
     * @param {object} e jquery event
     * @returns {void}
     */
    toggleNode: function toggleNode(node, e) {
      var next = node.next();
      var self = this;
      var s = this.settings;
      var result;

      if (next[0] && next[0].tagName.toLowerCase() === 'ul' && next[0].getAttribute('role') === 'group') {
        var currentIcon = node.find('svg.icon-tree').getIconName();

        if (DOM.hasClass(next[0], 'is-open')) {
          if (typeof s.onCollapse === 'function') {
            result = s.onCollapse(node);

            if (result && result.done && typeof result.done === 'function') {
              // A promise is returned
              result.done(function (continueSelectNode) {
                if (continueSelectNode) {
                  self.selectNodeFinish(node, focus, e);
                }
              });
            } else if (result) {
              // Boolean is returned instead of a promise
              self.selectNodeFinish(node, focus, e);
            }
          } else if (s.expandTarget === 'icon') {
            var parent = node[0].parentNode;

            if (e && DOM.hasClass(e.target, 'icon') && DOM.hasClass(parent, 'folder')) {
              self.selectNodeFinish(node, focus, e);
            }
          } else {
            // No Callback specified
            self.selectNodeFinish(node, focus, e);
          }

          node.closest('.folder').removeClass('is-open');

          if (currentIcon === s.folderIconOpen || s.useExpandTarget) {
            self.setFolderIcon(node, false, false, s.expandPlusminusRotate);
          } else if (/open|close/g.test(currentIcon) && !s.useExpandTarget) {
            self.setTreeIcon(node.find('svg.icon-tree'), currentIcon.replace('open', 'closed').replace(/\s?is-selected/, ''));
          }

          var parentNode = node.closest('.folder a');

          if (self.hasIconClass(parentNode)) {
            var nodeClass = parentNode.attr('class');

            if (/open|close/g.test(nodeClass) || s.useExpandTarget) {
              self.setTreeIcon(parentNode.find('svg.icon-tree'), nodeClass.replace('open', 'closed').replace(/\s?is-selected/, ''));
            }
          }

          self.isAnimating = true;

          if (!self.isMultiselect && !s.expandTarget === 'icon') {
            self.unSelectedNode(node.parent().find('li.is-selected'), false);
            DOM.removeClass(node[0], 'is-selected');
          }

          next.one('animateclosedcomplete', function () {
            DOM.removeClass(next[0], 'is-open');
            self.isAnimating = false;
          }).animateClosed();
          node[0].setAttribute('aria-expanded', node[0].getAttribute('aria-expanded') !== 'true');
        } else {
          if (typeof s.onExpand === 'function') {
            result = s.onExpand(node);

            if (result && result.done && typeof result.done === 'function') {
              // A promise is returned
              result.done(function (continueSelectNode) {
                if (continueSelectNode) {
                  self.selectNodeFinish(node, focus, e);
                }
              });
            } else if (result) {
              // Boolean is returned instead of a promise
              self.selectNodeFinish(node, focus, e);
            }
          } else if (s.expandTarget === 'icon') {
            var _parent = node[0].parentNode;

            if (e && DOM.hasClass(e.target, 'icon') && DOM.hasClass(_parent, 'folder')) {
              self.selectNodeFinish(node, focus, e);
            }
          } else {
            // No Callback specified
            self.selectNodeFinish(node, focus, e);
          }

          var nodeData = node.data('jsonData');

          if (s.source && nodeData.children && nodeData.children.length === 0) {
            var response = function response(nodes) {
              var id = nodeData.id;
              var elem = self.findById(id); // Add DB and UI nodes

              elem.children = nodes;
              self.addChildNodes(elem, node.parent());
              DOM.removeClass(node[0], 'is-loading');
              self.loading = false; // Open

              self.accessNode(next, node); // Sync data on node

              nodeData.children = nodes;
              node.data('jsonData', nodeData);

              if (DOM.hasClass(node[0].parentNode, 'folder')) {
                self.childrenCountInit(node[0].parentNode);
              }

              if (!self.isMultiselect && !s.expandTarget === 'icon') {
                self.selectNode(node, true);
              }

              self.initSelected();
            };

            var args = {
              node: node,
              data: node.data('jsonData')
            };
            DOM.addClass(node[0], 'is-loading');
            self.loading = true;
            self.settings.source(args, response);
            return;
          }

          if (currentIcon === s.folderIconClosed || s.useExpandTarget) {
            self.setFolderIcon(node, true, false, s.expandPlusminusRotate);
          } else if (/open|close/g.test(currentIcon) && !s.useExpandTarget) {
            self.setTreeIcon(node.find('svg.icon-tree'), currentIcon.replace('closed', 'open').replace(/\s?is-selected/, ''));
          }

          self.accessNode(next, node);
        }
      }
    },

    /**
     * Access The Node
     * @private
     * @param  {object} next The next element.
     * @param  {object} node The DOM element.
     */
    accessNode: function accessNode(next, node) {
      var _this4 = this;

      var nodeClass = node.attr('class');
      node.closest('.folder').addClass('is-open');
      var currentIcon = node.find('svg.icon-tree').getIconName();

      if (currentIcon === this.settings.folderIconClosed || this.settings.useExpandTarget) {
        this.setFolderIcon(node, true, false, this.settings.expandPlusminusRotate);
      } else if (/open|close/g.test(currentIcon) && !this.settings.useExpandTarget) {
        this.setTreeIcon(node.find('svg.icon-tree'), currentIcon.replace('closed', 'open').replace(/\s?is-selected/, ''));
      }

      if (this.hasIconClass(nodeClass)) {
        var isTypeFolder = next[0] && next[0].tagName.toLowerCase() === 'ul';

        if (/open|close/g.test(nodeClass) || !isTypeFolder || this.settings.useExpandTarget) {
          this.setTreeIcon(node.find('svg.icon-tree'), nodeClass.replace('is-selected', ''));
        }
      }

      this.isAnimating = true;
      next.one('animateopencomplete', function () {
        _this4.isAnimating = false;
      }).addClass('is-open').css('height', 0).animateOpen();
      node[0].setAttribute('aria-expanded', node[0].getAttribute('aria-expanded') !== 'true');
    },

    /**
     * Open The Node
     * @private
     * @param  {object} nextTarget The next tree element
     * @param  {object} nodeTarget The DOM element to open.
     */
    openNode: function openNode(nextTarget, nodeTarget) {
      var self = this;
      var nodeData = nodeTarget.data('jsonData');

      if (self.settings.source && nodeData.children && nodeData.children.length === 0) {
        var response = function response(nodes) {
          var id = nodeData.id;
          var elem = self.findById(id); // Add DB and UI nodes

          elem.children = nodes;
          self.addChildNodes(elem, nodeTarget.parent());
          nodeTarget.removeClass('is-loading');
          self.loading = false; // Open

          self.accessNode(nextTarget, nodeTarget); // Sync data on node

          nodeData.children = nodes;
          nodeTarget.data('jsonData', nodeData);
          self.selectNode(nodeTarget, true);
          self.initSelected();
        };

        var args = {
          node: nodeTarget,
          data: nodeTarget.data('jsonData')
        };
        nodeTarget.addClass('is-loading');
        self.loading = true;
        self.settings.source(args, response);
        return;
      }

      self.accessNode(nextTarget, nodeTarget);
    },

    /**
     * Check if given value has icon class
     * @private
     * @param  {string|object} elemClass class or element has icon class
     * @returns  {boolean} true if has icon.
     */
    hasIconClass: function hasIconClass(elemClass) {
      if (typeof elemClass !== 'string') {
        if (this.isjQuery(elemClass)) {
          elemClass = elemClass.length > 1 ? elemClass.first()[0] : elemClass[0];
        }

        elemClass = elemClass.getAttribute('class');
      }

      return elemClass && elemClass.indexOf('icon') > -1;
    },

    /**
     * Close The Node
     * @private
     * @param  {object} nextTarget The next tree element
     * @param  {object} nodeTarget The DOM element to open.
     */
    closeNode: function closeNode(nextTarget, nodeTarget) {
      var self = this;
      self.setTreeIcon(nodeTarget.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconClosed);

      if (self.hasIconClass(nodeTarget.closest('.folder a'))) {
        self.setTreeIcon(nodeTarget.closest('.folder a').find('svg.icon-tree'), nodeTarget.closest('.folder a').attr('class').replace('open', 'closed').replace(/\s?is-selected/, ''));
      }

      self.isAnimating = true;

      if (!self.isMultiselect) {
        self.unSelectedNode(nodeTarget.parent().find('li.is-selected'), false);
        nodeTarget.removeClass('is-selected');
      }

      nextTarget.one('animateclosedcomplete', function () {
        nextTarget.removeClass('is-open');
        self.isAnimating = false;
      }).animateClosed();
      nodeTarget.attr('aria-expanded', nodeTarget.attr('aria-expanded') !== 'true');
    },
    // Setup event handlers
    setupEvents: function setupEvents() {
      var self = this;
      self.element.on('updated.tree', function (e, newSettings) {
        self.updated(newSettings);
        self.initTree();
      });
    },
    // Handle Keyboard Navigation
    handleKeys: function handleKeys() {
      // Key Behavior as per: http://access.aol.com/dhtml-style-guide-working-group/#treeview
      var self = this; // On click give clicked element 0 tabindex and 'aria-selected=true', resets all other links

      this.element.on('click.tree', 'a:not(.is-clone)', function (e) {
        var target = $(this);
        var parent = this.parentNode;
        utils.clearSelection(); // Deselect all selected text.

        if (!DOM.hasClass(target[0], 'is-disabled') && !DOM.hasClass(target[0], 'is-loading')) {
          if (self.isMultiselect || self.settings.expandTarget === 'icon') {
            if (DOM.hasClass(e.target, 'icon') && DOM.hasClass(parent, 'folder')) {
              self.toggleNode(target, e);
            } else if (DOM.hasClass(parent, 'is-selected') || DOM.hasClass(parent, 'is-partial')) {
              self.unSelectedNode(target, true);
            } else {
              self.selectNode(target, true);
            }
          } else {
            self.selectNode(target, true);
            self.toggleNode(target, e);
          }

          e.stopPropagation();
        }

        if (self.popupEl && self.popupEl.data('popupmenu')) {
          self.popupEl.data('popupmenu').close();
          self.popupEl = null;
        }

        self.syncDataset();
        return false; // Prevent Click from Going to Top
      });
      this.element // Focus on "a" elements
      .on('focus.tree', 'a', function () {
        if (parseInt(this.getAttribute('aria-level'), 10) === 0 && parseInt(this.getAttribute('aria-posinset'), 10) === 1) {
          // First element if disabled
          if (DOM.hasClass(this, 'is-disabled')) {
            var e = $.Event('keydown.tree');
            e.keyCode = 40; // move down

            $(this).trigger(e);
            return; // eslint-disable-line
          }
        }
      }); // Handle Up/Down Arrow Keys and Space

      this.element.on('keydown.tree', 'a', function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);
        var next;
        var prev;

        if (self.isAnimating) {
          return;
        } // Down arrow


        if (charCode === 40) {
          var nextNode = self.getNextNode(target);
          self.setFocus(nextNode);
        } // Up arrow,


        if (charCode === 38) {
          var prevNode = self.getPreviousNode(target);
          self.setFocus(prevNode);
        } // Space


        if (e.keyCode === 32) {
          target.trigger('click.tree');
        } // Left arrow


        if (charCode === 37) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              prev = target.next().find('a:first');
              self.setFocus(prev);
            } else {
              self.toggleNode(target, e);
            }
          } else if (target.next().hasClass('is-open')) {
            self.toggleNode(target, e);
          } else {
            prev = target.closest('.folder').find('a:first');
            self.setFocus(prev);
          }

          e.stopPropagation();
          return false; // eslint-disable-line
        } // Right arrow


        if (charCode === 39) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              self.toggleNode(target, e);
            } else {
              next = target.closest('.folder').find('a:first');
              self.setFocus(next);
            }
          } else if (target.next().hasClass('is-open')) {
            next = target.next().find('a:first');
            self.setFocus(next);
          } else {
            self.toggleNode(target, e);
            self.setFocus(target);
          }

          e.stopPropagation();
          return false; // eslint-disable-line
        } // Home  (fn-right on mac)


        if (charCode === 36) {
          next = self.element.find('a:first:visible');
          self.setFocus(next);
        } // End (fn-right on mac)


        if (charCode === 35) {
          next = self.element.find('a:last:visible');
          self.setFocus(next);
        }
      }); // Handle Left/Right Arrow Keys
      // eslint-disable-next-line

      this.element.on('keypress.tree', 'a', function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);

        if (charCode >= 37 && charCode <= 40 || charCode === 32) {
          e.stopPropagation();
          return false;
        } // Printable Chars Jump to first high level node with it...


        if (e.which !== 0) {
          // eslint-disable-next-line
          target.closest('li').nextAll().find('a:visible').each(function () {
            var node = $(this);
            var first = node.text().substr(0, 1).toLowerCase();
            var term = String.fromCharCode(e.which).toLowerCase();

            if (first === term) {
              self.setFocus(node);
              return false;
            }
          });
        }
      });
    },

    /**
     * Handle Loading JSON.
     * @param {object} dataset to load.
     * @returns {void}
     */
    loadData: function loadData(dataset) {
      // eslint-disable-line
      if (!dataset) {
        return -1;
      }

      var self = this;
      self.element.empty();
      self.loading = true;
      dataset = this.arrangeDataset(dataset);
      var html = '';
      self.jsonData = [];

      for (var i = 0, l = dataset.length; i < l; i++) {
        html += self.getNodeHtml(dataset[i], i);
      }

      self.element[0].insertAdjacentHTML('beforeend', html);
      var nodes = [].slice.call(self.element[0].querySelectorAll('a[role="treeitem"]'));
      nodes.forEach(function (node, i) {
        var a = $(node);
        var data = self.jsonData[i];
        a.data('jsonData', data);

        if (data.selected) {
          self.selectNode(a, data.focus);
        }

        self.addAutomationAttributes(a, data);

        if (a.is('.hide-focus')) {
          a.hideFocus();
        }
      });
      var dropdowns = [].slice.call(self.element[0].querySelectorAll('select.dropdown'));

      for (var _i = 0; _i < dropdowns.length; _i++) {
        var dropdown = dropdowns[_i];
        var data = self.jsonData[_i];

        if (data.disabled) {
          $(dropdown).dropdown().disable();
        } else {
          $(dropdown).dropdown().on('selected.tree', function () {
            var nodeToUpdate = self.findById(this.parentElement.previousElementSibling.id);
            nodeToUpdate.text = this.value;
            self.updateNode(nodeToUpdate);
          });
        }
      }

      self.jsonData = undefined;
      self.loading = false;
      self.syncDataset();
      self.initSelected();
      self.focusFirst();
      self.attachMenu(self.settings.menuId);
      self.createSortable();
      this.childrenCountInit();
    },

    /**
     * Rearrange the given or default dataset. if dataset use `parent` key to arrange nodes
     * @private
     * @param {object} dataset a data object.
     * @returns {object} arranged data object
     */
    arrangeDataset: function arrangeDataset(dataset) {
      if (!this.hasKeyInData('parent', dataset)) {
        return dataset;
      }

      dataset = dataset || this.settings.dataset;
      var arrangedData = JSON.parse(JSON.stringify(dataset)); // Add given node to parent

      var addToParent = function addToParent(node) {
        var arranged = false; // Add child to given parent

        var addChild = function addChild(parent) {
          parent.children = parent.children || [];
          parent.children.push(node);
          arranged = true;
        }; // Traverse in given data and arrange it


        var arrange = function arrange(data) {
          for (var i = 0; i < data.length && !arranged; i++) {
            if (data[i].id === node.parent) {
              addChild(data[i]);
            }

            if (typeof data[i].children !== 'undefined') {
              arrange(data[i].children);
            }
          }
        };

        arrange(arrangedData);
      }; // Traverse in given data and add to parent


      var traverse = function traverse(data) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i].parent !== 'undefined') {
            addToParent(data[i]);
          }

          if (typeof data[i].children !== 'undefined') {
            traverse(data[i].children);
          }
        }
      };

      traverse(dataset); // Clean old nodes with parent key

      var clean = function clean(data, id) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i].children !== 'undefined') {
            clean(data[i].children, data[i].id);
          }

          if (typeof id === 'undefined' && typeof data[i].parent !== 'undefined' || typeof id !== 'undefined' && typeof data[i].parent !== 'undefined' && id !== data[i].parent) {
            data.splice(i, 1);
            i--;
          } else {
            delete data[i].parent;
          }
        }
      };

      clean(arrangedData); // Set and return the arranged data

      this.settings.dataset = arrangedData;
      return arrangedData;
    },

    /**
     * Check if given key is exists in dataset.
     * @private
     * @param {string} key to check.
     * @param {object} data to check in.
     * @returns {boolean} true if key found
     */
    hasKeyInData: function hasKeyInData(key, data) {
      var found = false;
      data = data || this.settings.dataset;
      /* eslint-disable no-restricted-syntax */

      var findkey = function findkey(obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            // eslint-disable-line
            var value = obj[prop];

            if (_typeof(value) === 'object' && !found) {
              findkey(value);
            } else if (key === prop) {
              found = true;
            }

            if (found) {
              break;
            }
          }
        }
      };
      /* eslint-enable no-restricted-syntax */


      for (var i = 0, l = data.length; i < l; i++) {
        if (found) {
          break;
        }

        findkey(data[i]);
      }

      return found;
    },

    /**
     * Create html for given json data.
     * @private
     * @param {object} data to do html.
     * @param {number} position for node.
     * @param {number} level for node.
     * @param {boolean} isParentsDisabled for node.
     * @returns {string} created html
     */
    getNodeHtml: function getNodeHtml(data, position, level, isParentsDisabled) {
      var selectHtml = '';
      var selectedOptionText = '';
      level = level || 0;
      position += 1;
      var s = this.settings;
      var isDisabled = isParentsDisabled || data.disabled || false;
      var isChildren = data.children && Array.isArray(data.children);
      var a = {
        id: typeof data.id !== 'undefined' ? " id=\"".concat(data.id, "\"") : '',
        href: " href=\"".concat(typeof data.href !== 'undefined' ? data.href : '#', "\""),
        expanded: " aria-expanded=\"".concat(data.open ? 'true' : 'false', "\""),
        icon: data.icon || data.icon === '' ? data.icon : 'tree-node',
        alertIcon: '',
        alertIconAttr: typeof data.alertIcon !== 'undefined' ? " data-alert-icon=\"".concat(data.alertIcon, "\"") : '',
        text: "<span class=\"tree-text\">".concat(data.text, "</span>"),
        class: ['hide-focus'],
        ariaDisabled: isDisabled ? 'aria-disabled="true"' : '',
        checkbox: this.isMultiselect && (!this.settings.hideCheckboxes || data.hideCheckbox === false) ? '<span class="tree-checkbox"></span>' : '',
        badge: _typeof(data.badge) === 'object' ? this.getBadgeHtml(data.badge) : '',
        expandTarget: isChildren ? this.getExpandTargetHtml(data.open) : '',
        childrenCount: isChildren ? this.getChildrenCountHtml(data) : ''
      };
      this.jsonData.push(data);

      if (s.useStepUI) {
        a.alertIcon = "<svg class=\"icon step-alert icon-".concat(data.alertIcon, "\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-").concat(data.alertIcon, "\"></use>");
      }

      var liClassList = isChildren ? 'folder' : '';
      liClassList += data.selected ? ' is-selected' : '';

      if (liClassList !== '') {
        liClassList += data.open ? ' is-open' : '';
        liClassList = " class=\"".concat(liClassList, "\"");
      }

      if (isDisabled) {
        a.class.push('is-disabled');
      }

      if (data.icon) {
        a.icon = data.icon;

        if (!isChildren || isChildren && /open|closed/i.test(data.icon)) {
          a.class.push(data.icon);
        }
      }

      if (isChildren && (!s.useExpandTarget || s.useExpandTarget && !data.icon)) {
        if (data.open) {
          a.icon = data.icon && /open|closed/i.test(data.icon) ? data.icon : s.folderIconOpen;
          isParentsDisabled = isDisabled;
        } else {
          a.icon = data.icon && /open|closed/i.test(data.icon) ? data.icon.replace('open', 'closed') : s.folderIconClosed;
        }
      }

      a.icon = "#icon-".concat(a.icon.replace(/^#?icon-?/, ''));
      a.class = " class=\"".concat(a.class.join(' '), "\"");
      a.style = ''; // Insert dropdown start

      if (data.type === 'dropdown') {
        a.style = 'style="display: none"';

        if (data.data) {
          selectHtml = '<select class="dropdown" close-on-select="true">';

          for (var i = 0; i < data.data.length; i++) {
            var option = data.data[i];

            if (option.value === data.text) {
              selectedOptionText = option.text;
              selectHtml += "<option value=\"".concat(option.value, "\" selected>").concat(option.text, "</option>");
            } else {
              selectHtml += "<option value=\"".concat(option.value, "\">").concat(option.text, "</option>");
            }
          }

          selectHtml += "</select><div class=\"dropdown-wrapper\"><div class=\"dropdown\"><span>".concat(selectedOptionText);
          selectHtml += '</span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use href="#icon-dropdown"></use></svg></div>';
          selectHtml = "<div class=\"treeDropdown\" style=\"width: 80px; margin-left: 35px; margin-bottom: -15px\">".concat(selectHtml, "</div>");
        }
      } // Insert dropdown end


      var html = "\n      <li".concat(liClassList, ">\n        <a role=\"treeitem\" aria-selected=\"false\" tabindex=\"-1\" ").concat(a.style, "\n          aria-level=\"").concat(level, "\"\n          aria-position=\"").concat(position, "\"\n          aria-setsize=\"").concat(position, "\"\n          ").concat(a.id + a.href + a.class + a.expanded + a.ariaDisabled + a.alertIconAttr, ">\n            <svg class=\"icon-tree icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"").concat(a.icon, "\"></use>\n            </svg>").concat(a.expandTarget + a.checkbox + a.alertIcon + a.badge + a.text + a.childrenCount, "\n        </a>\n        ").concat(selectHtml);

      if (isChildren) {
        html += "<ul class=\"folder".concat(data.open ? ' is-open' : '', "\" role=\"group\">");

        for (var _i2 = 0, l = data.children.length; _i2 < l; _i2++) {
          html += this.getNodeHtml(data.children[_i2], _i2, level + 1, isParentsDisabled);
        }

        html += '</ul>';
      }

      html += '</li>';
      return html;
    },

    /**
     * Get expand target html.
     * @private
     * @param {boolean} isOpen if true, use open icon.
     * @returns {string} html created
     */
    getExpandTargetHtml: function getExpandTargetHtml(isOpen) {
      var r = '';

      if (this.settings.useExpandTarget) {
        var cssClass = 'icon-expand-target';
        var expandTarget = isOpen ? {
          icon: this.settings.expandIconOpen,
          class: 'open'
        } : {
          icon: this.settings.expandIconClosed,
          class: 'close'
        };
        r = $.createIcon({
          icon: expandTarget.icon,
          classes: [cssClass, "".concat(cssClass, "-").concat(expandTarget.class)]
        });
      }

      return r;
    },

    /**
     * Get children count html.
     * @private
     * @param {object} data to do children.
     * @returns {string} html created
     */
    getChildrenCountHtml: function getChildrenCountHtml(data) {
      var r = '';

      if (this.settings.showChildrenCount) {
        r = "<span class=\"tree-children-count\">\n          (<span class=\"tree-children-count-text\">".concat(this.getDataChildrenCount(data), "</span>)\n        </span>");
      }

      return r;
    },

    /**
     * Get children count set via a tree node property.
     * @private
     * @param {object} nodeData to do children.
     * @returns {number} calculated actual children count
     */
    getDataChildrenCount: function getDataChildrenCount(nodeData) {
      return nodeData && /string|number/.test(_typeof(nodeData.childrenCount)) ? parseInt(nodeData.childrenCount, 10) : 0;
    },

    /**
     * Get calculated on the basis of actual children count.
     * @private
     * @param {object} a an anchor tag reference.
     * @returns {number} calculated actual children count
     */
    getActualChildrenCount: function getActualChildrenCount(a) {
      var count = 0;

      if (a) {
        var next = a.nextElementSibling;

        if (next && next.tagName.toLowerCase() === 'ul') {
          count = next.childElementCount;
        }
      }

      return count;
    },

    /**
     * Update children count for given node.
     * @private
     * @param {object} a an anchor tag reference.
     * @param {number} count optional to manually set the children count.
     * @returns {void}
     */
    updateChildrenCount: function updateChildrenCount(a, count) {
      if (a) {
        var countTextEl = a.querySelector('.tree-children-count-text');

        if (countTextEl) {
          count = /string|number/.test(_typeof(count)) ? parseInt(count, 10) : this.getActualChildrenCount(a);

          if (!(count === 0 && parseInt(countTextEl.textContent, 10) > 0 && typeof this.settings.source === 'function' && !DOM.hasClass(a.nextElementSibling, 'is-open'))) {
            countTextEl.textContent = count;
          }
        }
      }
    },

    /**
     * Auto calculate and update children count for given node.
     * @private
     * @param {object} elem the node element.
     * @returns {void}
     */
    updateAutoChildrenCount: function updateAutoChildrenCount(elem) {
      var _this5 = this;

      if (this.settings.showChildrenCount && elem) {
        var links = [].slice.call(elem.querySelectorAll('a'));
        links.forEach(function (a) {
          return _this5.updateChildrenCount(a);
        });
      }
    },

    /**
     * Initial update to children count.
     * @private
     * @param {object} elem Optional the node element.
     * @returns {void}
     */
    childrenCountInit: function childrenCountInit(elem) {
      var _this6 = this;

      elem = elem || this.element;
      elem = this.isjQuery(elem) ? elem[0] : elem;

      if (this.settings.showChildrenCount && elem) {
        if (this.settings.childrenAutoCount) {
          this.updateAutoChildrenCount(elem);
        } else {
          var links = [].slice.call(elem.querySelectorAll('a[data-children-count]'));
          links.forEach(function (a) {
            var childrenCount = a.getAttribute('data-children-count');

            if (typeof childrenCount !== 'undefined') {
              _this6.updateChildrenCount(a, childrenCount);
            }
          });
        }
      }
    },

    /**
     * Set the folder icon to use.
     * @private
     * @param {object} a an anchor tag reference.
     * @param {boolean} isOpen if true, use open icon.
     * @param {object} nodeData the node data.
     * @param {boolean} isRotatePlusminus if true, will rotate plus-minus icon.
     * @returns {void}
     */
    setFolderIcon: function setFolderIcon(a, isOpen, nodeData, isRotatePlusminus) {
      var s = this.settings;
      var aJq = this.isjQuery(a) ? a : $(a);
      a = aJq[0];

      if (a) {
        var svg = {
          el: {
            tree: a.querySelector('svg.icon-tree'),
            expand: a.querySelector('svg.icon-expand-target')
          },
          icon: isOpen ? {
            tree: s.folderIconOpen,
            expand: s.expandIconOpen,
            rotate: 'forward'
          } : {
            tree: s.folderIconClosed,
            expand: s.expandIconClosed,
            rotate: 'backward'
          }
        };
        var target;

        if (s.useExpandTarget) {
          target = {
            el: svg.el.expand,
            icon: svg.icon.expand,
            rotateClass: "rotate-".concat(svg.icon.rotate)
          };
          this.setTreeIcon(target.el, target.icon);

          if (isRotatePlusminus) {
            this.rotatePlusminus(target);
          }

          nodeData = nodeData || aJq.data('jsonData');

          if (!nodeData || nodeData && !nodeData.icon) {
            target = {
              el: svg.el.tree,
              icon: svg.icon.tree
            };
            this.setTreeIcon(target.el, target.icon);
          }
        } else {
          target = {
            el: svg.el.tree,
            icon: svg.icon.tree
          };
          this.setTreeIcon(target.el, target.icon);
        }
      }
    },

    /**
     * Rotate class for plusminus icons.
     * @private
     * @param {object} target to set values.
     * @returns {void}
     */
    rotatePlusminus: function rotatePlusminus(target) {
      if (this.settings.useExpandTarget && this.settings.expandPlusminusRotate) {
        DOM.addClass(target.el, target.rotateClass);
        $(target.el).one('webkitAnimationEnd.tree oAnimationEnd.tree msAnimationEnd.tree animationend.tree', function () {
          DOM.removeClass(target.el, target.rotateClass);
        });
      }
    },

    /**
     * Create badge html.
     * @private
     * @param {object} badgeData to do html.
     * @returns {string} html created
     */
    getBadgeHtml: function getBadgeHtml(badgeData) {
      var badge = {
        html: '',
        style: '',
        class: ['badge', 'tree-badge']
      };

      if (badgeData && !badgeData.remove) {
        badge.text = '';

        if (typeof badgeData.text !== 'undefined') {
          badge.text = badgeData.text.toString();

          if (badge.text.length === 1) {
            badge.class.push('round');
          }
        }

        if (/info|good|error|alert|pending/i.test(badgeData.type)) {
          badge.class.push(badgeData.type);
        } else if (badgeData.type && badgeData.type.charAt(0) === '#' && badgeData.type.length === 7) {
          badge.style = "background-color: ".concat(badgeData.type, " !important;");
        }

        if (badgeData.backColor) {
          badge.style = "background-color: ".concat(badgeData.backColor, " !important;");
        }

        if (badgeData.foreColor) {
          badge.style += "color: ".concat(badgeData.foreColor, " !important;");
        }

        if (badge.style !== '') {
          badge.style = " style=\"".concat(badge.style, "\"");
        }

        if (badge.text !== '') {
          if (badgeData.type && badgeData.type.indexOf('pending') !== -1) {
            badge.text = '';
          }

          badge.html = "<span class=\"".concat(badge.class.join(' '), "\"").concat(badge.style, ">").concat(badge.text, "</span>");
        }
      }

      return badge.html;
    },
    // Functions to Handle Internal Data Store
    addToDataset: function addToDataset(node, location) {
      var elem;
      var updatedNode;
      var index;

      if (node.parent) {
        elem = this.findById(node.parent);
      } // Update dataset after inserting node before or after other node


      if (location instanceof jQuery && location.is('li')) {
        updatedNode = this.findById($(location[0].parentNode.parentNode).find('a')[0].id);
        var childNodes = updatedNode.children || updatedNode.node.data('jsonData').children;
        index = childNodes.findIndex(function (element) {
          return element.text.trim() === $(location).text().trim();
        });
        childNodes.splice(index, 0, node);
      }

      if (location === 'bottom' && !node.parent && !elem) {
        this.settings.dataset.push(node);
      }

      if (location === 'top' && !node.parent && !elem) {
        this.settings.dataset.unshift(node);
      }

      if (node.parent && elem) {
        if (!elem.children) {
          elem.children = [];
        }

        if (location === 'bottom') {
          elem.children.push(node);
        } else {
          elem.children.unshift(node);
        }
      }

      return !(node.parent && !elem);
    },
    // Find the Node (Dataset) By Id
    findById: function findById(id, source) {
      var self = this;

      if (!source) {
        source = this.settings.dataset;
      }
      /* eslint-disable guard-for-in */

      /* eslint-disable no-restricted-syntax */


      for (var key in source) {
        var _item$node, _item$node$data;

        var item = source[key];

        if (item.id === id) {
          return item;
        }

        if (item.children || (_item$node = item.node) !== null && _item$node !== void 0 && (_item$node$data = _item$node == null ? void 0 : _item$node.data('jsonData')) !== null && _item$node$data !== void 0 && (_item$node$data == null ? void 0 : _item$node$data.children)) {
          var _item$node2, _item$node2$data;

          var subresult = self.findById(id, item.children || ((_item$node2 = item.node) === null || _item$node2 === void 0 ? void 0 : (_item$node2$data = _item$node2 == null ? void 0 : _item$node2.data('jsonData')) === null || _item$node2$data === void 0 ? void 0 : _item$node2$data == null ? void 0 : _item$node2$data.children));

          if (subresult) {
            return subresult;
          }
        }
      }
      /* eslint-enable no-restricted-syntax */

      /* eslint-enable guard-for-in */


      return null;
    },
    // Get node by ID if selected
    getNodeByIdIfSelected: function getNodeByIdIfSelected(id, source) {
      var node = this.findById(id, source);
      return node && node.selected ? node : null;
    },

    /**
     * Get selected nodes.
     * @returns {object} selected nodes
     */
    getSelectedNodes: function getSelectedNodes() {
      var node;
      var data;
      var selected = [];
      $('li.is-selected', this.element).each(function () {
        node = $('a:first', this);
        data = node.data('jsonData');
        selected.push({
          node: node,
          data: data
        });
      });
      return selected;
    },
    getNextNode: function getNextNode(target) {
      var next = target.parent().next().find('a:first');
      var subTarget = target.next(); // Move Into Children

      if (subTarget.is('ul.is-open')) {
        next = subTarget.find('a:first');
      } // Skip disabled


      if (next.hasClass('is-disabled')) {
        next = next.parent().next().find('a:first');
      } // Bottom of a group..{l=1000: max folders to be deep }


      if (next.length === 0) {
        for (var i = 0, l = 1000, closest = target; i < l; i++) {
          closest = closest.parent().closest('.folder');
          next = closest.next().find('a:first');

          if (next.length) {
            break;
          }
        }
      } // Another check for disabled


      if (next.hasClass('is-disabled')) {
        next = this.getNextNode(next);
      }

      return next;
    },
    getPreviousNode: function getPreviousNode(target) {
      var prev = target.parent().prev().find('a:first');
      var subTarget = prev.parent(); // Move into children at bottom

      if (subTarget.is('.folder.is-open') && subTarget.find('ul.is-open a').length && !subTarget.find('ul.is-disabled').length) {
        prev = subTarget.find('ul.is-open a:last');
      } // Skip disabled


      if (prev.hasClass('is-disabled')) {
        prev = prev.parent().prev().find('a:first'); // Another check if get to prev open folder

        subTarget = prev.parent();

        if (subTarget.is('.folder.is-open') && subTarget.find('ul.is-open a').length && !subTarget.find('ul.is-disabled').length) {
          prev = subTarget.find('ul.is-open a:last');
        }
      } // Top of a group


      if (prev.length === 0) {
        prev = target.closest('ul').prev('a');
      } // Another check for disabled


      if (prev.hasClass('is-disabled')) {
        prev = this.getPreviousNode(prev);
      }

      return prev;
    },

    /**
     * Sync the tree with the underlying dataset
     * @private
     * @param {object} node the jQuery element to sync (Optional)
     * @returns {void}
     */
    syncDataset: function syncDataset(node) {
      var json = [];
      var self = this;
      node = node || this.element;
      var items = [].slice.call(node.children('li').toArray());
      items.forEach(function (li) {
        var a = li.querySelector('a');

        if (a) {
          json.push(self.syncNode(a));
        }
      });
      this.settings.dataset = json;
      this.element.triggerHandler('rendered', {
        data: this.settings.dataset
      });
    },

    /**
     * Sync a node with its dataset record
     * @private
     * @param {object} node The node to sync (jQuery or DOM element)
     * @returns {object} synced node data
     */
    syncNode: function syncNode(node) {
      var self = this;
      var entry;
      var nodeJQ = this.isjQuery(node) ? node : $(node);
      node = nodeJQ[0];

      if (node) {
        var parent = node.parentNode;

        var hasClass = function hasClass(el, className) {
          return DOM.hasClass(el, className);
        };

        entry = {
          node: nodeJQ,
          id: node.getAttribute('id'),
          text: node.querySelector('.tree-text').textContent
        }; // Is folder open

        if (hasClass(node, 'is-open') || parent && parent.tagName.toLowerCase() === 'li' && hasClass(parent, 'is-open')) {
          entry.open = true;
        } // Href


        var href = node.getAttribute('href');

        if (href) {
          entry.href = href;
        } // Selected


        if (hasClass(parent, 'is-selected')) {
          entry.selected = true;
        } // Disabled


        if (hasClass(node, 'is-disabled')) {
          entry.disabled = true;
        } // Icon


        var classAttribute = node.getAttribute('class');

        if (classAttribute && classAttribute.indexOf('icon') > -1) {
          entry.icon = classAttribute;
        } // Children


        var ul = nodeJQ.next();

        if (ul[0] && ul[0].tagName.toLowerCase() === 'ul') {
          entry.children = [];
          var items = [].slice.call(ul.children('li').toArray());
          items.forEach(function (li) {
            var a = li.querySelector('a');

            if (a) {
              entry.children.push(self.syncNode(a));
            }
          });
        } // Merge json data


        var jsonData = nodeJQ.data('jsonData');

        if (jsonData) {
          delete jsonData.selected;
          delete jsonData.children;
          entry = $.extend({}, jsonData, entry);
        }

        var autoAttr = utils.parseSettings(nodeJQ, 'data-automation-attributes');

        if (autoAttr.attributes && jsonData) {
          utils.extend(jsonData, autoAttr);
          this.addAutomationAttributes(nodeJQ, jsonData);
        }

        nodeJQ.data('jsonData', entry);
      }

      return entry;
    },

    /**
    * Add automation attributes to given link items.
    * @param {jQuery} a The main link href node.
    * @param {object} nodeData The node data.
    * @returns {void}
    */
    addAutomationAttributes: function addAutomationAttributes(a, nodeData) {
      a = this.isjQuery(a) ? a : $(a);

      if (a.length && nodeData.attributes) {
        var textEl = a.find('.tree-text');
        var iconTree = a.find('.icon-tree');
        var iconExpandTarget = a.find('.icon-expand-target');
        var checkbox = a.find('.tree-checkbox');
        utils.addAttributes(a, this, nodeData.attributes, 'tree-link');
        utils.addAttributes(textEl, this, nodeData.attributes, 'tree-link-text');
        utils.addAttributes(iconTree, this, nodeData.attributes, 'tree-icon');
        utils.addAttributes(iconExpandTarget, this, nodeData.attributes, 'tree-icon-expand-target');
        utils.addAttributes(checkbox, this, nodeData.attributes, 'tree-checkbox');
      }
    },

    /**
     * Add a node and all its related markup.
     * @param {object} nodeData to add.
     * @param {object} location in tree.
     * @param {string} isBeforeOrAfter to insert node before or after selected tree node.
     * @returns {object} li added
     */
    // Parameter added - to add node before or after the node
    addNode: function addNode(nodeData, location, isBeforeOrAfter) {
      var self = this;
      var selectedOptionText;
      var selectHtml;
      var option;
      var badgeAttr = _typeof(nodeData.badge) === 'object' ? JSON.stringify(nodeData.badge) : nodeData.badge;
      nodeData.href = typeof nodeData.href !== 'undefined' ? nodeData.href : '#';
      location = !location ? 'bottom' : location; // supports button or top or jquery node

      var a = document.createElement('a');

      if (typeof nodeData.id !== 'undefined') {
        a.setAttribute('id', nodeData.id);
      }

      a.setAttribute('href', nodeData.href);

      if (typeof badgeAttr !== 'undefined') {
        a.setAttribute('data-badge', badgeAttr);
      }

      if (typeof nodeData.alertIcon !== 'undefined') {
        a.setAttribute('data-alert-icon', nodeData.alertIcon);
      }

      if (nodeData.text) {
        a.textContent = xssUtils.unescapeHTML(nodeData.text);
      }

      if (nodeData.disabled) {
        DOM.addClass(a, 'is-disabled');
      }

      if (nodeData.icon) {
        DOM.addClass(a, nodeData.icon);
      }

      var li = document.createElement('li');
      li.setAttribute('role', 'none');

      if (nodeData.open) {
        DOM.addClass(li, 'is-open');
      }

      li.appendChild(a); // Insert dropdown start

      if (nodeData.type === 'dropdown') {
        a.setAttribute('style', 'display: none');

        if (nodeData.data) {
          selectHtml = '<select class="dropdown" close-on-select="true">';

          for (var i = 0; i < nodeData.data.length; i++) {
            option = nodeData.data[i];

            if (option.value === nodeData.text) {
              selectedOptionText = option.text;
              selectHtml += "<option value=\"".concat(option.value, "\" selected>").concat(option.text, "</option>");
            } else {
              selectHtml += "<option value=\"".concat(option.value, "\">").concat(option.text, "</option>");
            }
          }

          selectHtml += "</select><div class=\"dropdown-wrapper\"><div class=\"dropdown\"><span>".concat(selectedOptionText);
          selectHtml += '</span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use href="#icon-dropdown"></use></svg></div>';
          $("<div class=\"treeDropdown\" style=\"width: 80px; margin-left: 35px; margin-bottom: -15px\">".concat(selectHtml, "</div>")).appendTo(li);

          if (nodeData.disabled) {
            $(li).find('select.dropdown').dropdown().disable();
          } else {
            $(li).find('select.dropdown').dropdown().on('selected.tree', function () {
              var nodeToUpdate = self.findById(this.parentElement.previousElementSibling.id);
              nodeToUpdate.text = this.value;
              self.updateNode(nodeToUpdate);
            });
          }
        }
      } // Insert dropdown end
      // Handle Location


      var found = this.loading ? true : this.addToDataset(nodeData, location);

      if (nodeData.parent instanceof jQuery) {
        found = true;
      } // Insert node in between the node


      if (location) {
        var locationToAdd;

        if (typeof location === 'string' && !/^(top|bottom|before|after)$/g.test(location)) {
          locationToAdd = $(/\.|#/.test(location[0]) ? location : "#".concat(location)).first();
        } else {
          locationToAdd = location instanceof jQuery ? location : $(location);
        }

        if (locationToAdd.length) {
          if (isBeforeOrAfter === 'before') {
            $(li).insertBefore(locationToAdd.is('li') ? locationToAdd : locationToAdd.closest('li'));
            found = true;
          }

          if (isBeforeOrAfter === 'after') {
            $(li).insertAfter(locationToAdd.is('li') ? locationToAdd : locationToAdd.closest('li'));
            found = true;
          }

          if (isBeforeOrAfter === 'top' && locationToAdd.is('ul')) {
            locationToAdd.prepend(li);
            found = true;
          }
        }
      }

      if (location instanceof jQuery && (!nodeData.parent || !found) && !(nodeData.parent instanceof jQuery) && !/^(top|bottom|before|after)$/g.test(isBeforeOrAfter)) {
        location[0].appendChild(li);
        found = true;
      }

      if (location === 'bottom' && (!nodeData.parent || !found)) {
        this.element[0].appendChild(li);
      }

      if (location === 'top' && (!nodeData.parent || !found)) {
        this.element.prepend(li);
      } // Support ParentId in JSON Like jsTree


      if (nodeData.parent) {
        var _locationToAdd = location === 'top' ? location : null;

        if (found && typeof nodeData.parent === 'string') {
          li = this.element.find("#".concat(nodeData.parent)).parent();

          if (!nodeData.disabled && li.is('.is-selected') && typeof nodeData.selected === 'undefined') {
            nodeData.selected = true;
          }

          this.addAsChild(nodeData, li, _locationToAdd);
        }

        if (nodeData.parent && nodeData.parent instanceof jQuery) {
          li = nodeData.parent;

          if (nodeData.parent.is('a')) {
            li = nodeData.parent.parent();
          }

          this.addAsChild(nodeData, li, _locationToAdd);
        }

        if (this.isjQuery(li)) {
          nodeData.node = li.find("ul li a#".concat(nodeData.id));
        }
      } else {
        if (typeof nodeData.tempidsparent !== 'undefined') {
          nodeData.parent = nodeData.tempidsparent;
          delete nodeData.tempidsparent;
        }

        li = $(li);
        this.addChildNodes(nodeData, li);
        nodeData.node = li.children('a').first();
      }

      a = $(a); // Added parameter to show or hide checkbox according to node.

      this.decorateNode(a, nodeData.icon, nodeData.hideCheckbox, nodeData);
      this.childrenCountInit(a.parentsUntil(this.element, '.folder:last'));

      if (nodeData.selected) {
        this.selectNode(a, nodeData.focus);
      }

      a.data('jsonData', nodeData);
      this.addAutomationAttributes(a, nodeData);
      this.createSortable();
      return li;
    },

    /**
     * Add a node to an existing node, making it a folder if need be
     * @private
     * @param {object} nodeData data for node to be added.
     * @param {object} li parent node to add node.
     * @param {string} location top|bottom optional.
     * @returns {void}
     */
    addAsChild: function addAsChild(nodeData, li, location) {
      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');
      var isFolder = !!ul;

      if (!isFolder) {
        li.insertAdjacentHTML('beforeend', '<ul class="folder" role="group"></ul>');
        ul = li.querySelector('ul');
      }

      if (nodeData.open) {
        DOM.addClass(ul, 'is-open');
      }

      if (!isFolder) {
        this.decorateNode(li.querySelector('a'));
      }

      if (typeof nodeData.parent !== 'undefined') {
        nodeData.tempidsparent = nodeData.parent;
      }

      nodeData.parent = '';
      this.addNode(nodeData, $(ul), location);
    },

    /**
     * Add the children for the specified node element,
     * and if `nodeData.children` not passed will remove current children from node
     * @private
     * @param {object} nodeData data for children to be added.
     * @param {object} li parent node to add children.
     * @returns {void}
     */
    addChildNodes: function addChildNodes(nodeData, li) {
      var _this7 = this;

      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');

      if (!nodeData.children) {
        if (ul) {
          ul.parentNode.removeChild(ul);
        }

        return;
      }

      if (!ul) {
        li.insertAdjacentHTML('beforeend', "<ul class=\"folder".concat(nodeData.open ? ' is-open' : '', "\" role=\"group\"></ul>"));
        ul = li.querySelector('ul');
      }

      ul.innerHTML = '';

      if (nodeData.children) {
        nodeData.children.forEach(function (elem) {
          return _this7.addNode(elem, $(ul));
        });
      }
    },
    // Check for true value
    isTrue: function isTrue(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === true || typeof v === 'string' && v.toLowerCase() === 'true');
    },
    // Check for false value
    isFalse: function isFalse(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === false || typeof v === 'string' && v.toLowerCase() === 'false');
    },

    /**
     * Update fx rename a node.
     * @param {object} nodeData to update.
     * @returns {void}
     */
    updateNode: function updateNode(nodeData) {
      // Passed in the node element or find the node in the dataset and ui and sync it
      var elem = nodeData.node ? {
        node: nodeData.node
      } : this.findById(nodeData.id);

      if (!elem || !elem.node[0]) {
        return;
      }

      var parent = elem.node[0].parentNode;
      var nodetext = elem.node[0].querySelector('.tree-text');
      var isDisabled = this.isTrue(nodeData.disabled) || this.isFalse(nodeData.enabled);
      var isEnabled = this.isTrue(nodeData.enabled) || this.isFalse(nodeData.disabled);
      var isChildrenNull = nodeData.children === null; // Update badge

      if (nodeData.badge) {
        var badge = elem.node[0].querySelector('.tree-badge');

        if (!badge && !nodeData.badge.remove) {
          if (typeof nodeData.badge.text !== 'undefined' && $.trim(nodeData.badge.text) !== '') {
            var newBadge = document.createElement('span');
            DOM.addClass(newBadge, 'tree-badge', 'badge');
            nodetext.parentNode.insertBefore(newBadge, nodetext);
            badge = elem.node[0].querySelector('.tree-badge');
          }
        } // Make update changes


        if (badge) {
          if (typeof nodeData.badge.text !== 'undefined') {
            nodeData.badge.text = nodeData.badge.text.toString();
            badge.textContent = nodeData.badge.text;
            DOM.removeClass(badge, 'round');

            if (nodeData.badge.text.length === 1) {
              DOM.addClass(badge, 'round');
            }
          }

          if (typeof nodeData.badge.type !== 'undefined') {
            DOM.removeClass(badge, 'info', 'good', 'error', 'alert', 'pending');

            if (/info|good|error|alert|pending/i.test(nodeData.badge.type)) {
              DOM.addClass(badge, nodeData.badge.type);
            } else if (nodeData.badge.type.charAt(0) === '#' && nodeData.badge.type.length === 7) {
              badge.style.backgroundColor = nodeData.badge.type;
            }

            if (nodeData.badge.type.indexOf('pending') !== -1) {
              badge.textContent = '';
            }
          }

          elem.badge = nodeData.badge; // Remove badge

          if (this.parseBool(nodeData.badge.remove)) {
            badge.parentNode.removeChild(badge);

            if (typeof elem.badge !== 'undefined') {
              delete elem.badge;
            }
          }
        }
      }

      if (nodeData.text) {
        nodetext.textContent = nodeData.text;
        elem.text = nodeData.text;
      }

      if (nodeData.icon === null) {
        var next = elem.node[0].nextElementSibling;

        if (next && next.tagName.toLowerCase() === 'ul') {
          this.setFolderIcon(elem.node[0], DOM.hasClass(next, 'is-open'), false, this.settings.expandPlusminusRotate);
        } else {
          this.setTreeIcon(elem.node[0].querySelector('svg.icon-tree'), 'icon-tree-node');
        }
      } else if (nodeData.icon) {
        this.setTreeIcon(elem.node[0].querySelector('svg.icon-tree'), nodeData.icon);
        elem.icon = nodeData.icon;
        var jsonData = elem.node.data('jsonData');

        if (jsonData) {
          jsonData.icon = nodeData.icon;
          elem.node.data('jsonData', jsonData);
        }
      } else if (nodeData.children && nodeData.children.length && !DOM.hasClass(parent, 'folder')) {
        this.convertFileToFolder(elem.node);
      }

      if (isDisabled) {
        DOM.addClass(elem.node[0], 'is-disabled');
        elem.node[0].setAttribute('aria-disabled', 'true');

        if (DOM.hasClass(parent, 'folder') && DOM.hasClass(parent, 'is-open')) {
          var nodes = [].slice.call(parent.querySelectorAll('a, ul[role=group]'));
          nodes.forEach(function (node) {
            DOM.addClass(node, 'is-disabled');
            node.setAttribute('aria-disabled', 'true');
          });
        }
      }

      if (isEnabled) {
        var isParentsDisabled = elem.node.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0;

        if (!isParentsDisabled) {
          DOM.removeClass(elem.node[0], 'is-disabled');
          elem.node[0].removeAttribute('aria-disabled');

          if (DOM.hasClass(parent, 'folder') && DOM.hasClass(parent, 'is-open')) {
            var _nodes = [].slice.call(parent.querySelectorAll('a, ul[role=group]'));

            _nodes.forEach(function (node) {
              DOM.removeClass(node, 'is-disabled');
              node.removeAttribute('aria-disabled');
            });
          }
        }
      }

      if (nodeData.childrenCount) {
        this.updateChildrenCount(elem.node[0], nodeData.childrenCount);
      }

      if (nodeData.node) {
        this.syncDataset();
      } // children: null|[] - To remove children key/value and show as leaf node, has to pass children property and value can be `null` or `[] -an empty array`.


      if (nodeData.children || isChildrenNull) {
        var _nodeData$children;

        if ((_nodeData$children = nodeData.children) !== null && _nodeData$children !== void 0 && (_nodeData$children == null ? void 0 : _nodeData$children.length)) {
          this.addChildNodes(nodeData, parent);
        } else {
          this.removeChildren(nodeData, parent);
        }
      }

      this.syncDataset();
      this.createSortable();
    },
    // Performs the usual Boolean coercion with the exception of
    // the strings "false" (case insensitive) and "0"
    parseBool: function parseBool(b) {
      return !/^(false|0)$/i.test(b) && !!b;
    },

    /**
     * Delete children nodes
     * @private
     * @param {object} nodeData data for icon to be replaced.
     * @param {object} li parent node to delete children.
     * @returns {void}
     */
    removeChildren: function removeChildren(nodeData, li) {
      li = this.isjQuery(li) ? li[0] : li;
      var ul = li.querySelector('ul');
      this.setTreeIcon(li.querySelector('svg.icon-tree'), nodeData.icon || 'icon-tree-node');
      DOM.removeClass(li, 'folder', 'is-open');

      if (ul) {
        ul.parentNode.removeChild(ul);
      }
    },

    /**
     * Delete a node from the dataset or tree.
     * @param {object} nodeData to delete.
     * @returns {void}
     */
    removeNode: function removeNode(nodeData) {
      var elem = this.findById(nodeData.id);
      var targetNode = null;

      if (nodeData instanceof jQuery) {
        elem = nodeData;
        targetNode = elem.parentsUntil(this.element, '.folder:last');
        elem.parent().remove();
      } else if (elem) {
        targetNode = elem.node.parentsUntil(this.element, '.folder:last');
        elem.node.parent().remove();
      }

      this.childrenCountInit(targetNode);

      if (!elem) {
        return;
      }

      this.syncDataset();
    },
    // Attach Context Menus
    attachMenu: function attachMenu(menuId) {
      var self = this;

      if (!menuId) {
        return;
      } // Handle focus state after closing contextmenu


      function returnFocus(popupmenuApi, args) {
        if (typeof $(':focus')[0] === 'undefined' && args !== null && args !== void 0 && (args == null ? void 0 : args.triggerElement)) {
          args.triggerElement.focus();
        }
      }

      this.element.off('contextmenu.tree').on('contextmenu.tree', 'a', function (e) {
        var node = $(this);
        e.preventDefault();
        self.popupEl = $(e.currentTarget).popupmenu({
          menuId: menuId,
          eventObj: e,
          trigger: 'immediate',
          attachToBody: true,
          returnFocus: returnFocus
        }).off('selected').on('selected', function (event, args) {
          /**
          * Fires when the an attached context menu item is selected.
          *
          * @event menuselect
          * @memberof Tree
          * @type {object}
          * @property {object} event - The jquery event object
          * @property {object} args for node element, item
          * @property {HTMLElement} args.node The DOM Element.
          * @property {object} data.item The attached node data.
          */
          self.element.triggerHandler('menuselect', {
            node: node,
            item: args
          });
        });
        /**
        * Fires when the attached context menu is opened. Use it to update the menu as needed
        * @memberof Tree
        * @event menuopen
        * @type {object}
        * @property {object} event - The jquery event object
        * @property {object} args for node element, item
        * @property {HTMLElement} args.menu The menu item
        * @property {HTMLElement} args.node The DOM Element.
        */

        self.element.triggerHandler('menuopen', {
          menu: $("#".concat(menuId)),
          node: node
        });
        return false;
      });
    },

    /**
     * Create sortable.
     * @private
     * @returns {void}
     */
    createSortable: function createSortable() {
      if (!this.settings.sortable) {
        return;
      }

      var self = this;
      var clone;
      var interval;
      var doDrag;
      self.targetArrow = self.element[0].previousElementSibling;
      self.linkSelector = 'a:not(.is-dragging-clone):not(.is-disabled)';

      if (!self.targetArrow || self.targetArrow && !DOM.hasClass(self.targetArrow, 'tree-drag-target-arrow')) {
        var div = document.createElement('div');
        DOM.addClass(div, 'tree-drag-target-arrow');
        self.element[0].parentNode.insertBefore(div, self.element[0]);
        self.targetArrow = self.element[0].previousElementSibling;
      }

      function isReady() {
        // Make sure all dynamic nodes sync
        if (!self.loading) {
          clearInterval(interval);
          var links = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
          links.forEach(function (link) {
            var a = $(link); // Quit if already binded with `drag`

            if (a.data('drag')) {
              return;
            } // Don't drag with folder icon, save for toggle nodes


            a.on('mousedown.tree', function (e) {
              e.preventDefault();

              if (e.which === 3) {
                doDrag = false;
              } else {
                doDrag = DOM.hasClass(e.target, 'icon') ? !DOM.hasClass(link.parentNode, 'folder') : true;
              }
            }) // Invoke drag
            .drag({
              clone: true,
              cloneAppendTo: a.closest('li'),
              clonePosIsFixed: true
            }) // Drag start =======================================
            .on('dragstart.tree', function (e, pos, thisClone) {
              if (!thisClone || !doDrag) {
                DOM.removeClass(link, 'is-dragging');

                if (thisClone) {
                  thisClone[0].parentNode.removeChild(thisClone[0]);
                }

                return;
              }

              clone = thisClone;
              clone[0].removeAttribute('id');
              DOM.addClass(clone[0], 'is-dragging-clone');
              var items = [].slice.call(clone[0].querySelectorAll('.tree-checkbox, .tree-badge'));
              items.forEach(function (node) {
                return node.parentNode.removeChild(node);
              });
              var startUl = a.closest('ul');
              self.sortable = {
                // Do not use index from each loop, get updated index on drag start
                startIndex: $(self.linkSelector, self.element).index(a),
                startNode: a,
                startIcon: $('svg.icon-tree', a).getIconName(),
                startUl: startUl,
                startLi: a.closest('li'),
                startFolderNode: startUl.prev('a'),
                startWidth: a.outerWidth()
              };
              self.element.triggerHandler('sortstart', self.sortable);
              e.preventDefault();
              e.stopImmediatePropagation();
            }) // While dragging ===================================
            .on('drag.tree', function (e, pos) {
              if (!clone) {
                return;
              }

              clone[0].style.left = "".concat(pos.left, "px");
              clone[0].style.top = "".concat(pos.top, "px");
              clone[0].style.opacity = '1';
              self.setDragOver(clone, pos);
            }) // Drag end =========================================
            .on('dragend.tree', function (e, pos) {
              var _self$sortable;

              self.targetArrow.style.display = 'none';
              var items = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
              items.forEach(function (node) {
                return DOM.removeClass(node, 'is-over');
              });

              if (!clone || !((_self$sortable = self.sortable) !== null && _self$sortable !== void 0 && (_self$sortable == null ? void 0 : _self$sortable.overDirection))) {
                return;
              }

              clone[0].style.left = "".concat(pos.left, "px");
              clone[0].style.top = "".concat(pos.top, "px");
              var start = self.sortable.startNode.parent();
              var end = self.sortable.overNode.parent(); // Over

              if (self.sortable.overDirection === 'over') {
                if (!DOM.hasClass(end[0], 'folder')) {
                  self.convertFileToFolder(self.sortable.overNode);
                }

                end[0].querySelector('ul').appendChild(start[0]);

                if (!DOM.hasClass(end[0], 'is-open')) {
                  self.toggleNode(self.sortable.overNode, e);
                }
              } else if (self.sortable.overDirection === 'up') {
                // Up
                start.insertBefore(end);
              } else if (self.sortable.overDirection === 'down') {
                // Down
                if (DOM.hasClass(end[0], 'is-open') && DOM.hasClass(end[0], 'folder')) {
                  $('ul:first', end).prepend(start);
                } else {
                  start.insertAfter(end);
                }
              } // Restore file type


              if (!self.sortable.startUl[0].querySelector('li') && !!self.sortable.startFolderNode.data('oldData') && self.sortable.startFolderNode.data('oldData').type === 'file') {
                self.convertFolderToFile(self.sortable.startFolderNode);
              } // Fix: On windows 10 with IE-11 icons disappears


              utils.fixSVGIcons(start);
              self.element.triggerHandler('sortend', self.sortable); // Sync dataset and ui

              self.syncDataset();

              if (self.isMultiselect) {
                self.initSelected();
              }

              self.updateAutoChildrenCount(self.element[0]);
              delete self.sortable;
            });
          });
        }
      } // Wait for make sure all dynamic nodes sync


      interval = setInterval(isReady, 10);
    },

    /**
     * Set actions while drag over.
     * @private
     * @param {object} clone node.
     * @param {object} pos node positions to compare.
     * @returns {void}
     */
    setDragOver: function setDragOver(clone, pos) {
      var self = this;
      var cloneSvg = clone[0].querySelector('svg.icon-tree');
      var treeRec = self.element[0].getBoundingClientRect();
      var extra = 20;
      var exMargin;
      var isParentsStartNode;
      var isBeforeStart;
      var isAfterSttart;
      var li;
      var a;
      var ul;
      var links;
      var rec;
      var left;
      var top;
      var direction;
      var doAction;

      if (!self.sortable) {
        return;
      } // Set as out of range


      var outOfRange = function outOfRange() {
        self.sortable.overNode = null;
        self.sortable.overIndex = null;
        self.sortable.overDirection = null;
        self.targetArrow.style.display = 'none';
        self.setTreeIcon(cloneSvg, 'icon-cancel');
      }; // Moving inside tree


      if (pos.top > treeRec.top - extra && pos.top < treeRec.bottom + extra && pos.left > treeRec.left - extra - self.sortable.startWidth && pos.left < treeRec.left + treeRec.height + extra) {
        extra = 2;
        links = [].slice.call(self.element[0].querySelectorAll(self.linkSelector));
        links.forEach(function (link, i) {
          direction = null;
          rec = link.getBoundingClientRect(); // Moving on/around node range

          if (pos.top > rec.top - extra && pos.top < rec.bottom + extra) {
            a = $(link); // Moving on/around node has parents as same node need to rearrange
            // Cannot rearrange parents to child

            isParentsStartNode = !!a.parentsUntil(self.element, '.folder').filter(function () {
              return $('a:first', this).is(self.sortable.startNode) && self.sortable.startLi.is('.folder');
            }).length;

            if (isParentsStartNode) {
              outOfRange();
              return;
            }

            li = link.parentNode;
            left = rec.left;
            ul = a.closest('ul');
            exMargin = parseInt(li.style.marginTop, 10) > 0 ? 2 : 0;
            isBeforeStart = i - 1 === self.sortable.startIndex && ul.is(self.sortable.startUl);
            isAfterSttart = i + 1 === self.sortable.startIndex && ul.is(self.sortable.startUl);
            links.forEach(function (node) {
              return DOM.removeClass(node, 'is-over');
            }); // Apply actions

            /* eslint-disable no-loop-func */

            doAction = function doAction() {
              if (!direction) {
                outOfRange();
                return;
              } // Reset icon


              self.setTreeIcon(cloneSvg, self.sortable.startIcon); // Over

              if (direction === 'over') {
                self.targetArrow.style.display = 'none';

                if (!DOM.hasClass(link, 'is-disabled')) {
                  DOM.addClass(link, 'is-over');
                }
              } else {
                // Up -or- Down
                links.forEach(function (node) {
                  return DOM.removeClass(node, 'is-over');
                });
                top = direction === 'up' ? rec.top - 1.5 - (DOM.hasClass(li, 'is-active') ? 3 : 0) : rec.bottom + (li.nextElementSibling && DOM.hasClass(li.nextElementSibling, 'is-active') ? -1 : 1.5) + exMargin;
                self.targetArrow.style.left = "".concat(left, "px");
                self.targetArrow.style.top = "".concat(top, "px");
                self.targetArrow.style.display = 'block';
              } // Set changes


              self.sortable.overNode = a;
              self.sortable.overIndex = i;
              self.sortable.overDirection = direction;
            };
            /* eslint-disable no-loop-func */
            // Set moveing directions


            if (i !== self.sortable.startIndex) {
              // If hover on link
              if (pos.left > rec.left - extra - self.sortable.startWidth && pos.left < rec.right + extra) {
                if (!isBeforeStart && pos.top < rec.top) {
                  direction = 'up';
                } else if (!isAfterSttart && pos.top > rec.top + extra * 2) {
                  direction = 'down';
                } else {
                  direction = 'over';
                }
              } else if (!isBeforeStart && pos.top < rec.top) {
                // Not hover on link
                direction = 'up';
              } else if (!isAfterSttart) {
                direction = 'down';
              }
            }

            doAction(direction);
          }
        });
      } else {
        // Out side from tree area
        outOfRange();
      }
    },
    // Convert file node to folder type
    convertFileToFolder: function convertFileToFolder(node) {
      var iconEl = $('svg.icon-tree', node);
      var newFolder = document.createElement('ul');
      newFolder.setAttribute('role', 'group');
      DOM.addClass(newFolder, 'folder');
      var oldData = {
        icon: iconEl.getIconName(),
        type: 'file'
      };

      if (this.hasIconClass(node)) {
        var iconClass = node.attr('class').replace(/\s?is-selected/, '');
        oldData.iconClass = iconClass;

        if (!this.settings.useExpandTarget) {
          node.removeClass(iconClass);
        }
      }

      node.data('oldData', oldData);
      var parent = node[0].parentNode;

      if (parent && parent.tagName.toLowerCase() === 'li') {
        DOM.addClass(parent, 'folder');
        parent.appendChild(newFolder);
      } // Inject expand target


      iconEl[0].insertAdjacentHTML('afterend', this.getExpandTargetHtml(false)); // Inject children count

      node[0].insertAdjacentHTML('beforeend', this.getChildrenCountHtml());
      this.setTreeIcon(iconEl, this.settings.folderIconClosed);
    },
    // Convert folder node to file type
    convertFolderToFile: function convertFolderToFile(node) {
      var parent = node.parent('.folder');
      parent.removeClass('folder is-open');
      $('.icon-expand-target, .tree-children-count', node).remove();
      $('ul:first', parent).remove();

      if (parent.length) {
        this.setTreeIcon($('svg.icon-tree', node), node.data('oldData') ? node.data('oldData').icon : 'tree-node');

        if (node.data('oldData') && node.data('oldData').iconClass) {
          node.addClass(node.data('oldData').iconClass);
        }

        node.data('oldData', null);
      }
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      if (this.settings.sortable) {
        this.element.find('a').each(function () {
          var a = $(this);
          var dragApi = a.data('drag');
          a.off('mousedown.tree');

          if (!!dragApi && !!dragApi.destroy) {
            dragApi.destroy();
          }
        });
        this.element.prev('.tree-drag-target-arrow').remove();
      }

      this.element.off('contextmenu.tree updated.tree click.tree focus.tree keydown.tree keypress.tree');
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, TREE_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      this.element.empty();
      $.removeData(this.element[0], COMPONENT_NAME$1a);
    },

    /**
     * Disables all nodes in the Tree component
     * @returns {void}
     */
    disable: function disable() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));
      nodes.forEach(function (node) {
        DOM.addClass(node, 'is-disabled');
        node.setAttribute('aria-disabled', 'true');
      });
    },

    /**
     * Enables all nodes in the Tree component
     * @returns {void}
     */
    enable: function enable() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));
      nodes.forEach(function (node) {
        DOM.removeClass(node, 'is-disabled');
        node.removeAttribute('aria-disabled');
      });
    },

    /**
     * Preserves all nodes' enablement states in the Tree component
     * @returns {array} of node objects containing attributes nodeId and state (enablement state)
     */
    preserveEnablementState: function preserveEnablementState() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('a'));
      var enablementStates = [];
      nodes.forEach(function (node) {
        if (DOM.hasClass(node, 'is-disabled') || node.getAttribute('aria-disabled') === true) {
          enablementStates.push({
            nodeId: node.id,
            state: 'disabled'
          });
        } else {
          enablementStates.push({
            nodeId: node.id,
            state: 'enabled'
          });
        }
      });
      this.settings.originalEnablementState = enablementStates;
      return enablementStates;
    },

    /**
     * Restores all nodes' original enablement states in the Tree component
     * @returns {void}
     */
    restoreEnablementState: function restoreEnablementState() {
      var s = this.settings;
      var nodes = [].slice.call(this.element[0].querySelectorAll('a')); // check to prevent error if preserveEnablementState() has not been invoked

      if (typeof s.originalEnablementState !== 'undefined' && s.originalEnablementState !== null) {
        nodes.forEach(function (node) {
          s.originalEnablementState.forEach(function (origNode) {
            if (origNode.nodeId === node.id) {
              if (origNode.state === 'disabled') {
                DOM.addClass(node, 'is-disabled');
                node.setAttribute('aria-disabled', 'true');
              } else {
                DOM.removeClass(node, 'is-disabled');
                node.removeAttribute('aria-disabled');
              }
            }
          });
        });
      }
    }
  };

  /**
   * jQuery Component Wrapper for Tree
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.tree = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1a);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1a, new Tree(this, settings));
      }
    });
  };

  /* eslint-disable no-underscore-dangle */

  var COMPONENT_NAME$1b = 'treemap'; // Default Radar Options

  var TREEMAP_DEFAULTS = {
    dataset: [],
    redrawOnResize: true,
    margin: {
      top: 20,
      right: 20,
      bottom: 20,
      left: 20
    },
    colors: null,
    showLabel: true,
    labelFormatter: '.0%',
    showTitle: true,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data'
    }
  };
  /**
   * A treemap chart is a diagram representing hierarchical data in the form of nested rectangles,
   * the area of each corresponding to its numerical value.
   * @class Treemap
   * @param {string} element The plugin element for the constuctor
   * @param {string} settings The settings element.
   * @param {array} settings.dataset The data to use in the radar
   * @param {boolean} [settings.redrawOnResize = true] If false, the component will not resize when resizing the page.
   * @param {object} [settings.margin] The margins of the SVG, which you may want to adjust depending on text location.
   * @param {array} [settings.colors] An array of colors used in sequence from front to end of the array.
   * @param {boolean} [settings.showLabel] If false then the percentage wont be shown in the blocks.
   * @param {string} [settings.labelFormatter] The d3 formatter function for the value label.
   * @param {boolean} [settings.showTitle] If true then the first name will be used for the title area.
   * @param {object} [settings.emptyMessage] An empty message will be displayed when there is no chart data.
   * This accepts an object of the form emptyMessage:
   * `{title: 'No Data Available',
   *  info: 'Make a selection on the list above to see results', icon: 'icon-empty-no-data',
   *  button: {text: 'xxx', click: <function>}
   *  }`
   * Set this to null for no message or will default to 'No Data Found with an icon.'
   * @param {string} [settings.attributes] Add extra attributes like id's to the chart elements. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  function Treemap(element, settings) {
    this.settings = utils.mergeSettings(element, settings, TREEMAP_DEFAULTS);

    if (settings && settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    this.element = $(element);
    this.init();
  } // Plugin Methods


  Treemap.prototype = {
    /**
     * Do initialization, build up and / or add events ect.
     * @private
     * @returns {object} The component prototype for chaining.
     */
    init: function init() {
      this.build().handleEvents();
      /**
      * Fires when the chart is complete done rendering, for customization.
      * @event rendered
      * @memberof Treemap
      * @property {object} event - The jquery event object
      * @property {array} svg - The svg object.
      */

      this.element.trigger('rendered', [this.svg]);
      return this;
    },

    /**
     * Build the Component.
     * @returns {object} The component prototype for chaining.
     * @private
     */
    build: function build() {
      this.setupColors();
      this.updateData(this.settings.dataset);
      return this;
    },

    /**
     * Generate internal color variables.
     * @private
     */
    setupColors: function setupColors() {
      if (!this.settings.colors || this.useBuiltInColors) {
        var palette = theme.themeColors().palette;
        this.settings.colors = [palette.azure['100'].value, palette.azure['90'].value, palette.azure['80'].value, palette.azure['70'].value, palette.azure['60'].value, palette.azure['40'].value, palette.azure['30'].value, palette.azure['20'].value, palette.amethyst['100'].value, palette.amethyst['90'].value, palette.amethyst['80'].value, palette.amethyst['70'].value, palette.amethyst['60'].value, palette.amethyst['50'].value, palette.amethyst['40'].value, palette.amethyst['40'].value, palette.amethyst['30'].value, palette.amethyst['20'].value, palette.turquoise['100'].value, palette.turquoise['90'].value, palette.turquoise['80'].value, palette.turquoise['70'].value, palette.turquoise['60'].value, palette.turquoise['50'].value, palette.turquoise['40'].value, palette.turquoise['40'].value, palette.turquoise['30'].value, palette.turquoise['20'].value];
        this.useBuiltInColors = true;
      }
    },

    /**
     * Update the chart with a new dataset
     * @param  {object} data The data to use.
     */
    updateData: function updateData(data) {
      var _this = this;

      var margin = Object.create(this.settings.margin);
      var width = this.element.parent().width() - margin.left - margin.right;
      var height = this.element.parent().height() - margin.top - margin.bottom; // Define the colors

      var color = d3.scaleOrdinal().range(this.settings.colors); // Handle Empty Data Set

      if (data.length === 0) {
        this.element.emptymessage(this.settings.emptyMessage);
        return;
      }

      utils.addAttributes(this.element, data, this.settings.attributes, '', true); // Show the title area

      if (this.settings.showTitle && data.name) {
        d3.select(this.element[0]).append('div').attr('class', 'chart-treemap-title').text(data.name);
        height -= 35;
        margin.top -= 19;
      } // Run the d3 tree map algorithm


      var treemap = d3.treemap().size([width, height]); // Set the height / width and class

      this.root = d3.select(this.element[0]).classed('chart-treemap', true).append('div').style('position', 'relative').style('width', "".concat(width + margin.left + margin.right, "px")).style('height', "".concat(height + margin.top + margin.bottom, "px")).style('left', "".concat(margin.left, "px")).style('top', "".concat(margin.top, "px")); // Format the data into a hierarchy tree

      var root = d3.hierarchy(data, function (d) {
        return d.children;
      }).sum(function (d) {
        return d.value;
      });
      var tree = treemap(root);
      this.total = d3.sum(tree.leaves(), function (d) {
        return d.value;
      });
      var tooltipInterval;
      charts.appendTooltip(); // Add the tree map nodes

      this.root.datum(root).selectAll('.chart-treemap-node').data(tree.leaves()).enter().append('div').attr('class', 'chart-treemap-node').style('left', function (d) {
        return "".concat(d.x0, "px");
      }).style('top', function (d) {
        return "".concat(d.y0, "px");
      }).style('width', function (d) {
        return "".concat(Math.max(0, d.x1 - d.x0 - 1), "px");
      }).style('height', function (d) {
        return "".concat(Math.max(0, d.y1 - d.y0 - 1), "px");
      }).style('background', function (d) {
        if (!d || !d.parent || !d.parent.data) {
          return '';
        }

        return color(d.parent.data.name);
      }).call(function (d) {
        // Add id's to each slice
        d._groups.forEach(function (sections) {
          sections.forEach(function (section) {
            var _dat$data$name;

            var dat = section.__data__;
            utils.addAttributes($(section), dat, _this.settings.attributes, (_dat$data$name = dat.data.name) === null || _dat$data$name === void 0 ? void 0 : _dat$data$name == null ? void 0 : _dat$data$name.toLowerCase(), true);
          });
        });
      }).on('mouseenter.treemap', function (d) {
        var rect = this.getBoundingClientRect();
        var percentText = this.querySelector('.chart-treemap-percent').innerText;
        var content = d.parent.data.tooltip; // Only show if small

        if (!content && rect.width > 60 && rect.height > 50) {
          return;
        }

        if (!content) {
          content = "<p><b>".concat(d.data.name, " </b> ").concat(percentText, "</p>");
        } else {
          content = content.replace('%percent%', percentText);
          content = content.replace('{{percent}}', percentText);
        }

        var size = charts.tooltipSize(content);
        var posX = rect.left - size.width / 2 + 12;
        var posY = rect.top - size.height - 6;
        charts.showTooltip(posX, posY, content, 'top');
      }).on('mouseleave.treemap', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      });
      this.root.selectAll('.chart-treemap-node').append('span').attr('class', 'chart-treemap-text').text(function (d) {
        return d.data.name;
      });

      if (this.settings.showLabel) {
        this.root.selectAll('.chart-treemap-node').append('span').attr('class', 'chart-treemap-percent').text(function (d) {
          return d3.format(_this.settings.labelFormatter)(d.value / _this.total);
        });
      }
    },

    /**
     * Sets up event handlers for this component and its sub-elements.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      this.element.on("updated.".concat(COMPONENT_NAME$1b), function () {
        _this2.updated();
      });

      if (this.settings.redrawOnResize) {
        $('body').on("resize.".concat(COMPONENT_NAME$1b), function () {
          _this2.handleResize();
        });
        this.element.on("resize.".concat(COMPONENT_NAME$1b), function () {
          _this2.handleResize();
        });
      }

      $('html').on("themechanged.".concat(COMPONENT_NAME$1b), function () {
        _this2.updated();
      });
      return this;
    },

    /**
     * Handles resizing a chart.
     * @private
     * @returns {void}
     */
    handleResize: function handleResize() {
      if (this.width === this.element.width()) {
        return;
      }

      this.width = this.element.width();

      if (!this.element.is(':visible')) {
        return;
      }

      this.updated();
    },

    /**
     * Handle updated settings and values.
     * @param  {object} settings The new settings to use.
     * @returns {object} The api for chaining.
     */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      this.setupColors();
      this.element.empty();
      return this.build();
    },

    /**
     * Simple Teardown - remove events & rebuildable markup.
     * @private
     * @returns {object} The Component prototype, useful for chaining.
     */
    teardown: function teardown() {
      this.element.off("updated.".concat(COMPONENT_NAME$1b));
      $('body').off("resize.".concat(COMPONENT_NAME$1b));
      $('html').off("themechanged.".concat(COMPONENT_NAME$1b));
      return this;
    },

    /**
     * Teardown - Remove added markup and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.element.empty().removeClass('chart-treemap');
      charts.removeTooltip();
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$1b);
    }
  };

  /**
   * jQuery Component Wrapper for Tremmap
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.treemap = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1b);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1b, new Treemap(this, settings));
      }
    });
  };

  /**
   * jQuery Component Wrapper for WeekView
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.weekview = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$B);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$B, new WeekView(this, settings));
      }
    });
  };

  // Component Name

  var COMPONENT_NAME$1c = 'wizard'; // Component Default Settings

  var WIZARD_DEFAULTS = {
    ticks: null,
    ticksTemplate: '<a class="tick {{state}}" href="{{href}}"><span class="label" data-shortlabel="{{shortLabel}}">{{label}}</span></a>'
  };
  /**
   * A horizontal form based wizard component.
   * @class Wizard
   * @param {jQuery[]|HTMLElement} element the Wizard container
   * @param {object} [settings] incoming settings
   * @param {jQuery[]} [settings.ticks]  Defines the data to use, must be specified.
   */

  function Wizard(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, WIZARD_DEFAULTS);
    this.init();
  } // Plugin Methods


  Wizard.prototype = {
    /**
     * @private
     */
    init: function init() {
      this.namespace = utils.uniqueId({
        classList: [COMPONENT_NAME$1c]
      });
      this.build().handleEvents();
    },

    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      this.header = this.element.find('.wizard-header');

      if (!this.header.length) {
        this.header = $('<div class="wizard-header"></div>').appendTo(this.element);
      }

      this.bar = this.element.find('.bar');

      if (!this.bar.length) {
        this.bar = $('<div class="bar"></div>').appendTo(this.header);
      }

      this.completedRange = this.element.find('.completed-range');

      if (!this.completedRange.length) {
        this.completedRange = $('<div class="completed-range"></div>').appendTo(this.bar);
      }

      this.buildTicks().updateRange();
      return this;
    },

    /**
     * Builds the HTML Markup that draws out defined Wizard tick marks.
     * @private
     * @returns {this} component instance
     */
    buildTicks: function buildTicks() {
      var s = this.settings;
      this.ticks = this.bar.children('.tick');

      if (!this.ticks.length && s.ticks) {
        var replaceMatch = function replaceMatch(str, c) {
          return str.replace(/{{(\w+)}}/g, function (m, p) {
            return c[p];
          });
        };

        var defaultTick = {
          state: '',
          href: '#',
          label: ''
        };

        for (var i = 0; i < s.ticks.length; i++) {
          var linkStr = replaceMatch(s.ticksTemplate, $.extend({}, defaultTick, s.ticks[i]));
          linkStr = linkStr.replace(/(\s(\w|-)+=("|')?)?undefined("|')?/gim, '');
          var link = $(linkStr);

          if (s.ticks[i].ngClick) {
            link.attr('ng-click', s.ticks[i].ngClick);
          }

          this.bar.append(link);
        }

        this.ticks = this.bar.children('.tick');
      }

      this.positionTicks();
      this.setLabelsData();
      this.adjustLabels();
      this.ticks.toArray().forEach(function (tick) {
        if (tick.classList.contains('is-disabled')) {
          ['onclick', 'ng-click'].forEach(function (attr) {
            return tick.removeAttribute(attr);
          });
        }
      });
      this.header[0].style.opacity = '1';
      return this;
    },

    /**
     * Set the labels data to keep control in case overlapping.
     * @private
     * @returns {this} component instance
     */
    setLabelsData: function setLabelsData() {
      var _this = this;

      var labels = [].slice.call(this.bar[0].querySelectorAll('.label'));
      this.labels = [];
      labels.forEach(function (node) {
        var label = node.textContent;
        var shortLabel = node.getAttribute('data-shortlabel');

        if (!shortLabel) {
          shortLabel = node.getAttribute('shortlabel');
        }

        var data = {
          label: label,
          shortLabel: shortLabel,
          node: node,
          jqEl: $(node)
        };

        if (!shortLabel || shortLabel === 'undefined') {
          node.removeAttribute('data-shortlabel');
          node.removeAttribute('shortlabel');
          delete data.shortLabel;
        }

        _this.labels.push(data);
      });
      return this;
    },

    /**
     * Adjust the labels if overlapping.
     * @private
     * @returns {this} component instance
     */
    adjustLabels: function adjustLabels() {
      var _this2 = this;

      var headerRect = this.header[0].getBoundingClientRect();
      var barWidth = parseFloat(window.getComputedStyle(this.bar[0]).width);
      var availWidth = 100 / (this.labels.length - 1) / 100 * barWidth - 15;
      var usingShortLabel = [];
      var labelsToFix = []; // Reset given label

      var resetLabel = function resetLabel(label) {
        delete label.isEllipsis;
        label.node.classList.remove('is-ellipsis');
        label.node.style.width = '';

        _this2.removeTooltip(label);
      }; // Add the fix to overlaping labels


      var adjustLabel = function adjustLabel(idx) {
        var label = _this2.labels[idx].node;

        if (usingShortLabel.indexOf(idx) === -1) {
          var shortLabel = _this2.labels[idx].shortLabel;

          if (shortLabel) {
            // Use short labels
            label.textContent = shortLabel;
            usingShortLabel.push(idx);
            resetLabel(_this2.labels[idx]);
          } else {
            // Add ellipsis
            label.classList.add('is-ellipsis');
            label.style.width = "".concat(availWidth, "px");

            _this2.setTooltip(_this2.labels[idx]);

            _this2.labels[idx].isEllipsis = true;
          }
        }

        label.style.left = "-".concat((label.offsetWidth - label.parentNode.offsetWidth) / 2, "px");
      }; // Add the fix to first and last labels


      var adjustFirstAndLastLabels = function adjustFirstAndLastLabels() {
        var fixLabel = function fixLabel(label, diff, isLast) {
          if (label.isEllipsis) {
            var width = parseFloat(label.node.style.width) - diff;
            label.node.style.width = "".concat(width, "px");
            label.node.style.left = "-".concat((width - label.node.parentNode.offsetWidth) / 2, "px");
          } else {
            var left = parseFloat(label.node.style.left) + diff * (isLast ? -1 : 1);
            label.node.style.left = "".concat(left, "px");
          }
        }; // First


        var label = _this2.labels[0];
        var labelRect = label.node.rect || label.node.getBoundingClientRect();

        if (headerRect.left > labelRect.left) {
          fixLabel(label, headerRect.left - labelRect.left);
        } // Last


        label = _this2.labels[_this2.labels.length - 1];
        labelRect = label.node.rect || label.node.getBoundingClientRect();

        if (headerRect.right < labelRect.right) {
          fixLabel(label, labelRect.right - headerRect.right, true);
        }
      }; // Reset all the labels to start from default


      this.labels.forEach(function (label) {
        var node = label.node;
        node.textContent = label.label;
        node.style.left = "-".concat((node.offsetWidth - node.parentNode.offsetWidth) / 2, "px");
        resetLabel(label);
      });
      adjustFirstAndLastLabels(); // Check for overlap

      var overlap = function overlap(r1, r2) {
        return !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
      }; // Set the overlaping labels which need to fix


      var setLabelsToFix = function setLabelsToFix() {
        _this2.labels.forEach(function (label) {
          label.rect = label.node.getBoundingClientRect();
        });

        labelsToFix = [];

        for (var i = 0, l = _this2.labels.length; i < l; i++) {
          if (i < l - 1) {
            var i2 = i + 1;

            if (overlap(_this2.labels[i].rect, _this2.labels[i2].rect)) {
              labelsToFix.push([i, i2]);
            }
          }
        }
      }; // Extra check to not loop more then max times


      var max = 50; // Start to add fix if needed, will execute at least once

      do {
        setLabelsToFix();
        labelsToFix.forEach(function (arr) {
          var label1 = _this2.labels[arr[0]].node;
          var label2 = _this2.labels[arr[1]].node;
          var idx = label1.offsetWidth > label2.offsetWidth ? 0 : 1;
          var i = arr[idx];
          var i2 = idx ? arr[0] : arr[1];
          adjustLabel(i);

          if (overlap(_this2.labels[i].rect, _this2.labels[i2].rect)) {
            adjustLabel(i2);
          }
        });
        adjustFirstAndLastLabels();
        setLabelsToFix();
        max--;
      } while (labelsToFix.length && max > 0); // Check and fix first and last


      adjustFirstAndLastLabels(); // Clear the cached bounding rect

      this.labels.forEach(function (label) {
        delete label.isEllipsis;
        delete label.rect;
      });
      return this;
    },

    /**
     * Triggers tooltip
     * @private
     * @param  {object} label The label.
     * @returns {void}
     */
    setTooltip: function setTooltip(label) {
      var _this3 = this;

      label.jqEl.tooltip({
        content: label.label,
        placement: 'bottom'
      }).on("blur.".concat(COMPONENT_NAME$1c), function () {
        return _this3.removeTooltip(label);
      });
    },

    /**
     * Removes tooltip
     * @private
     * @param  {object} label The label.
     * @returns {void}
     */
    removeTooltip: function removeTooltip(label) {
      var tooltipApi = label.jqEl.data('tooltip');

      if (tooltipApi) {
        tooltipApi.element.off("blur.".concat(COMPONENT_NAME$1c));
        tooltipApi.destroy();
      }
    },

    /**
     * Position the ticks
     * @private
     * @returns {void}
     */
    positionTicks: function positionTicks() {
      var len = this.ticks.length;
      var delta = 100 / (len - 1);

      var getPoint = function getPoint(i) {
        return i === len - 1 ? 100 : delta * i;
      };

      this.ticks.toArray().forEach(function (tick, i) {
        var pos = getPoint(i);
        var left = (Locale ? Locale.isRTL() : false) ? 100 - pos : pos;
        tick.style.left = "".concat(left, "%");

        if (tick.classList.contains('is-disabled')) {
          tick.setAttribute('tabindex', '-1');
        }
      });
    },

    /**
     * Re-renders the Wizard Range with updated ticks
     * @private
     * @returns {this} component instance
     */
    updateRange: function updateRange() {
      var getStyle = function getStyle(el, prop) {
        return parseFloat(window.getComputedStyle(el)[prop]);
      };

      var tick = this.ticks.filter('.current').last();
      var w = 0;

      if (tick.length) {
        w = 100 * getStyle(tick[0], 'left') / getStyle(tick.parent()[0], 'width');
        w = (Locale ? Locale.isRTL() : false) ? 100 - w : w;
      }

      this.completedRange[0].style.width = "".concat(w, "%");
      return this;
    },

    /**
     * Update the wizard component with new settings.
     * @param {object} [settings] incoming settings
     * @returns {this} component instance
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.buildTicks().updateRange();
      return this;
    },

    /**
     * @private
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var _this4 = this;

      this.labels.forEach(function (label) {
        _this4.removeTooltip(label);

        label.jqEl.off().removeData();
      });
      delete this.labels;
      this.ticks.off("click.".concat(COMPONENT_NAME$1c));
      this.element.off("updated.".concat(COMPONENT_NAME$1c));
      $('body').off("resize.".concat(this.namespace));
      this.ticks.remove();
      return this;
    },

    /**
     * Activates one of the Wizard's ticks.
     * This method is slated to be removed in a future v4.10.0 or v5.0.0.
     * @deprecated as of v4.4.0.  Please use `activate()` instead.
     * @param {jQuery.Event} e the activate event object
     * @param {jQuery[]|HTMLElement} tick the target tick to be activated
     * @returns {this} component instance
     */
    select: function select(e, tick) {
      return deprecateMethod(this.activate, this.select).apply(this, [e, tick]);
    },

    /**
     * Activates one of the Wizard's ticks.
     * Tick can either be a number (representing the tick's index) or a jQuery
     * element reference to a tick.
     * @param {jQuery.Event} e the activate event object
     * @param {jQuery[]|HTMLElement} tick the target tick to be activated
     * @returns {this} component instance
     */
    activate: function activate(e, tick) {
      if (e === undefined && !tick) {
        return this;
      }

      var self = this;

      function getTick() {
        var target; // Use the first variable as the tick definition or index if "e" is null,
        // undefined, or not an event object. This is for backwards compatibility with
        // this control's old select() method, which took an index as an argument.

        if (e !== undefined && (e === undefined || e === null || !e.type || !e.target) && !tick) {
          tick = e;
        }

        if (tick === undefined) {
          target = $(e.target);
          return target.is('.label') ? target.parent() : target;
        }

        if (typeof tick === 'number') {
          return self.ticks.eq(tick);
        }

        return tick;
      }

      tick = getTick();

      if (e && (tick.is('[disabled], .is-disabled') || !tick.is('a'))) {
        e.preventDefault();
        e.stopPropagation();
        return this;
      }
      /**
       * Fires before a step is activated/pressed. You can cancel selection by returning a 'beforeactivate'
       * handler as 'false'
       * @event beforeactivate
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */


      var canNav = this.element.triggerHandler('beforeactivate', [tick]);

      if (canNav === false) {
        return this;
      }

      var trueIndex = this.ticks.index(tick);
      this.ticks.removeClass('complete current').eq(trueIndex).addClass('current').prevAll('.tick').addClass('complete');
      this.updateRange();
      /**
       * Fires while a step is activated/pressed.
       * handler as 'false'
       * @event activated
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */

      this.element.trigger('activated', [tick]);
      /**
       * Fires after a step is activated/pressed. And the new Dom is loaded.
       * handler as 'false'
       * @event afteractivated
       * @memberof Wizard
       * @property {object} event - The jquery event object
       * @property {HTMLElement} tick - The tick (link) that was activated.
       */

      setTimeout(function () {
        self.element.trigger('afteractivated', [tick]);
      }, 300);
      return this;
    },

    /**
     * Destroy and remove added markup and events
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$1c);
    },

    /**
     * This component listens to the following events:
     * @private
     * @listens updated custom updated event
     * @listens click jQuery click event
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var _this5 = this;

      var self = this;
      this.element.on("updated.".concat(COMPONENT_NAME$1c), function () {
        self.updated();
      });
      this.ticks.on("click.".concat(COMPONENT_NAME$1c), function (e) {
        self.activate(e, $(this));
      });
      $('body').on("resize.".concat(this.namespace), function () {
        _this5.adjustLabels();
      });
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Wizard
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.wizard = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1c);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1c, new Wizard(this, settings));
      }
    });
  };

  /**
   * *
   * Calculate if a Placeholder is required and its value.
   * @private
   * @param  {object} formattedValue The formatted cell value
   * @param  {number} row The row index
   * @param  {number} cell The cell index
   * @param  {object} value The value in the dataset
   * @param  {object} col The column definition
   * @param  {object} item The row data
   * @returns {object} Returns the placeholder value.
   */

  function calculatePlaceholder(formattedValue, row, cell, value, col, item) {
    var placeholder = col.placeholder;

    if (placeholder && formattedValue === '') {
      var getType = {};

      if (getType.toString.call(placeholder) === '[object Function]') {
        placeholder = placeholder(row, cell, value, col, item);
      } else if (item && placeholder in item) {
        placeholder = item[placeholder];
      }

      return placeholder;
    }

    return '';
  }
  /**
   * *
   * Check if given column is disabled.
   * @private
   * @param  {number} row The row index
   * @param  {number} cell The cell index
   * @param  {object} value The value in the dataset
   * @param  {object} col The column definition
   * @param  {object} item The row data
   * @returns {boolean} Returns checked value.
   */


  function isColumnDisabled(row, cell, value, col, item) {
    var isTrue = function isTrue(v) {
      return typeof v !== 'undefined' && v !== null && (typeof v === 'boolean' && v === true || typeof v === 'string' && v.toLowerCase() === 'true');
    };

    var disabled = col ? col.disabled : null;
    return typeof disabled === 'function' ? disabled(row, cell, value, col, item) : isTrue(disabled);
  }
  /**
  * A object containing all the supported UI formatters.
  * @private
  */


  var formatters = {
    Text: function Text(row, cell, value) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Input: function Input(row, cell, value, col) {
      if (col.inlineEditor) {
        var html = "<label for=\"datagrid-inline-input-".concat(row, "-").concat(cell, "\" class=\"audible\">").concat(col.name, "</label><input id=\"datagrid-inline-input-").concat(row, "-").concat(cell, "\" class=\"").concat(col.align === 'right' ? 'is-number-mask' : '', "\" value=\"").concat(value, "\">");
        return html;
      }

      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Placeholder: function Placeholder(row, cell, value, col, item) {
      var placeholder = calculatePlaceholder(value, row, cell, value, col, item);

      if (placeholder !== '') {
        var html = "<span class=\"is-placeholder\">".concat(placeholder, "</span>");
        return html;
      }

      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str;
    },
    Ellipsis: function Ellipsis(row, cell, value, col) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      col.textOverflow = 'ellipsis';
      return str;
    },
    Password: function Password(row, cell, value) {
      var str = value === null || value === undefined || value === '' ? '' : value.toString();
      return str.replace(/./g, '*');
    },
    Readonly: function Readonly(row, cell, value) {
      return "<span class=\"is-readonly\">".concat(value === null || value === undefined ? '' : value, "</span>");
    },
    RowNumber: function RowNumber(row, cell, value, col, item, api) {
      var _api$pagerAPI;

      var rowNumber = api.runningCount || 1;

      if ((api === null || api === void 0 ? void 0 : (_api$pagerAPI = api == null ? void 0 : api.pagerAPI) === null || _api$pagerAPI === void 0 ? void 0 : _api$pagerAPI == null ? void 0 : _api$pagerAPI.activePage) > 1) {
        rowNumber += (api.pagerAPI.activePage - 1) * api.pagerAPI.settings.pagesize;
      }

      return "<span class=\"is-readonly\">".concat(rowNumber, "</span>");
    },
    Date: function Date(row, cell, value, col, isReturnValue) {
      var formatted = value === null || value === undefined ? '' : value;
      var value2;

      if (typeof value === 'string' && value) {
        if (col.sourceFormat) {
          value2 = Locale.parseDate(value, typeof col.sourceFormat === 'string' ? {
            pattern: col.sourceFormat
          } : col.sourceFormat);
        } else {
          value2 = Locale.parseDate(value, typeof col.dateFormat === 'string' ? {
            pattern: col.dateFormat
          } : col.dateFormat);
        }

        if (value2) {
          formatted = Locale.formatDate(value2, typeof col.dateFormat === 'string' ? {
            pattern: col.dateFormat
          } : col.dateFormat);
        } else {
          formatted = Locale.formatDate(value, typeof col.dateFormat === 'string' ? {
            pattern: col.dateFormat
          } : col.dateFormat);

          if ((formatted === 'NaN/NaN/NaN' || !formatted) && formatted !== '') {
            // show invalid dates not NaN/NaN/NaN
            formatted = value;
          }
        }
      } else if (value) {
        formatted = Locale.formatDate(value, typeof col.dateFormat === 'string' ? {
          pattern: col.dateFormat
        } : col.dateFormat);
      }

      if (!col.editor || isReturnValue === true) {
        return formatted;
      }

      return "<span class=\"trigger\">".concat(formatted, "</span>").concat($.createIcon({
        icon: 'calendar',
        classes: ['icon-calendar']
      }));
    },
    Time: function Time(row, cell, value, col, isReturnValue) {
      var formatted = value === null || value === undefined ? '' : value;
      var localeDateFormat = _typeof(Locale) === 'object' && Locale.calendar().dateFormat ? Locale.calendar().dateFormat.short : null;
      var localeTimeFormat = _typeof(Locale) === 'object' && Locale.calendar().timeFormat ? Locale.calendar().timeFormat : null;
      var value2;

      var parseTime = function parseTime(timeString) {
        if (timeString === '') {
          return null;
        }

        var time = timeString.match(/(\d+)(?::(\d\d))(?::(\d\d))?\s*([pP]?)/i);

        if (time === null) {
          return null;
        }

        var getValue = function getValue(v) {
          return !isNaN(parseInt(v, 10)) ? parseInt(v, 10) : 0;
        };

        var d = new Date();
        var hours = getValue(time[1]);
        hours -= hours === 12 ? 12 : 0;
        hours += time[4] ? 12 : 0;
        d.setHours(hours);
        d.setMinutes(getValue(time[2]));
        d.setSeconds(getValue(time[3]));
        return d;
      };

      if (typeof value === 'string' && value) {
        value2 = Locale.formatDate(parseTime(value), {
          pattern: "".concat(localeDateFormat, " ").concat(col.sourceFormat || col.timeFormat || localeTimeFormat)
        });

        if (value2) {
          formatted = value2.slice(value2.indexOf(' '));
        }
      } else if (value) {
        value2 = Locale.formatDate(value, {
          pattern: "".concat(localeDateFormat, " ").concat(col.sourceFormat || col.timeFormat || localeTimeFormat)
        });

        if (value2) {
          formatted = value2.slice(value2.indexOf(' '));
        }
      } // Remove extra space in begining


      formatted = formatted.replace(/^\s/, '');

      if (!col.editor || isReturnValue === true) {
        return formatted;
      }

      return "<span class=\"trigger\">".concat(formatted, "</span>").concat($.createIcon({
        icon: 'clock',
        classes: ['icon-clock']
      }));
    },
    Autocomplete: function Autocomplete(row, cell, value) {
      var formatted = value === null || value === undefined ? '' : value;
      return formatted;
    },
    Lookup: function Lookup(row, cell, value, col, item) {
      var formatted = value === null || value === undefined ? '' : value;
      var isPlaceholder = false;
      var placeholder = calculatePlaceholder(formatted, row, cell, value, col, item);

      if (placeholder !== '') {
        isPlaceholder = true;
      }

      if (!col.editor) {
        if (isPlaceholder) {
          return "<span class=\"is-placeholder\">".concat(placeholder, "</span>");
        }

        return formatted;
      }

      if (col.editorOptions && typeof col.editorOptions.field === 'function') {
        formatted = col.editorOptions.field(item, null, null);
        isPlaceholder = false;
      }

      if (formatted === null || formatted === undefined || formatted === '') {
        formatted = '';

        if (placeholder) {
          isPlaceholder = true;
          formatted = placeholder;
        }
      }

      return "<span class=\"trigger ".concat(isPlaceholder ? 'is-placeholder' : '').concat(col.align === 'right' ? 'align-text-right' : '', "\">").concat(formatted, "</span>").concat($.createIcon({
        icon: 'search-list',
        classes: ['icon-search-list']
      }));
    },
    Decimal: function Decimal(row, cell, value, col, item) {
      var formatted = value;

      if (typeof Locale !== 'undefined' && formatted !== null && formatted !== undefined && formatted !== '') {
        formatted = Locale.formatNumber(value, col.numberFormat);
      }

      formatted = formatted === null || formatted === undefined || formatted === 'NaN' ? '' : formatted;
      var placeholder = calculatePlaceholder(formatted, row, cell, value, col, item);

      if (placeholder !== '') {
        var html = "<span class=\"is-placeholder\">".concat(placeholder, "</span>");
        return html;
      }

      return formatted;
    },
    Integer: function Integer(row, cell, value, col) {
      var formatted = value;

      if (typeof Locale !== 'undefined' && formatted !== null && formatted !== undefined && formatted !== '') {
        formatted = Locale.formatNumber(value, col.numberFormat || {
          style: 'integer'
        });
      }

      return formatted === null || formatted === undefined || formatted === 'NaN' ? '' : formatted;
    },
    Hyperlink: function Hyperlink(row, cell, value, col, item, api) {
      var disableAttr = isColumnDisabled(row, cell, value, col, item) ? ' disabled' : '';
      var colHref = col.href || '#'; // Support for dynamic links based on content

      if (col.href && typeof col.href === 'function') {
        colHref = col.href(row, cell, item, col); // Passing a null href will produce "just text" with no link

        if (colHref == null) {
          return col.text || value;
        }
      } else {
        colHref = colHref.replace('{{value}}', value);
      }

      var textValue = col.text || value;

      if (!textValue && !col.icon) {
        return '';
      }

      return col.icon ? "<a href=\"".concat(colHref, "\"").concat(disableAttr, " class=\"btn-icon row-btn ").concat(col.cssClass || '', "\" ").concat(!api.settings.rowNavigation ? '' : 'tabindex="-1"').concat(col.hyperlinkTooltip ? " title=\"".concat(col.hyperlinkTooltip, "\"") : '', ">\n          ").concat($.createIcon({
        icon: col.icon,
        file: col.iconFile
      }), "\n          <span class=\"audible\">").concat(textValue, "</span>\n        </a>") : "<a href=\"".concat(colHref, "\"").concat(disableAttr, " ").concat(!api.settings.rowNavigation ? '' : 'tabindex="-1"', " class=\"hyperlink ").concat(col.cssClass || '', "\"").concat(col.target ? " target=\"".concat(col.target, "\"") : '').concat(col.hyperlinkTooltip ? " title=\"".concat(col.hyperlinkTooltip, "\"") : '', ">").concat(textValue, "</a>");
    },
    Template: function Template(row, cell, value, col, item) {
      var tmpl = col.template;
      var renderedTmpl = '';

      if (Tmpl && item && tmpl) {
        renderedTmpl = Tmpl.compile("{{#dataset}}".concat(tmpl, "{{/dataset}}"), {
          dataset: item
        });
      }

      return renderedTmpl;
    },
    Drilldown: function Drilldown() {
      var text = Locale.translate('Drilldown');

      if (text === undefined) {
        text = '';
      }

      return "<button type=\"button\" tabindex=\"-1\" class=\"btn-icon small datagrid-drilldown\">\n         ".concat($.createIcon({
        icon: 'drilldown'
      }), "\n        <span>").concat(text, "</span>\n      </button>");
    },
    RowReorder: function RowReorder() {
      var text = Locale.translate('ReorderRows');

      if (text === undefined) {
        text = 'Reorder Rows';
      }

      return "<div class=\"datagrid-reorder-icon draggable\">\n         ".concat($.createIcon({
        icon: 'drag'
      }), "\n        <span class=\"audible\">").concat(text, "</span>\n      </div>");
    },
    Checkbox: function Checkbox(row, cell, value, col, item, api) {
      var isChecked; // Use isChecked function if exists

      if (col.isChecked) {
        isChecked = col.isChecked(value);
      } else {
        // treat 1, true or '1' as checked
        isChecked = value === undefined ? false : value === true || parseInt(value, 10) === 1;
      } // We add hidden Yes/No text so that the exported excel spreadsheet shows
      // this text in checkbox columns


      var hiddenText = "<span class=\"hidden\" aria-hidden=\"true\" role=\"presentation\"> ".concat(Locale.translate(isChecked ? 'Yes' : 'No'), "</span>");
      var animate = api.wasJustUpdated;
      api.wasJustUpdated = false;
      return "<div class=\"datagrid-checkbox-wrapper\"><span role=\"checkbox\" aria-label=\"".concat(col.name, "\" class=\"datagrid-checkbox\n     ").concat(isChecked ? "is-checked ".concat(!animate ? ' no-animation' : ' ') : '', "\" aria-checked=\"").concat(isChecked, "\"></span>").concat(hiddenText, "</div>");
    },
    SelectionCheckbox: function SelectionCheckbox(row, cell, value, col, item, api) {
      var isChecked = value === undefined ? false : value === true;

      if (!value) {
        isChecked = api.isRowSelected(item);
      }

      var ariaString = ' ';

      if (api.settings.columnIds.length > 0) {
        for (var i = 0; i < api.settings.columnIds.length; i++) {
          ariaString += item[api.settings.columnIds[i]];
        }
      }

      ariaString = xssUtils.ensureAlphaNumericWithSpaces(ariaString);
      return "<div class=\"datagrid-checkbox-wrapper\"><span role=\"checkbox\" aria-label=\"".concat(col.name ? col.name : Locale.translate('Select') + ariaString, "\" class=\"datagrid-checkbox datagrid-selection-checkbox").concat(isChecked ? ' is-checked no-animate' : '', "\" aria-checked=\"").concat(isChecked, "\"></span></div>");
    },
    Actions: function Actions(row, cell, value, col) {
      // Render an Action Formatter
      return "<button type=\"button\" class=\"btn-actions\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-owns=\"".concat(col.menuId, "\">\n        <span class=\"audible\">").concat(col.title || Locale.translate('More'), "</span>\n        ").concat($.createIcon({
        icon: 'more'
      }), "\n      </button>");
    },
    // Multi Line TextArea
    Textarea: function Textarea(row, cell, value) {
      var formatted = value === null || value === undefined ? '' : value;
      return "<span class=\"datagrid-multiline-text\">".concat(formatted, "</span>");
    },
    // Rich Text Editor
    Editor: function Editor(row, cell, value, col) {
      var formatted = value === null || value === undefined ? '' : value;
      var classes = 'is-editor';
      classes += col.singleline ? ' is-singleline' : ' datagrid-multiline-text';
      classes += col.contentTooltip ? ' content-tooltip' : '';
      return "<div class=\"".concat(classes, "\">").concat(xssUtils.unescapeHTML(formatted), "</div>");
    },
    // Expand / Collapse Button
    Expander: function Expander(row, cell, value, col, item, api) {
      var attrs = utils.stringAttributes(api, api.settings.attributes, "btn-expand-row-".concat(row));
      var button = "<button ".concat(attrs, " type=\"button\" aria-label=\"").concat(Locale.translate('ExpandCollapse'), "\" class=\"btn-icon datagrid-expand-btn\" tabindex=\"-1\">\n      <span class=\"icon plus-minus\"></span>\n      </button>").concat(value ? "<span> ".concat(value, "</span>") : '');
      return button;
    },
    // Datagrid Group Row
    GroupRow: function GroupRow(row, cell, value, col, item, api) {
      var groupSettings = api.settings.groupable;
      var rowHtml = {
        left: '',
        center: '',
        right: ''
      };
      var groups = '';
      var isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

      if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
        isOpen = groupSettings.expanded(row, cell, value, col, item, api);
      }

      for (var i = 0; i < groupSettings.fields.length; i++) {
        groups += item[groupSettings.fields[i]] + (i === 0 ? '' : ',');
      }

      if (groupSettings.groupRowFormatter) {
        groups = groupSettings.groupRowFormatter(row, cell, value, col, item, api);
      }

      var button = "<button type=\"button\" class=\"btn-icon datagrid-expand-btn".concat(isOpen ? ' is-expanded' : '', "\" tabindex=\"-1\">\n    <span class=\"icon plus-minus").concat(isOpen ? ' active' : '', "\"></span>\n    <span class=\"audible\">").concat(Locale.translate('ExpandCollapse'), "</span>\n    </button><span> ").concat(groups, "</span>"); // Take the first

      var container = api.getContainer(groupSettings.fields ? groupSettings.fields[0] : '');
      rowHtml[container] = button;
      return rowHtml;
    },
    GroupFooterRow: function GroupFooterRow(row, cell, value, col, item, api) {
      var groupSettings = api.settings.groupable;
      var rowHtml = {
        left: '',
        center: '',
        right: ''
      };
      var visibleColumnsLeft = api.settings.frozenColumns.left.length;
      var visibleColumnsRight = api.settings.frozenColumns.right.length;
      var idx = api.columnIdxById(groupSettings.aggregate);
      var container = api.getContainer(groupSettings.aggregate);
      rowHtml.left = "<td role=\"gridcell\" colspan=\"".concat(visibleColumnsLeft, "\"><div class=\"datagrid-cell-wrapper\"></div></td><td role=\"gridcell\"><div class=\"datagrid-cell-wrapper\">").concat(container === 'left' ? item.sum : '<span>&nbsp;</span>', "</div></td>");
      rowHtml.center = "<td role=\"gridcell\" colspan=\"".concat(idx - visibleColumnsLeft - visibleColumnsRight, "\"><div class=\"datagrid-cell-wrapper\"></div></td><td role=\"gridcell\"><div class=\"datagrid-cell-wrapper\">").concat(container === 'center' ? item.sum : '<span>&nbsp;</span>', "</div></td>");
      rowHtml.right = "<td role=\"gridcell\" colspan=\"".concat(visibleColumnsRight, "\"><div class=\"datagrid-cell-wrapper\"></div></td><td role=\"gridcell\"><div class=\"datagrid-cell-wrapper\">").concat(container === 'right' ? item.sum : '<span>&nbsp;</span>', "</div></td>");

      if (groupSettings.groupFooterRowFormatter) {
        rowHtml[container] = groupSettings.groupFooterRowFormatter(idx, row, cell, value, col, item, api);
      }

      return rowHtml;
    },
    SummaryRow: function SummaryRow(row, cell, value, col) {
      var afterText = '';
      var beforeText = col.summaryText || '';

      if (col.summaryTextPlacement === 'after') {
        afterText = beforeText;
        beforeText = '';
      }

      if (typeof Locale !== 'undefined' && col.numberFormat && value !== null && value !== undefined && value !== '') {
        value = Locale.formatNumber(+value, col.numberFormat);
      }

      return beforeText + (value === null || value === undefined || value === '' ? '' : value.toString()) + afterText;
    },
    // Tree Expand / Collapse Button and Paddings
    Tree: function Tree(row, cell, value, col, item, api) {
      var isOpen = item ? item.expanded : true;
      var depth = api && api.settings.treeDepth && api.settings.treeDepth[row] ? api.settings.treeDepth[row].depth : 0; // When use filter then
      // If (settings.allowChildExpandOnMatch === false) and only parent node has a match
      // then make expand/collapse button collapsed and disabled

      var isExpandedBtnDisabled = item && item.isAllChildrenFiltered;
      var expandedBtnDisabledHtml = isExpandedBtnDisabled ? ' disabled' : '';

      if (isOpen && isExpandedBtnDisabled) {
        isOpen = false;
      } // Tabsize as button width (+/-)


      var tabsize = api.settings.rowHeight === 'short' ? 22 : 30;
      var button = "<button type=\"button\" class=\"btn-icon datagrid-expand-btn".concat(isOpen ? ' is-expanded' : '', "\" tabindex=\"-1\"").concat(depth ? " style=\"margin-left: ".concat(depth ? "".concat(tabsize * (depth - 1), "px") : '', "\"") : '').concat(expandedBtnDisabledHtml, ">\n      <span class=\"icon plus-minus ").concat(isOpen ? ' active' : '', "\"></span>\n      <span class=\"audible\">").concat(Locale.translate('ExpandCollapse'), "</span>\n      </button>").concat(value ? " <span>".concat(value, "</span>") : '');
      var node = " <span class=\"datagrid-tree-node\"".concat(depth ? " style=\"margin-left: ".concat(depth ? "".concat(tabsize * depth, "px") : '', "\"") : '', ">").concat(value, "</span>");
      return item && item[col.children ? col.children : 'children'] ? button : node;
    },
    // Badge / Tags and Visual Indictors
    ClassRange: function ClassRange(row, cell, value, col) {
      var ranges = col.ranges;
      var classes = '';
      var text = '';

      if (!ranges) {
        return {};
      }

      for (var i = 0; i < ranges.length; i++) {
        if (value >= ranges[i].min && value <= ranges[i].max) {
          classes = ranges[i].classes;
          text = ranges[i].text ? ranges[i].text : classes.split(' ')[0];
        }

        if (value === ranges[i].value) {
          classes = ranges[i].classes;
          text = ranges[i].text ? ranges[i].text : value;
        }
      }

      return {
        classes: classes,
        text: text
      };
    },
    // Badge (Visual Indictors)
    Badge: function Badge(row, cell, value, col) {
      var colorClasses = col.color;
      var text = col.name;

      if (col.ranges) {
        var ranges = formatters.ClassRange(row, cell, value, col);
        colorClasses = ranges.classes;
        text = ranges.text;
      }

      return "<span class=\"badge ".concat(colorClasses, "\">").concat(value, " <span class=\"audible\">").concat(text, "</span></span>");
    },
    Tag: function Tag(row, cell, value, col) {
      var _col$editorOptions;

      var ranges = formatters.ClassRange(row, cell, value, col);

      if (col !== null && col !== void 0 && (_col$editorOptions = col == null ? void 0 : col.editorOptions) !== null && _col$editorOptions !== void 0 && (_col$editorOptions == null ? void 0 : _col$editorOptions.clickable)) {
        return "<span class=\"tag is-linkable hide-focus ".concat(ranges.classes, "\"><a class=\"tag-content\" href=\"#\">#").concat(value, "</a><button class=\"btn-linkable\" focusable=\"false\" tabindex=\"-1\">\n        <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-caret-right\"></use></svg>\n      </button></span>");
      }

      return "<span class=\"tag ".concat(ranges.classes, " hide-focus\"><span class=\"tag-content\">").concat(value, "</span></span>");
    },
    Alert: function Alert(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      var icon = $.createIcon({
        icon: "".concat(ranges.classes, "-alert"),
        classes: ['icon', 'datagrid-alert-icon', "icon-".concat(ranges.classes)]
      });
      return "".concat(icon, "<span class=\"datagrid-alert-text\">").concat(ranges.text === 'value' ? value : ranges.text, "</span>");
    },
    Image: function Image(row, cell, value, col) {
      return "<img class=\"datagrid-img\" src=\"".concat(value, "\" alt=\"").concat(col.alt ? col.alt : Locale.translate('Image'), "\"").concat(col.dimensions ? " style=\"height:".concat(col.dimensions.height, ";width:").concat(col.dimensions.height, "\"") : '', "/>");
    },
    Color: function Color(row, cell, value, col) {
      var ranges = formatters.ClassRange(row, cell, value, col);
      var text = value === null || value === undefined || value === '' ? '' : value.toString();
      return "<span class=\"".concat(ranges.classes, "\">").concat(text, "</span>");
    },
    Colorpicker: function Colorpicker(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (col.inlineEditor) {
        return html;
      }

      var classList = "swatch".concat(value === '' ? ' is-empty' : '');
      html = "<span class=\"colorpicker-container trigger dropdown-trigger\"><span class=\"".concat(classList, "\" style=\"background-color: ").concat(value, "\"></span><input class=\"colorpicker\" id=\"colorpicker-").concat(cell, "\" name=\"colorpicker-").concat(cell, "\" type=\"text\" role=\"combobox\" aria-autocomplete=\"list\" value=\"").concat(value, "\">");
      html += "<span class=\"trigger\">".concat($.createIcon({
        icon: 'dropdown'
      }), "</span></span>");
      return html;
    },
    Button: function Button(row, cell, value, col, item, api) {
      var text;
      var disableAttr = isColumnDisabled(row, cell, value, col, item) ? ' disabled' : '';

      if (col.text) {
        text = col.text;
      } else {
        text = value === null || value === undefined || value === '' ? '' : value.toString();
      }

      var markup = "<button type=\"button\"".concat(disableAttr, " class=\"").concat(col.icon ? 'btn-icon' : 'btn-secondary', " row-btn ").concat(col.cssClass ? col.cssClass : '', "\"").concat(!api.settings.rowNavigation ? '' : ' tabindex="-1"', " >");

      if (col.icon) {
        markup += $.createIcon({
          icon: col.icon,
          file: col.iconFile
        });
      }

      markup += "<span>".concat(text, "</span></button>");
      return markup;
    },
    Dropdown: function Dropdown(row, cell, value, col, item) {
      var formattedValue = value;
      var compareValue;
      var option;
      var optionValue;
      var isPlaceholder = false;

      if (col.options && value !== undefined) {
        compareValue = col.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

        for (var i = 0, l = col.options.length; i < l; i++) {
          option = col.options[i];
          optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

          if (optionValue === compareValue) {
            formattedValue = option.label;
            break;
          }
        }
      }

      var placeholder = calculatePlaceholder(formattedValue, row, cell, value, col, item);

      if (placeholder !== '') {
        isPlaceholder = true;
        formattedValue = placeholder;
      }

      var html = "<span class=\"trigger dropdown-trigger ".concat(isPlaceholder ? 'is-placeholder' : '', "\">").concat(formattedValue, "</span>").concat($.createIcon({
        icon: 'dropdown'
      }));

      if (col.inlineEditor) {
        html = "<label for=\"full-dropdown\" class=\"audible\">".concat(col.name, "</label><select id=\"datagrid-dropdown").concat(row, "\" class=\"dropdown\">");

        for (var _i = 0, _l = col.options.length; _i < _l; _i++) {
          var opt = col.options[_i];
          var labelOrValue = void 0;

          if (opt.label !== undefined) {
            labelOrValue = opt.label;
          } else {
            labelOrValue = opt.value !== undefined ? opt.value : '';
          }

          html += "<option".concat(opt.id === undefined ? '' : " id=\"".concat(opt.id, "\""), "  value=\"").concat(opt.value, "\"").concat(opt.selected || opt.value === compareValue ? ' selected ' : '', ">").concat(labelOrValue, "</option>");
        }

        html += "</select>\n      <div class=\"dropdown-wrapper is-inline\">\n        <div class=\"dropdown\"><span>".concat(formattedValue, "</span></div>\n        <svg class=\"icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\">\n          <use href=\"#icon-dropdown\"></use>\n        </svg>\n      </div>");
      }

      return html;
    },
    Fileupload: function Fileupload(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (!col.inlineEditor) {
        if ($.trim(html) === '') {
          html = "<span class=\"trigger\">".concat(html, "</span>").concat($.createIcon({
            icon: 'folder',
            classes: ['icon-fileupload']
          }));
        } else {
          html = "<span class=\"trigger is-clearable\">".concat(html, "</span>").concat($.createIcon({
            icon: 'close',
            classes: ['icon-close']
          })).concat($.createIcon({
            icon: 'folder',
            classes: ['icon-fileupload']
          }));
        }
      }

      return html;
    },
    Spinbox: function Spinbox(row, cell, value, col) {
      var html = value === null || value === undefined || value === '' ? '' : value.toString();

      if (col.inlineEditor) {
        html = "<label for=\"spinbox-".concat(cell, "\" class=\"audible\">Quantity</label>\n        <span class=\"spinbox-wrapper\"><span class=\"spinbox-control down\">-</span>\n        <input id=\"spinbox-").concat(cell, "\" name=\"spinbox-").concat(cell, "\" type=\"text\" class=\"spinbox\" value=\"").concat(value, "\">\n        <span class=\"spinbox-control up\">+</span></span>");
      }

      return html;
    },
    Favorite: function Favorite(row, cell, value, col, item, api) {
      var isChecked; // Use isChecked function if exists

      if (col.isChecked) {
        isChecked = col.isChecked(value);
      } else {
        isChecked = value === undefined ? false : value === true;
      }

      var isEditable = col.editor && api.settings.editable;

      if (isChecked) {
        return "<span aria-label=\"".concat(Locale.translate('Favorite'), "\" class=\"icon-favorite").concat(isEditable ? ' is-editable' : '', "\">").concat($.createIcon({
          icon: 'star-filled'
        }), "</span>");
      }

      return col.showEmpty ? "<span aria-label=\"".concat(Locale.translate('Favorite'), "\" class=\"icon-favorite").concat(isEditable ? ' is-editable' : '', "\">").concat($.createIcon({
        icon: 'star-outlined'
      }), "</span>") : '';
    },
    Status: function Status(row, cell, value, col, item) {
      if (!item || !item.rowStatus) {
        return '<span></span>';
      }

      return "".concat($.createIcon({
        icon: item.rowStatus.icon,
        classes: ['icon', "icon-".concat(item.rowStatus.icon)]
      }), "<span class=\"audible\">").concat(item.rowStatus.text, "</span>");
    },
    TargetedAchievement: function TargetedAchievement(row, cell, value, col) {
      var perc = 100 * value;
      var text = "".concat(perc, "%");
      var ranges = formatters.ClassRange(row, cell, perc, col);
      var target = col.target;

      if (col.text) {
        text = col.text;
        text = text.replace('{{value}}', value);
        text = text.replace('<% value %>', value);
        text = text.replace('<%value%>', value);
        text = text.replace('{{percent}}', perc);
        text = text.replace('<% percent %>', perc);
        text = text.replace('<%percent%>', perc);
        col.showPercentText = true;
      }

      var barClass = col.ranges && ranges.classes ? ranges.classes : 'primary';
      return "<div class=\"total bar chart-completion-target chart-targeted-achievement\">\n              <div class=\"target remaining bar\" style=\"width: ".concat(target || 0, "%;\"></div>\n              <div class=\"completed bar ").concat(barClass, "\" style=\"width: ").concat(perc, "%;\"></div>\n              ").concat(col.showPercentText ? "<div class=\"chart-targeted-text l-center\">".concat(text, "</div>\n            </div>") : "<div class=\"audible\">".concat(perc, "%</div>"));
    },
    ProcessIndicator: function ProcessIndicator(row, cell, value) {
      if (!value.steps) {
        return '';
      }

      var processHtml = '<div class="process-indicator compact responsive"><div class="display">';

      for (var i = 0; i < value.steps; i++) {
        var isCurrent = i === (value === null || value === void 0 ? void 0 : value == null ? void 0 : value.current) - 1;
        processHtml += "<div class=\"step\">\n        <div class=\"lines\">\n          <span class=\"indicator ".concat(isCurrent ? ' current processing' : '', " ").concat(i < (value === null || value === void 0 ? void 0 : value == null ? void 0 : value.current) ? ' darker' : '', "\"></span>\n          <span class=\"separator ").concat(i < (value === null || value === void 0 ? void 0 : value == null ? void 0 : value.current) ? ' darker' : '', "\"></span>\n        </div>\n      </div>");
      }

      processHtml += '</div></div>';
      return processHtml;
    }
  };

  /* eslint-disable import/prefer-default-export */

  var excel = {};
  /**
   * Remove Hidden Columns and Non Exportable Columns.
   * @private
   * @param {string} customDs An optional customized version of the data to use.
   * @param {string} self The grid api to use (if customDs is not used)
   * @returns {object} an table element cleaned extra stuff
   */

  excel.cleanExtra = function (customDs, self) {
    var clean = function clean(table) {
      var removeNode = function removeNode(node) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      };

      var nonExportables = [];
      var rows = [].slice.call(table[0].querySelectorAll('tr'));
      rows.forEach(function (row) {
        if (row.classList.contains('is-hidden') || row.classList.contains('datagrid-expandable-row')) {
          removeNode(row);
          return;
        }

        var elements = [].slice.call(row.querySelectorAll('th, td, div, span'));
        elements.forEach(function (el) {
          if (el.classList.contains('is-hidden')) {
            removeNode(el);
            return;
          } // THEAD


          var attrExportable = el.getAttribute('data-exportable');

          if (attrExportable && attrExportable === 'no') {
            var index = parseInt(el.id.slice(-1), 10);
            nonExportables.push(index + 1);
            removeNode(el);
            return;
          } // TBODY


          var attrAriaColindex = el.getAttribute('aria-colindex');

          if (el.tagName.toLowerCase() === 'td' && attrAriaColindex) {
            if (nonExportables.indexOf(parseInt(attrAriaColindex, 10)) !== -1) {
              removeNode(el);
              return;
            }
          }

          var innerElements = [].slice.call(el.querySelectorAll('.is-hidden, .datagrid-expand-btn, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper'));
          innerElements.forEach(function (innerEl) {
            return removeNode(innerEl);
          });

          while (el.attributes.length > 0) {
            el.removeAttribute(el.attributes[0].name);
          } // White Hat Security Violation. Remove Excel formulas
          // Excel Formulas Start with =SOMETHING


          var text = el.textContent;

          if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
            el.textContent = "'".concat(text, "'");
          }
        });
      });
      return table;
    };

    var table = [];

    if (!self && customDs) {
      table = excel.datasetToHtml(customDs);
    } else {
      var dataset = self.settings.groupable ? self.originalDataset : self.settings.dataset;
      table = excel.appendRows(dataset, self.table[0].cloneNode(true), self);
    } // Create the header row


    if (!customDs && !table[0].querySelector('thead')) {
      var tbody = table[0].querySelector('tbody');
      var header = table[0].createTHead();
      var row = header.insertRow(0);
      var allHeaderNodes = self.headerNodes();

      for (var i = 0; i < allHeaderNodes.length; i++) {
        var headerNode = allHeaderNodes[i];
        var cell = row.insertCell(i);
        cell.innerHTML = headerNode.querySelector('.datagrid-header-text').textContent.trim();
        cell.setAttribute('class', headerNode.classList);
        cell.setAttribute('id', headerNode.getAttribute('id'));

        if (headerNode.getAttribute('data-exportable')) {
          cell.setAttribute('data-exportable', headerNode.getAttribute('data-exportable'));
        }
      }

      tbody.parentNode.insertBefore(header, tbody);
    }

    table = clean(table); // Exporting data with trailing negative signs moved in front

    if (self && self.settings.exportConvertNegative) {
      var cells = [].slice.call(table[0].querySelectorAll('td'));
      cells.forEach(function (td) {
        td.textContent = td.textContent.replace(/^(.+)(-$)/, '$2$1');
      });
    }

    return table;
  };
  /**
   * Save file to download `.xls or .csv`.
   * @private
   * @param {string} content The content for the file in the download.
   * @param {string} fileName The desired export filename in the download.
   * @param {boolean} isUtf16 If true, will encode as Utf-16le.
   * @returns {void}
   */


  excel.save = function (content, fileName, isUtf16) {
    var ext = (fileName.match(/\.([^.]*?)(?=\?|#|$)/) || [])[1];
    var isTypeExcel = typeof ext === 'string' && /\b(xlsx|xls)\b/g.test(ext);
    var blob = new Blob([content], {
      type: 'application/csv;charset=utf-8;'
    }); // ref: https://stackoverflow.com/a/43099608

    if (isUtf16 && !isTypeExcel) {
      var byteArray = [255, 254];

      for (var i = 0; i < content.length; ++i) {
        var charCode = content.charCodeAt(i);
        byteArray.push(charCode & 0xff); // eslint-disable-line

        byteArray.push(charCode / 256 >>> 0); // eslint-disable-line
      }

      blob = new Blob([new Uint8Array(byteArray)], {
        type: 'text/plain;charset=UTF-16LE;'
      });
    }

    if (Environment.browser.name === 'ie' || Environment.browser.name === 'edge') {
      if (window.navigator.msSaveBlob) {
        navigator.msSaveBlob(blob, fileName);
      }
    } else if (window.URL.createObjectURL) {
      // createObjectURL api allows downloading larger files
      if (isTypeExcel) {
        blob = new Blob([content], {
          type: 'application/vnd.ms-excel;charset=utf-8;'
        });
      }

      var objectUrl = URL.createObjectURL(blob);
      var link = document.createElement('a');
      link.href = objectUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(objectUrl);
    } else {
      var _link = document.createElement('a');

      _link.href = this.base64(content);
      _link.download = fileName;
      document.body.appendChild(_link);

      _link.click();

      document.body.removeChild(_link);
    }
  };
  /**
  * Convert a dataset to a html table for conversion to excel.
  * @private
  * @param {string} dataset The array of objects to convert
  * @returns {string} an html table as a string
  */


  excel.datasetToHtml = function (dataset) {
    var tableHtml = '<tbody>';

    var _loop = function _loop(i, l) {
      tableHtml += '<tr>';
      Object.keys(dataset[i]).forEach(function (key, index) {
        //eslint-disable-line
        if (dataset[i] && Object.prototype.hasOwnProperty.call(dataset[i], key)) {
          tableHtml += "<td>".concat(dataset[i][key], "</td>");
        }
      });
      tableHtml += '</tr>';
    };

    for (var i = 0, l = dataset.length; i < l; i++) {
      _loop(i);
    }

    tableHtml += '</tbody>';
    return $('<table></table>').append(tableHtml);
  };
  /**
  * Convert a dataset to a html table for conversion to excel.
  * @private
  * @param {array} dataset The array of objects to convert.
  * @param {object} table The table object.
  * @param {object} self The grid API.
  * @returns {object} The table with rows appended.
  */


  excel.appendRows = function (dataset, table, self) {
    var isjQuery = function isjQuery(obj) {
      return obj && (obj instanceof jQuery || obj.constructor.prototype.jquery);
    };

    var tableJq = isjQuery(table) ? table : $(table);
    table = tableJq[0];
    var tableHtml = '';
    var body = table.querySelector('tbody');
    body.innerHTML = '';

    var appendRow = function appendRow(d, i) {
      if (!d._isFilteredOut) {
        var rowHtml = self.rowHtml(d, i, i, false, false, i, true);
        var tr = document.createElement('tr');
        tr.innerHTML = rowHtml.left + rowHtml.center + rowHtml.right;
        tableHtml += tr.outerHTML; // Add tree rows

        if (d.children) {
          for (var j = 0, l = d.children.length; j < l; j++) {
            appendRow(d.children[j], j);
          }
        }
      }
    };

    dataset.forEach(function (d, i) {
      appendRow(d, i);
    });
    body.insertAdjacentHTML('beforeend', tableHtml);
    return tableJq;
  };
  /**
   * Convert a excel string to base64 format for download.
   * @private
   * @param {string} s The string containing the document.
   * @returns {string} The excel doc as a base64 string.
   */


  excel.base64 = function (s) {
    if (window.btoa) {
      return "data:application/vnd.ms-excel;base64,".concat(window.btoa(unescape(encodeURIComponent(s))));
    }

    return "data:application/vnd.ms-excel;,".concat(unescape(encodeURIComponent(s)));
  };
  /**
   * Copy pasted data into the dataset to facilitate copy from excel.
   * @param {object} pastedData The paste data from the paste event.
   * @param {[type]} rowCount The number of rows.
   * @param {[type]} colIndex The column index we started on.
   * @param {[type]} dataSet The dataset.
   * @param {[type]} self The datagrid API.
   * @returns {void}
   */


  excel.copyToDataSet = function (pastedData, rowCount, colIndex, dataSet, self) {
    var validateFields = function validateFields(values, settings, rowData, idx) {
      for (var j = 0, l = values.length; j < l; j++) {
        var col = settings.columns[idx];

        if (col.formatter !== formatters.Readonly) {
          if (col.editor.name === 'input') {
            if (col.filterType === 'integer' || col.filterType === 'decimal' || col.filterType === 'number') {
              // Number Values
              // Validates if input is number. If true, will overwrite the data in cell otherwise nothing will happen.
              if (!isNaN(values[j].trim())) {
                rowData[col.field] = values[j];
              }
            } else {
              // String Values
              // Just overwrite the data in the cell
              rowData[col.field] = values[j];
            }
          } else if (col.editor.name === 'input') {
            // Validates if input is date. If true, will overwrite the data in cell otherwise nothing will happen.
            if (!isNaN(Date.parse(values[j]))) {
              rowData[col.field] = new Date(values[j]);
            }
          }
        }

        idx++;
      }
    };

    var pastedDataLen = pastedData.length;
    var columnsLen = self.settings.columns.length;

    for (var i = 0; i < pastedDataLen; i++) {
      var rawVal = pastedData[i].split('\t');
      var startColIndex = colIndex;

      if (rowCount < dataSet.length) {
        var currentRowData = dataSet[rowCount];
        validateFields(rawVal, self.settings, currentRowData, startColIndex);
      } else {
        var newRowData = {};

        for (var k = 0; k < columnsLen; k++) {
          newRowData[self.settings.columns[k].field] = '';
        }

        validateFields(rawVal, self.settings, newRowData, startColIndex);
        dataSet.push(newRowData);
      }

      rowCount++;
    }

    self.renderRows();
    self.syncSelectedUI();
    self.pagerRefresh('bottom');
  };
  /**
   * Export the grid contents to xls format. This may give a warning when opening the file.
   * exportToCsv may be prefered.
   * @param {string} fileName The desired export filename in the download.
   * @param {string} worksheetName A name to give the excel worksheet tab.
   * @param {string} customDs An optional customized version of the data to use.
   * @param {object} self The grid api if customDS is not used
   * @returns {void}
   */


  excel.exportToExcel = function (fileName, worksheetName, customDs, self) {
    var template = '' + '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' + '<head>' + '<!--[if gte mso 9]>' + '<xml>' + '<x:ExcelWorkbook>' + '<x:ExcelWorksheets>' + '<x:ExcelWorksheet>' + '<x:Name>{worksheet}</x:Name>' + '<x:WorksheetOptions>' + '<x:Panes></x:Panes>' + '<x:DisplayGridlines></x:DisplayGridlines>' + '</x:WorksheetOptions>' + '</x:ExcelWorksheet>' + '</x:ExcelWorksheets>' + '</x:ExcelWorkbook>' + '</xml>' + '<![endif]-->' + '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>' + '</head>' + '<body>' + '<table border="1px solid #999999">{table}</table>' + '</body>' + '</html>';

    var formatExcel = function formatExcel(s, c) {
      return s.replace(/{(\w+)}/g, function (m, p) {
        return c[p];
      });
    };

    var table = excel.cleanExtra(customDs, self);
    var ctx = {
      worksheet: worksheetName || 'Worksheet',
      table: table[0].innerHTML
    };
    fileName = "".concat(fileName || self.element[0].id || 'Export', ".xls");
    excel.save(formatExcel(template, ctx), fileName);
  };
  /**
   * Export the grid contents to csv
   * @param {string} fileName The desired export filename in the download.
   * @param {string} customDs An optional customized version of the data to use.
   * @param {string|object} sep (optional) If user's machine is configured for a locale with alternate default separator.
   * The char double quote `"` is not allowed to be use as separator char
   * Can use as custom string `sep=;` or `;` will add to first line and use `;` as separator
   * @param {boolean} [sep.firstLine=true] if false will not added to first line `sep=<separator.char>`
   * @param {string} [sep.char=','] custom separator char
   * @param {boolean} [sep.flexChar=true] if false `char` will not be auto change to `\t` tab in case utf-16 encode for csv file
   * @param {boolean} [sep.flexUtf8=true] if false `utf-8` will not be auto change to `utf-16le` in case utf-16 encode for csv file
   * @param {string} self The grid api to use (if customDs is not used)
   * @returns {void}
   */


  excel.exportToCsv = function (fileName, customDs) {
    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sep=,';
    var self = arguments.length > 3 ? arguments[3] : undefined;

    var isObject = function isObject(v) {
      return v && _typeof(v) === 'object' && v.constructor === Object;
    };

    var isFalse = function isFalse(v) {
      return /^(false|0+|null)$/gi.test(v);
    }; // Set Separator


    var separator = {
      firstLine: true,
      char: ',',
      flexChar: true,
      flexUtf8: true
    };

    if (sep !== 'sep=,' && !isFalse(sep)) {
      var setChar = function setChar(char) {
        return char !== '"' ? char : separator.char;
      };

      if (isObject(sep)) {
        separator.firstLine = !isFalse(sep.firstLine);
        separator.flexChar = !isFalse(sep.flexChar);
        separator.flexUtf8 = !isFalse(sep.flexUtf8);

        if (typeof sep.char === 'string' && sep.char.length === 1 && !isFalse(sep.char)) {
          separator.char = setChar(sep.char);
        }
      } else if (typeof sep === 'string') {
        if (sep.length === 1 && !isFalse(sep)) {
          separator.char = setChar(sep);
        } else if (/^sep=.$/.test(sep)) {
          var char = sep.replace('sep=', '');
          separator.char = !isFalse(char) ? setChar(char) : separator.char;
        }
      }
    }

    var formatCsv = function formatCsv(table, isUtf16) {
      // utf16: use tab `\t` to separate columns in order be displayed properly on excel
      var separatorChar = isUtf16 && separator.flexChar ? '\t' : separator.char;
      var csv = [];
      var rows = [].slice.call(table[0].querySelectorAll('tr'));
      rows.forEach(function (row) {
        var rowContent = [];
        var cols = [].slice.call(row.querySelectorAll('td, th'));
        cols.forEach(function (col) {
          return rowContent.push(col.textContent.replace(/\r?\n|\r/g, '').replace(/"/g, '""').trim());
        });
        csv.push(rowContent.join("\"".concat(separatorChar, "\"")));
      });

      if (separator.firstLine && (separator.flexUtf8 && !isUtf16 || !separator.flexUtf8 && separator.char !== ',')) {
        csv.unshift(["sep=".concat(separator.char)]);
      }

      return "".concat(!separator.flexUtf8 ? "\uFEFF" : '', "\"").concat(csv.join('"\n"'), "\"");
    };

    var table = excel.cleanExtra(customDs, self); // ref: https://stackoverflow.com/a/2551031

    var isUtf16 = !/^[\u0000-\u007f]*$/.test(table[0].textContent) && separator.flexUtf8; // eslint-disable-line

    var data = formatCsv(table, isUtf16);
    fileName = "".concat(fileName || self.element[0].id || 'Export', ".csv");
    excel.save(data, fileName, isUtf16);
  };
  /* eslint-enable import/prefer-default-export */

  /**
  * An api for grouping data by a given field (s)
  * @private
  */

  var groupBy = function () {
    var equals = utils.equals; // See if the object has these proprties or not

    var has = function has(obj, target) {
      return obj.some(function (value) {
        return equals(value, target);
      });
    }; // Return just the object properties matching the names


    var pick = function pick(obj, names) {
      var chosen = {};

      for (var i = 0, l = names.length; i < l; i++) {
        chosen[names[i]] = obj[names[i]];
      }

      return chosen;
    }; // Return the specific keys from the object


    var keys = function keys(data, names) {
      return data.reduce(function (memo, item) {
        var key = pick(item, names);

        if (!has(memo, key)) {
          memo.push(key);
        }

        return memo;
      }, []);
    }; // Look through each value in the list and return an array of all the values
    // that contain all of the key-value pairs listed in properties.


    var where = function where(data, names) {
      var chosen = [];
      /* eslint-disable */

      data.map(function (item, idx) {

        for (var prop in names) {
          if (names[prop] !== item[prop]) {
            return;
          }
        }

        item.idx = idx;
        chosen.push(item);
        return;
      });
      /* eslint-enable */

      return chosen;
    }; // Grouping Function with Plugins/Aggregator


    var group = function group(data, names) {
      var stems = keys(data, names);
      return stems.map(function (stem) {
        return {
          key: stem,
          values: where(data, stem).map(function (item) {
            return item;
          })
        };
      });
    }; // Register an aggregator


    group.register = function (name, converter) {
      group[name] = function (data, names, extra) {
        var that = this;
        that.extra = extra;
        return group(data, names).map(converter, that);
      };

      return group[name];
    };

    return group;
  }();
  /**
  * Register built in aggregators
  * @private
  */


  groupBy.register('none', function (item) {
    return $.extend({}, item.key, {
      values: item.values
    });
  });
  groupBy.register('sum', function (item) {
    var field = this.extra;
    var nonEmpty = item.values.map(function (row) {
      return row[field];
    }).filter(function (val) {
      return val !== undefined && val !== null;
    });
    return $.extend({}, item.key, {
      values: item.values
    }, {
      sum: nonEmpty.reduce(function (a, b) {
        return Number(a) + Number(b);
      }, 0)
    });
  });
  groupBy.register('max', function (item) {
    var field = this.extra;
    return $.extend({}, item.key, {
      values: item.values
    }, // eslint-disable-next-line
    {
      max: Math.max.apply(Math, _toConsumableArray(item.values.map(function (row) {
        return row[field];
      }).filter(function (val) {
        return val !== undefined && val !== null;
      })))
    });
  });
  groupBy.register('min', function (item) {
    var field = this.extra;
    return $.extend({}, item.key, {
      values: item.values
    }, // eslint-disable-next-line
    {
      min: Math.min.apply(Math, _toConsumableArray(item.values.map(function (row) {
        return row[field];
      }).filter(function (val) {
        return val !== undefined && val !== null;
      })))
    });
  });
  groupBy.register('avg', function (item) {
    var field = this.extra;
    var nonEmpty = item.values.map(function (row) {
      return row[field];
    }).filter(function (val) {
      return val !== undefined && val !== null;
    });
    return $.extend({}, item.key, {
      values: item.values
    }, {
      avg: nonEmpty.reduce(function (a, b) {
        return Number(a) + Number(b);
      }, 0) / nonEmpty.length
    });
  });
  groupBy.register('count', function (item) {
    var field = this.extra;
    var nonEmpty = item.values.map(function (row) {
      return row[field];
    }).filter(function (val) {
      return val !== undefined && val !== null;
    });
    return $.extend({}, item.key, {
      values: item.values
    }, {
      count: nonEmpty.length
    });
  });
  groupBy.register('list', function (item) {
    var extra = this.extra;
    return $.extend({}, item.key, {
      values: item.values
    }, {
      list: item.values.map(function (thisItem) {
        var list = [];

        for (var i = 0, l = extra.list.length; i < l; i++) {
          var exclude = extra.exclude ? thisItem[extra.exclude] : false;

          if (thisItem[extra.list[i]] && !exclude) {
            list.push({
              value: thisItem[extra.list[i]],
              key: extra.list[i]
            });
          }
        }

        return list;
      })
    });
  });
  /**
  * Simple Summary Row Accumlator
  * @private
  */

  var aggregators = {};

  aggregators.aggregate = function (items, columns) {
    var totals = {};
    var self = this;

    for (var i = 0, l = columns.length; i < l; i++) {
      if (columns[i].aggregator) {
        (function () {
          var field = columns[i].field;

          self.sum = function (sum, node) {
            if (node._isFilteredOut) {
              // eslint-disable-line
              return sum;
            }

            var value;

            if (field.indexOf('.') > -1) {
              value = field.split('.').reduce(function (o, x) {
                return o ? o[x] : '';
              }, node);
            } else {
              value = node[field];
            }

            value = Number(value);
            var valuePlaces = numberUtils.decimalPlaces(value);
            var sumPlaces = numberUtils.decimalPlaces(sum);
            return Number((sum + value).toFixed(Math.max(valuePlaces, sumPlaces)));
          };

          var total = items.reduce(self[columns[i].aggregator], 0);

          if (field.indexOf('.') > -1) {
            var currentObj = totals;

            for (var j = 0, k = field.split('.').length; j < k; j++) {
              if (j === field.split('.').length - 1) {
                currentObj[field.split('.')[j]] = total;
              } else {
                if (!(field.split('.')[j] in currentObj)) {
                  currentObj[field.split('.')[j]] = {};
                }

                currentObj = currentObj[field.split('.')[j]];
              }
            }
          } else {
            totals[field] = total;
          }
        })();
      }
    }

    return totals;
  };

  /* eslint-disable no-underscore-dangle */

  var COMPONENT_NAME$1d = 'lookup'; // Lookup components are "modal" (one on-screen at any given time)

  var LOOKUP_GRID_ID = 'lookup-datagrid'; // When passing on attributes from the Lookup component to its subcomponents (modal/grid),
  // This helper appends suffixes representing those components to each attribute.

  function addSuffixToAttributes() {
    var parentAttrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var childAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var suffix = arguments.length > 2 ? arguments[2] : undefined;
    var attrs = [];

    if (!(parentAttrs !== null && parentAttrs !== void 0 && (parentAttrs == null ? void 0 : parentAttrs.length)) && !(childAttrs !== null && childAttrs !== void 0 && (childAttrs == null ? void 0 : childAttrs.length))) {
      return attrs;
    } // If no child attributes exist, just pass the parents on with the prefix


    if (!(childAttrs !== null && childAttrs !== void 0 && (childAttrs == null ? void 0 : childAttrs.length))) {
      attrs = parentAttrs.map(function (obj) {
        return {
          name: obj.name,
          value: "".concat(obj.value, "-").concat(suffix)
        };
      });
      return attrs;
    }

    if (!parentAttrs.length) {
      return childAttrs;
    } // If child attributes exist, only append the ones from the parent
    // that aren't defined in the child


    parentAttrs.forEach(function (attr) {
      var childAttr = childAttrs.find(function (toolbarAttrs) {
        return toolbarAttrs.name === attr.name;
      });
      attrs.push(childAttr || {
        name: attr.name,
        value: "".concat(attr.value, "-").concat(suffix)
      });
    });
    return attrs;
  }
  /**
   * Input element that opens a dialog with a list for selection.
   * @class Lookup
   * @param {jquery[]|htmlelement} element the base element
   * @param {object} [settings] incoming settings
   * @param {function} [settings.click] Provide a special function to run when the dialog opens to customize the interaction entirely.
   * @param {string} [settings.clickArguments={}] If a click method is defined, this flexible object can be passed
   * into the click method, and augmented with parameters specific to the implementation.
   * @param {function} [settings.clear] Provide a special function to run when the clear x is pressed
   * @param {string} [settings.clearArguments={}] If a clear method is defined, this flexible object can be passed
   * into the clear method, and augmented with parameters specific to the implementation.
   * @param {string} [settings.field='id'] Field name to return from the dataset or can be a function which returns a string on logic
   * @param {string} [settings.title] Dialog title to show, or befault shows  field label + "Lookup"
   * @param {string} [settings.icon] Swap out the lookup id for any other icon in the icon set by name
   * @param {array} [settings.buttons] Pass dialog buttons or Cancel / Apply
   * @param {object} [settings.options] Options to pass to the datagrid
   * @param {function} [settings.beforeShow] Call back that executes async before the lookup is opened.
   * @param {string} [settings.modalContent] Custom modal markup can be sent in here
   * @param {boolean} [settings.editable=true] Can the user type text in the field
   * @param {boolean} [settings.autoApply=true] If set to false the dialog wont apply the value on clicking a value.
   * @param {function} [settings.validator] A function that fires to let you validate form items on open and select
   * @param {boolean} [settings.autoWidth=false] If true the field will grow/change in size based on the content selected.
   * @param {char} [settings.delimiter=','] A character being used to separate data strings
   * @param {int} [settings.minWidth=400] Applys a minimum width to the lookup
   * @param {boolean} [settings.clearable=false] Add an ability to clear the lookup field. If "true", it will affix an "x" button to the right section of the field.
   */


  var LOOKUP_DEFAULTS = {
    click: null,
    field: 'id',
    title: null,
    icon: 'icon-search-list',
    buttons: [],
    options: null,
    beforeShow: null,
    modalContent: null,
    editable: true,
    autoApply: true,
    validator: null,
    autoWidth: false,
    clickArguments: {},
    delimiter: ',',
    minWidth: null,
    clearable: false,
    attributes: null
  };

  function Lookup(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, LOOKUP_DEFAULTS);
    this.init();
  }

  Lookup.prototype = {
    /**
     * @returns {boolean} true if the Lookup is currently the active element.
     */
    get isFocused() {
      var _this$modal;

      var active = document.activeElement;
      var inputIsActive = this.element.is(active);
      var wrapperHasActive = this.element.parent('.lookup-wrapper')[0].contains(active);
      var lookupModalHasActive = (_this$modal = this.modal) === null || _this$modal === void 0 ? void 0 : _this$modal == null ? void 0 : _this$modal.element[0].contains(active);
      return inputIsActive || wrapperHasActive || lookupModalHasActive;
    },

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.inlineLabel = this.element.closest('label');
      this.inlineLabelText = this.inlineLabel.find('.label-text');
      this.isInlineLabel = !!this.inlineLabelText.length;
      this.build();
      this.handleEvents();
      this.grid = null;
      this.selectedRows = null;
    },

    /**
     * Build the UI for the Lookup
     * @private
     * @returns {void}
     */
    build: function build() {
      var _this = this;

      var lookup = this.element; // appends a wrapper to the lookup field.

      function getWrapperCSSClass() {
        var str = 'lookup-wrapper';

        if (lookup.is('.input-xs')) {
          str += ' xs';
        }

        if (lookup.is('.input-sm')) {
          str += ' sm';
        }

        if (lookup.is('.input-lg')) {
          str += ' lg';
        }

        return str;
      }

      var cssClass = getWrapperCSSClass();

      if (this.element.is('.has-actions')) {
        cssClass += ' has-actions-wrapper';
      } // Add Button


      this.icon = $('<span class="trigger"></span>').append($.createIcon(this.settings.icon));

      if (this.settings.icon !== 'icon-search-list') {
        this.icon.addClass('has-custom-icon');
      }

      if (this.isInlineLabel) {
        this.inlineLabel.addClass(cssClass);
      } else {
        this.container = $("<span class=\"".concat(cssClass, "\"></span>"));

        if (this.element.is('.field-options')) {
          var field = this.element.closest('.field');
          var fieldOptionsTrigger = field.find('.btn-actions');
          lookup.add(fieldOptionsTrigger).add(fieldOptionsTrigger.next('.popupmenu')).wrapAll(this.container);
        } else {
          lookup.wrap(this.container);
        }
      }

      lookup.after(this.icon); // Hide icon if lookup input is hidden

      if (lookup.hasClass('hidden')) {
        this.icon.addClass('hidden');
      }

      if (this.settings.autoWidth) {
        this.applyAutoWidth();
      }

      if (!this.minWidth) {
        this.settings.minWidth = this.settings.options && this.settings.options.paging ? 482 : 400;
      } // Add Masking to show the #


      if (lookup.attr('data-mask')) {
        lookup.mask();
      }

      if (this.element.is(':disabled')) {
        this.disable();
      }

      if (this.settings.clearable) {
        lookup.searchfield({
          clearable: true,
          attributes: this.settings.attributes
        });
      }

      if (this.settings.clearable && this.settings.clear) {
        lookup.on('cleared', function (e) {
          _this.settings.clear(e, _this, _this.settings.clearArguments);
        });
      }

      if (!this.settings.editable) {
        this.element.attr('readonly', 'true').addClass('is-not-editable');
      } // Fix field options in case lookup is initialized after


      var wrapper = this.element.parent('.lookup-wrapper');

      if (wrapper.next().is('.btn-actions')) {
        if (this.element.data('fieldoptions')) {
          this.element.data('fieldoptions').destroy();
        }

        this.element.fieldoptions();
      }

      this.addAria();
      if (lookup.attr('autocomplete') === undefined) lookup.attr('autocomplete', 'off'); // Set attributes, if applicable

      if (Array.isArray(this.settings.attributes)) {
        utils.addAttributes(lookup, this, this.settings.attributes, 'input');
        utils.addAttributes(this.icon, this, this.settings.attributes, 'trigger');
      }
    },

    /**
     * Add/Update Aria
     * @private
     * @returns {void}
     */
    addAria: function addAria() {
      var self = this;
      self.label = self.isInlineLabel ? self.inlineLabelText : $("label[for=\"".concat(self.element.attr('id'), "\"]"));
    },

    /**
     * Handle events on the field
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var self = this;
      this.icon.on('click.lookup', function (e) {
        self.openDialog(e);
      }); // Down Arrow opens the dialog in this field

      this.element.on('keyup.lookup', function (e) {
        // If autocomplete open dont open list
        if ($('#autocomplete-list').length > 0) {
          return;
        }

        if (e.which === 40) {
          self.openDialog(e);
        }
      });
    },

    /**
     * Triggers tooltip
     * @private
     * @returns {void}
     */
    setTooltip: function setTooltip() {
      var _this2 = this;

      setTimeout(function () {
        var isOverlapping = _this2.element[0].scrollWidth > _this2.element[0].offsetWidth;

        var tooltipApi = _this2.element.data('tooltip');

        if (isOverlapping) {
          _this2.element.tooltip({
            content: _this2.element.val()
          });
        } else if (tooltipApi && !isOverlapping) {
          tooltipApi.destroy();
        }
      }, 100);
    },

    /**
     * Create and Open the Dialog
     * @private
     * @param {jquery.event} e click or keyup event
     * @returns {void}
     */
    openDialog: function openDialog(e) {
      var self = this; // Don't try to re-open the lookup if it's already open.

      if (this.isOpen) {
        return;
      }
      /**
        * Fires before open dialog.
        *
        * @event beforeopen
        * @memberof Lookup
        * @property {object} event - The jquery event object
        */


      var canOpen = self.element.triggerHandler('beforeopen');

      if (canOpen === false) {
        return;
      }

      if (self.isDisabled() || self.isReadonly() && !self.element.hasClass('is-not-editable')) {
        return;
      }

      if (self.settings.click) {
        self.settings.click(e, this, self.settings.clickArguments);
        return;
      }

      this.isOpen = true;

      if (this.settings.beforeShow) {
        var response = function response(grid) {
          if (grid) {
            self.createGrid(grid);
          }

          if (typeof grid === 'boolean' && grid === false) {
            self.isOpen = false;
            return false;
          }

          self.createModal();
          /**
            * Fires on complete dialog open (for busy indicator).
            *
            * @event complete
            * @memberof Lookup
            * @property {object} event - The jquery event object
            */

          self.element.triggerHandler('complete'); // for Busy Indicator

          /**
            * Fires on open dialog.
            *
            * @event open
            * @memberof Lookup
            * @property {object} event - The jquery event object
            * @property {object} modal instance
            * @property {object} grid in lookup
            */

          self.element.trigger('open', [self.modal, self.grid]);

          if (self.settings.validator) {
            self.settings.validator(self.element, self.modal, self.grid);
          }

          return true;
        };
        /**
          * Fires before start open dialog (for busy indicator).
          *
          * @event start
          * @memberof Lookup
          * @property {object} event - The jquery event object
          */


        this.element.triggerHandler('start'); // for Busy Indicator

        this.settings.beforeShow(this, response);
        return;
      }

      if (!this.settings.options) {
        return;
      }

      self.createModal();
      self.element.trigger('open', [self.modal, self.grid]);
      self.modal.element.find('.btn-actions').removeClass('is-selected'); // Set tabindex on first row

      if (self.grid) {
        self.grid.cellNode(0, 0, true).attr('tabindex', '0');
      } // Fix: IE-11 more button was not showing


      var thisMoreBtn = self.modal.element.find('.toolbar .more > .btn-actions');

      if (thisMoreBtn.length) {
        setTimeout(function () {
          utils.fixSVGIcons(thisMoreBtn);
        }, 600);
      }
      /**
        * Fires after open dialog.
        *
        * @event afteropen
        * @memberof Lookup
        * @property {object} event - The jquery event object
        * @property {object} modal instance
        * @property {object} grid in lookup
        */


      self.element.trigger('afteropen', [self.modal, self.grid]);

      if (self.settings.validator) {
        self.settings.validator(self.element, self.modal, self.grid);
      }
    },

    /**
     * Overidable function to create the modal dialog
     * @returns {void}
     */
    createModal: function createModal() {
      var self = this;
      var content = "<div id=\"".concat(LOOKUP_GRID_ID, "\"></div>");
      var thisLabel = $("label[for=\"".concat(self.element.attr('id'), "\"]"));

      function getLabelText() {
        var _self$settings, _self$settings$option, _self$settings$option2;

        if (self.isInlineLabel) {
          return self.inlineLabelText;
        }

        if (thisLabel.length) {
          return thisLabel.clone().find('span').remove().end().text();
        }

        if (self.settings.title) {
          return self.settings.title;
        }

        if ((_self$settings = self.settings) !== null && _self$settings !== void 0 && (_self$settings$option = _self$settings == null ? void 0 : _self$settings.options) !== null && _self$settings$option !== void 0 && (_self$settings$option2 = _self$settings$option == null ? void 0 : _self$settings$option.toolbar) !== null && _self$settings$option2 !== void 0 && (_self$settings$option2 == null ? void 0 : _self$settings$option2.title)) {
          var _self$settings2, _self$settings2$optio, _self$settings2$optio2;

          return (_self$settings2 = self.settings) === null || _self$settings2 === void 0 ? void 0 : (_self$settings2$optio = _self$settings2 == null ? void 0 : _self$settings2.options) === null || _self$settings2$optio === void 0 ? void 0 : (_self$settings2$optio2 = _self$settings2$optio == null ? void 0 : _self$settings2$optio.toolbar) === null || _self$settings2$optio2 === void 0 ? void 0 : _self$settings2$optio2 == null ? void 0 : _self$settings2$optio2.title;
        }

        return '';
      }

      var labelText = getLabelText();
      var settingContent = this.settings.modalContent;

      if (settingContent && settingContent instanceof jQuery) {
        content = settingContent;
        settingContent.show();
      }

      if (settingContent && !(settingContent instanceof jQuery)) {
        content = settingContent;
      }

      var buttons = this.settings.buttons;

      if (this.settings.options && this.settings.options.selectable === 'multiple' && buttons.length === 0 || !self.settings.autoApply && buttons.length === 0) {
        buttons = [{
          text: Locale.translate('Cancel'),
          click: function click(e, modal) {
            modal.oldActive = self.element;
            modal.close();
          }
        }, {
          text: Locale.translate('Apply'),
          click: function click(e, modal) {
            modal.oldActive = self.element;
            modal.close();
            self.insertRows();
          },
          isDefault: true
        }];
      }

      if (this.settings.options && this.settings.options.selectable === 'single' && buttons.length === 0 && self.settings.autoApply) {
        buttons = [{
          text: Locale.translate('Cancel'),
          click: function click(e, modal) {
            modal.oldActive = self.element;
            modal.close();
          }
        }, {
          text: Locale.translate('Apply'),
          click: function click(e, modal) {
            modal.oldActive = self.element;
            modal.close();
            self.insertRows();
          },
          isDefault: true
        }];
      }

      var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;
      $('body').modal({
        triggerButton: this.element,
        title: labelText,
        content: content,
        buttons: buttons,
        cssClass: "lookup-modal".concat(!hasKeywordSearch ? ' lookup-no-search' : ''),
        attributes: addSuffixToAttributes(this.settings.attributes, [], 'modal')
      }).off('open.lookup').on('open.lookup', function () {
        self.createGrid();
      }).off('close.lookup').on('close.lookup', function () {
        delete self.isOpen;
        /**
          * Fires on close dialog.
          *
          * @event close
          * @memberof Lookup
          * @property {object} event - The jquery event object
          * @property {object} modal instance
          * @property {object} grid in lookup
          */

        self.element.triggerHandler('close', [self.modal, self.grid]);
        self.setTooltip();
      });
      self.modal = $('body').data('modal');

      if (!this.settings.title) {
        self.modal.element.find('.modal-title').append(' <span class="datagrid-result-count"></span>');
      }

      self.modal.element.off('afterclose.lookup').on('afterclose.lookup', function () {
        self.closeTearDown();
      }); // Wait until search field available

      setTimeout(function () {
        $('.modal.is-visible .searchfield').on('keypress.lookup', function (e) {
          if (e.keyCode === 13) {
            return false; // Prevent for closing modal
          }

          return true;
        });
      }, 300);
    },

    /**
     * Tears down the modal/grid elements by removing events, markup, and component instances.
     * @private
     * @returns {void}
     */
    closeTearDown: function closeTearDown() {
      var search = $('.modal.is-visible .searchfield').off('keypress.lookup');

      if (search.data() && search.data('searchfield')) {
        search.data('searchfield').destroy();
      }

      if (search.data() && search.data('searchfield')) {
        search.data('searchfield').destroy();
        search.removeData();
      }

      search = null;

      if (this.grid && this.grid.destroy) {
        this.grid.deSelectAllRows();
        this.grid.clearFilter();
        this.grid.destroy();
        this.grid = null;
      }
    },

    /**
     * Take any number of arrays and merges them.
     * @private
     * @param {array} args any number of arrays
     * @returns {array} merged array
     */
    doMerge: function doMerge() {
      var hash = {};
      var arr = [];

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var i = 0; i < args.length; i++) {
        for (var j = 0; j < args[i].length; j++) {
          if (hash[args[i][j]] !== true) {
            arr[arr.length] = args[i][j];
            hash[args[i][j]] = true;
          }
        }
      }

      return arr;
    },

    /**
     * Overridable Function in which we create the grid on the current UI dialog.
     * @interface
     * @param {jquery[]} grid jQuery wrapped element containing a pre-invoked datagrid instance
     * @returns {void}
     */
    createGrid: function createGrid(grid) {
      var _this$settings,
          _this$settings$option,
          _this$settings$option2,
          _this3 = this;

      var self = this;
      var lookupGrid;

      if (grid) {
        lookupGrid = grid;
        LOOKUP_GRID_ID = grid.attr('id');
        self.settings.options = grid.data('datagrid').settings;
      } else {
        lookupGrid = self.modal.element.find("#".concat(LOOKUP_GRID_ID));
      }

      if (this.settings.minWidth) {
        lookupGrid = this.applyMinWidth(lookupGrid);
      }

      if (self.settings.options) {
        if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
          self.settings.options.cellNavigation = false;
          lookupGrid.find('tr').addClass('is-clickable');
        }

        self.settings.options.isList = true;

        if (self.settings.attributes) {
          self.settings.options.attributes = addSuffixToAttributes(self.settings.attributes, [], 'datagrid');
        } // Create grid (unless already exists from passed in grid)


        if (!lookupGrid.data('datagrid')) {
          lookupGrid.datagrid(self.settings.options);
        }
      }

      self.grid = lookupGrid.data('datagrid');

      if (!this.settings.title && self.modal) {
        self.modal.element.find('.title').not('.selection-count').remove();
      }

      var hasKeywordSearch = (_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : (_this$settings$option = _this$settings == null ? void 0 : _this$settings.options) === null || _this$settings$option === void 0 ? void 0 : (_this$settings$option2 = _this$settings$option == null ? void 0 : _this$settings$option.toolbar) === null || _this$settings$option2 === void 0 ? void 0 : _this$settings$option2 == null ? void 0 : _this$settings$option2.keywordFilter;

      if (!hasKeywordSearch && self.modal) {
        self.modal.element.find('.toolbar').appendTo(self.modal.element.find('.modal-header'));
      } // Reset keyword search from previous loads


      if (hasKeywordSearch && self.grid) {
        if (!self.grid.filterExpr || self.grid.filterExpr && self.grid.filterExpr[0] && self.grid.filterExpr[0].value !== '') {
          self.grid.keywordSearch('');
        }
      } // Mark selected rows


      lookupGrid.off('selected.lookup');
      var val = self.element.val();

      if (val && !this.settings.options.source) {
        self.selectGridRows(val);
      } // Restore selected rows when pages change


      if (this.settings.options.source) {
        lookupGrid.off('afterpaging.lookup').on('afterpaging.lookup', function () {
          var fieldVal = self.element.val();

          _this3.selectGridRows(fieldVal);
        });
      }

      if (this.settings.options) {
        lookupGrid.on('selected.lookup', function (e, selectedRows) {
          // Only proceed if a row is selected
          if (!selectedRows || selectedRows.length === 0) {
            return;
          }

          if (self.settings.validator) {
            self.settings.validator(self.element, self.modal, self.grid);
          }

          if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
            self.modal.close();
            self.insertRows();
          }
        });
      } // Set init values after render the grid


      if (this.settings.options.source) {
        this.grid.element.one('afterrender.lookup', function () {
          if (!_this3.initValues || _this3.initValues && !_this3.initValues.length) {
            _this3.initValues = [];

            var isMatch = function isMatch(node, v) {
              return (node[_this3.settings.field] || '').toString() === v.toString();
            };

            var fieldVal = _this3.element.val();

            if (fieldVal) {
              var fieldValues = fieldVal.indexOf(_this3.settings.delimiter) > 1 ? fieldVal.split(_this3.settings.delimiter) : [fieldVal];
              fieldValues.forEach(function (v) {
                _this3.initValues.push({
                  value: v,
                  visited: !!_this3.grid.settings.dataset.filter(function (node) {
                    return isMatch(node, v);
                  }).length // eslint-disable-line

                });
              });
            }
          }
        });
      }
    },

    /**
     * Given a field value, select the row
     * @param {object} val incoming value from the grid row
     * @returns {void}
     */
    selectGridRows: function selectGridRows(val) {
      var selectedId = val;
      var adjust = false;

      if (!val) {
        return;
      }

      if (this.grid && this.settings.options.source) {
        for (var i = this.grid._selectedRows.length - 1; i > -1; i--) {
          if (isNaN(this.grid._selectedRows[i].idx)) {
            this.grid._selectedRows.splice(i, 1);
          }
        }
      } // Multi Select


      if (selectedId.indexOf(this.settings.delimiter) > 1) {
        var selectedIds = selectedId.split(this.settings.delimiter);
        var isFound = false;

        for (var _i = 0; _i < selectedIds.length; _i++) {
          isFound = this.selectRowByValue(this.settings.field, selectedIds[_i]);

          if (this.grid && this.settings.options.source && !isFound) {
            var data = {};
            var foundInData = false;

            for (var j = 0; j < this.grid._selectedRows.length; j++) {
              if (this.grid._selectedRows[j].data[this.settings.field].toString() === selectedIds[_i].toString()) {
                foundInData = true;
              }
            }

            if (!foundInData) {
              data[this.settings.field] = selectedIds[_i];

              this.grid._selectedRows.push({
                data: data
              });
            }

            adjust = true;
          }
        } // There are rows selected off page. Update the count.


        if (adjust) {
          var self = this;
          self.modal.element.find('.contextual-toolbar .selection-count').text("".concat(selectedIds.length, " ").concat(Locale.translate('Selected')));
          this.grid.syncSelectedUI();
        }
      } else {
        // For Single Record Select
        var _selectedIds = [];

        _selectedIds.push(selectedId);

        var _isFound = false;

        for (var _i2 = 0; _i2 < _selectedIds.length; _i2++) {
          _isFound = this.selectRowByValue(this.settings.field, _selectedIds[_i2]);

          if (this.grid && this.settings.options.source && !_isFound) {
            var _data = {};
            var _foundInData = false;

            for (var _j = 0; _j < this.grid._selectedRows.length; _j++) {
              if (this.grid._selectedRows[_j].data[this.settings.field].toString() === _selectedIds[_i2].toString()) {
                _foundInData = true;
              }
            }

            if (!_foundInData) {
              _data[this.settings.field] = _selectedIds[_i2];

              this.grid._selectedRows.push({
                data: _data
              });
            }

            adjust = true;
          }
        } // There are rows selected off page. Update the count.


        if (adjust) {
          var _self = this;

          _self.modal.element.find('.contextual-toolbar .selection-count').text("".concat(_selectedIds.length, " ").concat(Locale.translate('Selected')));

          this.grid.syncSelectedUI();
        }

        return;
      }

      this.selectRowByValue(this.settings.field, selectedId);
    },

    /**
     * Find the row and select it based on select value / function / field value
     * @param {string} field the ID of the field whose value is to be returned.
     * @param {string} value the value to set.
     * @returns {boolean} True if the id is found.
     */
    selectRowByValue: function selectRowByValue(field, value) {
      if (!this.settings.options) {
        return false;
      }

      var data = this.settings.options.source ? this.grid.settings.dataset : this.settings.options.dataset;
      var selectedRows = []; // in this case we will recall on source - server side paging

      if (!data) {
        return false;
      }

      for (var i = 0; i < data.length; i++) {
        var _data$i$field;

        var isMatch = false;

        if (typeof this.settings.match === 'function') {
          if (this.settings.match(value, data[i], this.element, this.grid)) {
            isMatch = true;
          }
        }

        if (typeof this.settings.match !== 'function' && ((_data$i$field = data[i][field]) === null || _data$i$field === void 0 ? void 0 : _data$i$field == null ? void 0 : _data$i$field.toString()) === (value === null || value === void 0 ? void 0 : value == null ? void 0 : value.toString())) {
          isMatch = true;
        }

        if (isMatch) {
          var rowIndex = this.grid.settings.source ? this.grid.actualRowIndex(this.grid.tableBody.find('tr').eq(i)) : i;
          selectedRows.push(rowIndex);
        }
      }

      if (this.grid && selectedRows.length > 0) {
        this.grid.selectRows(selectedRows, false, true);
        return true;
      }

      return false;
    },

    /**
     * Get the selected rows and return them to the UI
     * @returns {void}
     */
    insertRows: function insertRows() {
      var value = [];
      this.selectedRows = this.grid.selectedRows();

      for (var i = 0; i < this.selectedRows.length; i++) {
        var currValue = '';

        if (typeof this.settings.field === 'function') {
          currValue = this.settings.field(this.selectedRows[i].data, this.element, this.grid);
        } else {
          currValue = this.selectedRows[i].data[this.settings.field];
        } // Push the value/s to the Array.


        value.push(currValue); // Clear _selected tag

        var idx = this.selectedRows[i].idx;

        if (this.settings.options.dataset && this.settings.options.dataset[idx]) {
          delete this.settings.options.dataset[idx]._selected;
        }
      } // Eliminate duplicate values.


      value = value.filter(function (a, b) {
        return value.indexOf(a) === b;
      });
      /**
        * Fires on input value change.
        *
        * @event change
        * @memberof Lookup
        * @property {object} event - The jquery event object
        * @property {object} selected rows
        */

      this.element.val(value.join(this.settings.delimiter)).trigger('change', [this.selectedRows]);
      this.element.trigger('input', [this.selectedRows]);
      this.applyAutoWidth();
      this.element.focus();
    },

    /**
     * Enable the input.
     * @returns {void}
     */
    enable: function enable() {
      this.element.prop('disabled', false).prop('readonly', false);
      this.element.parent().removeClass('is-disabled');
    },

    /**
     * Disable the input.
     * @returns {void}
     */
    disable: function disable() {
      this.element.prop('disabled', true);
      this.element.parent().addClass('is-disabled');
    },

    /**
     * Make the input readonly.
     * @returns {void}
     */
    readonly: function readonly() {
      this.element.prop('readonly', true);
    },

    /**
     * Make the input the size of the text.
     * @private
     * @returns {void}
     */
    applyAutoWidth: function applyAutoWidth() {
      var value = this.element.val();
      var length = value.length;
      var isUpperCase = value === value.toUpperCase();
      var isNumber = !isNaN(value);
      this.element.attr('size', length + (isUpperCase && !isNumber ? 2 : 1));
    },

    /**
     * Apply the min width setting to the datagrid.
     * @private
     * @param {jquery[]} lookupGrid jQuery wrapped element
     * @returns {jquery[]} grid jQuery wrapped element with the css applied
     */
    applyMinWidth: function applyMinWidth(lookupGrid) {
      if (this.settings.minWidth == null) {
        return lookupGrid;
      } // check that the minWidth is less than the windows width, so
      // that the control remains responsive


      if ($(window).width() > this.settings.minWidth) {
        this.modal.element.addClass('has-minwidth');
        var minWidth = "".concat(this.settings.minWidth, "px");
        lookupGrid.css({
          'min-width': minWidth
        });
      }

      return lookupGrid;
    },

    /**
     * Input is disabled or not
     * @returns {boolean} whether or not the Input is disabled
     */
    isDisabled: function isDisabled() {
      return this.element.prop('disabled');
    },

    /**
     * Input is readonly or not
     * @returns {boolean} whether or not the Input is readonly
     */
    isReadonly: function isReadonly() {
      return this.element.prop('readonly');
    },

    /**
     * Updates the lookup instance with new settings
     * @param {object} settings incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },

    /**
    * Send in a new data set to display in the datagrid in the lookup.
    * This will work whether or not the lookup is open or closed.
    * @param {object} dataset The array of data to show in the datagridgrid.
    * @param {object} pagerInfo The extra pager info object with information like activePage and pagesize.
    */
    updateDataset: function updateDataset(dataset, pagerInfo) {
      this.settings.options.dataset = dataset;

      if (pagerInfo && pagerInfo.activePage) {
        this.settings.options.activePage = pagerInfo.activePage;
      }

      if (pagerInfo && pagerInfo.pagesize) {
        this.settings.options.pagesize = pagerInfo.pagesize;
      }

      if (this.grid) {
        this.grid.updateDataset(dataset, pagerInfo);
      }
    },

    /**
    * Teardown events and objects.
    * @returns {void}
    */
    destroy: function destroy() {
      $('.modal .searchfield').off('keypress.lookup');
      $('body').off('open.lookup close.lookup');
      this.icon.off('click.lookup');
      this.icon.remove();
      this.element.off('keyup.lookup');
      this.element.unwrap();

      if (this.modal && this.modal.element) {
        this.modal.element.off('afterclose.lookup');

        if (typeof this.modal.destroy === 'function') {
          this.modal.destroy();
        }
      }

      $.removeData(this.element[0], COMPONENT_NAME$1d);
    }
  };

  /**
   * jQuery Component Wrapper for Lookup
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */

  $.fn.lookup = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1d);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1d, new Lookup(this, settings));
      }
    });
  };

  function addStandardInputFeatures(input, row, cell, value, container, column, e, api, item) {
    if (column.align) {
      input.addClass("l-".concat(column.align, "-text"));
    }

    if (column.maxLength) {
      input.attr('maxlength', column.maxLength);
    }

    if (column.uppercase) {
      input.addClass('uppercase-text');
    }

    if (column.mask && typeof column.mask === 'function') {
      var mask = column.mask(row, cell, value, column, item);
      input.mask({
        pattern: mask,
        mode: column.maskMode
      });
    } else if (column.maskOptions && typeof column.maskOptions === 'function') {
      var maskOptions = column.maskOptions(row, cell, value, column, item);
      input.mask(maskOptions);
    } else if (column.mask) {
      input.mask({
        pattern: column.mask,
        mode: column.maskMode
      });
    }

    var defaults = {
      patternOptions: {
        allowNegative: true,
        allowDecimal: true,
        integerLimit: 4,
        decimalLimit: 2,
        symbols: {
          thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
          decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
          negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
        }
      },
      process: 'number'
    };
    var useMask = false;

    if (column.maskOptions) {
      useMask = true;
    }

    if (column.numberFormat) {
      useMask = true;
      defaults = {
        patternOptions: {
          decimalLimit: column.numberFormat.maximumFractionDigits
        }
      };
    }

    if (column.maskOptions && typeof column.maskOptions === 'function') {
      useMask = false;
    }

    if (useMask) {
      column.maskOptions = utils.extend(true, {}, defaults, column.maskOptions);
      input.mask(column.maskOptions);
    }

    if (!column.align || column.align !== 'right') {
      input.removeClass('is-number-mask');
    }
  }
  /**
  *  A object containing all the supported Editors.
  * @private
  */


  var editors = {
    // Supports, Text, Numeric, Integer via mask
    Input: function Input(row, cell, value, container, column, e, api, item) {
      this.name = 'input';
      this.originalValue = value;
      this.useValue = !!column.inlineEditor;

      this.init = function () {
        if (column.inlineEditor) {
          this.input = container.find('input');
        } else {
          this.input = $("<input type=\"".concat(column.inputType || 'text', "\" autocomplete=\"off\"/>")).appendTo(container);
        }

        addStandardInputFeatures(this.input, row, cell, value, container, column, e, api, item);
      };

      this.val = function (v) {
        var thisValue;

        if (v) {
          this.input.val(v);
        }

        if (column && column.numberFormat && column.numberFormat.style === 'percent') {
          thisValue = this.input.val().trim().replace(/(\s%?|%)$/g, '');
          return Locale.parseNumber(thisValue) / 100;
        }

        return this.input.val();
      };

      this.focus = function () {
        this.input.focus();

        if (api.settings.selectOnEdit) {
          this.input.select();
        }
      };

      this.destroy = function () {
        var _this = this;

        if (column.inlineEditor) {
          return;
        }

        setTimeout(function () {
          _this.input.remove();
        }, 0);
      };

      this.init();
    },
    Textarea: function Textarea(row, cell, value, container, column, e, api) {
      this.name = 'textarea';
      this.originalValue = value;

      this.init = function () {
        container.addClass('datagrid-textarea-cell-wrapper');
        var autogrowStartHeight = container.get(0).scrollHeight;
        var style = column.editorOptions && column.editorOptions.minHeight ? "style=\"min-height: ".concat(column.editorOptions.minHeight, "px\"") : '';
        this.input = $("<textarea ".concat(style, " class=\"textarea\">").concat(this.originalValue, "</textarea>")).appendTo(container);
        var editorOptions = column.editorOptions ? column.editorOptions : {}; // disable the characterCounter by default

        if (!('characterCounter' in editorOptions)) {
          editorOptions.characterCounter = false;
        }

        this.api = this.input.data('autogrow-start-height', autogrowStartHeight).textarea(column.editorOptions).data('textarea');
        this.input.on('click.textareaeditor', function (evt) {
          evt.stopPropagation();
        });

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }
      };

      this.val = function (v) {
        if (v) {
          // note that focus will help move text to end of input.
          this.input.focus().val(v);
        }

        return this.input.val();
      };

      this.focus = function () {
        this.input.focus();

        if (api.settings.selectOnEdit) {
          this.input.select();
        }
      };

      this.destroy = function () {
        var _this2 = this;

        container.removeClass('datagrid-textarea-cell-wrapper');
        setTimeout(function () {
          _this2.input.off('click.textareaeditor');

          _this2.input.remove();
        }, 0);
      };

      this.init();
    },
    // Rich Text Editor
    Editor: function Editor(row, cell, value, container, column, e, api) {
      this.name = 'editor';
      this.originalValue = value;

      this.init = function () {
        var self = this; // Editor options

        var editorOptions = $.extend({}, {
          buttons: {
            editor: ['header1', 'header2', 'separator', 'bold', 'italic', 'underline', 'separator', 'foreColor', 'separator', 'justifyLeft', 'justifyCenter', 'justifyRight'],
            source: []
          },
          excludeButtons: {
            editor: []
          }
        }, column.editorOptions); // Editor width

        this.editorWidth = api.setUnit(editorOptions.width || container.outerWidth());
        delete editorOptions.width;
        container[0].innerHTML = "<div class=\"editor-wrapper\" style=\"width: ".concat(this.editorWidth, ";\">\n          <div class=\"editor\" data-init=\"false\">").concat(xssUtils.unescapeHTML(value), "</div>\n        </div>");
        this.td = container.closest('td');
        this.input = $('.editor', container);
        this.input.popover({
          content: $('.editor-wrapper', container),
          placementOpts: {
            x: 0,
            y: "-".concat(parseInt(container[0].style.height, 10) + 35),
            parent: this.td,
            parentXAlignment: Locale.isRTL() ? 'right' : 'left',
            strategies: ['flip', 'nudge', 'shrink']
          },
          placement: 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#editor-popup',
          extraClass: 'editor-popup',
          onHidden: function onHidden() {
            api.commitCellEdit(self.input);
          }
        }).editor(editorOptions).on('keydown.editor', function (event) {
          var key = event.which || event.keyCode || event.charCode || 0; // Ctrl + Enter (Some browser return keyCode: 10, not 13)

          if ((event.ctrlKey || event.metaKey) && (key === 13 || key === 10)) {
            var apiPopover = self.input.data('tooltip');

            if (apiPopover) {
              apiPopover.hide();
              api.setNextActiveCell(event);
            }
          }
        });
        utils.fixSVGIcons($('#editor-popup'));
      };

      this.val = function () {
        return xssUtils.escapeHTML(this.input.html());
      };

      this.focus = function () {
        var _this3 = this;

        setTimeout(function () {
          _this3.input.focus();
        }, 0);
      };

      this.destroy = function () {
        var self = this;
        container.removeAttr('style');
        api.quickEditMode = false;

        if (self.input.data('editor')) {
          self.input.destroy();
          self.input.remove();
        }
      };

      this.init();
    },
    Checkbox: function Checkbox(row, cell, value, container, column, event, grid) {
      this.name = 'checkbox';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value

      this.container = container;

      this.init = function () {
        this.input = $('<input type="checkbox" class="checkbox"/>').appendTo(container);
        this.input.after('<label class="checkbox-label"></label>');

        if (column.align) {
          this.input.addClass("l-".concat(column.align, "-text"));
        }
      };

      this.val = function (v) {
        // eslint-disable-line
        var isChecked;

        if (v === undefined) {
          return this.input.prop('checked');
        } // Use isChecked function if exists


        if (column.isChecked) {
          isChecked = column.isChecked(v);
        } else {
          isChecked = v;
        } // just toggle it if we click right on it


        if ((event.type === 'click' || event.type === 'keydown' && event.keyCode === 32) && !$(event.target).is('.datagrid-checkbox-wrapper, .datagrid-cell-wrapper')) {
          isChecked = !isChecked;
          grid.setNextActiveCell(event);
        }

        this.input.prop('checked', isChecked);
      };

      this.focus = function () {
        this.input.trigger('focusout');
        this.container.parent().focus();
      };

      this.destroy = function () {
        var _this4 = this;

        setTimeout(function () {
          _this4.input.next('.checkbox-label').remove();

          _this4.input.remove();
        }, 0);
      };

      this.init();
    },
    Colorpicker: function Colorpicker(row, cell, value, container, column, event, grid) {
      this.name = 'colorpicker';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value

      value = xssUtils.stripTags(value);

      this.init = function () {
        this.input = $("<input id=\"colorpicker-".concat(cell, "\" name=\"colorpicker-").concat(cell, "\" class=\"colorpicker\" value=\"").concat(value, "\" type=\"text\" autocomplete=\"off\"/>")).appendTo(container);
        this.input.colorpicker(column.editorOptions);
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        var self = this;
        this.input.trigger('openlist');
        var rowNodes = grid.rowNodes(row);
        rowNodes.removeClass('is-hover-row');
        this.input.focus();

        if (grid.settings.selectOnEdit) {
          this.input.select();
        }

        this.input.off('listclosed').on('listclosed', function () {
          grid.commitCellEdit(self.input);
          container.parent('td').focus();
          return; // eslint-disable-line
        });
      };

      this.destroy = function () {// We dont need to destroy since it will when the list is closed
      };

      this.init();
    },
    Dropdown: function Dropdown(row, cell, value, container, column, event, grid, rowData) {
      this.name = 'dropdown';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value

      this.cell = grid.activeCell;

      this.init = function () {
        var _this5 = this;

        if (column.inlineEditor) {
          this.input = container.find('select');
          return;
        }

        this.input = $('<select class="dropdown"></select>').appendTo(container);

        if (column.options) {
          var html;
          var opt;
          var optionValue;
          value = grid.fieldValue(rowData, column.field);
          var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

          for (var i = 0; i < column.options.length; i++) {
            html = $('<option></option>');
            opt = column.options[i];
            optionValue = column.caseInsensitive && typeof opt.value === 'string' ? opt.value.toLowerCase() : opt.value;

            if (opt.selected || compareValue === optionValue) {
              html.attr('selected', 'true');
              this.originalValue = optionValue;
            }

            html.attr('value', opt.value).attr('id', opt.id).attr('data-type', _typeof(opt.value));
            html.text(opt.label);
            this.input.append(html);
          }
        }

        var editorOptions = column.editorOptions || {};

        function hasEditingClass() {
          return editorOptions.cssClass && /is-editing/g.test(editorOptions.cssClass);
        } // Add the class to both the options being passed, as well as the column's original options


        if (!hasEditingClass()) {
          editorOptions.cssClass = editorOptions.cssClass || '';
          editorOptions.cssClass += ' is-editing';
        }

        this.input.dropdown(editorOptions);
        this.input.on('requestend', function () {
          _this5.val(_this5.datasetValue);
        }); // Append the Dropdown's sourceArguments with some row/col meta-data

        var api = this.input.data('dropdown');
        api.settings.sourceArguments = {
          column: column,
          container: container,
          grid: grid,
          cell: cell,
          event: event,
          row: row,
          rowData: rowData,
          value: value
        };
      };

      this.val = function (v) {
        this.datasetValue = v;

        if (v !== undefined) {
          var compareValue = column.caseInsensitive && typeof v === 'string' ? v.toLowerCase() : v;
          this.input.val(v);
          this.input.find('option').each(function () {
            var opt = $(this);
            var valueAttr = opt.attr('value');
            var type = opt.attr('data-type');
            var optionValue = valueAttr; // Get option value in proper type before checking equality

            if (type === 'number') {
              optionValue = parseFloat(valueAttr);
            } else if (type === 'boolean') {
              optionValue = valueAttr === 'true';
            } else if (type === 'string' && column.caseInsensitive) {
              optionValue = valueAttr.toLowerCase();
            }

            if (optionValue === compareValue) {
              opt.attr('selected', 'true');
            }
          });
        }

        var selected = this.input.find(':selected');
        var val = selected.attr('value');
        var dataType = selected.attr('data-type'); // For non-string option values (number, boolean, etc.),
        // convert string attr value to proper type

        if (dataType === 'number') {
          val = parseFloat(val);
        } else if (dataType === 'boolean') {
          val = val === 'true';
        }

        if (val === undefined) {
          val = selected.text();
        }

        return val;
      };

      this.focus = function () {
        var self = this; // Check if isClick or cell touch and just open the list

        if (event.type === 'click') {
          this.input.trigger('openlist');
          var rowNodes = grid.rowNodes(row);
          rowNodes.removeClass('is-hover-row');
          $('#dropdown-list input').focus();
        } else {
          this.input[0].parentNode.querySelector('div.dropdown').focus();
        } // Unselect dropdown search, and move cursor at end


        if (!grid.settings.selectOnEdit) {
          var ddSearch = $('#dropdown-search')[0];

          if (ddSearch) {
            if (typeof ddSearch.selectionStart === 'number') {
              ddSearch.selectionEnd = ddSearch.value.length;
              ddSearch.selectionStart = ddSearch.selectionEnd;
            } else if (typeof ddSearch.createTextRange !== 'undefined') {
              var range = ddSearch.createTextRange();
              range.collapse(false);
              range.select();
            }
          }
        }

        this.input.off('listclosed').on('listclosed', function (e, type) {
          grid.commitCellEdit(self.input);

          if (type === 'select') {
            container.parent('td').focus();
            return;
          }

          if (type === 'tab') {
            setTimeout(function () {
              container.parent('td').focus();
            }, 100);
          }
        });
      };

      this.destroy = function () {// We dont need to destroy since it will when the list is closed
      };

      this.init();
    },
    Date: function Date(row, cell, value, container, column, event, grid) {
      this.name = 'date';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="datepicker" autocomplete="off"/>').appendTo(container);
        this.input.datepicker(column.editorOptions || {
          dateFormat: column.dateFormat
        });
      };

      this.val = function (v) {
        if (v === '0000' || v === '000000' || v === '00000000') {
          // Means no date in some applications
          v = '';
        }

        if (v) {
          // Note that the value should be formatted from the formatter.
          this.input.val(v);
        }

        return formatters.Date(row, cell, this.input.val(), column, true);
      };

      this.focus = function () {
        var self = this;
        this.input.focus();

        if (grid.settings.selectOnEdit) {
          this.input.select();
        } // Check if isClick or cell touch and just open the list


        if (event.type === 'click' && $(event.target).is('.icon')) {
          this.input.parent().find('.icon').trigger('click');
          this.input.closest('td').addClass('is-focused');
        }

        this.input.on('listclosed', function () {
          self.input.closest('td').removeClass('is-focused');
          setTimeout(function () {
            self.input.trigger('focusout');
            container.parent().focus();
            grid.setNextActiveCell(event);
          }, 1);
        });
      };

      this.destroy = function () {
        var _this6 = this;

        setTimeout(function () {
          grid.quickEditMode = false;

          _this6.input.remove();
        }, 0);
      };

      this.init();
    },
    Fileupload: function Fileupload(row, cell, value, container, column, event, grid) {
      var _this7 = this;

      var s = utils.mergeSettings(undefined, column.editorOptions, {
        allowedTypes: '*' // restrict file types(ie. 'jpg|png|gif') ['*' all types]

      });
      var fileExtensions = s.allowedTypes.split(/[\s|]+/g);
      var id = utils.uniqueId(this, "fileupload-".concat(row, "-").concat(cell, "-"));
      var multiple = s.useMultiple ? ' multiple' : '';
      var disabled = s.isDisabled ? ' disabled' : '';
      var types = '';

      if (fileExtensions.length === 1) {
        if (fileExtensions[0] !== '*') {
          types = ".".concat(xssUtils.ensureAlphaNumeric(fileExtensions[0]));
        }
      } else {
        for (var i = 0, l = fileExtensions.length; i < l; i++) {
          types += ".".concat(xssUtils.ensureAlphaNumeric(fileExtensions[i]) + (i !== l - 1 ? ',' : ''));
        }
      }

      if (types !== '') {
        types = " accept=\"".concat(types, "\"");
      }

      this.name = 'fileupload';
      this.originalValue = value;
      this.status = 'init';
      this.useValue = true; // use the data set value not cell value

      this.init = function () {
        id = xssUtils.ensureAlphaNumeric(id);
        multiple = xssUtils.ensureAlphaNumeric(multiple);
        disabled = xssUtils.ensureAlphaNumeric(disabled);
        this.input = $("<input id=\"".concat(id, "\" name=\"").concat(id, "\" class=\"fileupload\" type=\"file\" ").concat(types).concat(multiple).concat(disabled, " autocomplete=\"off\"/>"));
        container.append("<label>".concat(this.input[0].outerHTML, "</label>"));
        this.api = this.input.fileupload(column.editorOptions).data('fileupload');
        this.input.closest('td').addClass('is-fileupload').find('label:eq(1)').addClass('audible');
      };

      this.val = function (v) {
        if (v) {
          v = xssUtils.stripTags(v);
          this.input.attr('value', v);
          return v;
        }

        return this.input.val();
      };

      this.focus = function () {
        /**
         * Handle cancel on file-input
         * Bind body to listen one time only, right after file chooser window popup open
         * Listen on body `focusin`(on close popup window),
         * if no `change` event triggered means it canceled
         * @private
         * @returns {void}
         */
        var handleCancel = function handleCancel() {
          $('body').one('focusin.fileuploadeditor', function () {
            setTimeout(function () {
              if (_this7.status !== 'change') {
                _this7.status = 'cancel';
                grid.commitCellEdit(_this7.input);
              }
            }, 100);
          });
        };
        /**
         * Handle clear the value on file-input
         * @private
         * @returns {void}
         */


        var handleClear = function handleClear() {
          if (_this7.originalValue !== '') {
            _this7.status = 'clear';
          }

          grid.commitCellEdit(_this7.input);
        };
        /**
         * Open file chooser popup window for file-input
         * @private
         * @returns {void}
         */


        var openFileChooserWindow = function openFileChooserWindow() {
          if (_this7.api) {
            handleCancel();

            _this7.api.fileInput.trigger('click');
          }
        }; // Handle change for file-input


        _this7.input.on('change.fileuploadeditor', function () {
          _this7.status = 'change';
          grid.commitCellEdit(_this7.input);
        }); // Using keyboard


        if (event.type === 'keydown') {
          var key = event.which || event.keyCode || event.charCode || 0;

          if (key === 8 || key === 46) {
            // Backspace: 8, Delete: 46
            handleClear();
          } else if (key === 13 || key === 10) {
            // Enter (Some browser return keyCode: 10, not 13)
            openFileChooserWindow();
          } else {
            grid.commitCellEdit(_this7.input);
          }
        } // Check if isClick or cell touch


        if (event.type === 'click') {
          var target = $(event.target);

          if (target.is('.icon-close')) {
            handleClear();
          } else if (target.is('.icon-fileupload')) {
            openFileChooserWindow();
          } else {
            grid.commitCellEdit(_this7.input);
          }
        }
      };

      this.destroy = function () {
        _this7.input.off('change.fileuploadeditor');

        grid.quickEditMode = false;

        if (_this7.api) {
          _this7.api.destroy();
        }
      };

      this.init();
    },
    Time: function Time(row, cell, value, container, column, event, grid) {
      this.name = 'time';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="timepicker" autocomplete="off" />').appendTo(container);
        this.api = this.input.timepicker(column.editorOptions || '').data('timepicker');
      };

      this.val = function (v) {
        if (v) {
          // Note that the value should be formatted from the formatter.
          this.input.val(v);
        }

        return this.input.val();
      };

      this.focus = function () {
        var self = this;
        this.input.focus();

        if (grid.settings.selectOnEdit) {
          this.input.select();
        } // Check if isClick or cell touch and just open the list


        if (event.type === 'click' && $(event.target).is('.icon')) {
          this.input.parent().find('.icon').trigger('click');
          this.input.closest('td').addClass('is-focused');
        }

        this.api.trigger.on('hide.editortime', function () {
          self.input.closest('td').removeClass('is-focused');
          setTimeout(function () {
            self.input.trigger('focusout');
            container.parent().focus();
            grid.setNextActiveCell(event);
          }, 1);
        });
      };

      this.destroy = function () {
        var self = this;

        if (self.api && self.api.trigger) {
          self.api.trigger.off('hide.editortime');
        }

        setTimeout(function () {
          grid.quickEditMode = false;
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Lookup: function Lookup(row, cell, value, container, column, event, grid, rowData) {
      this.name = 'lookup';
      this.originalValue = value;

      this.init = function () {
        this.input = $("<input class=\"lookup ".concat(column.align === 'right' ? 'align-text-right' : '', "\" data-init=\"false\" autocomplete=\"off\" />")).appendTo(container);
        addStandardInputFeatures(this.input, row, cell, value, container, column, event, grid, rowData);

        if (!column.editorOptions) {
          column.editorOptions = {};
        }

        if (!column.editorOptions.options) {
          column.editorOptions.options = {};
        }

        if (!column.editorOptions.options.toolbar) {
          column.editorOptions.options.toolbar = {};
        }

        if (!column.editorOptions.options.toolbar.title) {
          column.editorOptions.options.toolbar.title = column.name;
        }

        this.input.lookup(column.editorOptions);
        container.find('span.trigger').attr('tabindex', '-1'); // Append the Lookup's clickArguments with some row/col meta-data

        var api = this.input.data('lookup');
        api.settings.clickArguments = {
          column: column,
          container: container,
          grid: grid,
          cell: cell,
          event: event,
          row: row,
          rowData: rowData,
          value: value
        };
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        var self = this;
        var api = self.input.data('lookup');
        var td = self.input.closest('td'); // Using keyboard

        if (event.type === 'keydown') {
          self.input.focus();

          if (grid.settings.selectOnEdit) {
            self.input.select();
          }

          td.on('keydown.editorlookup', function (e) {
            if (e.keyCode === 40) {
              e.preventDefault();
              e.stopPropagation();
            }
          });
        } // Check if isClick or cell touch and just open the list


        if (event.type === 'click') {
          if ($(event.target).is('svg')) {
            api.openDialog(event);
          } else {
            self.input.focus();

            if (grid.settings.selectOnEdit) {
              self.input.select();
            }

            td.on('touchcancel.editorlookup touchend.editorlookup', '.trigger', function () {
              api.openDialog();
            });
          }
        } // Update on change from lookup


        self.input.on('change.editorlookup', function () {
          grid.quickEditMode = false;
        });
      };

      this.destroy = function () {
        var self = this;
        var td = this.input.closest('td');
        setTimeout(function () {
          grid.quickEditMode = false;
          td.off('keydown.editorlookup').find('.trigger').off('touchcancel.editorlookup touchend.editorlookup');
          self.input.remove();
        }, 0);
      };

      this.init();
    },
    Autocomplete: function Autocomplete(ow, cell, value, container, column, event, grid) {
      this.name = 'autocomplete';
      this.originalValue = value;

      this.init = function () {
        this.input = $('<input class="autocomplete datagrid-autocomplete" autocomplete="off" />').appendTo(container);

        if (!column.editorOptions) {
          column.editorOptions = {};
        }

        column.editorOptions.width = container.parent().width();
        column.editorOptions.offset = {
          left: -1,
          top: grid.settings.rowHeight === 'medium' ? 1 : 5
        };

        if (column.maxLength) {
          this.input.attr('maxlength', column.maxLength);
        }

        if (column.uppercase) {
          this.input.addClass('uppercase-text');
        }

        this.input.autocomplete(column.editorOptions);
      };

      this.val = function (v) {
        return v ? this.input.val(v) : this.input.val();
      };

      this.focus = function () {
        grid.quickEditMode = true;
        this.input.focus();

        if (grid.settings.selectOnEdit) {
          this.input.select();
        }
      };

      this.destroy = function () {
        var _this8 = this;

        setTimeout(function () {
          grid.quickEditMode = false;

          _this8.input.remove();
        }, 0);
      };

      this.init();
    },
    Spinbox: function Spinbox(ow, cell, value, container, column, event, grid) {
      var self = this;
      this.name = 'spinbox';
      this.originalValue = value;
      this.useValue = true; // use the data set value not cell value

      this.init = function () {
        if (column.inlineEditor) {
          self.input = container.find('input');
          return;
        }

        var markup = "<label for=\"spinbox-".concat(cell, "\" class=\"audible\">Quantity</label>\n        <span class=\"spinbox-wrapper\"><span class=\"spinbox-control down\">-</span>\n        <input id=\"spinbox-").concat(cell, "\" name=\"spinbox-").concat(cell, "\" type=\"text\" class=\"spinbox\" value=\"'+ ").concat(value, " +'\" autocomplete=\"off\" />\n        <span class=\"spinbox-control up\">+</span></span>");
        DOM.append(container, markup, '<label><span><input>');
        self.input = container.find('input');

        if (!column.editorOptions) {
          column.editorOptions = {};
        }

        self.input.spinbox(column.editorOptions);
      };

      this.val = function (v) {
        if (v) {
          self.input.val(v);
        }

        return parseInt(self.input.val(), 10);
      };

      this.focus = function () {
        grid.quickEditMode = true;
        self.input.focus();

        if (grid.settings.selectOnEdit) {
          self.input.select();
        }
      };

      this.destroy = function () {
        if (column.inlineEditor) {
          return;
        }

        setTimeout(function () {
          grid.quickEditMode = false;
          var textVal = self.val();

          if (self.input && self.input.data('spinbox')) {
            self.input.data('spinbox').destroy();
          }

          if (self.input) {
            self.input.remove();
          }

          container.text(textVal);
        }, 0);
      };

      this.init();
    },
    Favorite: function Favorite(row, cell, value, container, column, event, grid) {
      this.name = 'favorite';
      this.useValue = true;
      this.originalValue = value;

      this.init = function () {
        this.input = $("<span class=\"icon-favorite\">".concat($.createIcon({
          icon: value ? 'star-filled' : 'star-outlined'
        }), "<input type=\"checkbox\"></span>")).appendTo(container);
        this.input = this.input.find('input');
      };

      this.val = function (v) {
        // eslint-disable-line
        var isChecked;

        if (v === undefined) {
          return this.input.prop('checked');
        } // Use isChecked function if exists


        if (column.isChecked) {
          isChecked = column.isChecked(v);
        } else {
          isChecked = v;
        } // just toggle it when clicked


        if ((event.type === 'click' || event.type === 'keydown' && event.keyCode === 32) && !$(event.target).is('.datagrid-cell-wrapper')) {
          isChecked = !isChecked;
          grid.setNextActiveCell(event);
        }

        this.input.prop('checked', isChecked);
        this.input.find('use').attr('href', isChecked ? '#icon-star-filled' : '#icon-star-outlined');
      };

      this.focus = function () {
        this.input.trigger('focusout').focus();
      };

      this.destroy = function () {
        var _this9 = this;

        setTimeout(function () {
          _this9.input.parent().remove();
        }, 0);
      };

      this.init();
    }
  };

  var COMPONENT_NAME$1e = 'datagrid';
  /**
   * The Datagrid Component displays and process data in tabular format.
   * @class Datagrid
   * @constructor
   *
   * @param {jQuery[]|HTMLElement} element The component element.
   * @param {object}   [settings] The component settings.
   * @param {boolean}  [settings.actionableMode=false] If actionableMode is "true, tab and shift tab behave like left and right arrow key, if the cell is editable it goes in and out of edit mode. F2 - toggles actionableMode "true" and "false"
   * @param {boolean}  [settings.cellNavigation=true] If cellNavigation is "false, will show border around whole row on focus
   * @param {boolean}  [settings.rowNavigation=true] If rowNavigation is "false, will NOT show border around the row
   * @param {boolean}  [settings.showHoverState=true] If false there will be no hover effect.
   * @param {boolean}  [settings.alternateRowShading=false] Sets shading for readonly grids
   * @param {array}    [settings.columns=[]] An array of columns (see column options)
   * @param {array}    [settings.frozenColumns={ left: [], right: [] }] An object with two arrays of column id's. One for freezing columns to the left side, and one for freezing columns to the right side.
   * @param {boolean}  [settings.frozenColumns.expandRowAcrossAllCells=true] Expand the expandable across all frozen columns.
   * @param {array}    [settings.dataset=[]] An array of data objects
   * @param {boolean}  [settings.columnReorder=false] Allow Column reorder
   * @param {boolean}  [settings.saveColumns=false] Save Column Reorder and resize, this is deprecated, use saveUserSettings
   * @param {object}   [settings.saveUserSettings]
   * @param {object}   [settings.saveUserSettings.columns=true]
   * @param {object}   [settings.saveUserSettings.rowHeight=true]
   * @param {object}   [settings.saveUserSettings.sortOrdertrue]
   * @param {object}   [settings.saveUserSettings.pageSize=true]
   * @param {object}   [settings.saveUserSettings.activePage=true]
   * @param {object}   [settings.saveUserSettings.filter=true]
   * @param {boolean}  [settings.focusAfterSort=false] If true will focus the active cell after sorting.
   * @param {boolean}  [settings.editable=false] Enable editing in the grid, requires column editors.
   * @param {boolean}  [settings.selectOnEdit=true] if true, will select the cell text soon get to edit mode.
   * @param {Function}  [settings.isRowDisabled=null] Allows you to provide a function so you can set some rows to disabled base on data or row index.
   * @param {boolean}  [settings.isList=false] Makes the grid have readonly "list" styling
   * @param {string}   [settings.menuId=null]  ID of the menu to use for a row level right click context menu
   * @param {string}   [settings.menuSelected=null] Callback for the grid level context menu
   * @param {string}   [settings.menuBeforeOpen=null] Callback for the grid level beforeopen menu event
   * @param {string}   [settings.headerMenuId=null] Id of the menu to use for a header right click context menu
   * @param {string}   [settings.headerMenuSelected=false] Callback for the header level context menu
   * @param {string}   [settings.headerMenuBeforeOpen=false] Callback for the header level beforeopen menu event
   * @param {string}   [settings.uniqueId=null] Unique DOM ID to use as local storage reference and internal variable names
   * @param {string}   [settings.rowHeight=normal] Controls the height of the rows / number visible rows. May be (extra-small, small, medium or large) previous values of short, medium, normal are also mapped.
   * @param {number|string|function}   [settings.fixedRowHeight=null] Sets the height of the row to something other then the three built in rowHeights. If `auto` is used the row heights will be calculated, this can be expensive. This can also be a function that returns the row height dynamically.
   * @param {string}   [settings.selectable=false] Controls the selection Mode this may be: false, 'single' or 'multiple' or 'mixed' or 'siblings'
   * @param {null|function} [settings.onBeforeSelect=null] If defined as a function will fire as callback before rows are selected. You can return false to veto row selection.
   * @param {object}   [settings.groupable=null]  Controls fields to use for data grouping Use Data grouping, e.g. `{fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}`
   * @param {boolean}  [settings.showNewRowIndicator=true] If true, the new row indicator will display after adding a row.
   * @param {string}   [settings.stretchColumn=null] If 'last' the last column will stretch to the end, otherwise specific columns can be targetted.
   * @param {boolean}  [settings.stretchColumnOnChange=true] If true, column will recalculate its width and stretch if required.
   * @param {boolean}  [settings.spacerColumn=false] If true an extra column will be added to the end that fills the space. This allows columns to not stretch to fill so they are a constant size. This setting cannot be used with percent columns.
   * @param {boolean}  [settings.stickyHeader=false] If true the data grid headers will stick to the top of the container the grid is in when scrolling down.
   * @param {boolean}  [settings.columnSizing='both'] Determines the sizing method for the auto sizing columns. Options are: both | data | header (including filter)
   * @param {boolean}  [settings.clickToSelect=true] Controls if using a selection mode if you can click the rows to select
   * @param {object}   [settings.toolbar=false]  Toggles and appends various toolbar features for example `{title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}`
   * @param {boolean}  [settings.selectChildren=true] Will prevent selecting of all child nodes on a multiselect tree.
   * @param {boolean}  [settings.allowSelectAcrossPages=null] Makes it possible to save selections when changing pages on server side paging. You may want to also use showSelectAllCheckBox: false
   * @param {boolean}  [settings.selectAllCurrentPage=false] Select all will effect only on current page and its for client side paging only.
   * @param {boolean}  [settings.initializeToolbar=true] Set to false if you will initialize the toolbar yourself
   * @param {array}    [settings.columnIds=[]] An array of column IDs used to define aria descriptors for selection checkboxes.
   * @param {boolean}  [settings.paging=false] Enable paging mode
   * @param {number}   [settings.pagesize=25] Number of rows per page
   * @param {array}    [settings.pagesizes=[10, 25, 50, 75]] Array of page sizes to show in the page size dropdown.
   * @param {boolean}  [settings.indeterminate=false] Disable the ability to go to a specific page when paging.
   * @param {Function} [settings.source=false]  Callback function for paging
   * @param {boolean}  [settings.hidePagerOnOnePage=false]  If true, hides the pager if there's only one page worth of results.
   * @param {boolean}  [settings.filterable=false] Enable Column Filtering, This will require column filterTypes as well.
   * @param {boolean}  [settings.filterWhenTyping=true] Enable Column Filtering as you stop typing in inputs
   * @param {boolean}  [settings.disableClientFilter=false] Disable Filter Logic client side and let your server do it
   * @param {boolean}  [settings.disableClientSort=false] Disable Sort Logic client side and let your server do it
   * @param {string}   [settings.resultsText=null] Can provide a custom function to adjust results text on the toolbar
   * @param {boolean}  [settings.showFilterTotal=true] Paging results display filter count, change to false to not show filtered count
   * @param {boolean}  [settings.rowReorder=false] If set you can reorder rows. Requires a rowReorder formatter column.
   * @param {boolean}  [settings.resizeMode='flex'] Changes the column resize behavior.
   * `flex` will resize columns independently shifting other columns to fit the table layout if needed.
   * `fit` will resize using the neighbours column width. This is more useful with less columns.
   * If holding the Shift key you can use one of the other modes while dragging as a user.
   * @param {boolean}  [settings.showDirty=false]  If true the dirty indicator will be shown on the rows
   * @param {boolean}  [settings.showSelectAllCheckBox=true] Allow to hide the checkbox header (true to show, false to hide)
   * @param {boolean}  [settings.allowOneExpandedRow=true] Controls if you cna expand more than one expandable row.
   * @param {boolean}  [settings.enableTooltips=false] Process tooltip logic at a cost of performance
   * @param {boolean}  [settings.disableRowDeactivation=false] if a row is activated the user will not be able to deactivate it by clicking on the activated row
   * @param {boolean}  [settings.disableRowDeselection=false] if a row is selected the user will not be able to deselect it by clicking on the selected row again
   * @param {boolean}  [settings.sizeColumnsEqually=false] If true make all the columns equal width
   * @param {boolean}  [settings.expandableRow=false] If true we append an expandable row area without the rowTemplate feature being needed.
   * @param {boolean}  [settings.exportConvertNegative=false] If set to true export data with trailing negative signs moved in front.
   * @param {array}    [settings.columnGroups=null] An array of columns to use for grouped column headers.
   * @param {boolean}  [settings.treeGrid=false] If true a tree grid is expected so addition calculations will be used to calculate of the row children
   * @param {Function} [settings.onPostRenderCell=null] A call back function that will fire and send you the cell container and related information for any cells cells with a component attribute in the column definition.
   * @param {Function} [settings.onDestroyCell=null] A call back that goes along with onPostRenderCel and will fire when this cell is destroyed and you need noification of that.
   * @param {Function} [settings.onEditCell=null] A callback that fires when a cell is edited, the editor object is passed in to the function
   * @param {Function} [settings.onExpandRow=null] A callback function that fires when expanding rows. To be used. when expandableRow is true. The function gets eventData about the row and grid and a response function callback. Call the response function with markup to append and delay opening the row.
   * @param {Function} [settings.onExpandChildren=null] A callback function that fires when expanding children with treeGrid.
   * @param {Function} [settings.onCollapseChildren=null] A callback function that fires when collapseing children with treeGrid.
   * @param {Function} [settings.onKeyDown=null] A callback function that fires when any key is pressed down.
   * @param {boolean}  [settings.searchExpandableRow=true] If true keywordSearch will search in expandable rows (default). If false it will not search expandable rows.
   * @param {object}   [settings.emptyMessage]
   * @param {object}   [settings.emptyMessage.title='No Data Available']
   * @param {object}   [settings.emptyMessage.info='']
   * @param {object}   [settings.emptyMessage.icon='icon-empty-no-data']
   * @param {object}   [settings.emptyMessage.height=null]
   * An empty message will be displayed when there is no rows in the grid. This accepts an object of the form
   * emptyMessage: {title: 'No Data Available', info: 'Make a selection on the list above to see results',
   * icon: 'icon-empty-no-data', button: {text: 'Button Text', click: <function>}, height: null|'small'} set this to null for no message
   * or will default to 'No Data Found with an icon.'
   * height: The empty message container height. If set to 'small' will show only title and all other will not be render (like: icon, button, info)
   * @param {boolean} [settings.allowChildExpandOnMatch=false] Used with filter
   * if true:
   * and if only parent has a match then add all children nodes too
   * or if one or more child node got match then add parent node and all the children nodes
   * if false:
   * and if only parent has a match then make expand/collapse button to be collapsed, disabled
   * and do not add any children nodes
   * or if one or more child node got match then add parent node and only matching children nodes
   * @param {string} [settings.attributes] Add extra attributes like id's to the toast element. For example `attributes: { name: 'id', value: 'my-unique-id' }`
  */

  var DATAGRID_DEFAULTS = {
    // F2 - toggles actionableMode "true" and "false"
    // If actionableMode is "true, tab and shift tab behave like left and right arrow key,
    // if the cell is editable it goes in and out of edit mode
    actionableMode: false,
    cellNavigation: true,
    // If cellNavigation is "false, will show border around whole row on focus
    rowNavigation: true,
    // If rowNavigation is "false, will NOT show border around the row
    showHoverState: true,
    alternateRowShading: false,
    columns: [],
    frozenColumns: {
      left: [],
      right: [],
      expandRowAcrossAllCells: true
    },
    dataset: [],
    columnReorder: false,
    // Allow Column reorder
    saveColumns: false,
    // Save Column Reorder and resize
    saveUserSettings: {},
    focusAfterSort: false,
    // If true will focus the active cell after sorting.
    editable: false,
    selectOnEdit: true,
    isRowDisabled: null,
    isList: false,
    // Makes a readonly "list"
    menuId: null,
    // Id to the right click context menu
    headerMenuId: null,
    // Id to the right click context menu to use for the header
    menuSelected: null,
    // Callback for the grid level right click menu
    menuBeforeOpen: null,
    // Call back for the grid level before open menu event
    headerMenuSelected: null,
    // Callback for the header level right click menu
    headerMenuBeforeOpen: null,
    // Call back for the header level before open menu event
    uniqueId: null,
    // Unique ID for local storage reference and variable names
    rowHeight: 'large',
    // extra-small, short, medium, normal - or older values: (short, medium or normal)
    fixedRowHeight: null,
    selectable: false,
    // false, 'single' or 'multiple' or 'siblings'
    selectChildren: true,
    // can prevent selecting of all child nodes on multiselect
    onBeforeSelect: null,
    allowSelectAcrossPages: null,
    selectAllCurrentPage: false,
    // Select all will effect only on current page and its for client side paging only
    groupable: null,
    showNewRowIndicator: true,
    stretchColumn: null,
    stretchColumnOnChange: false,
    spacerColumn: false,
    stickyHeader: false,
    columnSizing: 'all',
    twoLineHeader: false,
    clickToSelect: true,
    toolbar: false,
    initializeToolbar: true,
    // can set to false if you will initialize the toolbar yourself
    columnIds: [],
    // Paging settings
    paging: false,
    pagesize: 25,
    pagesizes: [10, 25, 50, 75],
    showPageSizeSelector: true,
    // Will show page size selector
    indeterminate: false,
    // removed ability to go to a specific page.
    source: null,
    // callback for paging
    hidePagerOnOnePage: false,
    // If true, hides the pager if there's only one page worth of results.
    // Filtering settings
    filterable: false,
    filterWhenTyping: true,
    disableClientFilter: false,
    // Disable Filter Logic client side and let your server do it
    disableClientSort: false,
    // Disable Sort Logic client side and let your server do it
    resultsText: null,
    // Can provide a custom function to adjust results text
    showFilterTotal: true,
    // Paging results show filtered count, false to not show.
    virtualized: false,
    // Prevent Unused rows from being added to the DOM
    virtualRowBuffer: 10,
    // how many extra rows top and bottom to allow as a buffer
    rowReorder: false,
    // Allows you to reorder rows. Requires rowReorder formatter
    showDirty: false,
    resizeMode: 'flex',
    showSelectAllCheckBox: true,
    // Allow to hide the checkbox header (true to show, false to hide)
    allowOneExpandedRow: true,
    // Only allows one expandable row at a time
    enableTooltips: false,
    // Process tooltip logic at a cost of performance
    disableRowDeactivation: false,
    disableRowDeselection: false,
    sizeColumnsEqually: false,
    // If true make all the columns equal width
    expandableRow: false,
    // Supply an empty expandable row template
    exportConvertNegative: false,
    // Export data with trailing negative signs moved in front
    columnGroups: null,
    // The columns to use for grouped column headings
    treeGrid: false,
    onPostRenderCell: null,
    onDestroyCell: null,
    onEditCell: null,
    onExpandRow: null,
    onExpandChildren: null,
    // Callback fires when expanding children with treeGrid
    onCollapseChildren: null,
    // Callback fires when collapseing children with treeGrid
    onKeyDown: null,
    emptyMessage: {
      title: Locale ? Locale.translate('NoData') : 'No Data Available',
      info: '',
      icon: 'icon-empty-no-data',
      height: null
    },
    searchExpandableRow: true,
    allowChildExpandOnMatch: false,
    attributes: null
  };

  function Datagrid(element, settings) {
    this.settings = utils.mergeSettings(element, settings, DATAGRID_DEFAULTS);
    this.element = $(element);

    if (settings.dataset) {
      this.settings.dataset = settings.dataset;
    }

    if (typeof this.settings.frozenColumns.expandRowAcrossAllCells === 'undefined') {
      this.settings.frozenColumns.expandRowAcrossAllCells = DATAGRID_DEFAULTS.frozenColumns.expandRowAcrossAllCells; // eslint-disable-line
    }
    this.init();
  }
  /**
  * Actual Datagrid prototype
  * @private
  */


  Datagrid.prototype = {
    /**
     * @returns {Pager} IDS Pager component API.
     */
    get pagerAPI() {
      var api;

      if (this.tableBody && this.tableBody.length) {
        api = this.tableBody.data('pager');
      }

      return api;
    },

    /**
    * Init the datagrid from its uninitialized state.
    * @private
    * @returns {void}
    */
    init: function init() {
      var html = $('html');
      this.isTouch = Environment.features.touch;
      this.isSafari = html.is('.is-safari');
      this.isWindows = navigator.userAgent.indexOf('Windows') !== -1;
      this.appendTooltip();
      this.initSettings();
      this.setOriginalColumns();
      this.removeToolbarOnDestroy = false;
      this.nonVisibleCellErrors = [];
      this.recordCount = 0;
      this.canvas = null;
      this.totalWidths = {
        left: 0,
        center: 0,
        right: 0
      };
      this.stretchColumnWidth = 0;
      this.stretchColumnDiff = 0;
      this.stretchColumnIdx = -1;
      this.editor = null; // Current Cell Editor thats in Use

      this.activeCell = {
        node: null,
        cell: null,
        row: null
      }; // Current Active Cell

      this.dontSyncUi = false;
      this.widthPercent = false;
      this.rowSpans = [];
      this.filterRowRendered = false; // Flag used to determine if the header is rendered or not.

      this.scrollLeft = 0;
      this.scrollTop = 0;
      this._selectedRows = [];
      this.restoreColumns();
      this.restoreUserSettings();
      this.appendToolbar();
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.firstRender();
      this.handleEvents();
      this.handleKeys();
      /**
       * Fires after the grid is rendered.
      * @event rendered
      * @memberof Datagrid
      * @property {object} event - The jquery event object
      * @property {array} ui - An array with references to the domElement, header and pagerBar
      */

      this.element.trigger('rendered', [this.element, this.element.find('thead'), this.pagerAPI]);
    },

    /**
    * Initialize internal variables and states.
    * @private
    */
    initSettings: function initSettings() {
      this.ignoredColumnById('rowStatus');
      this.setInlineActionableMode();
      this.sortColumn = {
        sortField: null,
        sortAsc: true
      };
      this.gridCount = $('.datagrid').length + 1;
      this.lastSelectedRow = 0; // Remember index to use shift key

      this.contextualToolbar = this.element.prev('.contextual-toolbar');
      this.contextualToolbar.addClass('datagrid-contextual-toolbar');
    },

    /**
    * Ignore given Column from settings.
    * @private
    * @param {string} columnId for column to be ignored
    * @returns {void}
    */
    ignoredColumnById: function ignoredColumnById(columnId) {
      var s = this.settings;

      if (!columnId || !s.columns || s.columns && !s.columns.length) {
        return;
      }

      var column = {
        index: -1
      };

      for (var i = 0, l = s.columns.length; i < l; i++) {
        if (s.columns[i].id === columnId) {
          column.index = i;
        }
      }

      if (column.index > -1) {
        s.columns.splice(column.index, 1);
      }
    },

    /**
    * Set `actionableMode` if found inlineEditor.
    * @private
    * @returns {void}
    */
    setInlineActionableMode: function setInlineActionableMode() {
      var s = this.settings;

      if (!s.columns || s.columns && !s.columns.length) {
        return;
      }

      var column = {
        index: -1
      };

      for (var i = 0, l = s.columns.length; i < l; i++) {
        if (s.columns[i].inlineEditor) {
          column.index = i;
        }
      }

      this.inlineMode = column.index > -1;

      if (this.inlineMode) {
        this.element[0].classList.add('has-inline-editor');
        this.settings.actionableMode = true;
      } else {
        this.element[0].classList.remove('has-inline-editor');
      }
    },

    /**
     * Render or render both the header and row area.
     * @param {string} isToggleFilter Check if filterrow type should be passed to the data source request
     * @param {object} pagingInfo information about the pager state
     * @returns {void}
     */
    render: function render(isToggleFilter, pagingInfo) {
      if (!pagingInfo) {
        pagingInfo = {};
      }

      if (isToggleFilter) {
        pagingInfo.type = 'filterrow';
      }

      if (this.settings.source) {
        pagingInfo.preserveSelected = this.settings.allowSelectAcrossPages;
        this.triggerSource(pagingInfo);
        return;
      }

      this.loadData(this.settings.dataset, pagingInfo);
    },

    /**
    * Run the initial render on the Header and Rows.
    * @private
    */
    firstRender: function firstRender() {
      var self = this;
      this.hasLeftPane = this.settings.frozenColumns.left.length > 0;
      this.hasRightPane = this.settings.frozenColumns.right.length > 0;

      if (this.hasLeftPane) {
        self.bodyWrapperLeft = $('<div class="datagrid-wrapper left"></div>');
        self.tableLeft = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.bodyWrapperLeft);
        self.element.append(self.bodyWrapperLeft);
      }

      self.bodyWrapperCenter = $("<div class=\"datagrid-wrapper center scrollable-x".concat(!this.hasRightPane ? ' scrollable-y' : '', "\"></div>"));
      self.table = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.bodyWrapperCenter);
      self.element.append(self.bodyWrapperCenter);

      if (this.hasRightPane) {
        self.bodyWrapperRight = $('<div class="datagrid-wrapper right scrollable-y"></div>');
        self.tableRight = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.bodyWrapperRight);
        self.element.append(self.bodyWrapperRight);
      }

      this.element.removeClass('datagrid').addClass('datagrid-container').attr('x-ms-format-detection', 'none');

      if (this.settings.stickyHeader) {
        this.element.removeClass('datagrid').addClass('is-sticky');
      } // initialize row height by a setting


      if (this.settings.rowHeight !== 'normal' && this.settings.rowHeight !== 'large') {
        var rowHeight = this.settings.rowHeight === 'short' ? 'small' : this.settings.rowHeight;
        rowHeight = this.settings.rowHeight === 'normal' ? 'large' : rowHeight;

        if (this.hasLeftPane) {
          self.tableLeft.addClass("".concat(rowHeight, "-rowheight"));
        }

        self.table.addClass("".concat(rowHeight, "-rowheight"));

        if (this.hasRightPane) {
          self.tableRight.addClass("".concat(rowHeight, "-rowheight"));
        }

        this.element.addClass("".concat(rowHeight, "-rowheight"));
      }

      if (this.settings.isList) {
        $(this.element).addClass('is-gridlist');
      } else {
        $(this.element).removeClass('is-gridlist');
      }

      self.table.empty();
      self.clearCache();
      self.container = self.element.closest('.datagrid-container');
      self.renderRows();
      self.renderHeader();

      if (this.stretchColumnDiff < 0) {
        var currentCol = this.bodyColGroup.find('col').eq(self.getStretchColumnIdx())[0];
        currentCol.style.width = "".concat(this.stretchColumnWidth, "px");
      }

      if (this.settings.emptyMessage) {
        self.setEmptyMessage(this.settings.emptyMessage);
        self.checkEmptyMessage();
      }

      self.buttonSelector = '.btn, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split';
      $(self.buttonSelector, self.table).button();
      this.handlePaging();
      this.triggerSource('initial');
    },

    /**
    * Add a row of data to the grid and dataset.
    * @param {object} data An data row object
    * @param {string} location Where to add the row. This can be 'bottom' or 'top', default is top.
    */
    addRow: function addRow(data, location) {
      var _this = this;

      var self = this;
      var isTop = false;
      var row = 0;
      var cell = 0;
      var args;
      var rowNode; // Get first or last index of matching key/value

      function getIndexByKey(array, key, value, isReverse) {
        for (var i = 0, l = array.length; i < l; i++) {
          var idx = isReverse ? l - 1 - i : i;

          if (array[idx][key] === value) {
            return idx;
          }
        }

        return -1;
      }

      if (!location || location === 'top') {
        location = 'top';
        isTop = true;
      } // Add row status


      var newRowStatus = {
        icon: 'new',
        text: Locale.translate('New'),
        tooltip: Locale.translate('New')
      };
      data = data || {};
      data.rowStatus = data.rowStatus || newRowStatus;
      this.saveDirtyRows();
      var dataset = this.settings.dataset;

      if (this.settings.groupable) {
        dataset = this.originalDataset || dataset;
        var targetIndex = -1;

        if (typeof location === 'string') {
          var field = this.settings.groupable.fields[0];
          var idx = getIndexByKey(dataset, field, data[field], !isTop);
          targetIndex = idx > -1 ? !isTop ? idx + 1 : idx : 0;
          dataset.splice(targetIndex, 0, data);
          row = targetIndex;
        } else {
          dataset.splice(location, 0, data);
          row = location;
        }
      } else if (typeof location === 'string') {
        dataset[isTop ? 'unshift' : 'push'](data);
        row = isTop ? row : dataset.length - 1;
      } else {
        dataset.splice(location, 0, data);
        row = location;
      }

      this.restoreDirtyRows();
      this.setRowGrouping();

      if (!this.settings.groupable) {
        this.pagerRefresh(location);
      } // Update selected


      this._selectedRows.forEach(function (selected) {
        if (typeof selected.pagingIdx !== 'undefined' && selected.pagingIdx >= row) {
          selected.idx++;
          selected.pagingIdx++;
        }
      }); // Add to ui


      this.clearCache();
      this.renderRows();

      if (this.settings.groupable) {
        rowNode = this.dataRowNode(row);
        row = this.visualRowIndex(rowNode);
      } // Sync with others


      this.syncSelectedUI(); // Set active and fire handler

      setTimeout(function () {
        self.setActiveCell(row, cell);

        if (!_this.settings.groupable) {
          rowNode = _this.visualRowNode(row);
        }

        args = {
          row: row,
          cell: cell,
          target: rowNode,
          value: data,
          oldValue: {}
        };
        /**
         * Fires after a row is added via the api.
        * @event addrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {number} args.row The row index
        * @property {number} args.cell The cell index
        * @property {HTMLElement} args.target The html element.
        * @property {object} args.value - An object all the row data.
        * @property {object} args.oldValue - Always an empty object added for consistent api.
        */

        self.element.triggerHandler('addrow', args);
      }, 100);
    },

    /**
    * Refresh the pager based on the current page and dataset.
    * @private
    * @param {object} location Can be set to 'top' or left off for bottom pager.
    * @param {boolean} savePage if true the activate page will be restored.
    */
    pagerRefresh: function pagerRefresh(location, savePage) {
      if (!this.pagerAPI) {
        return;
      }

      var pagingInfo = {};

      if (typeof location === 'string') {
        pagingInfo.activePage = location === 'top' ? 1 : this.pagerAPI.state.pages;
      } else if (typeof location === 'number') {
        pagingInfo.activePage = Math.floor(location / (this.pagerAPI.settings.pagesize + 1));
      }

      if (!this.settings.source) {
        pagingInfo.total = this.settings.dataset.length;
        pagingInfo.pagesize = this.settings.pagesize;
      }

      if (savePage) {
        pagingInfo.activePage = this.settings.pagesize * this.pagerAPI.activePage > this.settings.dataset.length ? 1 : this.pagerAPI.activePage;
      }

      this.renderPager(pagingInfo, true);
    },

    /**
    * Remove a row of data to the grid and dataset.
    * @param {number} row The row index
    * @param {boolean} noSync Dont sync the selected rows.
    * @param {boolean} noTrigger If true, do not trigger the removerow event.
    * @returns {object|boolean} If noTrigger is true then return the event args otherwise nothing is returned
    */
    removeRow: function removeRow(row, noSync, noTrigger) {
      var rowNode = this.tableBody.find("tr[aria-rowindex=\"".concat(row + 1, "\"]"));
      var arrayToUse = this.settings.groupable && this.originalDataset ? this.originalDataset : this.settings.dataset;
      var rowData = arrayToUse[row];
      this.saveDirtyRows();
      this.unselectRow(row, noSync);
      arrayToUse.splice(row, 1);
      this.restoreDirtyRows();

      if (this.settings.selectable) {
        if (!this.settings.groupable && this.settings.groupable && this.originalDataset) {
          this.syncDatasetWithSelectedRows();
        }
      }

      this.preventSelection = true;

      if (!noSync) {
        this.setRowGrouping();
        this.pagerRefresh('top', true);
        this.clearCache();
        this.renderRows();
      }

      if (this.nonVisibleCellErrors.length !== 0) {
        this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
          return error.row !== row;
        });
        this.showNonVisibleCellErrors();
      }

      delete this.preventSelection;
      this.syncSelectedUI();
      var args = {
        row: row,
        cell: null,
        target: rowNode,
        item: rowData,
        oldValue: rowData
      };

      if (!noTrigger) {
        /**
        *  Fires after a row is removed via the api
        * @event rowremove
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} args Object with the arguments
        * @property {number} args.row The row index
        * @property {number} args.cell The cell index
        * @property {HTMLElement} args.target The row node that is being dragged.
        * @property {HTMLElement} args.item The dragged rows data.
        */
        this.element.trigger('rowremove', args);
      } else {
        return args;
      }

      return true;
    },

    /**
    * Remove all selected rows from the grid and dataset.
    * @param {boolean} isTrigger if true will trigger `rowremove` one time only with all selection data for more then one selected.
    */
    removeSelected: function removeSelected(isTrigger) {
      this._selectedRows.sort(function (a, b) {
        return a.idx < b.idx ? -1 : a.idx > b.idx ? 1 : 0;
      });

      var args = [];

      for (var i = this._selectedRows.length - 1; i >= 0; i--) {
        args.push({
          row: this._selectedRows[i].idx,
          item: this._selectedRows[i],
          cell: null,
          target: null
        });
        this.removeRow(this._selectedRows[i].idx, i > 0, isTrigger);
      }

      if (isTrigger) {
        this.element.trigger('rowremove', args);
      }
    },

    /**
    * Send in a new data set to display in the datagrid.
    * @param {object} dataset The array of objects to show in the grid. Should match
    * the column definitions.
    * @param {object} pagerInfo The pager info object with information like activePage ect.
    */
    updateDataset: function updateDataset(dataset, pagerInfo) {
      if (this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var searchField = this.element.parent().find('.toolbar').find('.searchfield');
        searchField.val('');
        searchField.parent().removeClass('has-text');
        this.clearFilter();
      }

      this.loadData(dataset, pagerInfo);
    },

    /**
    * Trigger the source method to call to the backend on demand.
    * @param {object|string} [pagerType=undefined] The pager info object with information like activePage ect.
    * @param {function} callback The call back functions
    * @param {string} [op=undefined] an optional info string that can be applied to identify which operation cause the source call
    */
    triggerSource: function triggerSource(pagerType, callback, op) {
      if (!this.settings.source) {
        return;
      }

      var self = this;
      var pagingInfo = {};

      if (this.pagerAPI) {
        pagingInfo = this.pagerAPI.state;
      }

      if (typeof pagerType === 'string') {
        pagingInfo.type = pagerType;
        pagingInfo.trigger = op;
      } else if (pagerType) {
        pagingInfo = utils.extend({}, pagingInfo, pagerType);
      }

      if (callback && typeof callback !== 'function') {
        if (typeof callback.type === 'string') {
          pagingInfo.type = callback.type;
        }
      }
      /**
      * Fires just before changing page. Returning false from the request function will cancel paging.
      * @event beforepaging
      * @memberof Pager
      * @property {object} event - The jquery event object
      * @property {function} request - The paging request info
      */


      var doPaging = this.element.triggerHandler('beforepaging', pagingInfo);

      if (doPaging === false) {
        return;
      }

      function response(data, updatedPagingInfo) {
        if (updatedPagingInfo.activePage > -1) {
          self.activePage = updatedPagingInfo.activePage;
        }

        if (updatedPagingInfo.grandTotal) {
          self.grandTotal = updatedPagingInfo.grandTotal;
        } // Set the remote dataset on the grid


        self.loadData(data, updatedPagingInfo);

        if (callback && typeof callback === 'function') {
          callback(true);
        }
        /**
        * Fires after changing paging has completed for source operations.
        * @event afterpaging
        * @memberof Datagrid
        * @property {object} event - The jquery event object
        * @property {object} pagingInfo - The paging info object
        */


        self.element.trigger('afterpaging', pagingInfo);
        self.afterPaging(pagingInfo);
      }

      if (this.sortColumn && this.sortColumn.sortId) {
        pagingInfo.sortAsc = this.sortColumn.sortAsc;
        pagingInfo.sortField = this.sortColumn.sortField;
        pagingInfo.sortId = this.sortColumn.sortId;
      }

      if (this.filterExpr && this.filterExpr.length) {
        pagingInfo.filterExpr = this.filterExpr;
      }
      /**
       * Fires when change page.
       * @event paging
       * @memberof Pager
       * @property {object} event The jquery event object
       * @property {object} request The paging request object
       */


      this.element.trigger('paging', pagingInfo);
      this.settings.source(pagingInfo, response);
    },

    /**
     * Do some work after changing the page
     * @param {object} pagingInfo Info about the paging operation
     * @private
     */
    afterPaging: function afterPaging(pagingInfo) {
      if (!this.settings.paging) {
        return;
      }

      if (this.settings.source) {
        // Hide the entire pager bar if we're only showing one page, if applicable
        if (this.pagerAPI && this.pagerAPI.hidePagerBar(pagingInfo)) {
          this.element.removeClass('paginated');
        } else {
          this.element.addClass('paginated');
        }

        if (pagingInfo.total) {
          this.recordCount = pagingInfo.total;
          this.displayCounts(pagingInfo.total);
        }
      }

      if (!this.settings.source && this.filterExpr && this.filterExpr[0] && this.filterExpr[0].column === 'all') {
        this.highlightSearchRows(this.filterExpr[0].value);
      }
    },

    /**
    * Send in a new data set to display in the datagrid. Use better named updateDataset
    * @private
    * @param {object} dataset The array of objects to show in the grid.
    * Should match the column definitions.
    * @param {object} pagerInfo The pager info object with information like activePage ect.
    */
    loadData: function loadData(dataset, pagerInfo) {
      var _pagerInfo, _pagerInfo$filterExpr;

      this.settings.dataset = dataset;

      if (!pagerInfo) {
        pagerInfo = {};
      }

      if (pagerInfo.type === 'filterrow') {
        pagerInfo.activePage = this.pagerAPI && this.pagerAPI.activePage || 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = pagerInfo.total || -1;
        pagerInfo.type = 'filterrow';
      }

      if (!pagerInfo.activePage) {
        pagerInfo.activePage = 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = -1;

        if (this.settings.treeGrid) {
          pagerInfo.preserveSelected = true;
        }
      }

      if (this.settings.source && pagerInfo.grandTotal) {
        this.grandTotal = pagerInfo.grandTotal;
      } else {
        this.grandTotal = null;
      }

      if (this.pagerAPI) {
        if (this.settings.showDirty && this.settings.source && /first|last|next|prev|sorted/.test(pagerInfo.type)) {
          this.dirtyArray = undefined;
        }
      } // Clear groupable


      if (this.settings.groupable && this.settings.dataset[0] && !this.settings.dataset[0].values) {
        this._selectedRows = [];
        this.originalDataset = null;
        this.clearDirty();
      } // Update Paging and Clear Rows


      this.setTreeDepth();

      if (this.settings.source) {
        this.originalDataset = null;
        this.setRowGrouping();
      }

      this.setTreeRootNodes(); // Figure out whether or not to preserve previously selected rows

      if (!pagerInfo.preserveSelected && this.settings.source && !this.settings.allowSelectAcrossPages) {
        if (this.settings.selectAllCurrentPage) {
          this.unSelectAllRowsCurrentPage();
        } else {
          this.unSelectAllRows();
        }
      }

      if (!pagerInfo.preserveSelected && (pagerInfo.type === 'initial' || !pagerInfo.type)) {
        if (this.settings.selectAllCurrentPage) {
          this.unSelectAllRowsCurrentPage();
        } else {
          this.unSelectAllRows();
        }
      }

      if (this.settings.disableClientFilter) {
        this.restoreFilter = true;
        this.restoreSortOrder = true;
        this.savedFilter = this.filterConditions();
      } // Resize and re-render if have a new dataset
      // (since automatic column sizing depends on the dataset)


      if (pagerInfo.type === 'initial') {
        this.clearCache();
        this.restoreUserSettings();
        this.renderRows();
        this.renderHeader();
      } else if (this.element.find('.datagrid-filter-wrapper .is-open').length === 0) {
        this.clearCache();
        this.setTreeDepth();
        this.setRowGrouping();
        this.setTreeRootNodes();
        this.renderRows();
      } else {
        // Filter field is open so do not resize
        this.clearCache();
        this.renderRows();
      } // Setup focus on the first cell


      this.cellNode(0, 0, true).attr('tabindex', '0');
      this.renderPager(pagerInfo, true);
      this.displayCounts(); // Highlight search results

      if (this.settings.paging && this.settings.source && (_pagerInfo = pagerInfo) !== null && _pagerInfo !== void 0 && (_pagerInfo == null ? void 0 : _pagerInfo.filterExpr) && ((_pagerInfo$filterExpr = pagerInfo.filterExpr[0]) === null || _pagerInfo$filterExpr === void 0 ? void 0 : _pagerInfo$filterExpr == null ? void 0 : _pagerInfo$filterExpr.column) === 'all') {
        this.highlightSearchRows(pagerInfo.filterExpr[0].value);
      }
    },

    /**
    * Generate a unique id based on the page and grid count. Add a suffix.
    * @private
    * @param {object} suffix Add this string to make the id more unique
    * @returns {string} The unique id.
    */
    uniqueId: function uniqueId(suffix) {
      suffix = suffix === undefined || suffix === null ? '' : suffix;
      var uniqueid = this.settings.uniqueId ? "".concat(this.settings.uniqueId, "-").concat(suffix) : "".concat(window.location.pathname.split('/').pop().replace(/\.xhtml|\.shtml|\.html|\.htm|\.aspx|\.asp|\.jspx|\.jsp|\.php/g, '').replace(/[^-\w]+/g, '').replace(/\./g, '-').replace(/ /g, '-').replace(/%20/g, '-'), "-").concat(this.element.attr('id') || 'datagrid', "-").concat(this.gridCount || 0).concat(suffix);
      return uniqueid.replace(/--/g, '-');
    },

    /**
    * Returns an array with all visible columns.
    * @param {boolean} skipBuiltIn If true then built in columns like selectionCheckbox are skipped.
    * @returns {array} An array with the visible columns.
    */
    visibleColumns: function visibleColumns(skipBuiltIn) {
      var visible = [];

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = this.settings.columns[j];

        if (column.hidden) {
          continue;
        }

        if (skipBuiltIn && column.id === 'selectionCheckbox') {
          continue;
        }

        visible.push(column);
      }

      return visible;
    },

    /**
    * Gets an if for the column group used for grouped headers.
    * @private
    * @param {object} idx The index of the column group
    * @returns {string} The name of the column group
    */
    getColumnGroup: function getColumnGroup(idx) {
      var total = 0;
      var colGroups = this.settings.columnGroups;

      for (var l = 0; l < colGroups.length; l++) {
        if (colGroups[l].hidden) {
          continue;
        }

        total += colGroups[l].colspan;

        if (total >= idx) {
          return this.uniqueId("-header-group-".concat(l));
        }
      }

      return '';
    },

    /**
    * Adjust the group row and header groups on column/hide show
    * @private
    * @param {number} colIndex The index of the column effected
    * @param {boolean} hideShow True if we showed the column, false if we hid it.
    */
    updateColumnGroup: function updateColumnGroup(colIndex, hideShow) {
      var colGroups = this.settings.columnGroups;

      if (!this.originalColGroups) {
        this.originalColGroups = utils.deepCopy(colGroups);
      } // Extend the Group Row to fill the grid for the new totals


      if (this.settings.groupable) {
        var groupHeaders = this.tableBody.find('.datagrid-rowgroup-header');
        var newColspan = this.visibleColumns().length;

        for (var i = 0; i < groupHeaders.length; i++) {
          groupHeaders[i].children[0].setAttribute('colspan', newColspan);
        }

        return;
      }

      if (!colGroups) {
        return;
      } // Update the dom


      if (!this.colGroups) {
        return;
      }

      var total = 0;
      var groupIdx = -1;
      this.originalColGroups.forEach(function (group, i) {
        var colSpan = parseInt(group.colspan, 10);

        if (colIndex >= total && colIndex <= total + colSpan) {
          groupIdx = i;
        }

        total += colSpan;
      });
      var currColspan = parseInt(this.colGroups[groupIdx].getAttribute('colspan'), 10);
      var wasHidden = this.colGroups[groupIdx].classList.contains('is-hidden');

      if (hideShow && wasHidden) {
        this.colGroups[groupIdx].classList.remove('is-hidden');
        return;
      }

      if (hideShow && !wasHidden) {
        this.colGroups[groupIdx].classList.remove('is-hidden');
        this.colGroups[groupIdx].setAttribute('colspan', currColspan + 1);
        return;
      }

      if (currColspan - 1 === 0) {
        this.colGroups[groupIdx].classList.add('is-hidden');
        return;
      }

      this.colGroups[groupIdx].setAttribute('colspan', currColspan - 1);
    },

    /**
    * Update group headers after column reorder/dragged.
    * @private
    * @param {number} indexFrom The column index dragged from.
    * @param {number} indexTo The column index dragged to.
    * @returns {void}
    */
    updateGroupHeadersAfterColumnReorder: function updateGroupHeadersAfterColumnReorder(indexFrom, indexTo) {
      var colGroups = this.settings.columnGroups;

      if (!colGroups) {
        return;
      }

      if (!this.originalColGroups) {
        this.originalColGroups = utils.deepCopy(colGroups);
      }

      var groups = colGroups.map(function (group) {
        return parseInt(group.colspan, 10);
      });
      var changed = {
        from: null,
        to: null,
        total: 0
      };
      groups.forEach(function (colspan, i) {
        changed.total += colspan;

        if (changed.total > indexFrom && changed.from === null) {
          changed.from = i;
        }

        if (changed.total > indexTo && changed.to === null) {
          changed.to = i;
        }
      });

      if (changed.from !== changed.to) {
        colGroups[changed.from].colspan -= 1;
        colGroups[changed.to].colspan += 1;
      }
    },

    /**
    * Returns the text for a header adding built in defaults
    * @private
    * @param {object} col The column id.
    * @returns {string} The current header text
    */
    headerText: function headerText(col) {
      var text = col.name ? col.name : '';

      if (!text && col.id === 'drilldown') {
        text = Locale.translate('Drilldown');
        return "<span class=\"audible\">".concat(text, "</span>");
      }

      return text;
    },

    /**
     * Get the name of the container (left, right, center) that this column will appear in.
     * @private
     * @param  {string} id The column id to check using the id property.
     * @returns {string} The container that the column appears in.
     */
    getContainer: function getContainer(id) {
      if (this.settings.frozenColumns.left && this.settings.frozenColumns.left.indexOf(id) > -1) {
        return 'left';
      }

      if (this.settings.frozenColumns.right && this.settings.frozenColumns.right.indexOf(id) > -1) {
        return 'right';
      }

      return 'center';
    },

    /**
    * Render the header area.
    * @private
    */
    renderHeader: function renderHeader() {
      var self = this;
      var headerRows = {
        left: '',
        center: '',
        right: ''
      };
      var uniqueId; // Handle Nested Headers

      var colGroups = this.settings.columnGroups;

      if (colGroups) {
        this.element.addClass('has-group-headers');
        var columns = this.settings.columns;
        var columnsLen = columns.length;
        var visibleColumnsLen = this.visibleColumns().length;
        var groups = colGroups.map(function (group) {
          return parseInt(group.colspan, 10);
        });

        var getGroupsTotal = function getGroupsTotal() {
          return groups.reduce(function (a, b) {
            return a + b;
          }, 0);
        };

        var getDiff = function getDiff() {
          var groupsTotal = getGroupsTotal();
          return groupsTotal > columnsLen ? groupsTotal - columnsLen : columnsLen - groupsTotal;
        };

        headerRows.left += '<tr role="row" class="datagrid-header-groups">';
        headerRows.center += '<tr role="row" class="datagrid-header-groups">';
        headerRows.right += '<tr role="row" class="datagrid-header-groups">';
        var groupsTotal = getGroupsTotal();
        var diff;

        if (groupsTotal > columnsLen) {
          var move = true;

          for (var _i = groups.length - 1; _i >= 0 && move; _i--) {
            diff = getDiff();

            if (groups[_i] >= diff) {
              groups[_i] -= diff;
              move = false;
            } else {
              groups[_i] = 0;
            }
          }
        }

        var i = 0;
        var total = 0;
        groups.forEach(function (groupColspan, k) {
          var colspan = groupColspan;

          for (var l = i + groupColspan; i < l; i++) {
            if (i < columnsLen && columns[i].hidden) {
              colspan--;
            }
          }

          var hiddenStr = colGroups[k].hidden || colspan < 1 ? ' class="is-hidden"' : '';
          var colspanStr = " colspan=\"".concat(colspan > 0 ? colspan : 1, "\"");
          var groupedHeaderAlignmentClass = colGroups[k].align ? "l-".concat(colGroups[k].align, "-text") : '';
          uniqueId = self.uniqueId("-header-group-".concat(k));

          if (colspan > 0) {
            total += colspan;
          }

          var container = self.getContainer(self.settings.columns[k].id);
          headerRows[container] += "<th".concat(hiddenStr).concat(colspanStr, " id=\"").concat(uniqueId, "\" class=\"").concat(groupedHeaderAlignmentClass, "\"><div class=\"datagrid-column-wrapper\"><span class=\"datagrid-header-text\">").concat(colGroups[k].name, "</span></div></th>");
        });

        if (total < visibleColumnsLen) {
          diff = visibleColumnsLen - total;
          var colspanStr = " colspan=\"".concat(diff > 0 ? diff : 1, "\"");

          if (self.hasRightPane) {
            headerRows.right += "<th".concat(colspanStr, "></th>");
          } else {
            headerRows.center += "<th".concat(colspanStr, "></th>");
          }
        }

        if (this.settings.spacerColumn) {
          headerRows.center += '<th class="datagrid-header-groups-spacer-column"></th>';
        }

        headerRows.left += '</tr><tr>';
        headerRows.center += '</tr><tr>';
        headerRows.right += '</tr><tr>';
      } else {
        headerRows.left += '<tr role="row">';
        headerRows.center += '<tr role="row">';
        headerRows.right += '<tr role="row">';
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var _column$id;

        var column = self.settings.columns[j];
        var container = self.getContainer(column.id);
        var id = self.uniqueId("-header-".concat(j));
        var isSortable = column.sortable === undefined ? true : column.sortable;
        var isResizable = column.resizable === undefined ? true : column.resizable;
        var isExportable = column.exportable === undefined ? true : column.exportable;
        var isSelection = column.id === 'selectionCheckbox';
        var headerAlignmentClass = this.getHeaderAlignmentClass(column); // Make frozen columns hideable: false

        if ((self.hasLeftPane || self.hasRightPane) && (self.settings.frozenColumns.left && self.settings.frozenColumns.left.indexOf(column.id) > -1 || self.settings.frozenColumns.right && self.settings.frozenColumns.right.indexOf(column.id) > -1)) {
          column.hideable = false;
        } // Ensure hidable columns are marked as such


        if (column.hideable === undefined) {
          column.hideable = true;
        } // Assign css classes


        var cssClass = '';
        cssClass += isSortable ? ' is-sortable' : '';
        cssClass += isResizable ? ' is-resizable' : '';
        cssClass += column.hidden ? ' is-hidden' : '';
        cssClass += column.filterType ? ' is-filterable' : '';
        cssClass += column.textOverflow === 'ellipsis' ? ' text-ellipsis' : '';
        cssClass += headerAlignmentClass !== '' ? headerAlignmentClass : ''; // Apply css classes

        cssClass = cssClass !== '' ? " class=\"".concat(cssClass.substr(1), "\"") : '';
        var ids = utils.stringAttributes(this, this.settings.attributes, "col-".concat((_column$id = column.id) === null || _column$id === void 0 ? void 0 : _column$id == null ? void 0 : _column$id.toLowerCase()));

        if (!ids) {
          ids = "id=\"".concat(id, "\"");
        }

        headerRows[container] += "<th scope=\"col\" role=\"columnheader\" ".concat(ids, " data-column-id=\"").concat(column.id, "\"").concat(column.field ? " data-field=\"".concat(column.field, "\"") : '').concat(column.headerTooltip ? " title=\"".concat(column.headerTooltip, "\"") : '').concat(column.reorderable === false ? ' data-reorder="false"' : '').concat(colGroups ? " headers=\"".concat(self.getColumnGroup(j), "\"") : '', " data-exportable=\"").concat(isExportable ? 'yes' : 'no', "\"").concat(cssClass, ">");
        var sortIndicator = '';

        if (isSortable) {
          sortIndicator = "".concat('<div class="sort-indicator">' + '<span class="sort-asc">').concat($.createIcon({
            icon: 'dropdown'
          }), "</span>") + "<span class=\"sort-desc\">".concat($.createIcon({
            icon: 'dropdown'
          }), "</div>");
        } // If header text is center aligned, for proper styling,
        // place the sortIndicator as a child of datagrid-header-text.


        headerRows[container] += "<div class=\"".concat(isSelection ? 'datagrid-checkbox-wrapper ' : 'datagrid-column-wrapper').concat(headerAlignmentClass, "\">\n      <span class=\"datagrid-header-text").concat(column.required ? ' required' : '', "\">").concat(self.headerText(this.settings.columns[j])).concat(headerAlignmentClass === ' l-center-text' ? sortIndicator : '', "</span>");

        if (isSelection) {
          if (self.settings.showSelectAllCheckBox) {
            headerRows[container] += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox" tabindex="0"></span>';
          } else {
            headerRows[container] += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox" style="display:none" tabindex="0"></span>';
          }
        } // Note the space in classname.
        // Place sortIndicator via concatenation if
        // header text is not center aligned.


        if (isSortable && headerAlignmentClass !== ' l-center-text') {
          headerRows[container] += sortIndicator;
        }

        headerRows[container] += "</div>".concat(self.filterRowHtml(column, j), "</th>");
      } // Set Up Spacer column


      if (this.settings.spacerColumn) {
        headerRows.center += '<th class="datagrid-header-spacer-column"></th>';
      }

      headerRows.left += '</tr>';
      headerRows.center += '</tr>';
      headerRows.right += '</tr>'; // Set Up Header Panes

      if (self.headerRow === undefined) {
        if (self.hasLeftPane) {
          self.headerRowLeft = $("<thead class=\"datagrid-header left\">".concat(headerRows.left, "</thead>"));
          self.tableLeft.find('colgroup').after(self.headerRowLeft);
        }

        self.headerRow = $("<thead class=\"datagrid-header center\">".concat(headerRows.center, "</thead>"));
        self.table.find('colgroup').after(self.headerRow);

        if (self.hasRightPane) {
          self.headerRowRight = $("<thead class=\"datagrid-header right\">".concat(headerRows.right, "</thead>"));
          self.tableRight.find('colgroup').after(self.headerRowRight);
        }
      } else {
        if (self.hasLeftPane) {
          DOM.html(self.headerRowLeft, headerRows.left, '*');
        }

        DOM.html(self.headerRow, headerRows.center, '*');

        if (self.hasRightPane) {
          DOM.html(self.headerRowRight, headerRows.right, '*');
        }
      }

      if (colGroups && self.headerRow) {
        self.colGroups = $.makeArray(this.container.find('.datagrid-header-groups th'));
      }

      self.syncHeaderCheckbox(this.settings.dataset);
      self.setScrollClass();
      self.attachFilterRowEvents();

      if (self.settings.columnReorder) {
        self.createDraggableColumns();
      }

      this.restoreSortOrder = false;
      this.setSortIndicator(this.sortColumn.sortId, this.sortColumn.sortAsc);

      if (this.restoreFilter) {
        this.restoreFilter = false;
        this.applyFilter(this.savedFilter, 'restore');
        this.savedFilter = null;
      } else if (this.filterExpr && this.filterExpr.length > 0) {
        this.setFilterConditions(this.filterExpr);
      }

      this.activeEllipsisHeaderAll();
    },

    /**
     * Get the alignment class based on settings. Note there is a space at the front of the classname.
     * @private
     * @param {object} column The column info.
     * @returns {string} The class as a string.
     */
    getHeaderAlignmentClass: function getHeaderAlignmentClass(column) {
      var headerAlignmentClass = '';

      if (column.headerAlign === undefined) {
        headerAlignmentClass = column.align ? " l-".concat(column.align, "-text") : '';
      } else {
        headerAlignmentClass = " l-".concat(column.headerAlign, "-text");
      }

      return headerAlignmentClass;
    },

    /**
    * Set filter datepicker with range/single date.
    * @private
    * @param {object} input element to target datepicker.
    * @param {string} operator filter type.
    * @param {object} options pass in to datepicker.
    * @returns {void}
    */
    filterSetDatepicker: function filterSetDatepicker(input, operator, options) {
      var datepickerApi = input.data('datepicker');
      var isRange = input.data('is-range');
      options = options || {}; // Init datepicker

      var initDatepicker = function initDatepicker() {
        if (datepickerApi && typeof datepickerApi.destroy === 'function') {
          datepickerApi.destroy();
        }

        input.datepicker(options);
      }; // invoke datepicker


      if ((!datepickerApi || !isRange) && operator === 'in-range') {
        input.data('is-range', true);
        options.range = {
          useRange: true
        };
        initDatepicker();
      } else if ((!datepickerApi || isRange) && operator !== 'in-range') {
        options.range = {
          useRange: false
        };
        input.removeData('is-range');
        initDatepicker();
      }
    },

    /**
    * Returns the markup for a specific filter row area.
    * @private
    * @param {object} columnDef The column object for the header
    * @param {object} idx The column idx for the header
    * @returns {string} The filter html to use
    */
    filterRowHtml: function filterRowHtml(columnDef, idx) {
      var self = this;
      var filterMarkup = '';
      var headerAlignmentClass = this.getHeaderAlignmentClass(columnDef); // Generate the markup for the various Types
      // Supported Filter Types: text, integer, date, select, decimal,
      // lookup, percent, checkbox, contents

      if (columnDef.filterType) {
        var _col$id;

        var col = columnDef;
        var filterId = self.uniqueId("-header-filter-".concat(idx));
        var filterOptions = Array.isArray(col.filterRowEditorOptions) ? col.filterRowEditorOptions : col.options;
        var integerDefaults;
        var emptyOption = ''; // Set empty option for select filter type

        if (col.filterType === 'select' && filterOptions) {
          var found = false;

          for (var i = 0, l = filterOptions.length; i < l; i++) {
            if (!filterOptions[i].label) {
              found = true;
              break;
            }
          }

          if (!found) {
            emptyOption = '<option></option>';
          }
        }

        filterMarkup = "<div class=\"datagrid-filter-wrapper".concat(headerAlignmentClass, "\" ").concat(!self.settings.filterable ? ' style="display:none"' : '', ">").concat(self.filterButtonHtml(col), "<label class=\"audible\" for=\"").concat(filterId, "\">").concat(col.name, "</label>");
        var attrs = utils.stringAttributes(this, this.settings.attributes, "filter-".concat((_col$id = col.id) === null || _col$id === void 0 ? void 0 : _col$id == null ? void 0 : _col$id.toLowerCase()));

        if (!attrs) {
          attrs = "id=\"".concat(filterId, "\"");
        }

        switch (col.filterType) {
          case 'checkbox':
            // just the button
            break;

          case 'date':
            filterMarkup += "<input ".concat(col.filterDisabled ? ' disabled' : '', " type=\"text\" class=\"datepicker\" ").concat(attrs, "/>");
            break;

          case 'integer':
            {
              integerDefaults = {
                patternOptions: {
                  allowNegative: true,
                  allowThousandsSeparator: false,
                  allowDecimal: false,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
                  }
                },
                process: 'number'
              };
              col.maskOptions = utils.extend(true, {}, integerDefaults, col.maskOptions);
              filterMarkup += "<input".concat(col.filterDisabled ? ' disabled' : '', " type=\"text\" ").concat(attrs, " />");
              break;
            }

          case 'percent':
          case 'decimal':
            {
              var decimalDefaults = {
                patternOptions: {
                  allowNegative: true,
                  allowDecimal: true,
                  symbols: {
                    thousands: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.group : ',',
                    decimal: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.decimal : '.',
                    negative: Locale.currentLocale.data.numbers ? Locale.currentLocale.data.numbers.minusSign : '-'
                  }
                },
                process: 'number'
              };

              if (col.numberFormat) {
                integerDefaults = {
                  patternOptions: {
                    decimalLimit: col.numberFormat.maximumFractionDigits
                  }
                };
                col.maskOptions = utils.extend(true, {}, integerDefaults, decimalDefaults, col.maskOptions);
              } else {
                col.maskOptions = utils.extend(true, {}, decimalDefaults, col.maskOptions);
              }

              filterMarkup += "<input".concat(col.filterDisabled ? ' disabled' : '', " type=\"text\" ").concat(attrs, " />");
              break;
            }

          case 'contents':
          case 'select':
            filterMarkup += "<select ".concat(attrs, " ").concat(col.filterType === 'select' ? 'class="dropdown"' : 'multiple class="multiselect"').concat(col.filterDisabled ? ' disabled' : '', ">").concat(emptyOption);

            if (filterOptions) {
              for (var _i2 = 0, _l = filterOptions.length; _i2 < _l; _i2++) {
                var option = filterOptions[_i2];
                var optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

                if (option && optionValue !== '') {
                  filterMarkup += "<option value = \"".concat(optionValue, "\">").concat(option.label, "</option>");
                }
              }
            }

            filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use href="#icon-dropdown"></use></svg></div>';
            break;

          case 'multiselect':
            filterMarkup += "<select ".concat(attrs, " class=\"multiselect\" multiple").concat(col.filterDisabled ? ' disabled' : '', ">");

            if (filterOptions) {
              for (var _i3 = 0, _l2 = filterOptions.length; _i3 < _l2; _i3++) {
                var _option = filterOptions[_i3];

                var _optionValue = col.caseInsensitive && typeof _option.value === 'string' ? _option.value.toLowerCase() : _option.value;

                if (_option && typeof _option.label === 'string') {
                  filterMarkup += "<option value = \"".concat(_optionValue, "\">").concat(_option.label, "</option>");
                }
              }
            }

            filterMarkup += '</select><div class="dropdown-wrapper"><div class="dropdown"><span></span></div><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use href="#icon-dropdown"></use></svg></div>';
            break;

          case 'time':
            filterMarkup += "<input ".concat(col.filterDisabled ? ' disabled' : '', " type=\"text\" class=\"timepicker\" ").concat(attrs, "/>");
            break;

          case 'lookup':
            filterMarkup += "<input ".concat(col.filterDisabled ? ' disabled' : '', " type=\"text\" class=\"lookup\" ").concat(attrs, " >");
            break;

          default:
            filterMarkup += "<input".concat(col.filterDisabled ? ' disabled' : '', " type=\"text\" ").concat(attrs, "/>");
            break;
        }

        filterMarkup += '</div>';
      }

      if (!columnDef.filterType) {
        filterMarkup = "<div class=\"datagrid-filter-wrapper is-empty".concat(" ".concat(headerAlignmentClass), "\"></div>");
      }

      return filterMarkup;
    },

    /**
    * Attach Events and initialize plugins for the filter row.
    * @private
    */
    attachFilterRowEvents: function attachFilterRowEvents() {
      var _this2 = this;

      var self = this;

      if (!this.settings.filterable) {
        return;
      }

      this.element.addClass('has-filterable-columns');

      if (this.settings.twoLineHeader) {
        this.element.addClass('has-two-line-header');
      } // Attach Keyboard support


      this.element.off('click.datagrid-filter').on('click.datagrid-filter', '.btn-filter', function () {
        var filterBtn = $(this);
        var popupOpts = {
          trigger: 'immediate',
          offset: {
            y: 15
          },
          placementOpts: {
            strategies: ['flip', 'nudge']
          }
        };
        var popupmenu = filterBtn.data('popupmenu');

        if (popupmenu) {
          popupmenu.close(true, true);
        } else {
          filterBtn.off('beforeopen.datagrid-filter').on('beforeopen.datagrid-filter', function () {
            var menu = filterBtn.next('.popupmenu-wrapper');
            utils.fixSVGIcons(menu);
            self.hideTooltip();
          }).popupmenu(popupOpts).off('selected.datagrid-filter').on('selected.datagrid-filter', function () {
            var rowElem = filterBtn.closest('th[role="columnheader"]');
            var col = self.columnById(rowElem.attr('data-column-id'))[0]; // Set datepicker and numbers filter with range/single

            if (col && /date|integer|decimal/.test(col.filterType)) {
              var input = rowElem.find('input');
              var svg = rowElem.find('.btn-filter .icon-dropdown:first');
              var operator = svg.getIconName().replace('filter-', '');

              if (col.filterType === 'date') {
                self.filterSetDatepicker(input, operator, col.editorOptions);
              } else {
                var _col$maskOptions;

                var rangeDelimeter = ((_col$maskOptions = col.maskOptions) === null || _col$maskOptions === void 0 ? void 0 : _col$maskOptions == null ? void 0 : _col$maskOptions.rangeNumberDelimeter) || '-';
                var isRange = operator === 'in-range';
                var maskApi = input.data('mask');
                var settings = isRange ? {
                  process: 'rangeNumber',
                  patternOptions: {
                    delimeter: rangeDelimeter
                  }
                } : {
                  process: 'number',
                  patternOptions: {
                    delimeter: ''
                  }
                };

                if (maskApi && maskApi.settings.process !== settings.process) {
                  col.maskOptions = utils.extend(true, {}, col.maskOptions, settings);
                  maskApi.updated(settings);
                }
              }
            }

            self.applyFilter(null, 'selected');
          }).off('close.datagrid-filter').on('close.datagrid-filter', function () {
            var data = $(this).data('popupmenu');

            if (data) {
              data.destroy();
            }
          });
        }

        return false;
      });
      var typingTimer;
      this.element.off('keydown.datagrid-filter-input').on('keydown.datagrid-filter-input', '.datagrid-filter-wrapper input', function (e) {
        clearTimeout(typingTimer);
        e.stopPropagation();

        if (e.which === 13) {
          self.applyFilter(null, 'enter');
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        return true;
      });

      if (this.settings.filterWhenTyping) {
        this.element.off('keyup.datagrid-filter-input').on('keyup.datagrid-filter-input', '.datagrid-filter-wrapper input', function (e) {
          if (e.which === 13) {
            return;
          }

          if (_this2.activeCell && _this2.activeCell.isFocused) {
            _this2.activeCell.isFocused = false;
          }

          clearTimeout(typingTimer);
          typingTimer = setTimeout(function () {
            self.applyFilter(null, 'keyup');
          }, 400);
        });
      }

      this.element.find('.datagrid-header tr:not(.datagrid-header-groups) th').each(function () {
        var col = self.columnById($(this).attr('data-column-id'))[0];
        var elem = $(this);

        if (!col) {
          // No ID found
          return true;
        }

        elem.find('select.dropdown').each(function () {
          var dropdown = $(this);
          dropdown.dropdown(col.editorOptions).on('selected.datagrid', function () {
            self.applyFilter(null, 'selected');
          }).on('listopened.datagrid', function () {
            var api = dropdown.data('dropdown');

            if (api) {
              if (!utils.isInViewport(api.list[0])) {
                self.adjustPosLeft(api.list[0]);
              }
            }
          }); // Append the Dropdown's sourceArguments with some row/col meta-data

          var api = dropdown.data('dropdown');
          api.settings.sourceArguments = {
            column: col,
            container: elem,
            grid: self,
            cell: col,
            event: undefined,
            row: -1,
            rowData: {},
            value: undefined
          };
        });
        elem.find('select.multiselect').each(function () {
          var _this3 = this;

          var multiselect = $(this);
          multiselect.multiselect(col.editorOptions).on('selected.datagrid', function () {
            // Wierd Hack - Sync to "sync" up the filter row
            var ddElem = $(_this3);
            $("#".concat(ddElem.attr('id'))).val(ddElem.val());
            self.applyFilter(null, 'selected');
          }); // Append the Dropdown's sourceArguments with some row/col meta-data

          var api = multiselect.data('dropdown');
          api.settings.sourceArguments = {
            column: col,
            container: elem,
            grid: self,
            cell: col,
            event: undefined,
            row: -1,
            rowData: {},
            value: undefined
          };
        });

        if (col.maskOptions) {
          elem.find('input').mask(col.maskOptions);
        }

        if (col.mask) {
          elem.find('input').mask(col.mask);
        }

        var datepickerEl = elem.find('.datepicker');

        if (datepickerEl.length && typeof $().datepicker === 'function') {
          datepickerEl.datepicker(col.editorOptions || {
            dateFormat: col.dateFormat
          }).on('listclosed.datepicker', function () {
            self.applyFilter(null, 'selected');
          });
        }

        var lookupEl = elem.find('.lookup');

        if (lookupEl.length && typeof $().lookup === 'function') {
          if (col.editorOptions) {
            if (col.editorOptions.clickArguments) {
              col.editorOptions.clickArguments.grid = self;
            } else {
              col.editorOptions.clickArguments = {
                grid: self
              };
            }

            if (col.editorOptions.clearArguments) {
              col.editorOptions.clearArguments.grid = self;
            } else {
              col.editorOptions.clearArguments = {
                grid: self
              };
            }
          }

          lookupEl.lookup(col.editorOptions || {});

          if (self.settings.filterWhenTyping) {
            lookupEl.on('change', function () {
              self.applyFilter(null, 'selected');
            });
          }
        }

        var timepickerEl = elem.find('.timepicker');

        if (timepickerEl.length && typeof $().timepicker === 'function') {
          timepickerEl.timepicker(col.editorOptions || {
            timeFormat: col.timeFormat
          });
        } // Attach Mask


        if (col.mask) {
          elem.find('input').mask({
            pattern: col.mask,
            mode: col.maskMode
          });
        }

        return null;
      });
      self.filterRowRendered = true;
    },

    /**
    * Render one filter item as used in renderFilterButton
    * @private
    * @param {object} icon The icon for the menu item
    * @param {object} text The text for the menu item
    * @param {object} checked If the menu item is selected
    * @returns {string} The html for the filter item.
    */
    filterItemHtml: function filterItemHtml(icon, text, checked) {
      var iconMarkup = $.createIcon({
        classes: 'icon icon-filter',
        icon: "filter-".concat(icon)
      });
      return "<li class=\"".concat(icon, " ").concat(checked ? ' is-checked' : '', "\"><a href=\"#\">").concat(iconMarkup, "<span>").concat(Locale.translate(text), "</span></a></li>");
    },

    /**
    * Render the Filter Button and Menu based on filterType - which determines the options
    * @private
    * @param {object} col The column object
    * @returns {string} The html for the filter button.
    */
    filterButtonHtml: function filterButtonHtml(col) {
      var _col$id2;

      if (!col.filterType) {
        return '';
      }

      var self = this;
      var isDisabled = col.filterDisabled;
      var filterConditions = $.isArray(col.filterConditions) ? col.filterConditions : [];

      var inArray = function inArray(s, array) {
        array = array || filterConditions;
        return $.inArray(s, array) > -1;
      };

      var render = function render(icon, text, checked) {
        var isChecked = filterConditions.length && filterConditions[0] === icon ? true : checked;
        return filterConditions.length && !inArray(icon) ? '' : self.filterItemHtml(icon, text, isChecked);
      };

      var attrs = utils.stringAttributes(this, this.settings.attributes, "btn-filter-".concat((_col$id2 = col.id) === null || _col$id2 === void 0 ? void 0 : _col$id2 == null ? void 0 : _col$id2.toLowerCase()));

      var renderButton = function renderButton(defaultValue, extraClass) {
        return "<button type=\"button\" ".concat(attrs, " class=\"btn-menu btn-filter").concat(extraClass ? " ".concat(extraClass) : '', "\" data-init=\"false\" ").concat(isDisabled ? ' disabled' : '').concat(defaultValue ? " data-default=\"".concat(defaultValue, "\"") : '', " type=\"button\"><span class=\"audible\">Filter</span>") + "<svg class=\"icon-dropdown icon\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"#icon-filter-{{icon}}\"></use></svg>".concat($.createIcon({
          icon: 'dropdown',
          classes: 'icon-dropdown'
        }), "</button><ul class=\"popupmenu has-icons is-translatable is-selectable\">");
      };

      var formatFilterText = function formatFilterText(str) {
        str = str.split('-').map(function (s) {
          s = s.charAt(0).toUpperCase() + s.slice(1);
          return s;
        }).join('');

        switch (str) {
          case 'StartWith':
            str = str.replace('StartWith', 'StartsWith');
            break;

          case 'EndWith':
            str = str.replace('EndWith', 'EndsWith');
            break;

          case 'LessEquals':
            str = str.replace('LessEquals', 'LessOrEquals');
            break;

          case 'GreaterEquals':
            str = str.replace('GreaterEquals', 'GreaterOrEquals');
            break;
        }

        return str;
      };

      var btnMarkup = '';
      var btnDefault = ''; // Just the dropdown

      if (col.filterType === 'contents' || col.filterType === 'select' || col.filterType === 'multiselect') {
        return '';
      }

      if (col.filterType === 'text') {
        btnDefault = filterConditions.length ? filterConditions[0] : 'contains';

        if (filterConditions.length === 0) {
          btnMarkup = renderButton(btnDefault) + render('contains', 'Contains', true) + render('does-not-contain', 'DoesNotContain') + render('equals', 'Equals') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty') + render('end-with', 'EndsWith') + render('does-not-end-with', 'DoesNotEndWith') + render('start-with', 'StartsWith') + render('does-not-start-with', 'DoesNotStartWith');
          btnMarkup = btnMarkup.replace('{{icon}}', btnDefault);
        } else {
          btnMarkup = renderButton(btnDefault) + filterConditions.map(function (filter) {
            return render(filter, formatFilterText(filter));
          }).join('');
          btnMarkup = btnMarkup.replace('{{icon}}', btnDefault);
        }
      }

      if (col.filterType === 'checkbox') {
        btnDefault = filterConditions.length ? filterConditions[0] : 'selected-notselected';
        btnMarkup += renderButton(btnDefault, 'btn-filter-checkbox') + render('selected-notselected', 'All', true) + render('selected', 'Selected') + render('not-selected', 'NotSelected');
        btnMarkup = btnMarkup.replace('{{icon}}', btnDefault);
      }

      if (col.filterType !== 'checkbox' && col.filterType !== 'text') {
        btnDefault = filterConditions.length ? filterConditions[0] : 'equals';
        btnMarkup += renderButton(btnDefault) + render('equals', 'Equals', col.filterType === 'lookup' || col.filterType === 'integer' || col.filterType === 'decimal' || col.filterType === 'date' || col.filterType === 'time') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty');
        btnMarkup = btnMarkup.replace('{{icon}}', btnDefault);
      }

      if (/\b(date|integer|decimal|percent)\b/g.test(col.filterType)) {
        btnMarkup += render('in-range', 'InRange');
      }

      if (/\b(integer|decimal|date|time|percent)\b/g.test(col.filterType)) {
        btnMarkup += "".concat(render('less-than', 'LessThan')).concat(render('less-equals', 'LessOrEquals')).concat(render('greater-than', 'GreaterThan')).concat(render('greater-equals', 'GreaterOrEquals'));
        btnMarkup = btnMarkup.replace('{{icon}}', 'less-than');
      }

      if (col.filterType === 'lookup') {
        btnDefault = filterConditions.length ? filterConditions[0] : 'contains';
        btnMarkup = renderButton(btnDefault) + render('contains', 'Contains', true) + render('does-not-contain', 'DoesNotContain') + render('equals', 'Equals') + render('does-not-equal', 'DoesNotEqual') + render('is-empty', 'IsEmpty') + render('is-not-empty', 'IsNotEmpty') + render('end-with', 'EndsWith') + render('does-not-end-with', 'DoesNotEndWith') + render('start-with', 'StartsWith') + render('does-not-start-with', 'DoesNotStartWith') + render('less-than', 'LessThan') + render('less-equals', 'LessOrEquals') + render('greater-than', 'GreaterThan') + render('greater-equals', 'GreaterOrEquals');
        btnMarkup = btnMarkup.replace('{{icon}}', btnDefault);
      }

      btnMarkup += '</ul>';
      return btnMarkup;
    },

    /**
    * Toggle the visibility of the filter row.
    */
    toggleFilterRow: function toggleFilterRow() {
      if (this.settings.filterable) {
        this.element.find('.datagrid-filter-wrapper').hide();
        this.settings.filterable = false;
        this.filterRowRendered = false;
        this.element.removeClass('has-filterable-columns');
        this.element.removeClass('has-two-line-header');
        /**
        *  Fires after the filter row is closed by the user.
        * @event closefilterrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        */

        this.element.triggerHandler('closefilterrow');
      } else {
        this.settings.filterable = true;
        this.filterRowRendered = true;
        this.element.addClass('has-filterable-columns');

        if (this.settings.twoLineHeader) {
          this.element.addClass('has-two-line-header');
        }

        this.element.find('.datagrid-filter-wrapper').show();
        /**
        * Fires after the filter row is opened by the user.
        * @event openfilterrow
        * @memberof Datagrid
        * @property {object} event The jquery event object
        */

        this.element.triggerHandler('openfilterrow');
        this.attachFilterRowEvents();
      }

      this.setupTooltips();
    },

    /**
    * Apply the Filter with the currently selected conditions, or the ones passed in.
    * @param {object} conditions An array of objects with the filter conditions.
    * @param {string} [trigger] A string to identify the triggering action.
    */
    applyFilter: function applyFilter(conditions, trigger) {
      var self = this;
      var filterChanged = false; // Remove all nested key/value `_isFilteredOut` from given dataset

      var removeFilteredOut = function removeFilteredOut(dataset) {
        for (var i = 0, len = dataset.length; i < len; i++) {
          if (typeof dataset[i]._isFilteredOut !== 'undefined') {
            delete dataset[i]._isFilteredOut;
          }

          if (dataset[i].children) {
            removeFilteredOut(dataset[i].children);
          }
        }
      };

      if (conditions) {
        this.setFilterConditions(conditions);
      } else {
        conditions = this.filterConditions();
      }

      if (this.filterExpr === undefined) {
        this.filterExpr = [];
      }

      if (this.pagerAPI && JSON.stringify(conditions) !== JSON.stringify(this.filterExpr)) {
        this.filterExpr = conditions;
        filterChanged = true;

        if (this.settings.treeGrid) {
          removeFilteredOut(this.settings.dataset);
        }
      }

      var checkRow = function checkRow(rowData) {
        var isMatch = true;

        var _loop = function _loop(i) {
          var columnDef = self.columnById(conditions[i].columnId)[0];

          if (columnDef === undefined) {
            return {
              v: false
            };
          }

          var rowValue = rowData && rowData[columnDef.field] !== undefined ? rowData[columnDef.field] : self.fieldValue(rowData, columnDef.field);
          var rowValueStr = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          var conditionValue = conditions[i].value.toString().toLowerCase();
          var rangeData = null;
          var rangeSeparator = null;
          var rangeValues = null;
          var isRangeNumber = false; // Percent filter type

          if (columnDef.filterType === 'percent') {
            conditionValue = (conditionValue / 100).toString();

            if ("".concat(columnDef.name).toLowerCase() === 'decimal') {
              rowValue = formatters.Decimal(false, false, rowValue, columnDef);
              conditionValue = formatters.Decimal(false, false, conditionValue, columnDef);
            } else if ("".concat(columnDef.name).toLowerCase() === 'integer') {
              rowValue = formatters.Integer(false, false, rowValue, columnDef);
              conditionValue = formatters.Integer(false, false, conditionValue, columnDef);
            }
          } // Run Data over the formatter


          if (columnDef.filterType === 'text') {
            var fmt = columnDef.formatter;
            var id = conditions[i].columnId;
            rowValue = self.formatValue(fmt, i, id, rowValue, columnDef, rowData, self); // Strip any html markup that might be in the formatters

            var rex = /(<([^>]+)>)|(amp;)|(&lt;([^>]+)&gt;)/ig;
            rowValue = rowValue.replace(rex, '').trim().toLowerCase();
            rowValueStr = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          }

          if (columnDef.filterType === 'contents' || columnDef.filterType === 'select' || columnDef.filterType === 'multiselect') {
            rowValue = rowValue === null || rowValue === undefined ? '' : rowValue.toString().toLowerCase();
          }

          if ((typeof rowValue === 'number' || !isNaN(rowValue) && rowValue !== '' && !(conditions[i].value instanceof Array)) && !/^(date|time|text)$/.test(columnDef.filterType)) {
            var _columnDef$maskOption;

            rowValue = rowValue === null ? rowValue : parseFloat(rowValue);

            if (columnDef && ((_columnDef$maskOption = columnDef.maskOptions) === null || _columnDef$maskOption === void 0 ? void 0 : _columnDef$maskOption == null ? void 0 : _columnDef$maskOption.process) === 'rangeNumber') {
              var _columnDef$maskOption2;

              var splitter = (_columnDef$maskOption2 = columnDef.maskOptions.patternOptions) === null || _columnDef$maskOption2 === void 0 ? void 0 : _columnDef$maskOption2 == null ? void 0 : _columnDef$maskOption2.delimeter;
              splitter = ")".concat(splitter, "(");

              if (conditionValue.substr(0, 1) === "(") {
                conditionValue = conditionValue.substr(1);
              }

              if (conditionValue.substr(-1) === ")") {
                conditionValue = conditionValue.substr(0, conditionValue.length - 1);
              }

              conditionValue = conditionValue.split(splitter).map(function (x) {
                return Locale.parseNumber(x);
              }).sort(function (a, b) {
                return a - b;
              });
              isRangeNumber = true;
            } else {
              conditionValue = Locale.parseNumber(conditionValue);
              isRangeNumber = false;
            }
          }

          if (columnDef.filterType === 'date' || columnDef.filterType === 'time') {
            if (typeof rowValue === 'string') {
              rowValue = columnDef.formatter(false, false, rowValue, columnDef, true);
            }

            var getValues = function getValues(rValue, cValue) {
              cValue = Locale.parseDate(cValue, conditions[i].format);

              if (cValue) {
                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  cValue.setDate(1);
                  cValue.setMonth(0);
                  cValue.setYear(0);
                }

                cValue = cValue.getTime();
              }

              if (rValue instanceof Date) {
                // Copy date
                rValue = new Date(rValue.getTime());

                if (columnDef.filterType === 'time') {
                  // drop the day, month and year
                  rValue.setDate(1);
                  rValue.setMonth(0);
                  rValue.setYear(0);
                } else if (!(columnDef.editorOptions && columnDef.editorOptions.showTime)) {
                  // Drop any time component of the row data for the filter as it is a date only field
                  rValue.setHours(0);
                  rValue.setMinutes(0);
                  rValue.setSeconds(0);
                  rValue.setMilliseconds(0);
                }

                rValue = rValue.getTime();
              } else if (typeof rValue === 'string' && rValue) {
                if (!columnDef.sourceFormat) {
                  rValue = Locale.parseDate(rValue, {
                    pattern: conditions[i].format
                  });
                } else {
                  rValue = Locale.parseDate(rValue, typeof columnDef.sourceFormat === 'string' ? {
                    pattern: columnDef.sourceFormat
                  } : columnDef.sourceFormat);
                }

                if (rValue) {
                  if (columnDef.filterType === 'time') {
                    // drop the day, month and year
                    rValue.setDate(1);
                    rValue.setMonth(0);
                    rValue.setYear(0);
                  } else if (!(columnDef.editorOptions && columnDef.editorOptions.showTime)) {
                    // Drop any time component of the row data for the filter
                    // as it is a date only field
                    rValue.setHours(0);
                    rValue.setMinutes(0);
                    rValue.setSeconds(0);
                    rValue.setMilliseconds(0);
                  }

                  rValue = rValue.getTime();
                }
              }

              return {
                rValue: rValue,
                cValue: cValue
              };
            };

            var values = null;

            if (conditions[i].operator === 'in-range') {
              var cell = self.settings.columns.indexOf(columnDef);
              var input = self.element.find(".datagrid-header th:eq(".concat(cell, ") .datagrid-filter-wrapper input"));
              var datepickerApi = input.data('datepicker');

              if (datepickerApi) {
                rangeSeparator = datepickerApi.settings.range.separator;
                rangeData = datepickerApi.settings.range.data;

                if (rangeData && rangeData.start) {
                  values = getValues(rowValue, rangeData.start);
                } else if (rangeSeparator && conditionValue.indexOf(rangeSeparator) > -1) {
                  rangeValues = conditionValue.split(rangeSeparator);
                  values = getValues(rowValue, rangeValues[0]);
                }
              }
            } else {
              values = getValues(rowValue, conditions[i].value);
            }

            rowValue = values ? values.rValue : rowValue;
            conditionValue = values ? values.cValue : conditionValue;
          }

          switch (conditions[i].operator) {
            case 'equals':
              // This case is multiselect
              if (conditions[i].value instanceof Array) {
                isMatch = false;

                for (var k = 0; k < conditions[i].value.length; k++) {
                  var match = conditions[i].value[k].toLowerCase() === rowValue && (rowValue.toString() !== '' || conditions[i].value[k] === '');

                  if (match) {
                    isMatch = true;
                  }
                }
              } else {
                isMatch = rowValue === conditionValue && rowValue !== '';
              }

              break;

            case 'does-not-equal':
              isMatch = rowValue !== conditionValue;
              break;

            case 'contains':
              isMatch = rowValueStr.indexOf(conditionValue) > -1 && rowValue.toString() !== '';
              break;

            case 'does-not-contain':
              isMatch = rowValueStr.indexOf(conditionValue) === -1;
              break;

            case 'end-with':
              isMatch = rowValueStr.lastIndexOf(conditionValue) === rowValueStr.length - conditionValue.toString().length && rowValueStr !== '' && rowValueStr.length >= conditionValue.toString().length;
              break;

            case 'start-with':
              isMatch = rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '';
              break;

            case 'does-not-end-with':
              isMatch = rowValueStr.lastIndexOf(conditionValue) === rowValueStr.length - conditionValue.toString().length && rowValueStr !== '' && rowValueStr.length >= conditionValue.toString().length;
              isMatch = !isMatch;
              break;

            case 'does-not-start-with':
              isMatch = !(rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;

            case 'is-empty':
              isMatch = rowValueStr === '';
              break;

            case 'is-not-empty':
              if (rowValue === '') {
                isMatch = rowValue !== '';
                break;
              }

              isMatch = !(rowValue === null);
              break;

            case 'in-range':
              isMatch = false;

              if (rangeData && rangeData.startDate && rangeData.endDate) {
                var d1 = rangeData.startDate.getTime();
                var d2 = rangeData.endDate.getTime();
                isMatch = rowValue >= d1 && rowValue <= d2 && rowValue !== null;
              } else if (rangeValues) {
                var _d = Locale.parseDate(rangeValues[0], conditions[i].format);

                var _d2 = Locale.parseDate(rangeValues[1], conditions[i].format);

                if (_d && _d2) {
                  _d = _d.getTime();
                  _d2 = _d2.getTime();
                  isMatch = rowValue >= _d && rowValue <= _d2 && rowValue !== null;
                }
              }

              if (isRangeNumber) {
                var isNotEmpty = rowValue !== '' && rowValue !== null;
                isMatch = rowValue >= conditionValue[0] && rowValue <= conditionValue[1] && isNotEmpty;
              }

              break;

            case 'less-than':
              isMatch = rowValue < conditionValue && rowValue !== '' && rowValue !== null;
              break;

            case 'less-equals':
              isMatch = rowValue <= conditionValue && rowValue !== '' && rowValue !== null;
              break;

            case 'greater-than':
              isMatch = rowValue > conditionValue && rowValue !== '' && rowValue !== null;
              break;

            case 'greater-equals':
              isMatch = rowValue >= conditionValue && rowValue !== '' && rowValue !== null;
              break;

            case 'selected':
              if (columnDef && columnDef.isChecked) {
                isMatch = columnDef.isChecked(rowValue);
                break;
              }

              isMatch = (rowValueStr === '1' || rowValueStr === 'true' || rowValue === true || rowValue === 1) && rowValueStr !== '';
              break;

            case 'not-selected':
              if (columnDef && columnDef.isChecked) {
                isMatch = !columnDef.isChecked(rowValue);
                break;
              }

              isMatch = rowValueStr === '0' || rowValueStr === 'false' || rowValue === false || rowValue === 0 || rowValueStr === '';
              break;

            case 'selected-notselected':
              isMatch = true;
              break;
          }

          if (!isMatch) {
            return {
              v: false
            };
          }
        };

        for (var i = 0; i < conditions.length; i++) {
          var _ret = _loop(i);

          if (_typeof(_ret) === "object") return _ret.v;
        }

        return isMatch;
      };

      if (!this.settings.disableClientFilter) {
        if (this.settings.treeGrid) {
          // Check nodes and set key/value `_isFilteredOut` in given dataset
          var checkNodes = function checkNodes(dataset) {
            var isFiltered = true;

            for (var i = 0, len = dataset.length; i < len; i++) {
              var nodeData = dataset[i];
              var isChildFiltered = true;

              if (nodeData.children) {
                isChildFiltered = checkNodes(nodeData.children);

                if (isChildFiltered) {
                  nodeData._isFilteredOut = !checkRow(nodeData);

                  if (!nodeData._isFilteredOut) {
                    isFiltered = false;
                  }
                } else {
                  isFiltered = false;
                }
              } else {
                nodeData._isFilteredOut = !checkRow(nodeData);

                if (!nodeData._isFilteredOut) {
                  isFiltered = false;
                }
              }
            }

            return isFiltered;
          }; // Check empty filter conditions


          var isFilterEmpty = function isFilterEmpty() {
            var isEmpty = true;

            for (var i = 0, len = conditions.length; i < len; i++) {
              if (conditions[i].filterType === 'checkbox' || conditions[i].value.toString().trim() !== '') {
                isEmpty = false;
              }
            }

            return isEmpty;
          };

          if (isFilterEmpty()) {
            removeFilteredOut(this.settings.dataset);
          } else {
            checkNodes(this.settings.dataset);
          }
        } else if (this.settings.groupable) {
          var isFiltered;

          for (var i = 0, len = this.settings.dataset.length; i < len; i++) {
            var isGroupFiltered = true;

            for (var i2 = 0, dataSetLen = this.settings.dataset[i].values.length; i2 < dataSetLen; i2++) {
              isFiltered = !checkRow(this.settings.dataset[i].values[i2]);
              this.settings.dataset[i].values[i2]._isFilteredOut = isFiltered;

              if (!isFiltered) {
                isGroupFiltered = false;
              }
            }

            this.settings.dataset[i]._isFilteredOut = isGroupFiltered;
          }
        } else {
          var _isFiltered;

          for (var _i4 = 0, _len = this.settings.dataset.length; _i4 < _len; _i4++) {
            _isFiltered = !checkRow(this.settings.dataset[_i4]);
            this.settings.dataset[_i4]._isFilteredOut = _isFiltered;
          }
        }
      }

      this.setChildExpandOnMatch();

      if (!this.settings.source) {
        this.clearCache();
        this.renderRows();
      }

      if (filterChanged) {
        var pagingInfo = {
          trigger: trigger,
          type: 'filtered'
        };

        if (this.settings.source) {
          pagingInfo.preserveSelected = this.settings.allowSelectAcrossPages;
        }

        this.setSearchActivePage(pagingInfo);
      }
      /**
      * Fires after a filter action ocurs
      * @event filtered
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Object with the arguments
      * @property {number} args.op The filter operation, this can be 'apply', 'clear'
      * @property {object} args.conditions An object with all the condition data.
      * @property {string} args.trigger Info on what was the triggering action. May be render, select or key
      */


      if (this.settings.disableClientFilter && trigger === 'restore') {
        return;
      }

      this.element.trigger('filtered', {
        op: 'apply',
        conditions: conditions,
        trigger: trigger
      });
      this.saveUserSettings();
    },

    /**
     * Adjust the left positon for given element to be in viewport
     * @private
     * @param {object} el The element
     * @returns {void}
     */
    adjustPosLeft: function adjustPosLeft(el) {
      var padding = 20;
      var b = el.getBoundingClientRect();
      var w = window.innerWidth || document.documentElement.clientWidth;

      if (b.left < 0 && b.right <= w) {
        el.style.left = "".concat(padding, "px"); // Left side
      } else if (b.left >= 0 && !(b.right <= w)) {
        el.style.left = "".concat(w - b.width - padding, "px"); // Right side
      }
    },

    /**
     * Set child nodes when use filter as
     * settings.allowChildExpandOnMatch === true
     * and if only parent got match then add all children nodes too
     * or if one or more child node got match then add parent node and all the children nodes
     * settings.allowChildExpandOnMatch === false
     * and if only parent got match then make expand/collapse button to be collapsed, disabled
     * and do not add any children nodes
     * or if one or more child node got match then add parent node and only matching children nodes
     * @private
     * @returns {void}
     */
    setChildExpandOnMatch: function setChildExpandOnMatch() {
      var s = this.settings;

      if (s.treeGrid) {
        var checkNodes = function checkNodes(nodeData, depth) {
          for (var i = 0, l = nodeData.length; i < l; i++) {
            var node = nodeData[i];
            var children = node.children;
            var childrenLen = children ? children.length : 0;

            if (childrenLen) {
              if (!node._isFilteredOut) {
                if (s.allowChildExpandOnMatch) {
                  for (var i2 = 0; i2 < childrenLen; i2++) {
                    children[i2]._isFilteredOut = false;
                  }
                } else {
                  var isAllChildrenFiltered = true;

                  for (var _i5 = 0; _i5 < childrenLen; _i5++) {
                    if (!children[_i5]._isFilteredOut) {
                      isAllChildrenFiltered = false;
                    }
                  }

                  node.isAllChildrenFiltered = isAllChildrenFiltered;
                }
              }

              checkNodes(children);
            }
          }
        };

        var setParents = function setParents(nodeData) {
          var found = false;

          for (var i = 0, l = nodeData.length; i < l; i++) {
            var _node$children;

            var node = nodeData[i];

            if (node._isFilteredOut && !found && (_node$children = node.children) !== null && _node$children !== void 0 && (_node$children == null ? void 0 : _node$children.length)) {
              node._isFilteredOut = !setParents(node.children);
            }

            if (typeof node._isFilteredOut === 'boolean' && !node._isFilteredOut) {
              found = true;
            }
          }

          return found;
        };

        setParents(s.dataset);
        checkNodes(s.dataset, 0);
      }
    },

    /**
    * Clear the Filter row Conditions and Reset the Data.
    */
    clearFilter: function clearFilter() {
      if (!this.settings.filterable) {
        return;
      }

      this.clearFilterFields();
      this.applyFilter();
      this.element.trigger('filtered', {
        op: 'clear',
        conditions: []
      });
    },

    /**
    * Clear the Filter fields.
    */
    clearFilterFields: function clearFilterFields() {
      if (!this.settings.filterable) {
        return;
      }

      this.element.find('.datagrid-header input, select').each(function () {
        var input = $(this);
        input.val('');

        if (input.is('select')) {
          input.find('option').each(function () {
            $(this).prop('selected', false);
          });
        }

        input.trigger('updated');
      }); // reset all the filters to first item

      this.element.find('.datagrid-header .btn-filter').each(function () {
        var btn = $(this);
        var ul = btn.next();
        var first = ul.find('li:first');
        btn.find('svg:first > use').attr('href', "#icon-filter-".concat(btn.attr('data-default')));
        ul.find('.is-checked').removeClass('is-checked');
        first.addClass('is-checked');
      });
    },

    /**
    * Set the Filter Conditions on the UI Only.
    * @param {object} conditions An array of objects with the filter conditions.
    */
    setFilterConditions: function setFilterConditions(conditions) {
      this.clearFilterFields();

      for (var i = 0; i < conditions.length; i++) {
        // Find the filter row
        var rowElem = this.element.find(".datagrid-header th[data-column-id=\"".concat(conditions[i].columnId, "\"]"));
        var input = rowElem.find('input, select');
        var btn = rowElem.find('.btn-filter');
        var ul = btn.next();

        if (conditions[i].value === undefined) {
          conditions[i].value = '';
        }

        input.val(conditions[i].value); // Enable clear button

        if (input.is('.lookup') && input.parent().find('svg.close').length === 1 && conditions[i].value) {
          input.parent().find('svg.close').removeClass('is-empty');
        }

        if (input.is('select')) {
          var firstVal = conditions[i].value instanceof Array ? conditions[i].value[0] : conditions[i].value;

          if (conditions[i].innerHTML) {
            input[0].innerHTML = conditions[i].innerHTML;
          }

          if (!input.find("option[value=\"".concat(firstVal, "\"]")).length) {
            var dropdownApi = input.data('dropdown');

            if (dropdownApi) {
              dropdownApi.setCode(conditions[i].value);
            }
          } else if (conditions[i].value instanceof Array && !conditions[i].selectedOptions) {
            var options = input[0].querySelectorAll('option');
            input.val('');

            for (var k = 0; k < options.length; k++) {
              options[k].selected = false;
            }

            for (var j = 0; j < conditions[i].value.length; j++) {
              input.find("option[value=\"".concat(conditions[i].value[j], "\"]")).prop('selected', true);
            }
          } else {
            input.find("option[value=\"".concat(conditions[i].value, "\"]")).prop('selected', true);
          }

          input.trigger('updated');
        }

        btn.find('svg:first > use').attr('href', "#icon-filter-".concat(conditions[i].operator));
        ul.find('.is-checked').removeClass('is-checked');
        ul.find(".".concat(conditions[i].operator)).addClass('is-checked');
      }
    },

    /**
    * Get filter conditions in array from whats set in the UI.
    * @returns {array} An array with the currently showing filter conditions.
    */
    filterConditions: function filterConditions() {
      // Do not modify keyword search filter expr
      if (this.filterExpr && this.filterExpr.length === 1 && this.filterExpr[0].keywordSearch) {
        delete this.filterExpr[0].keywordSearch;
        return this.filterExpr;
      }

      var filterExpr = [];
      var self = this; // Create an array of objects with: field, id, filterType, operator, value

      this.element.find('th.is-filterable').each(function () {
        var rowElem = $(this);
        var btn = rowElem.find('.btn-filter');
        var input = rowElem.find('input, select');
        var isDropdown = input.is('select');
        var svg = btn.find('.icon-dropdown:first');
        var op = null;
        var format = null;

        if (!btn.length && !isDropdown) {
          return;
        }

        op = isDropdown ? 'equals' : svg.getIconName().replace('filter-', '');

        if (op === 'selected-notselected') {
          return;
        }

        if (input.val() === '' && ['is-not-empty', 'is-empty', 'selected', 'not-selected'].indexOf(op) === -1) {
          return;
        }

        if (input.val() instanceof Array && input.val().length === 0) {
          return;
        }

        var value = input.val() ? input.val() : '';

        if (input.attr('data-mask-mode') && input.attr('data-mask-mode') === 'number') {
          value = Locale.parseNumber(value);
        }

        var condition = {
          columnId: rowElem.attr('data-column-id'),
          operator: op,
          value: value
        };

        if (input.data('datepicker')) {
          format = input.data('datepicker').pattern;
          condition.format = format;
        }

        if (input.data('timepicker')) {
          format = input.data('timepicker').settings.timeFormat;
          condition.format = format;
        }

        if (input.is('select')) {
          condition.innerHTML = input[0].innerHTML;
        }

        var column = self.columnById(condition.columnId);

        if (column && column[0]) {
          condition.filterType = column[0].filterType;
        }

        filterExpr.push(condition);
      });
      return filterExpr;
    },

    /**
    * Get extra top position for current target in header
    * @private
    * @returns {number} the extra top position of the rows depending on rowHeight setting.
    */
    getExtraTop: function getExtraTop() {
      var s = this.settings;
      var topPositions = {
        default: {
          extraSmall: 0,
          short: 0,
          small: 0,
          medium: 0,
          normal: 0,
          large: 0
        },
        filterable: {
          extraSmall: 0,
          short: 0,
          small: 0,
          medium: 0,
          normal: 0,
          large: 0
        },
        group: {
          extraSmall: -22,
          short: -25,
          small: -25,
          medium: -30,
          normal: -39,
          large: -39
        },
        groupFilter: {
          extraSmall: -28,
          short: -29,
          small: -29,
          medium: -32,
          normal: -39,
          large: -39
        }
      };
      var extraTop = 0;
      var prop = s.rowHeight === 'extra-small' ? 'extraSmall' : s.rowHeight;

      if (s.columnGroups) {
        extraTop = s.filterable ? topPositions.groupFilter[prop] : topPositions.group[prop];
      } else {
        extraTop = s.filterable ? topPositions.filterable[prop] : topPositions.default[prop];
      }

      return extraTop;
    },

    /**
    * Get height for current target in header
    * @private
    * @returns {number} the height of the rows depending on rowHeight setting.
    */
    getTargetHeight: function getTargetHeight() {
      var s = this.settings;
      var heights = {
        default: {
          extraSmall: 20,
          short: 20,
          small: 20,
          medium: 28,
          normal: 35,
          large: 35
        },
        filterable: {
          extraSmall: 47,
          short: 53,
          small: 53,
          medium: 54,
          normal: 60,
          large: 60
        },
        group: {
          extraSmall: 43,
          short: 46,
          small: 46,
          medium: 56,
          normal: 74,
          large: 74
        },
        groupFilter: {
          extraSmall: 80,
          small: 80,
          short: 83,
          medium: 87,
          normal: 103,
          large: 103
        }
      };
      var height = 0;
      var prop = s.rowHeight === 'extra-small' ? 'extraSmall' : s.rowHeight;

      if (s.columnGroups) {
        height = s.filterable && this.filterRowRendered ? heights.groupFilter[prop] : heights.group[prop];
      } else {
        height = s.filterable && this.filterRowRendered ? heights.filterable[prop] : heights.default[prop];
      }

      return height;
    },

    /**
    * Get padding for a row height
    * @private
    * @returns {number} padding (left and right) for the current rowHeight
    */
    getCellPadding: function getCellPadding() {
      var padding = {
        'extra-small': 8,
        short: 8,
        small: 8,
        medium: 16,
        normal: 16,
        large: 16
      };
      return padding[this.settings.rowHeight];
    },

    /**
    * Create draggable columns
    * @private
    */
    createDraggableColumns: function createDraggableColumns() {
      var self = this;
      var headers = self.headerNodes().not('[data-column-id="selectionCheckbox"]').not('.datagrid-header-spacer-column');
      var showTarget = $('.drag-target-arrows', self.element);

      if (!showTarget.length) {
        self.element.prepend("<span class=\"drag-target-arrows\" style=\"height: ".concat(self.getTargetHeight(), "px;\"></span>"));
        showTarget = $('.drag-target-arrows', self.element);
      }

      headers.not('[data-reorder="false"]').prepend("</span><span class=\"handle\">".concat($.createIcon({
        icon: 'drag'
      }), "</span>"));
      headers.prepend('<span class="is-draggable-target"></span>');
      headers.last().append('<span class="is-draggable-target last"></span>');
      self.element.addClass('has-draggable-columns'); // Initialize Drag api

      $('.handle', headers).each(function () {
        var clone = null;
        var headerPos = null;
        var offPos = null;
        var extraTopPos = 0;
        var handle = $(this);
        var header = handle.parent();
        handle.on('mousedown.datagrid', function (e) {
          e.preventDefault();
          header.drag({
            clone: true,
            cloneAppendTo: headers.first().parent().parent(),
            clonePosIsFixed: true
          }).on('dragstart.datagrid', function (dragStartEvent, pos, thisClone) {
            clone = thisClone;
            clone.removeAttr('id').addClass('is-dragging-clone').css({
              left: !Locale.isRTL() ? pos.left : pos.right - clone.width(),
              top: pos.top,
              height: header.height(),
              border: 0
            });
            $('.is-draggable-target', clone).remove();
            self.setDraggableColumnTargets();
            extraTopPos = self.getExtraTop();
            headerPos = header.position();
            offPos = {
              top: pos.top - headerPos.top,
              left: pos.left - headerPos.left
            };
            var index = self.targetColumn(headerPos);
            self.draggableStatus.startIndex = index;
            e.stopImmediatePropagation();
          }).on('drag.datagrid', function (dragEvent, pos) {
            clone[0].style.left = "".concat(parseInt(!Locale.isRTL() ? pos.left : pos.left + pos.offset.x - pos.clone.width(), 10), "px");
            clone[0].style.top = "".concat(parseInt(pos.top, 10), "px");
            headerPos = {
              top: pos.top - offPos.top,
              left: pos.left - offPos.left
            };

            if (Locale.isRTL()) {
              headerPos.left = parseInt(clone[0].style.left, 10);
            }

            var n = 0;
            var target = null;
            var rect = null;
            var index = self.targetColumn(headerPos);
            $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

            if (index !== -1) {
              for (var i = 0, l = self.draggableColumnTargets.length; i < l; i++) {
                target = self.draggableColumnTargets[i];
                n = i + 1;

                if (target.index === index && target.index !== self.draggableStatus.startIndex) {
                  if (target.index > self.draggableStatus.startIndex && n < l) {
                    target = self.draggableColumnTargets[n];
                  }

                  target.el.addClass('is-over');
                  showTarget.addClass('is-over');
                  rect = target.el[0].getBoundingClientRect();
                  showTarget[0].style.left = "".concat(parseInt(rect.left + (Locale.isRTL() ? 2 : 0), 10), "px");
                  var lastAdjustment = 0;

                  if (target.el.hasClass('last')) {
                    lastAdjustment = -(header.height() - 3);
                  }

                  showTarget[0].style.top = "".concat(parseInt(rect.top, 10) + 1 + extraTopPos + lastAdjustment, "px");
                }
              }
            }

            e.stopImmediatePropagation();
          }).on('dragend.datagrid', function (dragendEvent, pos) {
            if (!Locale.isRTL()) {
              clone[0].style.left = "".concat(parseInt(pos.left, 10), "px");
              clone[0].style.top = "".concat(parseInt(pos.top, 10), "px");
            }

            headerPos = {
              top: pos.top - offPos.top,
              left: pos.left - offPos.left
            };

            if (Locale.isRTL()) {
              headerPos.left = parseInt(clone[0].style.left, 10);
            }

            var index = self.targetColumn(headerPos);
            var dragApi = header.data('drag');
            var tempArray = [];
            var i;
            var l;
            var indexFrom;
            var indexTo; // Unbind drag from header

            if (dragApi && dragApi.destroy) {
              dragApi.destroy();
            }

            self.draggableStatus.endIndex = index;
            $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

            if (self.draggableStatus.endIndex !== -1) {
              if (self.draggableStatus.startIndex !== self.draggableStatus.endIndex) {
                // Swap columns
                for (i = 0, l = self.settings.columns.length; i < l; i++) {
                  if (!self.settings.columns[i].hidden && self.settings.columns[i].id !== 'selectionCheckbox') {
                    tempArray.push(i);
                  }
                }

                indexFrom = tempArray[self.draggableStatus.startIndex] || 0;
                indexTo = tempArray[self.draggableStatus.endIndex] || 0;
                self.updateGroupHeadersAfterColumnReorder(indexFrom, indexTo);
                self.arrayIndexMove(self.settings.columns, indexFrom, indexTo);
                self.updateColumns(self.settings.columns);
              }
            }
          });
        });
      });
    },

    /**
    * Set draggable columns target elements
    * @private
    */
    setDraggableColumnTargets: function setDraggableColumnTargets() {
      var self = this;
      var headers = self.headerNodes().not('.is-hidden').not('[data-column-id="selectionCheckbox"]').not('.datagrid-header-spacer-column');
      var target;
      var pos;
      var extra;
      self.draggableColumnTargets = [];
      self.draggableStatus = {}; // Move last target if not found in last header

      if (!$('.is-draggable-target.last', headers.last()).length) {
        headers.last().append($('.is-draggable-target.last', self.headerNodes()));
      }

      $('.is-draggable-target', headers).each(function (index) {
        var idx = $(this).is('.last') ? index - 1 : index; // Extra target for last header th

        target = headers.eq(idx);
        pos = target.position(); // Extra space around, if dropped item bit off from drop area

        extra = 20;
        self.draggableColumnTargets.push({
          el: $(this),
          index: idx,
          pos: pos,
          width: target.outerWidth(),
          height: target.outerHeight(),
          dropArea: {
            x1: pos.left - extra,
            x2: pos.left + target.outerWidth() + extra,
            y1: pos.top - extra + self.getExtraTop(),
            y2: pos.top + target.outerHeight() + extra
          }
        });
      });
    },

    /**
    * Get column index for dragging columns
    * @private
    * @param {object} pos The position index
    * @returns {number} The column array index
    */
    targetColumn: function targetColumn(pos) {
      var self = this;
      var idx = -1;
      var target;
      var i;
      var l;

      for (i = 0, l = self.draggableColumnTargets.length - 1; i < l; i++) {
        target = self.draggableColumnTargets[i];

        if (pos.left > target.dropArea.x1 && pos.left < target.dropArea.x2 && pos.top > target.dropArea.y1 && pos.top < target.dropArea.y2) {
          idx = target.index; // In RTL mode return the first one found. In LTR return the last one found.

          if (Locale.isRTL()) {
            return idx;
          }
        }
      }

      return idx;
    },

    /**
    * Move an array element to a different position. May be dups of this function.
    * @private
    * @param {array} arr The array
    * @param {array} from The from position
    * @param {array} to The to position
    */
    arrayIndexMove: function arrayIndexMove(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    /**
    * Attach Drag Events to Rows
    * @private
    */
    createDraggableRows: function createDraggableRows() {
      var self = this;

      if (!this.settings.rowReorder) {
        return;
      }

      this.tableBody.children().filter(function () {
        return $(this).find('.datagrid-reorder-icon').length < 1;
      }).attr('data-arrange-exclude', true); // Attach the Drag API

      this.tableBody.arrange({
        placeholder: "<tr class=\"datagrid-reorder-placeholder\"><td colspan=\"".concat(this.visibleColumns().length, "\"></td></tr>"),
        handle: '.datagrid-reorder-icon',
        isVisualItems: true
      }).off('beforearrange.datagrid').on('beforearrange.datagrid', function (e, status) {
        if (self.isSafari) {
          status.start.css({
            display: 'inline-block'
          });
        }
      }).off('arrangeupdate.datagrid').on('arrangeupdate.datagrid', function (e, status) {
        if (self.isSafari) {
          status.end.css({
            display: ''
          });
        }

        self.reorderRow(status.startIndex, status.endIndex, status);
      });
    },

    /**
     * Move a row from one position to another.
     * @param {number} startIndex The row to move.
     * @param {boolean} endIndex The end index.
     * @param {object} status The drag event object.
     */
    reorderRow: function reorderRow(startIndex, endIndex, status) {
      var moveDown = endIndex > startIndex;
      var startRow = this.tableBody.find('tr').eq(startIndex);
      var endRow = this.tableBody.find('tr').eq(endIndex); // Move the elem in the data set

      var dataRowIndex = {
        start: this.dataRowIndex(status ? status.start : endRow)
      };
      dataRowIndex.end = dataRowIndex.start + (endIndex - startIndex);
      this.arrayIndexMove(this.settings.dataset, dataRowIndex.start, dataRowIndex.end);

      if (status) {
        // If using expandable rows move the expandable row with it
        if (this.settings.rowTemplate || this.settings.expandableRow) {
          if (moveDown) {
            this.tableBody.find('tr').eq(startIndex * 2).insertAfter(status.end);
            status.end.next().next().insertAfter(status.over);
          } else {
            this.tableBody.find('tr').eq(startIndex * 2).next().insertAfter(status.end);
          }
        }
      } else {
        // Move in the ui
        startRow[moveDown ? 'insertAfter' : 'insertBefore'](endRow);
      } // Resequence the rows


      var allRows = this.tableBody.find('tr:not(.datagrid-expandable-row)');

      for (var i = 0; i < allRows.length; i++) {
        allRows[i].setAttribute('data-index', i);
        allRows[i].setAttribute('aria-rowindex', this.pagingRowIndex(i + 1));
      }
      /**
      * Fires after a row is moved via the rowReorder option.
      * @event rowremove
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} status Object with row reorder info
      * @property {number} status.endIndex The ending row index
      * @property {number} status.startIndex The starting row index
      * @property {HTMLElement} status.over The row object that was dragged over.
      * @property {HTMLElement} status.start The starting row object.
      */


      this.element.trigger('rowreorder', [{
        endIndex: endIndex,
        startIndex: startIndex,
        over: endRow,
        start: startRow
      }]);
      this.syncSelectedRowsIdx();
    },

    /**
    * Return the value in a field, taking into account nested objects. Fx obj.field.id
    * @private
    * @param {object} obj The object to use
    * @param {string} field The field as a string fx 'field' or 'obj.field.id'
    * @returns {any} The current value in the field.
    */
    fieldValue: function fieldValue(obj, field) {
      if (!field || !obj) {
        return '';
      }

      var rawValue;

      if (field.indexOf('.') > -1) {
        rawValue = field.split('.').reduce(function (o, x) {
          return o ? o[x] : '';
        }, obj);
      } else {
        rawValue = obj[field];
      }

      var value = rawValue || rawValue === 0 || rawValue === false ? rawValue : '';
      value = xssUtils.escapeHTML(value);
      return value;
    },

    /**
    * Setup internal tree root nodes array.
    * @private
    */
    setTreeRootNodes: function setTreeRootNodes() {
      if (!this.settings.treeGrid) {
        return;
      }

      this.settings.treeRootNodes = this.settings.treeDepth.filter(function (node) {
        return node.depth === 1;
      });
    },

    /**
     * Setup internal tree depth array.
     * @private
     * @param {array} dataset The json array to use for calculating tree depth.
     */
    setTreeDepth: function setTreeDepth(dataset) {
      if (!this.settings.treeGrid) {
        return;
      }

      var self = this;
      var idx = 0;

      var iterate = function iterate(node, depth) {
        var _node$children2;

        var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        idx++;
        self.settings.treeDepth.push({
          idx: idx,
          depth: depth,
          parents: parent.slice(),
          node: node
        });
        var len = (_node$children2 = node.children) === null || _node$children2 === void 0 ? void 0 : _node$children2 == null ? void 0 : _node$children2.length;

        if (len) {
          parent.push(idx - 1);

          for (var i = 0; i < len; i++) {
            iterate(node.children[i], depth + 1, parent.slice());
          }
        }
      };

      dataset = dataset || this.settings.dataset;
      self.settings.treeDepth = [];

      for (var i = 0, len = dataset.length; i < len; i++) {
        iterate(dataset[i], 1);
      }
    },

    /**
    * Setup internal row grouping
    * @private
    */
    setRowGrouping: function setRowGrouping() {
      var groupSettings = this.settings.groupable;

      if (!groupSettings) {
        return;
      }

      if (!this.originalDataset) {
        this.originalDataset = this.settings.dataset.slice();
      } else {
        this.settings.dataset = this.originalDataset;
      }

      if (!groupSettings.aggregator || groupSettings.aggregator === 'none') {
        this.settings.dataset = groupBy.none(this.settings.dataset, groupSettings.fields);
        return;
      }

      if (groupSettings.aggregator === 'sum') {
        this.settings.dataset = groupBy.sum(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'max') {
        this.settings.dataset = groupBy.max(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'min') {
        this.settings.dataset = groupBy.min(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'avg') {
        this.settings.dataset = groupBy.avg(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'count') {
        this.settings.dataset = groupBy.count(this.settings.dataset, groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'list') {
        this.settings.dataset = groupBy.list(this.settings.dataset, groupSettings.fields, groupSettings.aggregatorOptions);
        return;
      }

      this.settings.dataset = groupBy(this.settings.dataset, groupSettings.fields);
    },

    /**
    * Clear the table body and rows.
    * @private
    */
    renderRows: function renderRows() {
      var tableHtml = '';
      var tableHtmlLeft = '';
      var tableHtmlRight = '';
      var j = 0;
      var self = this;
      var s = self.settings;
      var body = self.table.find('tbody');
      var activePage = 1;

      if (self.pagerAPI) {
        var pagerState = self.pagerAPI.state;

        if (pagerState.filteredActivePage) {
          activePage = pagerState.filteredActivePage;
        } else {
          activePage = pagerState.activePage;
        }
      }

      self.bodyColGroupHtmlLeft = '<colgroup>';
      self.bodyColGroupHtml = '<colgroup>';
      self.bodyColGroupHtmlRight = '<colgroup>';
      self.triggerDestroyCell(); // Trigger Destroy on previous cells

      if (!self.settings.columns || self.settings.columns.length === 0) {
        self.settings.columns.push({
          id: 'blank',
          value: '',
          field: ''
        });
      }

      this.currentPageRows = [];

      for (j = 0; j < self.settings.columns.length; j++) {
        var col = self.settings.columns[j];
        var container = self.getContainer(col.id);
        var colWidth = self.columnWidth(col, j);

        switch (container) {
          case 'left':
            self.bodyColGroupHtmlLeft += "<col".concat(colWidth).concat(col.hidden ? ' class="is-hidden"' : '', "></col>");
            break;

          case 'right':
            self.bodyColGroupHtmlRight += "<col".concat(colWidth).concat(col.hidden ? ' class="is-hidden"' : '', "></col>");
            break;

          default:
            self.bodyColGroupHtml += "<col".concat(colWidth).concat(col.hidden ? ' class="is-hidden"' : '', "></col>");
        }

        if (col.colspan) {
          self.hasColSpans = true;
        }
      } // Prevent flashing message area on filter / reload


      if (self.emptyMessageContainer) {
        self.emptyMessageContainer.hide();
      }

      if (body.length === 0) {
        if (self.hasLeftPane) {
          self.tableBodyLeft = $('<tbody></tbody>');
          self.tableLeft.append(self.tableBodyLeft);
        }

        self.tableBody = $('<tbody></tbody>');
        self.table.append(self.tableBody);

        if (self.hasRightPane) {
          self.tableBodyRight = $('<tbody></tbody>');
          self.tableRight.append(self.tableBodyRight);
        }
      }

      self.groupArray = [];
      self.recordCount = 0;
      self.filteredCount = 0;
      self.runningCount = 0; // Reset recordCount for paging

      if (s.treeGrid && s.paging && !s.source && activePage > 1) {
        self.recordCount = s.treeRootNodes[s.pagesize * activePage - s.pagesize].idx - 1;
      }

      if (this.restoreSortOrder) {
        this.sortDataset();
      }

      var rowStatusTooltip = false;

      for (var i = 0; i < s.dataset.length; i++) {
        // For better performance dont render out of page
        if (s.paging && !s.source) {
          if (activePage === 1 && i - this.filteredCount >= s.pagesize) {
            if (!s.dataset[i]._isFilteredOut) {
              this.recordCount++;
            } else {
              this.filteredCount++;
            }

            continue; //eslint-disable-line
          }

          if (activePage > 1 && !(i - this.filteredCount >= s.pagesize * (activePage - 1) && i - this.filteredCount < s.pagesize * activePage)) {
            if (!s.dataset[i]._isFilteredOut) {
              if (this.filteredCount) {
                this.recordCount++;
              }
            } else {
              this.filteredCount++;
            }

            continue; //eslint-disable-line
          }
        }

        if (s.virtualized) {
          if (!this.isRowVisible(this.recordCount)) {
            this.recordCount++;
            continue; //eslint-disable-line
          }
        } // Exclude Filtered Rows


        if ((!s.treeGrid && s.dataset[i])._isFilteredOut) {
          this.filteredCount++;
          continue; //eslint-disable-line
        } // Handle Grouping


        if (this.settings.groupable) {
          // Filter and sorted
          if (s.dataset[i].values) {
            var thisLength = s.dataset[i].values.length;
            var thisFilterCount = 0;

            for (var k = 0; k < thisLength; k++) {
              if (s.dataset[i].values[k]._isFilteredOut) {
                thisFilterCount++;
              }
            }

            if (thisFilterCount === thisLength) {
              continue; //eslint-disable-line
            }
          } // First push group row


          if (!this.settings.groupable.suppressGroupRow) {
            // Show the grouping row
            var groupHtml = self.rowHtml(s.dataset[i], this.recordCount, i, true);

            if (this.hasLeftPane && groupHtml.left) {
              tableHtmlLeft += groupHtml.left;
            }

            if (groupHtml.center) {
              tableHtml += groupHtml.center;
            }

            if (this.hasRightPane && groupHtml.right) {
              tableHtmlRight += groupHtml.right;
            }
          }

          if (this.settings.groupable.showOnlyGroupRow && s.dataset[i].values[0]) {
            var rowData = s.dataset[i].values[0];

            if (s.dataset[i].list) {
              rowData.list = s.dataset[i].list;
            }

            rowData.values = s.dataset[i].values;

            var _groupHtml = self.rowHtml(rowData, this.recordCount, i);

            if (this.hasLeftPane && _groupHtml.left) {
              tableHtmlLeft += _groupHtml.left;
            }

            if (_groupHtml.center) {
              tableHtml += _groupHtml.center;
            }

            if (this.hasRightPane && _groupHtml.right) {
              tableHtmlRight += _groupHtml.right;
            }

            this.recordCount++;
            self.groupArray.push({
              group: i,
              node: 0
            });
            continue; //eslint-disable-line
          } // Now Push Groups


          for (var _k = 0; _k < s.dataset[i].values.length; _k++) {
            if (!s.dataset[i].values[_k]._isFilteredOut) {
              var _rowHtml = self.rowHtml(s.dataset[i].values[_k], this.recordCount, s.dataset[i].values[_k].idx);

              if (self.hasLeftPane && _rowHtml.left) {
                tableHtmlLeft += _rowHtml.left;
              }

              if (_rowHtml.center) {
                tableHtml += _rowHtml.center;
              }

              if (self.hasRightPane && _rowHtml.right) {
                tableHtmlRight += _rowHtml.right;
              }

              this.recordCount++;
              self.groupArray.push({
                group: i,
                node: _k
              });
            }
          } // Now Push summary rowHtml


          if (this.settings.groupable.groupFooterRow) {
            var _rowHtml2 = self.rowHtml(s.dataset[i], this.recordCount, i, true, true);

            if (self.hasLeftPane && _rowHtml2.left) {
              tableHtmlLeft += _rowHtml2.left;
            }

            if (_rowHtml2.center) {
              tableHtml += _rowHtml2.center;
            }

            if (self.hasRightPane && _rowHtml2.right) {
              tableHtmlRight += _rowHtml2.right;
            }
          }

          continue; //eslint-disable-line
        }

        var currentCount = i;

        if (s.treeGrid) {
          currentCount = this.recordCount;
        }

        self.runningCount++;
        var rowHtml = self.rowHtml(s.dataset[i], currentCount, i);

        if (self.hasLeftPane && rowHtml.left) {
          tableHtmlLeft += rowHtml.left;
        }

        if (rowHtml.center) {
          var _this$filterExpr;

          tableHtml += rowHtml.center;

          if (s.treeGrid && (_this$filterExpr = this.filterExpr) !== null && _this$filterExpr !== void 0 && (_this$filterExpr == null ? void 0 : _this$filterExpr.length)) {
            if ($("<table>".concat(rowHtml.center, "</table>")).find('tr:first').is('.is-hidden')) {
              this.filteredCount++;
            }
          }
        }

        if (self.hasRightPane && rowHtml.right) {
          tableHtmlRight += rowHtml.right;
        }

        if (!s.dataset[i]._isFilteredOut) {
          this.recordCount++;
        }

        this.visibleRowCount = currentCount + 1;

        if (s.dataset[i].rowStatus) {
          rowStatusTooltip = true;
        }
      } // Append a Summary Row


      if (this.settings.summaryRow) {
        self.element.addClass('has-summary-row');
        var totals = self.calculateTotals();
        var summaryRowHtml = self.rowHtml(totals, this.recordCount, null, false, true);

        if (self.hasLeftPane && summaryRowHtml.left) {
          tableHtmlLeft += summaryRowHtml.left;
        }

        if (summaryRowHtml.center) {
          tableHtml += summaryRowHtml.center;
        }

        if (self.hasRightPane && summaryRowHtml.right) {
          tableHtmlRight += summaryRowHtml.right;
        }
      }

      if (self.bodyColGroupHtml !== '<colgroup>') {
        if (this.settings.spacerColumn) {
          self.bodyColGroupHtml += '<col style="width: 100%">';
        }

        self.bodyColGroupHtmlLeft += '</colgroup>';
        self.bodyColGroupHtml += '</colgroup>';
        self.bodyColGroupHtmlRight += '</colgroup>';

        if (self.bodyColGroupLeft) {
          self.bodyColGroupLeft.remove();
        }

        if (self.bodyColGroup) {
          self.bodyColGroup.remove();
        }

        if (self.bodyColGroupRight) {
          self.bodyColGroupRight.remove();
        }

        if (self.hasLeftPane) {
          self.bodyColGroupLeft = $(self.bodyColGroupHtmlLeft);
          (self.headerRowLeft || self.tableBodyLeft).before(self.bodyColGroupLeft);
        }

        self.bodyColGroup = $(self.bodyColGroupHtml);
        (self.headerRow || self.tableBody).before(self.bodyColGroup);

        if (self.hasRightPane) {
          self.bodyColGroupRight = $(self.bodyColGroupHtmlRight);
          (self.headerRowRight || self.tableBodyRight).before(self.bodyColGroupRight);
        }
      }

      if (self.hasLeftPane) {
        DOM.html(self.tableBodyLeft, tableHtmlLeft, '*');
      }

      DOM.html(self.tableBody, tableHtml, '*');

      if (self.hasRightPane) {
        DOM.html(self.tableBodyRight, tableHtmlRight, '*');
      }

      self.setVirtualHeight();
      self.setScrollClass();
      self.setupTooltips(rowStatusTooltip);
      self.afterRender();
    },

    /**
    * Fire events and do steps needed after a full render.
    * @private
    */
    afterRender: function afterRender() {
      var _this4 = this;

      var self = this;

      if (this.settings.fixedRowHeight && this.settings.fixedRowHeight === 'auto' && this.settings.frozenColumns) {
        self.tableBody.find('tr').each(function (i) {
          var leftHeight = 0;
          var centerHeight = 0;
          var rightHeight = 0;
          var row = $(this);
          centerHeight = row.height();

          if (self.tableBodyLeft) {
            leftHeight = self.tableBodyLeft.find('tr').eq(i).height();
          }

          if (self.tableBodyRight) {
            rightHeight = self.tableBodyLeft.find('tr').eq(i).height();
          }

          var maxHeight = Math.max(leftHeight, centerHeight, rightHeight);
          row.css('height', maxHeight);

          if (self.tableBodyLeft) {
            leftHeight = self.tableBodyLeft.find('tr').eq(i).css('height', maxHeight);
          }

          if (self.tableBodyRight) {
            rightHeight = self.tableBodyLeft.find('tr').eq(i).css('height', maxHeight);
          }

          return true;
        });
      } // Column column postRender functions


      if (this.settings.onPostRenderCell) {
        var _loop2 = function _loop2(i) {
          var col = self.settings.columns[i];

          if (col.component) {
            self.tableBody.find('tr').each(function () {
              var _self$settings$frozen, _self$settings$frozen2;

              var row = $(this);
              var rowIdx = self.settings.treeGrid ? self.actualPagingRowIndex(self.actualRowIndex(row)) : self.dataRowIndex(row);
              var lineage = row.attr('data-lineage');
              var rowData = self.rowData(rowIdx);
              var colIdx = self.columnIdxById(col.id) - (((_self$settings$frozen = self.settings.frozenColumns) === null || _self$settings$frozen === void 0 ? void 0 : (_self$settings$frozen2 = _self$settings$frozen == null ? void 0 : _self$settings$frozen.left) === null || _self$settings$frozen2 === void 0 ? void 0 : _self$settings$frozen2 == null ? void 0 : _self$settings$frozen2.length) || 0);
              var args = {
                row: lineage || rowIdx,
                cell: colIdx,
                value: rowData,
                rowData: rowData,
                col: col,
                api: self
              };
              self.settings.onPostRenderCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        };

        for (var i = 0; i < this.settings.columns.length; i++) {
          _loop2(i);
        }
      } // Init Inline Elements


      var dropdowns = self.tableBody.find('select.dropdown');

      if (dropdowns.dropdown) {
        dropdowns.dropdown();
      } // Commit Edits for inline editing


      self.tableBody.find('.dropdown-wrapper.is-inline').prev('select').on('listclosed', function () {
        var elem = $(this);
        var newValue = elem.val();
        var row = elem.closest('tr');
        self.updateCellNode(row.attr('aria-rowindex'), elem.closest('td').index(), newValue, false, true);
      });
      var spinboxes = self.tableBody.find('.spinbox');

      if (spinboxes.spinbox) {
        spinboxes.spinbox();
      } // Set UI elements after dataload


      if (!self.settings.source) {
        self.displayCounts();
      }

      self.setAlternateRowShading();
      self.createDraggableRows();
      var focusedEl = document.activeElement;

      if (self.activeCell.isFocused && (!focusedEl || focusedEl && focusedEl.tagName.toLowerCase() === 'body')) {
        self.setActiveCell(self.activeCell.row, self.activeCell.cell);
      } // Deselect rows when changing pages


      if (self.settings.paging && self.settings.source && !self.settings.allowSelectAcrossPages) {
        if (!self.preventSelection) {
          self._selectedRows = [];
        }

        self.syncSelectedUI();
      } // Restore selected rows when pages change


      if (self.settings.paging && self.settings.source && self.settings.allowSelectAcrossPages) {
        self.syncSelectedRows();
        self.syncSelectedUI();
      } // Restore selected rows when pages change for single select


      if (self.settings.paging && !self.settings.source && self.settings.allowSelectAcrossPages === null) {
        self.syncSelectedRows();
        self.syncSelectedUI();
      }

      if (this.stretchColumnDiff < 0) {
        var currentCol = this.bodyColGroup.find('col').eq(self.getStretchColumnIdx())[0];
        currentCol.style.width = "".concat(this.stretchColumnWidth, "px");
      }
      /**
      * Fires after the entire grid is rendered.
      * @event afterrender
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {HTMLElement} body Object table body area
      * @property {HTMLElement} header Object table header area
      * @property {HTMLElement} pager Object pager body area
      */


      setTimeout(function () {
        self.element.trigger('afterrender', {
          body: self.container.find('tbody'),
          header: self.container.find('thead'),
          pager: self.pagerAPI
        });

        _this4.activateFirstCell();
      });
    },

    /**
     * Set active node to first cell and focus if possible
     * @private
     */
    activateFirstCell: function activateFirstCell() {
      if (!this.activeCell || !this.activeCell.node) {
        this.activeCell = {
          node: this.cellNode(0, 0).attr('tabindex', '0'),
          isFocused: false,
          cell: 0,
          row: 0
        };
      }
    },

    /**
    * Trigger the onDestroyCell for each cell
    * @private
    */
    triggerDestroyCell: function triggerDestroyCell() {
      var _this5 = this;

      var self = this;

      if (!self.tableBody) {
        return;
      } // Call onDestroyCell


      if (this.settings.onPostRenderCell && this.settings.onDestroyCell) {
        var rows = self.tableBody.find('tr');

        if (rows.length === 0) {
          return;
        }

        var _loop3 = function _loop3(i) {
          var col = _this5.settings.columns[i];

          if (col.component) {
            rows.each(function () {
              var row = $(this);
              var rowIdx = row.index();
              var colIdx = self.columnIdxById(col.id);
              var args = {
                row: row.index(),
                cell: colIdx,
                value: self.settings.dataset[rowIdx],
                col: col,
                api: self
              };
              self.settings.onDestroyCell(row.find('td').eq(colIdx).find('.datagrid-cell-wrapper .content')[0], args);
            });
          }
        };

        for (var i = 0; i < this.settings.columns.length; i++) {
          _loop3(i);
        }
      }
    },

    /**
    * Cache info on virtual scrolling for better performance.
    * @private
    */
    cacheVirtualStats: function cacheVirtualStats() {
      var containerHeight = this.element[0].offsetHeight;
      var scrollTop = this.bodyWrapperCenter[0].scrollTop;
      var headerHeight = this.settings.rowHeight === 'normal' || this.settings.rowHeight === 'large' ? 40 : this.settings.rowHeight === 'medium' ? 30 : 25;
      var bodyH = containerHeight - headerHeight;
      var rowH = this.settings.rowHeight === 'normal' || this.settings.rowHeight === 'large' ? 50 : this.settings.rowHeight === 'medium' ? 40 : 30;

      if (this.settings.rowHeight === 'extra-small') {
        headerHeight = 22;
        rowH = 27;
      }

      this.virtualRange = {
        rowHeight: rowH,
        top: Math.max(scrollTop - (this.settings.virtualRowBuffer - 1) * rowH, 0),
        bottom: scrollTop + bodyH + (this.settings.virtualRowBuffer - 1) * rowH,
        totalHeight: rowH * this.settings.dataset.length,
        bodyHeight: bodyH
      };
    },

    /**
    * Check if the row is in the visble scroll area + buffer
    * Just call renderRows() on events that change
    * @private
    * @param  {number} rowIndex Row index to check.
    * @returns {boolean} Current row visibility.
    */
    isRowVisible: function isRowVisible(rowIndex) {
      if (!this.settings.virtualized) {
        if (this.settings.paging && !this.settings.source && rowIndex && this.pagerAPI) {
          return (this.pagerAPI.activePage - 1) * this.settings.pagesize <= rowIndex && this.pagerAPI.activePage * this.settings.pagesize >= rowIndex;
        }

        return true;
      }

      if (rowIndex === 0) {
        this.cacheVirtualStats();
      } // determine if the row is in view


      var pos = rowIndex * this.virtualRange.rowHeight;

      if (pos >= this.virtualRange.top && pos < this.virtualRange.bottom) {
        return true;
      }

      return false;
    },

    /**
     * Set the heights on top or bottom based on scroll position
     * @private
     */
    setVirtualHeight: function setVirtualHeight() {
      if (!this.settings.virtualized || !this.virtualRange) {
        return;
      }

      var bottom = this.virtualRange.totalHeight - this.virtualRange.bottom;
      var vTop = this.virtualRange.top;
      this.topSpacer = this.tableBody.find('.datagrid-virtual-row-top');
      this.bottomSpacer = this.tableBody.find('.datagrid-virtual-row-bottom');

      if (vTop > 0 && !this.topSpacer.length) {
        this.topSpacer = $("<tr class=\"datagrid-virtual-row-top\" style=\"height: ".concat(vTop, "px\"><td colspan=\"").concat(this.visibleColumns().length, "\"></td></tr>"));
        this.tableBody.prepend(this.topSpacer);
      }

      if (vTop > 0 && this.topSpacer.length) {
        this.topSpacer.css('height', "".concat(vTop, "px"));
      }

      if (vTop === 0 && (this.topSpacer.length || this.virtualRange.topRow <= 1)) {
        this.topSpacer.remove();
      }

      if (bottom > 0 && !this.bottomSpacer.length) {
        this.bottomSpacer = $("<tr class=\"datagrid-virtual-row-bottom\" style=\"height: ".concat(bottom, "px\"><td colspan=\"").concat(this.visibleColumns().length, "\"></td></tr>"));
        this.tableBody.append(this.bottomSpacer);
      }

      if (bottom > 0 && this.bottomSpacer.length) {
        this.bottomSpacer.css('height', "".concat(bottom, "px"));
      }

      if (bottom <= 0 && (this.bottomSpacer.length || this.virtualRange.bottomRow >= this.settings.dataset.length)) {
        this.bottomSpacer.remove();
      }
    },

    /**
     * Set the alternate shading class.
     * @private
     */
    setAlternateRowShading: function setAlternateRowShading() {
      if (this.settings.alternateRowShading && this.settings.treeGrid) {
        $('tr[role="row"]:visible', this.tableBody).removeClass('alt-shading').filter(':odd').addClass('alt-shading');
      }
    },

    /**
     * The default cell formatters thats used when no formatter is provided.
     * @private
     * @param  {function} formatter The formatter function.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @param  {string} fieldValue The current field value.
     * @param  {object} columnDef The column settings.
     * @param  {object} rowData The current row data.
     * @param  {object} api The grid API reference.
     * @returns {void}
     */
    formatValue: function formatValue(formatter, row, cell, fieldValue, columnDef, rowData, api) {
      var formattedValue;
      api = api || this; // Use default formatter if undefined

      if (formatter === undefined) {
        formatter = this.defaultFormatter;
      }

      if (typeof formatter === 'string') {
        formattedValue = formatters[formatter](row, cell, fieldValue, columnDef, rowData, api);
        formattedValue = formattedValue.toString();
      } else {
        formattedValue = formatter(row, cell, fieldValue, columnDef, rowData, api).toString();
      }

      return formattedValue;
    },

    /**
     * Return the html markup for the row.
     * @private
     * @param  {object} rowData The data to use to render the row
     * @param  {number} dataRowIdx The row index.
     * @param  {number} actualIndex The actual data index
     * @param  {boolean} isGroup If true we are building a group row.
     * @param  {object} isFooter If true we are building a footer row.
     * @param  {string} actualIndexLineage Series of actualIndex values to reach a child actualIndex in a tree
     * @param  {boolean} skipChildren If true we dont append children.
     * @returns {string} The html used to construct the row.
     */
    rowHtml: function rowHtml(rowData, dataRowIdx, actualIndex, isGroup, isFooter, actualIndexLineage, skipChildren) {
      var isEven = false;
      var self = this;
      var isSummaryRow = this.settings.summaryRow && !isGroup && isFooter;
      var activePage = self.pagerAPI ? self.pagerAPI.activePage : 1;
      var containerHtml = {
        left: '',
        center: '',
        right: ''
      };
      var d = self.settings.treeDepth ? self.settings.treeDepth[dataRowIdx] : 0;
      var depth = null;
      var j = 0;
      var isHidden = false;
      var skipColumns; // Calculate all nested children

      var calculateChildren = function calculateChildren(ds) {
        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        count += ds.length;

        for (var i = 0, l = ds.length; i < l; i++) {
          if (ds[i].children) {
            count = calculateChildren(ds[i].children, count);
          }
        }

        return count;
      };

      if (!rowData) {
        return '';
      }

      var isRowDisabled = false; // Run a function that helps check if disabled

      if (self.settings.isRowDisabled && typeof self.settings.isRowDisabled === 'function') {
        var isDisabled = self.settings.isRowDisabled(actualIndex, rowData);

        if (isDisabled) {
          isRowDisabled = true;
        }
      } // Or allow the data to determine it


      if (rowData.isRowDisabled) {
        isRowDisabled = true;
      } // Default


      d = d ? d.depth : 0;
      depth = d; // Determine if the tree rows should be hidden or not

      if (self.settings.treeDepth && self.settings.treeDepth.length) {
        if (rowData._isFilteredOut) {
          isHidden = true;
        } else {
          var _nodeData$parents;

          var nodeData = self.settings.treeDepth[dataRowIdx];

          if (nodeData && nodeData.depth > 1 && (_nodeData$parents = nodeData.parents) !== null && _nodeData$parents !== void 0 && (_nodeData$parents == null ? void 0 : _nodeData$parents.length)) {
            for (var i = 0, l = nodeData.parents.length; i < l; i++) {
              var parentIdx = nodeData.parents[i];
              var parent = self.settings.treeDepth[parentIdx];

              if (parent.node && parent.node.expanded !== undefined && !parent.node.expanded) {
                isHidden = true;
                break;
              }
            }
          }
        }
      }

      if (this.settings.groupable && !isFooter) {
        var groupSettings = this.settings.groupable;
        isHidden = groupSettings.expanded === undefined ? false : !groupSettings.expanded;

        if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
          isHidden = !groupSettings.expanded(dataRowIdx, 0, null, null, rowData, this);
          this.isFooterHidden = isHidden;
        }
      } // Group Rows


      var visibleColumnsLeft = this.settings.frozenColumns.left.length;
      var visibleColumnsRight = this.settings.frozenColumns.right.length;
      var visibleColumnsCenter = this.visibleColumns().length - visibleColumnsLeft - visibleColumnsRight;

      if (this.settings.groupable && isGroup && !isFooter) {
        var groupRowHtml = formatters.GroupRow(dataRowIdx, 0, null, null, rowData, this);
        containerHtml.left = "<tr class=\"datagrid-rowgroup-header".concat(isHidden ? '' : ' is-expanded', "\" role=\"rowgroup\"><td role=\"gridcell\" colspan=\"").concat(visibleColumnsLeft, "\">").concat(groupRowHtml.left || '<span>&nbsp;</span>', "</td></tr>");
        containerHtml.center = "<tr class=\"datagrid-rowgroup-header".concat(isHidden ? '' : ' is-expanded', "\" role=\"rowgroup\"><td role=\"gridcell\" colspan=\"").concat(visibleColumnsCenter, "\">").concat(groupRowHtml.center || '<span>&nbsp;</span>', "</td></tr>");
        containerHtml.right = "<tr class=\"datagrid-rowgroup-header".concat(isHidden ? '' : ' is-expanded', "\" role=\"rowgroup\"><td role=\"gridcell\" colspan=\"").concat(visibleColumnsRight, "\">").concat(groupRowHtml.right || '<span>&nbsp;</span>', "</td></tr>");
        return containerHtml;
      }

      if (this.settings.groupable && isGroup && isFooter) {
        var groupFooterHtml = formatters.GroupFooterRow(dataRowIdx, 0, null, null, rowData, this);
        containerHtml.left = "<tr class=\"datagrid-row datagrid-rowgroup-footer".concat(this.isFooterHidden ? ' is-hidden' : '', "\" role=\"rowgroup\">").concat(groupFooterHtml.left || '<span>&nbsp;</span>', "</tr>");
        containerHtml.center = "<tr class=\"datagrid-row datagrid-rowgroup-footer".concat(this.isFooterHidden ? ' is-hidden' : '', "\" role=\"rowgroup\">").concat(groupFooterHtml.center || '<span>&nbsp;</span>', "</tr>");
        containerHtml.right = "<tr class=\"datagrid-row datagrid-rowgroup-footer".concat(this.isFooterHidden ? ' is-hidden' : '', "\" role=\"rowgroup\">").concat(groupFooterHtml.right || '<span>&nbsp;</span>', "</tr>");
        this.isFooterHidden = false;
        return containerHtml;
      }

      var ariaRowindex = dataRowIdx + 1 + (self.settings.source && !self.settings.indeterminate ? (activePage - 1) * self.settings.pagesize : 0);
      isEven = this.recordCount % 2 === 0;
      var isSelected = this.isRowSelected(rowData);
      var isActivated = rowData._rowactivated;
      var rowStatus = {
        class: '',
        svg: ''
      };

      if (rowData && rowData.rowStatus && (rowData.rowStatus.icon === 'new' ? self.settings.showNewRowIndicator : true)) {
        rowStatus.show = true;
        rowStatus.class = " rowstatus-row-".concat(rowData.rowStatus.icon);
        rowStatus.icon = rowData.rowStatus.icon === 'success' ? '#icon-check' : '#icon-exclamation';
        rowStatus.title = rowData.rowStatus.tooltip !== '' ? " title=\"".concat(rowData.rowStatus.tooltip, "\"") : '';
        rowStatus.svg = "<svg class=\"icon icon-rowstatus\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"".concat(rowStatus.title, "><use href=\"").concat(rowStatus.icon, "\"></use></svg>");
      } // Run a function that dynamically gets the rowHeight


      var dynamicRowHeight = '';

      if (this.settings.fixedRowHeight && typeof this.settings.fixedRowHeight === 'function') {
        dynamicRowHeight = " style=\"height: ".concat(this.settings.fixedRowHeight(this.recordCount, ariaRowindex, actualIndex, rowData), "\"px\" ");
      }

      if (this.settings.fixedRowHeight && typeof this.settings.fixedRowHeight === 'number') {
        dynamicRowHeight = " style=\"height: ".concat(this.settings.fixedRowHeight, "px\" ");
      }

      if (this.currentPageRows) {
        var args = {
          ariaRowindex: ariaRowindex,
          actualIndexLineage: actualIndexLineage,
          dataIndex: actualIndex,
          isFilteredOut: rowData._isFilteredOut
        };
        this.currentPageRows.push(args);
      }

      containerHtml.center = "<tr role=\"row\" aria-rowindex=\"".concat(ariaRowindex, "\"") + " data-index=\"".concat(actualIndex, "\"").concat(actualIndexLineage ? " data-lineage=\"".concat(actualIndexLineage, "\"") : '').concat(self.settings.treeGrid && rowData.children ? " aria-expanded=\"".concat(rowData.expanded ? 'true"' : 'false"') : '').concat(self.settings.treeGrid ? " aria-level=\"".concat(depth, "\"") : '').concat(isRowDisabled ? ' aria-disabled="true"' : '').concat(isSelected ? ' aria-selected="true"' : '', " class=\"datagrid-row").concat(rowStatus.class).concat(isHidden ? ' is-hidden' : '').concat(rowData._isFilteredOut ? ' is-filtered' : '').concat(isActivated ? ' is-rowactivated' : '').concat(isRowDisabled ? ' is-rowdisabled' : '').concat(isSelected ? this.settings.selectable === 'mixed' ? ' is-selected hide-selected-color' : ' is-selected' : '').concat(self.settings.alternateRowShading && !isEven ? ' alt-shading' : '').concat(isSummaryRow ? ' datagrid-summary-row' : '').concat(!self.settings.cellNavigation && self.settings.selectable !== false ? ' is-clickable' : '').concat(self.settings.treeGrid ? rowData.children ? ' datagrid-tree-parent' : depth > 1 ? ' datagrid-tree-child' : '' : '', "\"").concat(dynamicRowHeight, ">");
      containerHtml.left = containerHtml.center;
      containerHtml.right = containerHtml.center;

      for (j = 0; j < self.settings.columns.length; j++) {
        var _this$settings$attrib, _col$id3;

        var col = self.settings.columns[j];
        var container = this.getContainer(col.id);
        var cssClass = '';
        var defaultFormatter = col.summaryRowFormatter || col.formatter || self.defaultFormatter;
        var formatter = isSummaryRow ? defaultFormatter : col.formatter || self.defaultFormatter;
        var formatted = self.formatValue(formatter, dataRowIdx, j, self.fieldValue(rowData, self.settings.columns[j].field), self.settings.columns[j], rowData, self);

        if (formatted.indexOf('<span class="is-readonly">') === 0) {
          col.readonly = true;
        }

        if (formatted.indexOf('datagrid-checkbox') > -1 || formatted.indexOf('btn-actions') > -1) {
          cssClass += ' l-center-text';
        }

        if (formatted.indexOf('trigger') > -1) {
          cssClass += ' datagrid-trigger-cell';
        }

        if (formatted.indexOf('trigger') === -1 && col && col.editor) {
          var editorName = this.getEditorName(col.editor);

          if (['colorpicker', 'dropdown', 'time', 'lookup', 'date'].indexOf(editorName) >= 0) {
            cssClass += ' datagrid-trigger-cell datagrid-no-default-formatter';
          }
        }

        if (col.editor && this.settings.editable) {
          cssClass += ' has-editor';
        }

        if (col.expanded) {
          self.treeExpansionField = col.expanded;
        }

        if (col.align) {
          cssClass += " l-".concat(col.align, "-text");
        }

        if (col.textOverflow === 'ellipsis') {
          cssClass += ' text-ellipsis';
        }

        if (col.uppercase) {
          cssClass += ' uppercase-text';
        } // Add Column Css Classes
        // Add a readonly class if set on the column


        cssClass += col.readonly ? ' is-readonly' : '';
        cssClass += col.hidden ? ' is-hidden' : ''; // Run a function that helps check if editable

        if (col.isEditable && !col.readonly) {
          var fieldVal = self.fieldValue(rowData, self.settings.columns[j].field);
          var canEdit = col.isEditable(ariaRowindex - 1, j, fieldVal, col, rowData);

          if (!canEdit) {
            cssClass += ' is-readonly';
          }
        } // Run a function that helps check if readonly


        var ariaReadonly = col.id !== 'selectionCheckbox' && (col.readonly || col.editor === undefined) ? 'aria-readonly="true"' : '';

        if (col.isReadonly && !col.readonly && col.id !== 'selectionCheckbox') {
          var _fieldVal = self.fieldValue(rowData, self.settings.columns[j].field);

          var isReadonly = col.isReadonly(this.recordCount, j, _fieldVal, col, rowData);

          if (isReadonly) {
            cssClass += ' is-cell-readonly';
            ariaReadonly = 'aria-readonly="true"';
          }
        }

        var cellValue = self.fieldValue(rowData, self.settings.columns[j].field); // Run a function that dynamically adds a class

        if (col.cssClass && typeof col.cssClass === 'function') {
          cssClass += " ".concat(col.cssClass(this.recordCount, j, cellValue, col, rowData));
        }

        if (col.cssClass && typeof col.cssClass === 'string') {
          cssClass += " ".concat(col.cssClass);
        }

        cssClass += col.focusable ? ' is-focusable' : '';
        cssClass += formatter.name === 'Actions' ? ' has-btn-actions' : '';
        var rowspan = this.calculateRowspan(cellValue, dataRowIdx, col);

        if (rowspan === '') {
          continue;
        } // Run an optional function to calculate a colspan - the spanning is the next N columns given in the function


        var colspan = 0;

        if (skipColumns > 0 && !col.hidden) {
          var _this$settings, _this$settings$frozen;

          // From the previous run and a colspan is set then we are skipping columns
          skipColumns -= 1;
          cssClass += ' is-spanned-hidden'; // Hide or make some cells invisble which are spanned

          var leftColumns = (_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : (_this$settings$frozen = _this$settings == null ? void 0 : _this$settings.frozenColumns) === null || _this$settings$frozen === void 0 ? void 0 : _this$settings$frozen == null ? void 0 : _this$settings$frozen.left.length;

          if (leftColumns > 0 && j === leftColumns) {
            cssClass = cssClass.replace(' is-spanned-hidden', ' is-spanned-invisible');
            colspan = skipColumns + 1;

            if (colspan > 0 && this.visibleColumns().length - j === colspan) {
              cssClass += ' is-spanned-last';
            }
          }

          if (leftColumns > 0 && j < leftColumns) {
            cssClass = cssClass.replace(' is-spanned-hidden', ' is-spanned-last');
          }
        }

        if (col.colspan && typeof col.colspan === 'function' && !skipColumns) {
          var _fieldVal2 = self.fieldValue(rowData, self.settings.columns[j].field);

          colspan = col.colspan(ariaRowindex - 1, j, _fieldVal2, col, rowData, self); // Hide border on the first spanned cell

          if (colspan > 0) {
            var _this$settings2, _this$settings2$froze;

            skipColumns = colspan - 1;

            var _leftColumns = (_this$settings2 = this.settings) === null || _this$settings2 === void 0 ? void 0 : (_this$settings2$froze = _this$settings2 == null ? void 0 : _this$settings2.frozenColumns) === null || _this$settings2$froze === void 0 ? void 0 : _this$settings2$froze == null ? void 0 : _this$settings2$froze.left.length;

            if (_leftColumns > 0 && j < _leftColumns) {
              cssClass += ' is-spanned-last';
            }
          } // Hide border on the last frozen span column


          if (colspan > 0) {
            var _this$settings3, _this$settings3$froze;

            skipColumns = colspan - 1;

            var _leftColumns2 = (_this$settings3 = this.settings) === null || _this$settings3 === void 0 ? void 0 : (_this$settings3$froze = _this$settings3 == null ? void 0 : _this$settings3.frozenColumns) === null || _this$settings3$froze === void 0 ? void 0 : _this$settings3$froze == null ? void 0 : _this$settings3$froze.left.length;

            if (_leftColumns2 > 0 && j < _leftColumns2 && cssClass.indexOf('is-spanned-last') === -1) {
              cssClass += ' is-spanned-last';
            }
          } // Hide border on the last span if it spans the rest


          if (colspan > 0 && cssClass.indexOf('is-spanned-last') === -1 && this.visibleColumns().length - 1 === colspan) {
            cssClass += ' is-spanned-last';
          }
        } // Set rowStatus info


        if (j !== 0) {
          rowStatus.class = '';
          rowStatus.svg = '';
        }

        if (rowStatus.class !== '') {
          cssClass += ' rowstatus-cell';
        }

        if (self.isCellDirty(self.settings.groupable ? actualIndex : dataRowIdx, j)) {
          cssClass += ' is-dirty-cell';
        } // Trim extra spaces


        if (cssClass !== '') {
          cssClass = cssClass.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
        }

        var idProp = (_this$settings$attrib = this.settings.attributes) === null || _this$settings$attrib === void 0 ? void 0 : _this$settings$attrib == null ? void 0 : _this$settings$attrib.filter(function (a) {
          return a.name === 'id';
        });
        var ariaDescribedby = "aria-describedby=\"".concat((idProp === null || idProp === void 0 ? void 0 : idProp == null ? void 0 : idProp.length) === 1 ? "".concat(idProp[0].value, "-col-").concat((_col$id3 = col.id) === null || _col$id3 === void 0 ? void 0 : _col$id3 == null ? void 0 : _col$id3.toLowerCase()) : self.uniqueId("-header-".concat(j)), "\"");
        containerHtml[container] += "<td role=\"gridcell\" ".concat(ariaReadonly, " aria-colindex=\"").concat(j + 1, "\"") + " ".concat(ariaDescribedby).concat(isSelected ? ' aria-selected="true"' : '').concat(cssClass ? " class=\"".concat(cssClass, "\"") : '').concat(colspan ? " colspan=\"".concat(colspan, "\"") : '').concat(col.tooltip && typeof col.tooltip === 'string' ? " title=\"".concat(col.tooltip.replace('{{value}}', cellValue), "\"") : '').concat(self.settings.columnGroups ? "headers = \"".concat(self.uniqueId("-header-".concat(j)), " ").concat(self.getColumnGroup(j), "\"") : '').concat(rowspan || '', ">").concat(rowStatus.svg, "<div class=\"datagrid-cell-wrapper\">");

        if (col.contentVisible) {
          var canShow = col.contentVisible(dataRowIdx + 1, j, cellValue, col, rowData);

          if (!canShow) {
            formatted = '';
          }
        }

        if (self.settings.onPostRenderCell && col.component) {
          containerHtml[container] += '<div class="content"></div>';
          formatted = '';
        }

        containerHtml[container] += "".concat(formatted, "</div></td>");
      } // Set Up Spacer column


      if (this.settings.spacerColumn) {
        containerHtml.center += '<td class="datagrid-spacer-column"></td>';
      }

      containerHtml.left += '</tr>';
      containerHtml.center += '</tr>';
      containerHtml.right += '</tr>';

      if (self.settings.rowTemplate) {
        var tmpl = self.settings.rowTemplate;
        var item = rowData;
        var height = self.settings.rowTemplateHeight || 107;
        var renderedTmpl = '';

        if (Tmpl && item) {
          renderedTmpl = Tmpl.compile("{{#dataset}}".concat(tmpl, "{{/dataset}}"), {
            dataset: item
          });
        }

        if (this.hasLeftPane) {
          containerHtml.left += "<tr class=\"datagrid-expandable-row no-border\"><td colspan=\"".concat(visibleColumnsLeft, "\">\n          <div class=\"datagrid-row-detail\"><div style=\"height: ").concat(height, "px\"></div></div>\n          </td></tr>");
        }

        containerHtml.center += "<tr class=\"datagrid-expandable-row\"><td colspan=\"".concat(visibleColumnsCenter + (this.settings.spacerColumn ? 1 : 0), "\">\n        <div class=\"datagrid-row-detail\"><div class=\"datagrid-row-detail-padding\">").concat(renderedTmpl, "</div></div>\n        </td></tr>");

        if (this.hasRightPane) {
          containerHtml.right += "<tr class=\"datagrid-expandable-row no-border\"><td colspan=\"".concat(visibleColumnsRight, "\">\n          <div class=\"datagrid-row-detail\"><div style=\"height: ").concat(height, "px\"></div></div>\n          </td></tr>");
        }
      }

      if (self.settings.expandableRow) {
        if (this.hasLeftPane) {
          containerHtml.left += "<tr class=\"datagrid-expandable-row\"><td colspan=\"".concat(visibleColumnsLeft, "\">\n          <div class=\"datagrid-row-detail\"><div class=\"datagrid-row-detail-padding\"></div></div>\n          </td></tr>");
        }

        containerHtml.center += "<tr class=\"datagrid-expandable-row\"><td colspan=\"".concat(visibleColumnsCenter, "\">\n        <div class=\"datagrid-row-detail\"><div class=\"datagrid-row-detail-padding\"></div></div>\n        </td></tr>");

        if (this.hasRightPane) {
          containerHtml.right += "<tr class=\"datagrid-expandable-row no-border\"><td colspan=\"".concat(visibleColumnsRight, "\">\n          <div class=\"datagrid-row-detail\"><div class=\"datagrid-row-detail-padding\"></div></div>\n          </td></tr>");
        }
      } // Render Tree Children


      if (rowData.children && !skipChildren && !rowData._isFilteredOut) {
        for (var _i6 = 0, _l3 = rowData.children.length; _i6 < _l3; _i6++) {
          var lineage = actualIndexLineage ? "".concat(actualIndexLineage, ".").concat(actualIndex) : "".concat(actualIndex);
          this.recordCount++;
          var childRowHtml = self.rowHtml(rowData.children[_i6], this.recordCount, _i6, false, false, lineage);
          containerHtml.left += childRowHtml.left;
          containerHtml.center += childRowHtml.center;
          containerHtml.right += childRowHtml.right;
        }
      } else if (this.settings.treeGrid && !skipChildren && rowData._isFilteredOut) {
        if (rowData.children) {
          var count = calculateChildren(rowData.children);
          this.recordCount += count + (rowData._isFilteredOut && depth === 1 ? 1 : 0);
        } else if (depth === 1) {
          this.recordCount++;
        }
      }

      return containerHtml;
    },

    /**
     * Return the name of the editor.
     * @private
     * @param  {object} editor The editor to check
     * @returns {string} The editors name
     */
    getEditorName: function getEditorName(editor) {
      if (!editor) {
        return '';
      }

      var editorName = editor.name; // In IE functions do not have names

      if (!function f() {}.name) {
        var getFnName = function getFnName(fn) {
          return (fn.toString().match(/function (.+?)\(/) || [, ''])[1]; //eslint-disable-line
        };

        editorName = getFnName(editor);
      }

      return editorName ? editorName.toLowerCase() : '';
    },

    /**
     * This Function approximates the table auto widthing
     * Except use all column values and compare the text width of the header as max
     * @private
     * @param  {object} columnDef The column to check.
     * @returns {number} The text width.
     */
    calculateTextWidth: function calculateTextWidth(columnDef) {
      var title = columnDef.name || '';
      var max = 0;
      var maxWidth = 0;
      var padding = 0;
      var maxText = '';
      var hasButton = false;
      var self = this; // Get Data width

      if (columnDef.formatter === formatters.Colorpicker) {
        maxText = '';
      } else if (columnDef.formatter === formatters.Dropdown && columnDef.options && this.settings.columnSizing !== 'data') {
        var row = null;
        var val = ''; // Find Longest option label

        for (var i = 0; i < columnDef.options.length; i++) {
          if (columnDef.options[i].label.length > val.length) {
            val = columnDef.options[i].label;
          }
        }

        val = self.formatValue(columnDef.formatter, 0, 0, val, columnDef, row, self);
        val = xssUtils.stripHTML(val);
        maxText = val;
      } else {
        var len = 0;
        var arrayToTest = this.settings.dataset;

        if (this.settings.groupable) {
          arrayToTest = this.originalDataset;
        } // Get max cell value length for this column


        for (var _i7 = 0; _i7 < arrayToTest.length; _i7++) {
          var _val = this.fieldValue(arrayToTest[_i7], columnDef.field);

          var _row = arrayToTest[_i7]; // Get formatted value (without html) so we have accurate string that
          // will display for this cell

          _val = self.formatValue(columnDef.formatter, _i7, 0, _val, columnDef, _row, self);
          hasButton = _val.toString().indexOf('btn-secondary') > -1;
          _val = xssUtils.stripHTML(_val);
          len = _val.toString().length;

          if (this.settings.groupable && _row) {
            for (var k = 0; k < _row.length; k++) {
              var groupVal = this.fieldValue(_row[k], columnDef.field);
              groupVal = self.formatValue(columnDef.formatter, _i7, 0, groupVal, columnDef, _row, self);
              groupVal = xssUtils.stripHTML(groupVal);
              len = groupVal.toString().length;

              if (len > max) {
                max = len;
                maxText = groupVal;
              }
            }
          }

          if (len > max) {
            max = len;
            maxText = _val;
          }
        } // Get any Filter value


        if (this.filterExpr && this.filterExpr.length > 0) {
          var colFilter = $.grep(this.filterExpr, function (e) {
            return e.columnId === columnDef.id;
          });

          if (colFilter && colFilter.length === 1) {
            var _val2 = colFilter[0].value;
            len = _val2.toString().length;

            if (len > max) {
              max = len;
              maxText = _val2;
            }
          }
        }

        if (maxText === '' && (columnDef.formatter === formatters.Date || columnDef.formatter === formatters.Time)) {
          var _row2 = null;

          var _val3 = new Date(9999, 11, 31, 23, 59, 59, 999);

          _val3 = self.formatValue(columnDef.formatter, 0, 0, _val3, columnDef, _row2, self);
          _val3 = xssUtils.stripHTML(_val3);
          maxText = _val3;
        }
      }

      var hasTag = columnDef.formatter ? columnDef.formatter.toString().indexOf('<span class="tag') > -1 : false;
      var hasAlert = columnDef.formatter ? columnDef.formatter.toString().indexOf('datagrid-alert-icon') > -1 : false;
      var hasTrigger = columnDef.formatter === formatters.Date || columnDef.formatter === formatters.Time || columnDef.formatter === formatters.Lookup || columnDef.formatter === formatters.Colorpicker || columnDef.formatter === formatters.Dropdown;
      padding += this.getCellPadding() * 2;

      if (hasAlert) {
        padding += 20;
      }

      if (hasTag) {
        padding += 10;
      }

      if (hasButton) {
        padding += 50;
      }

      if (this.settings.editable && columnDef.editor === editors.Spinbox) {
        padding += 46;
      }

      if (this.settings.editable && (columnDef.formatter === formatters.Dropdown || columnDef.formatter === formatters.Lookup || columnDef.editor === editors.Time)) {
        padding += 10;
      }

      if (this.settings.editable && columnDef.editor === editors.Date) {
        padding += 5;
      }

      maxWidth = this.calculateTextRenderWidth(maxText) + padding;

      if (columnDef.formatter === formatters.Colorpicker) {
        maxWidth = 150;
      }

      var isSortable = columnDef.sortable === undefined ? true : columnDef.sortable;
      var headerPadding = isSortable ? this.getCellPadding() * 2 + 15 : this.getCellPadding() * 2;
      var minHeaderWidth = this.calculateTextRenderWidth(title, true) + headerPadding; // Calculate the width required for the filter field

      if (columnDef.filterType && this.settings.filterable) {
        if (minHeaderWidth < this.getCellPadding() * 2) {
          minHeaderWidth = this.getCellPadding() * 5 + maxWidth + 36;
        }

        if (columnDef.filterType !== 'checkbox') {
          if (maxText !== '') {
            if (minHeaderWidth < maxWidth + (this.getCellPadding() * 2 + 32) && maxText !== '') {
              minHeaderWidth = maxWidth + (this.getCellPadding() * 2 + 32);
            }
          } else if (minHeaderWidth < 100) {
            minHeaderWidth = 100;
          }
        }

        if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef == null ? void 0 : columnDef.textOverflow) === 'ellipsis' && (this.settings.rowHeight === 'small' || this.settings.rowHeight === 'extra-small')) {
          minHeaderWidth += 6;
        }
      }

      if (this.settings.columnSizing === 'data') {
        minHeaderWidth = 50 + this.getCellPadding() * 2 + (hasTrigger ? 25 : 0);
      }

      if (this.settings.columnSizing === 'header') {
        maxWidth = 0;
      }

      return Math.ceil(Math.max(maxWidth, minHeaderWidth));
    },

    /**
     * This Function calculates the width to render a text string
     * @private
     * @param  {string} maxText The text to render.
     * @param  {boolean} isHeader If its a header being calculated
     * @returns {number} the calculated text width in pixels.
     */
    calculateTextRenderWidth: function calculateTextRenderWidth(maxText, isHeader) {
      // if given, use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');

      if (!this.fontCached || !this.fontHeaderCached) {
        this.fontCached = theme.currentTheme.id && theme.currentTheme.id.indexOf('uplift') > -1 ? '400 16px arial' : '400 14px arial';
        this.fontHeaderCached = theme.currentTheme.id && theme.currentTheme.id.indexOf('uplift') > -1 ? '600 14px arial' : '700 12px arial';

        if (this.settings.rowHeight === 'extra-small') {
          this.fontCached = theme.currentTheme.id && theme.currentTheme.id.indexOf('uplift') > -1 ? '400 14px arial' : '400 12px arial';
          this.fontHeaderCached = theme.currentTheme.id && theme.currentTheme.id.indexOf('uplift') > -1 ? '600 14px arial' : '700 12px arial';
        }
      }

      context.font = this.fontCached;

      if (isHeader) {
        context.font = this.fontHeaderCached;
      }

      return context.measureText(maxText).width;
    },

    /**
     * Set the scroll class if the scrollbar is visible to effect the display.
     * @private
     */
    setScrollClass: function setScrollClass() {
      var height = parseInt(this.bodyWrapperCenter[0].offsetHeight, 10);
      var headerHeight = this.headerRow ? this.headerRow[0].offsetHeight : 0;
      var tableHeight = parseInt(this.tableBody[0].offsetHeight, 10);
      this.element.removeClass('has-vertical-scroll has-visible-last-row');

      if (tableHeight < height - headerHeight) {
        this.element.addClass('has-visible-last-row');
      }

      if (!this.hasLeftPane && !this.hasRightPane) {
        return;
      }

      var hasScrollBarV = parseInt(this.bodyWrapperCenter[0].scrollHeight, 10) > height + 2;
      var width = parseInt(this.bodyWrapperCenter[0].offsetWidth, 10);
      var hasScrollBarH = parseInt(this.bodyWrapperCenter[0].scrollWidth, 10) > width;

      if (hasScrollBarV) {
        this.element.addClass('has-vertical-scroll');
      }

      if (hasScrollBarH) {
        this.element.addClass('has-horizontal-scroll');
      }
    },

    /**
     * Clear internal header cache info.
     * @private
     * @returns {void}
     */
    clearCache: function clearCache() {
      this.totalWidths.left = 0;
      this.totalWidths.center = 0;
      this.totalWidths.right = 0;
      this.elemWidth = 0;
      this.stretchColumnWidth = 0;
      this.stretchColumnDiff = 0;
      this.stretchColumnIdx = -1;
      this.fontCached = null;
      this.fontHeaderCached = null;
      this.fixColumnIds();
    },

    /**
     * Fix duplicate column Id's
     * @private
     */
    fixColumnIds: function fixColumnIds() {
      for (var i = 0; i < this.settings.columns.length; i++) {
        var col = this.settings.columns[i]; // Check for duplicate ID's and adjust them.

        var colsById = this.columnById(col.id);

        if (colsById.length > 1) {
          for (var k = 1; k < colsById.length; k++) {
            colsById[k].id = "".concat(colsById[k].id, "-").concat(k);
          }
        }
      }
    },

    /**
     * Return the index of the stretch column
     * @returns {number} The index of the stretch column
     */
    getStretchColumnIdx: function getStretchColumnIdx() {
      var self = this;
      var stretchColumnIdx = self.stretchColumnIdx;

      if (stretchColumnIdx === -1 && self.settings.stretchColumn !== 'last') {
        self.headerNodes().each(function (i) {
          var col = $(this);

          if (col.attr('data-column-id') === self.settings.stretchColumn) {
            stretchColumnIdx = i;
          }
        });
      }

      return stretchColumnIdx;
    },

    /**
     * Return the width for a column (upfront with no rendering)
     * @private
     * @param  {[type]} col The column object to use
     * @param  {[type]} index The column index
     * @returns {void}
     */
    columnWidth: function columnWidth(col, index) {
      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) {
          // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }

        this.widthSpecified = false;
      }

      return this.calculateColumnWidth(col, index);
    },

    /**
     * Calculate the width for a column (upfront with no rendering)
     * Simulates https://www.w3.org/TR/CSS21/tables.html#width-layout
     * @private
     * @param {object} col The column object to use
     * @param {number} index The column index
     * @returns {void}
     */
    calculateColumnWidth: function calculateColumnWidth(col, index) {
      var _col$formatter, _col$formatter$toStri;

      var colPercWidth;
      var visibleColumns = this.visibleColumns(true);
      var lastColumn = index === this.visibleColumns().length - 1;
      var container = this.getContainer(col.id);

      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) {
          // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }

        this.widthSpecified = false;
        this.widthPixel = false;
      } // A column element with a value other than 'auto' for the 'width' property
      // sets the width for that column.


      if (col.width) {
        this.widthSpecified = true;
        this.widthPercent = false;
      }

      if (!this.widthPixel && col.width) {
        this.widthPixel = typeof col.width !== 'string';
      }

      var colWidth = col.width;

      if (typeof col.width === 'string' && col.width.indexOf('px') === -1) {
        this.widthPercent = true;
        colPercWidth = col.width.replace('%', '');
      }

      var textWidth = this.calculateTextWidth(col); // reasonable default on error

      if (!this.widthSpecified || !colWidth) {
        colWidth = Math.max(textWidth, colWidth || 0);
      } // Simulate Auto Width Algorithm


      if ((!this.widthSpecified || col.width === undefined) && this.settings.sizeColumnsEqually && ['selectionCheckbox', 'expander', 'drilldown', 'rowStatus', 'favorite'].indexOf(col.id) === -1) {
        var percentWidth = Math.round(this.elemWidth / visibleColumns.length);
        colWidth = percentWidth - (lastColumn ? 2 : 0); // borders causing scroll
        // Handle Columns where auto width is bigger than the percent width

        if (percentWidth < textWidth) {
          colWidth = textWidth;
        }
      } // Some Built in columns


      if (col.id === 'selectionCheckbox' || col.id === 'favorite') {
        colWidth = 43;
        col.width = colWidth;
      }

      if (col.id === 'favorite') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (!col.width && ((_col$formatter = col.formatter) === null || _col$formatter === void 0 ? void 0 : (_col$formatter$toStri = _col$formatter == null ? void 0 : _col$formatter.toString()) === null || _col$formatter$toStri === void 0 ? void 0 : _col$formatter$toStri == null ? void 0 : _col$formatter$toStri.indexOf('ProcessIndicator')) > -1) {
        colWidth = 155;
        col.width = colWidth;
      }

      if (col.id === 'expander') {
        colWidth = 55;
        col.width = colWidth;
      }

      if (col.id === 'rowStatus') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'rowReorder') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'drilldown') {
        colWidth = 62;
        col.width = colWidth;
      } // make sure that the column is atleast the minimum width


      if (col.minWidth && colWidth < col.minWidth) {
        colWidth = col.minWidth;
      } // make sure that the column is no more than the maximum width


      if (col.minWidth && colWidth > col.maxWidth) {
        colWidth = col.maxWidth;
      }

      this.totalWidths[container] += col.hidden ? 0 : colWidth;

      if (this.settings.stretchColumn !== 'last' && this.settings.stretchColumn !== null && this.settings.stretchColumn === col.id) {
        this.stretchColumnIdx = index;
        this.stretchColumnWidth = colWidth;
        return ' style="width: 99%"';
      } // For the last column stretch it if it doesnt fit the area


      if (lastColumn) {
        var diff = this.elemWidth - this.totalWidths[container];

        if (this.settings.stretchColumn !== 'last' && this.settings.stretchColumn !== null) {
          this.stretchColumnDiff = diff;
        }

        if (this.hasLeftPane) {
          this.tableLeft.css('width', this.totalWidths.left);
        }

        if (this.hasRightPane) {
          this.tableRight.css('width', this.totalWidths.right);
        }
      }

      if (!this.widthPercent && colWidth === undefined) {
        return '';
      }

      return " style=\"width: ".concat(this.widthPercent ? "".concat(colPercWidth, "%") : "".concat(colWidth, "px"), "\"");
    },

    /**
    * Figure out if the row spans and should skip rendiner.
    * @private
    * @param  {any} value Value to check
    * @param  {number} row Row index
    * @param  {number} col Column index
    * @returns {void}
    */
    calculateRowspan: function calculateRowspan(value, row, col) {
      var total = 0;
      var min = null;

      if (!col.rowspan) {
        return null;
      }

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (value === this.settings.dataset[i][col.field]) {
          total++;

          if (min === null) {
            min = i;
          }
        }
      }

      return row === min ? " rowspan =\"".concat(total, "\"") : '';
    },

    /**
    * Summary Row Totals use the aggregators
    * @private
    * @returns {number} the total widths
    */
    calculateTotals: function calculateTotals() {
      this.settings.totals = aggregators.aggregate(this.settings.dataset, this.settings.columns);
      return this.settings.totals;
    },

    /**
    * Set unit type (pixel or percent)
    * @private
    * @param  {any} v value to check
    * @returns {number} the total widths
    */
    setUnit: function setUnit(v) {
      return v + (/(px|%)/i.test("".concat(v)) ? '' : 'px');
    },

    /**
     * Setup tooltips on the cells.
     * @private
     * @param  {boolean} rowstatus true set tootip with row status
     * @param  {boolean} isForced true set tootip
     * @returns {void}
     */
    setupTooltips: function setupTooltips(rowstatus, isForced) {
      if (!rowstatus && !isForced && !this.settings.enableTooltips) {
        return;
      }

      var self = this;
      var defaultDelay = 400;
      var tooltipTimer; // Set selector

      var selector = {
        th: '.datagrid-header th',
        td: '.datagrid-wrapper tbody tr.datagrid-row td[role="gridcell"]:not(.rowstatus-cell)',
        rowstatus: '.datagrid-wrapper tbody tr.datagrid-row td[role="gridcell"] .icon-rowstatus'
      };

      if (this.settings.filterable) {
        selector.headerColumn = "".concat(selector.th, " .datagrid-column-wrapper");
        selector.headerFilter = "".concat(selector.th, " .datagrid-filter-wrapper .btn-menu");
        selector.header = "".concat(selector.headerColumn, ", ").concat(selector.headerFilter);
      } else {
        selector.header = selector.th;
      }

      selector.iconAlert = "".concat(selector.td, " .icon-alert");
      selector.iconSuccess = "".concat(selector.td, " .icon-success");
      selector.iconError = "".concat(selector.td, " .icon-error");
      selector.iconInfo = "".concat(selector.td, " .icon-info");
      selector.icons = "".concat(selector.iconAlert, ", ").concat(selector.iconSuccess, ", ").concat(selector.iconError, ", ").concat(selector.iconInfo); // Selector string

      if (rowstatus && this.settings.enableTooltips) {
        selector.str = "".concat(selector.header, ", ").concat(selector.td, ", ").concat(selector.icons, ", ").concat(selector.rowstatus);
      } else if (rowstatus) {
        selector.str = "".concat(selector.header, ", ").concat(selector.rowstatus);
      } else {
        selector.str = "".concat(selector.header, ", ").concat(selector.td, ", ").concat(selector.icons);
      } // Handle tooltip to show


      var handleShow = function handleShow(elem, delay) {
        delay = typeof delay === 'undefined' ? defaultDelay : delay;
        tooltipTimer = setTimeout(function () {
          var isHeaderColumn = DOM.hasClass(elem, 'datagrid-column-wrapper');
          var isHeaderFilter = DOM.hasClass(elem.parentNode, 'datagrid-filter-wrapper');
          var isPopup = isHeaderFilter ? elem.parentNode.querySelectorAll('.popupmenu.is-open').length > 0 : false;
          var tooltip = $(elem).data('gridtooltip') || self.cacheTooltip(elem);
          var containerEl = isHeaderColumn ? elem.parentNode : elem;
          var width = self.getOuterWidth(containerEl);

          if (tooltip && (tooltip.forced || tooltip.textwidth > width - 35) && !isPopup) {
            self.showTooltip(tooltip);
          }
        }, delay);
      }; // Handle tooltip to hide


      var handleHide = function handleHide(elem, delay) {
        delay = typeof delay === 'undefined' ? defaultDelay : delay;
        clearTimeout(tooltipTimer);
        setTimeout(function () {
          self.hideTooltip(); // Clear cache for header filter, so it can use always current selected

          if (DOM.hasClass(elem.parentNode, 'datagrid-filter-wrapper')) {
            self.removeTooltipData(elem);
          }
        }, delay);
      }; // Bind events


      this.element.off('mouseenter.gridtooltip focus.gridtooltip', selector.str).on('mouseenter.gridtooltip focus.gridtooltip', selector.str, function () {
        handleShow(this);
      }).off('mouseleave.gridtooltip click.gridtooltip blur.gridtooltip', selector.str).on('mouseleave.gridtooltip click.gridtooltip blur.gridtooltip', selector.str, function () {
        handleHide(this);
      }).off('longpress.gridtooltip', selector.str).on('longpress.gridtooltip', selector.str, function () {
        handleShow(this, 0);
      }).off('keydown.gridtooltip', selector.str).on('keydown.gridtooltip', selector.str, function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var handle = false;

        if (e.shiftKey && key === 112) {
          // Shift + F1
          handleShow(this, 0);
        } else if (key === 27) {
          // Escape
          handle = self.isGridtooltip();
          handleHide(this, 0);
        }

        if (handle) {
          e.preventDefault();
        }

        return !handle;
      });

      if (this.toolbar && this.toolbar.parent().find('.table-errors').length > 0) {
        this.toolbar.parent().find('.table-errors').off('mouseenter.tableerrortooltip', '.icon').on('mouseenter.tableerrortooltip', '.icon', function () {
          handleShow(this);
        }).off('mouseleave.tableerrortooltip click.tableerrortooltip', '.icon').on('mouseleave.tableerrortooltip click.tableerrortooltip', '.icon', function () {
          handleHide(this);
        }).off('longpress.tableerrortooltip', '.icon').on('longpress.tableerrortooltip', '.icon', function () {
          handleShow(this, 0);
        });
      }
    },

    /**
     * Get outerWidth for a given element.
     * @private
     * @param  {boolean} element to calculate the outerWidth
     * @returns {number} computed outerWidth
     */
    getOuterWidth: function getOuterWidth(element) {
      var style = getComputedStyle(element);
      var width = element.offsetWidth;
      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      return width;
    },

    /**
     * Get closest element of a given element by passing callback to
     * target by class, id, or tag name
     * Callback usage as:
     * const elem = this.element[0].querySelector(selectorString);
     * class: const closestEl = this.closest(elem, el => el.classList.contains('some-class'));
     * id: const closestEl = this.closest(elem, el => el.id === 'some-id');
     * tag: const closestEl = this.closest(elem, el => el.tagName.toLowerCase() === 'some-tag');
     * http://clubmate.fi/jquerys-closest-function-and-pure-javascript-alternatives/
     * @private
     * @param  {object} el The element to start from.
     * @param  {object} fn The callback function.
     * @returns {object} The closest element.
     */
    closest: function closest(el, fn) {
      return el && (fn(el) ? el : this.closest(el.parentNode, fn));
    },

    /**
     * Returns all header nodes (not the groups)
     * @private
     * @returns {array} Array with all header dom nodes
     */
    headerNodes: function headerNodes() {
      if (!this.headerRow) {
        return $();
      }

      return this.element.find('.datagrid-header tr:not(.datagrid-header-groups) th');
    },

    /**
     * Returns all colgroup nodes
     * @private
     * @returns {array} Array with all colgroups across all panes
     */
    colGroupNodes: function colGroupNodes() {
      if (!this.headerRow) {
        return $();
      }

      return this.element.find('colgroup col');
    },

    /**
     * Refresh one row in the grid
     * @param  {number} idx The row index to update.
     * @param  {object} data The data object.
     * @returns {void}
     */
    updateRow: function updateRow(idx, data) {
      var s = this.settings;
      var rowData = data;

      if (!rowData) {
        rowData = s.treeGrid ? s.treeDepth[idx].node : this.getActiveDataset()[idx];
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var col = this.settings.columns[j];

        if (col.hidden) {
          continue;
        }

        this.updateCellNode(idx, j, this.fieldValue(rowData, col.field), true);
      }

      this.settings.dataset[idx] = utils.extend(true, this.settings.dataset[idx], data);

      if (this.settings.rowReorder && this.tableBody.data('arrange')) {
        this.tableBody.data('arrange').updated();
      }
    },

    /**
     * Given a new column set update the rows and reload
     * @param  {array} columns The array with columns to use.
     * @param  {array} columnGroups The array with new columns groups to use.
     * @returns {void}
     */
    updateColumns: function updateColumns(columns, columnGroups) {
      if (columnGroups === undefined) {
        columnGroups = null;
      }

      var conditions = [];

      if (this.settings.filterable && this.filterRowRendered) {
        conditions = this.filterConditions();
      }

      this.settings.columns = columns;

      if (columnGroups) {
        this.settings.columnGroups = columnGroups;
      }

      this.rerender();
      /**
      * Fires after the entire grid is rendered.
      * @event columnchange
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {HTMLElement} args Additional arguments
      * @property {string} args.type Info on the type of column change action, can be 'updatecolumns', 'hidecolumn', 'showcolumn', 'resizecolumn'
      * @property {object} args.columns The columns object
      */

      this.element.trigger('columnchange', [{
        type: 'updatecolumns',
        columns: this.settings.columns
      }]);
      this.saveUserSettings();

      if (this.settings.filterable && this.filterRowRendered) {
        this.setFilterConditions(conditions);
      }
    },

    /**
     * Omit events and save to local storage for supported settings.
     * @returns {void}
     */
    saveUserSettings: function saveUserSettings() {
      /**
      * Fires after settings are changed in some way
      * @event settingschanged
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.rowHeight The current row height
      * @property {object} args.columns The columns object
      * @property {string} args.sortOrder The current sort column.
      * @property {number} args.pagesize The current page size
      * @property {boolean} args.showPageSizeSelector If the page size selector is shown.
      * @property {number} args.activePage The currently active page.
      * @property {string} args.filter Info on the type of column change action, can be 'updatecolumns'
      */
      this.element.trigger('settingschanged', [{
        rowHeight: this.settings.rowHeight,
        columns: this.settings.columns,
        sortOrder: this.sortColumn,
        pagesize: this.settings.pagesize,
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.pagerAPI ? this.pagerAPI.activePage : 1,
        filter: this.filterConditions()
      }]); // Save to Local Storage if the settings are set

      var savedSettings = this.settings.saveUserSettings;

      if ($.isEmptyObject(savedSettings) || !this.canUseLocalStorage()) {
        return;
      } // Save Columns


      if (savedSettings.columns) {
        localStorage[this.uniqueId('usersettings-columns')] = this.copyThenStringify(this.settings.columns);
      } // Save Row Height


      if (savedSettings.rowHeight) {
        localStorage[this.uniqueId('usersettings-row-height')] = this.settings.rowHeight;
      } // Save Sort Order


      if (savedSettings.sortOrder) {
        localStorage[this.uniqueId('usersettings-sort-order')] = JSON.stringify(this.sortColumn);
      } // Save Page Size


      if (savedSettings.pagesize) {
        localStorage[this.uniqueId('usersettings-pagesize')] = this.settings.pagesize;
      } // Save Show Page Size Selector


      if (savedSettings.showPageSizeSelector) {
        localStorage[this.uniqueId('usersettings-show-pagesize-selector')] = this.settings.showPageSizeSelector;
      } // Save Page Num


      if (savedSettings.activePage && this.pagerAPI) {
        localStorage[this.uniqueId('usersettings-active-page')] = this.pagerAPI.activePage;
      } // Filter Conditions


      if (savedSettings.filter) {
        localStorage[this.uniqueId('usersettings-filter')] = JSON.stringify(this.filterConditions());
      }
    },

    /**
     * Returns true if local storage may be used / is available
     * @private
     * @returns {boolean} If it can be used.
     */
    canUseLocalStorage: function canUseLocalStorage() {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }

      return false;
    },

    /**
     * Set the original column which may later be reloaded.
     * @private
     */
    setOriginalColumns: function setOriginalColumns() {
      this.originalColumns = utils.deepCopy(this.settings.columns);
    },

    /**
     * Parse a JSON array with columns and return the column object.
     * @private
     * @param  {string} columnStr The json representation of the column object.
     * @param  {string} excludeWidth If true do not reset the column width.
     * @returns {array} The array of columns.
     */
    columnsFromString: function columnsFromString(columnStr, excludeWidth) {
      if (!columnStr) {
        return [];
      }

      var self = this;
      var columns = JSON.parse(columnStr);

      if (!columns) {
        return [];
      } // Map back the missing functions/objects


      for (var i = 0; i < columns.length; i++) {
        var isHidden = void 0;
        var orgColumn = self.columnById(columns[i].id);
        var width = orgColumn.width;

        if (orgColumn) {
          isHidden = columns[i].hidden;
          $.extend(columns[i], orgColumn[0]);

          if (isHidden !== undefined) {
            columns[i].hidden = isHidden;
          } else {
            delete columns[i].hidden;
          }

          if (excludeWidth) {
            columns[i].width = width;
          }
        }
      }

      return columns;
    },

    /**
    * Restore the columns from a provided list or local storage
    * @param {array} cols - The columns list to restore, if you saved the settings manually.
    */
    restoreColumns: function restoreColumns(cols) {
      if (!this.settings.saveColumns || !this.canUseLocalStorage()) {
        return;
      }

      if (cols) {
        this.updateColumns(cols);
        return;
      } // Done on load as apposed to passed in


      var lsCols = localStorage[this.uniqueId('columns')];

      if (!cols && lsCols) {
        this.originalColumns = utils.deepCopy(this.settings.columns);
        this.settings.columns = this.columnsFromString(lsCols);
      }
    },

    /**
     * Restore the user settings from local Storage or as passed in.
     * @param  {object} settings The object containing the settings to use.
     * @returns {void}
     */
    restoreUserSettings: function restoreUserSettings(settings) {
      var options = this.settings.saveUserSettings;

      if (!settings && ($.isEmptyObject(options) || !this.canUseLocalStorage())) {
        return;
      } // Restore The data thats passed in


      if (settings) {
        if (settings.columns) {
          this.updateColumns(settings.columns);
        }

        if (settings.rowHeight) {
          this.rowHeight(settings.rowHeight);
        }

        if (settings.sortOrder) {
          this.setSortColumn(settings.sortOrder.sortId, settings.sortOrder.sortAsc);
        }

        if (settings.pagesize) {
          this.settings.pagesize = parseInt(settings.pagesize, 10);
          this.pagerAPI.settings.pagesize = parseInt(settings.pagesize, 10);

          if (!settings.activePage) {
            this.pagerAPI.setActivePage(1, true);
          }
        }

        if (settings.showPageSizeSelector) {
          this.settings.showPageSizeSelector = settings.showPageSizeSelector;
          this.pagerAPI.showPageSizeSelector(settings.showPageSizeSelector);
        }

        if (settings.filter) {
          this.applyFilter(settings.filter, 'restore');
        }

        if (settings.activePage) {
          var savedActivePage = parseInt(settings.activePage, 10);
          this.pagerAPI.setActivePage(savedActivePage, true);
          this.restoreActivePage = true;
        }

        return;
      } // Restore Column Width and Order


      if (options.columns) {
        var savedColumns = localStorage[this.uniqueId('usersettings-columns')];

        if (savedColumns) {
          this.settings.columns = this.columnsFromString(savedColumns);
        }
      } // Restore Row Height


      if (options.rowHeight) {
        var savedRowHeight = localStorage[this.uniqueId('usersettings-row-height')];

        if (savedRowHeight) {
          this.settings.rowHeight = savedRowHeight;
        }
      } // Restore Sort Order


      if (options.sortOrder) {
        var savedSortOrder = localStorage[this.uniqueId('usersettings-sort-order')];

        if (savedSortOrder) {
          this.sortColumn = JSON.parse(savedSortOrder);
          this.restoreSortOrder = true;
        }
      } // Restore Page Size


      if (options.pagesize) {
        var savedPagesize = localStorage[this.uniqueId('usersettings-pagesize')];

        if (savedPagesize) {
          this.settings.pagesize = parseInt(savedPagesize, 10);
        }
      } // Restore Show Page Size Selector


      if (options.showPageSizeSelector) {
        var savedShowPageSizeSelector = localStorage[this.uniqueId('usersettings-show-pagesize-selector')];
        savedShowPageSizeSelector = savedShowPageSizeSelector.toString().toLowerCase() === 'true';

        if (savedShowPageSizeSelector) {
          this.settings.showPageSizeSelector = savedShowPageSizeSelector;
        }
      } // Restore Active Page


      if (options.activePage) {
        var _savedActivePage = localStorage[this.uniqueId('usersettings-active-page')];

        if (_savedActivePage) {
          this.savedActivePage = parseInt(_savedActivePage, 10);
          this.restoreActivePage = true;
        }
      }

      if (options.filter) {
        var savedFilter = localStorage[this.uniqueId('usersettings-filter')];

        if (savedFilter) {
          this.savedFilter = JSON.parse(savedFilter);
          this.restoreFilter = true;
        }
      }
    },

    /**
     * Copy the object and remove some uneeded properties from the object
     * @private
     * @param  {object} columns The column set to stringify.
     * @returns {string} The JSON object as a string
     */
    copyThenStringify: function copyThenStringify(columns) {
      if (!columns) {
        return JSON.stringify(columns);
      }

      var clone = columns.map(function (col) {
        var newCol = utils.extend({}, col);

        if (newCol.editorOptions) {
          delete newCol.editorOptions;
        }

        return newCol;
      });
      return JSON.stringify(clone);
    },

    /**
    * Reset Columns to defaults (used on restore menu item)
    */
    resetColumns: function resetColumns() {
      if (this.canUseLocalStorage()) {
        localStorage.removeItem(this.uniqueId('columns'));
      }

      if (this.originalColumns) {
        var originalColumns = utils.deepCopy(this.originalColumns);
        var columnGroups = this.settings.columnGroups && this.originalColGroups ? this.originalColGroups : null;
        this.updateColumns(originalColumns, columnGroups);
      }

      this.clearFilter();
    },

    /**
    * Hide a column.
    * @param {string} id The id of the column to hide.
    */
    hideColumn: function hideColumn(id) {
      var _this$settings$column, _this$settings4, _this$settings4$froze;

      var idx = this.columnIdxById(id);

      if (idx === -1 || (_this$settings$column = this.settings.columns[idx]) !== null && _this$settings$column !== void 0 && (_this$settings$column == null ? void 0 : _this$settings$column.hidden)) {
        return;
      }

      this.settings.columns[idx].hidden = true;
      this.headerNodes().eq(idx).addClass('is-hidden');
      this.colGroupNodes().eq(idx).addClass('is-hidden');
      var frozenLeft = ((_this$settings4 = this.settings) === null || _this$settings4 === void 0 ? void 0 : (_this$settings4$froze = _this$settings4 == null ? void 0 : _this$settings4.frozenColumns) === null || _this$settings4$froze === void 0 ? void 0 : _this$settings4$froze == null ? void 0 : _this$settings4$froze.left.length) || 0;
      this.tableBody.find("> tr > td:nth-child(".concat(idx - frozenLeft + 1, ")")).addClass('is-hidden');
      this.bodyColGroup.find('col').eq(idx - frozenLeft).addClass('is-hidden'); // Shrink or remove colgroups

      this.updateColumnGroup(idx, false); // Handle colSpans if present on the column

      if (this.hasColSpans) {
        var colSpan = this.element.find('.datagrid-header th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan -= 1;

          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find("> tr > td:nth-child(".concat(idx + 1, ")")).addClass('is-hidden');
          }
        }
      } // Handle expandable rows


      if (this.settings.rowTemplate || this.settings.expandableRow) {
        this.syncExpandableRowColspan();
      }

      this.element.trigger('columnchange', [{
        type: 'hidecolumn',
        index: idx,
        columns: this.settings.columns
      }]);
      this.saveUserSettings();
    },

    /**
    * Sync the colspan on the expandable row. (When column count changes)
    * @private
    */
    syncExpandableRowColspan: function syncExpandableRowColspan() {
      var visibleColumnCount = this.visibleColumns().length;
      this.tableBody.find('.datagrid-expandable-row > td').attr('colspan', visibleColumnCount);
    },

    /**
    * Show a hidden column.
    * @param {string} id The id of the column to show.
    */
    showColumn: function showColumn(id) {
      var _this$settings5, _this$settings5$froze;

      var idx = this.columnIdxById(id);

      if (idx === -1 || !this.settings.columns[idx].hidden) {
        return;
      }

      this.settings.columns[idx].hidden = false;
      this.headerNodes().eq(idx).removeClass('is-hidden');
      this.colGroupNodes().eq(idx).removeClass('is-hidden');
      var frozenLeft = ((_this$settings5 = this.settings) === null || _this$settings5 === void 0 ? void 0 : (_this$settings5$froze = _this$settings5 == null ? void 0 : _this$settings5.frozenColumns) === null || _this$settings5$froze === void 0 ? void 0 : _this$settings5$froze == null ? void 0 : _this$settings5$froze.left.length) || 0;
      this.tableBody.find("> tr > td:nth-child(".concat(idx - frozenLeft + 1, ")")).removeClass('is-hidden');
      this.bodyColGroup.find('col').eq(idx - frozenLeft).removeClass('is-hidden'); // Shrink or add colgroups

      this.updateColumnGroup(idx, true); // Handle colSpans if present on the column

      if (this.hasColSpans) {
        var colSpan = this.element.find('.datagrid-header th').eq(idx).attr('colspan');

        if (colSpan && colSpan > 0) {
          colSpan -= 1;

          for (var i = 0; i < colSpan; i++) {
            idx += colSpan;
            this.tableBody.find("> tr > td:nth-child(".concat(idx + 1, ")")).removeClass('is-hidden');
          }
        }
      } // Handle expandable rows


      if (this.settings.rowTemplate || this.settings.expandableRow) {
        this.syncExpandableRowColspan();
      }

      this.element.trigger('columnchange', [{
        type: 'showcolumn',
        index: idx,
        columns: this.settings.columns
      }]);
      this.saveUserSettings();
    },

    /**
    * Export the grid contents to csv
    * @param {string} fileName The desired export filename in the download.
    * @param {string} customDs An optional customized version of the data to use.
    * @param {string} separator (optional) If user's machine is configured for a locale with alternate default separator.
    */
    exportToCsv: function exportToCsv(fileName, customDs, separator) {
      excel.exportToCsv(fileName, customDs, separator, this);
    },

    /**
    * Export the grid contents to xls format. This may give a warning when opening the file.
    * exportToCsv may be prefered.
    * Consider Deprecated use excel.exportToExcel
    * @param {string} fileName The desired export filename in the download.
    * @param {string} worksheetName A name to give the excel worksheet tab.
    * @param {string} customDs An optional customized version of the data to use.
    */
    exportToExcel: function exportToExcel(fileName, worksheetName, customDs) {
      excel.exportToExcel(fileName, worksheetName, customDs, this);
    },
    copyToDataSet: function copyToDataSet(pastedValue, rowCount, colIndex, dataSet) {
      excel.copyToDataSet(pastedValue, rowCount, colIndex, dataSet, this);
    },

    /**
    * Open the personalization dialog.
    * @private
    */
    personalizeColumns: function personalizeColumns() {
      var _this6 = this;

      var self = this;
      var markup = "<div class=\"listview-search alternate-bg\"><label class=\"audible\" for=\"gridfilter\">Search</label><input class=\"searchfield\" placeholder=\"".concat(Locale.translate('SearchColumnName'), "\" name=\"searchfield\" id=\"gridfilter\"></div>");
      markup += '<div class="listview alternate-bg" id="search-listview"><ul></ul></div>';
      $('body').modal({
        title: Locale.translate('PersonalizeColumns'),
        content: markup,
        cssClass: 'full-width datagrid-columns-dialog',
        buttons: [{
          text: Locale.translate('Close'),
          click: function click(e, modal) {
            modal.close();
            $('body').off('beforeopen.datagrid');
          }
        }]
      }).off('beforeopen.datagrid').on('beforeopen.datagrid', function (e, modal) {
        if (!modal) {
          return;
        }

        self.isColumnsChanged = false;
        modal.element.find('.searchfield').searchfield({
          clearable: true
        });
        modal.element.find('.listview').listview({
          source: _this6.settings.columns,
          template: "\n            <ul>\n            {{#dataset}}\n              {{#name}}\n              <li>\n                <a href=\"#\" target=\"_self\" tabindex=\"-1\">\n                  <label class=\"inline\">\n                    <input tabindex=\"-1\" type=\"checkbox\" class=\"checkbox\" {{^hideable}}disabled{{/hideable}} {{^hidden}}checked{{/hidden}} data-column-id=\"{{id}}\"/>\n                    <span class=\"label-text\">{{name}}</span>\n                  </label>\n                </a>\n              </li>\n              {{/name}}\n            {{/dataset}}\n            </ul>",
          searchable: true,
          selectOnFocus: false,
          listFilterSettings: {
            filterMode: 'contains',
            searchableTextCallback: function searchableTextCallback(item) {
              return item.name || item.id;
            }
          }
        }).off('selected.datagrid').on('selected.datagrid', function (selectedEvent, args) {
          var chk = args.elem.find('.checkbox');
          var id = chk.attr('data-column-id');
          var isChecked = chk.prop('checked');
          args.elem.removeClass('is-selected hide-selected-color');

          if (chk.is(':disabled')) {
            return;
          }

          self.isColumnsChanged = true; // Set listview dataset node state, to be in sync after filtering

          var lv = {
            node: {},
            api: $(this).data('listview')
          };

          if (lv.api) {
            var idx = self.columnIdxById(id);

            if (idx !== -1 && lv.api.settings.dataset[idx]) {
              lv.node = lv.api.settings.dataset[idx];
            }
          }

          if (!isChecked) {
            self.showColumn(id);
            chk.prop('checked', true);
            lv.node.hidden = false;
          } else {
            self.hideColumn(id);
            chk.prop('checked', false);
            lv.node.hidden = true;
          }

          if (self.settings.groupable) {
            self.rerender();
          }
        });
        modal.element.on('close.datagrid', function () {
          self.isColumnsChanged = false;
        });
        modal.element.on('keydown.datagrid', function (event) {
          // Escape Button Code. Make sure to close the modal correctly.
          if (event.keyCode === 27) {
            modal.close();
            $('body').off('beforeopen.datagrid');
          }
        });
      });
    },

    /**
    * Explicitly Set the width of a column
    * @private
    * @param {string} id Specifies if the column info is provide by id or as a node reference.
    * @param {number} width The width of the column
    * @param {boolean} set If true the width will actively be set, else it was set during resize.
    */
    setColumnWidth: function setColumnWidth(id, width, set) {
      var self = this;
      var percent = parseFloat(width);
      var columnSettings = this.columnById(id)[0];
      var idx = -1;

      if (!percent || !id) {
        return;
      }

      if (typeof id === 'string') {
        self.headerNodes().each(function (i) {
          var col = $(this);

          if (col.attr('data-column-id') === id) {
            idx = i;
          }
        });
      } // calculate percentage


      if (typeof width !== 'number') {
        width = percent / 100 * self.element.width();
      } // Prevent Sub Pixel Thrashing


      if (Math.abs(width - columnSettings.width) < 2) {
        return;
      } // Handle Col Span - as the width is calculated on the total


      if (typeof columnSettings.colspan === 'number') {
        width /= columnSettings.colspan;
      } // Save the column back in settings for later


      if (columnSettings) {
        columnSettings.width = width;
      }

      if (set) {
        var currentCol = this.bodyColGroup.find('col').eq(idx)[0];
        currentCol.style.width = "".concat(width, "px");
      }

      this.element.trigger('columnchange', [{
        type: 'resizecolumn',
        index: idx,
        columns: this.settings.columns
      }]);
      this.saveUserSettings();
    },

    /**
     * Check if given column header should be able to set active ellipsis
     * @private
     * @param {string} column to check ellipsis
     * @returns {boolean} true if should be able to set ellipsis
     */
    isEllipsisActiveHeader: function isEllipsisActiveHeader(column) {
      column = column || {};
      var isSortable = column.sortable === undefined ? true : column.sortable;
      return isSortable && column.textOverflow === 'ellipsis';
    },

    /**
     * Set active ellipsis on all columns header
     * @private
     * @returns {void}
     */
    activeEllipsisHeaderAll: function activeEllipsisHeaderAll() {
      for (var i = 0, l = this.settings.columns.length; i < l; i++) {
        var id = this.settings.columns[i].id;
        var column = this.columnById(id)[0];

        if (this.isEllipsisActiveHeader(column)) {
          var columnEl = this.element[0].querySelector(".datagrid-header th[data-column-id=\"".concat(id, "\"]"));
          this.activeEllipsisHeader(columnEl);
        }
      }
    },

    /**
     * Set active ellipsis on given column header
     * @private
     * @param {string} columnEl to set ellipsis active
     * @returns {void}
     */
    activeEllipsisHeader: function activeEllipsisHeader(columnEl) {
      if (columnEl) {
        var textEl = columnEl.querySelector('.datagrid-column-wrapper .datagrid-header-text');
        var isEllipsisActive = columnEl.scrollWidth < textEl.scrollWidth + 65; // 65:sort-icons

        columnEl.classList[isEllipsisActive ? 'add' : 'remove']('is-ellipsis-active');
      }
    },

    /**
    * Generate the ui handles used to resize columns.
    * @private
    */
    createResizeHandle: function createResizeHandle() {
      var _this7 = this;

      var self = this;

      if (this.resizeHandle) {
        return;
      }

      this.resizeHandle = $('<div class="resize-handle" aria-hidden="true"></div>');

      if (this.settings.columnGroups) {
        this.resizeHandle[0].style.height = '80px';
      }

      if (this.settings.filterable) {
        this.resizeHandle[0].style.height = '62px';
      }

      this.element.find('table').before(this.resizeHandle);
      var column;
      var columnId;
      var widthToSet;
      var nextWidthToSet;
      var nextColumnId;
      var usingShiftKey = false;
      this.resizeHandle.drag({
        axis: 'x'
      }).on('dragstart.datagrid', function () {
        if (!self.currentHeader) {
          return;
        }

        self.dragging = true;
        usingShiftKey = false;
        columnId = self.currentHeader.attr('data-column-id');
        column = self.columnById(columnId)[0];

        if (self.isEllipsisActiveHeader(column)) {
          self.currentHeader[0].classList.add('is-ellipsis-active');
        }
      }).on('drag.datagrid', function (e, ui) {
        if (!self.currentHeader || !column) {
          return;
        } // Setup enforcement for column or default min and max widths


        var minWidth = column.minWidth || 12;
        var maxWidth = column.maxWidth || 2000;
        var node = self.currentHeader;
        var idx = node.index();
        var isLeftPane = self.getContainer(node.attr('data-column-id')) === 'left';
        _this7.dragging = true;
        var left = ui.left + 5;

        var currentCol = _this7.bodyColGroup.find('col').eq(idx)[0];

        if (isLeftPane) {
          currentCol = _this7.bodyColGroupLeft.find('col').eq(idx)[0];
        }

        var currentColWidth = parseInt(self.currentHeader.width(), 10);
        var cssWidth = parseInt(currentCol.style.width || currentColWidth, 10); // Convert from percentage

        if (currentCol.style.width.indexOf('%') > -1) {
          cssWidth = currentColWidth;
        }

        var offsetParentLeft = parseFloat(self.currentHeader.offsetParent().offset().left);
        var offsetLeft = parseFloat(self.currentHeader.offset().left);
        var leftOffset = idx === 0 ? 0 : offsetLeft - offsetParentLeft - 2;

        if (self.hasLeftPane && !isLeftPane && idx === 0) {
          leftOffset = offsetLeft - offsetParentLeft - 2;
        }

        var diff = currentColWidth - (left - leftOffset); // Enforce Column or Default min and max widths

        widthToSet = cssWidth - diff;

        if (widthToSet < minWidth || widthToSet > maxWidth) {
          self.resizeHandle.css('cursor', 'inherit');
          return;
        }

        if (widthToSet === cssWidth) {
          return;
        }

        currentCol.style.width = "".concat(widthToSet, "px");
        var inRange = idx === _this7.settings.frozenColumns.left.length - 1 || idx <= _this7.settings.frozenColumns.left.length - 1 && diff > 0;

        if (inRange && _this7.getContainer(columnId) === 'left') {
          _this7.totalWidths.left += diff < 0 ? Math.abs(diff) : -diff;

          _this7.tableLeft.css('width', _this7.totalWidths.left);
        }

        if (keyboard.pressedKeys.get('Shift')) {
          usingShiftKey = true;
        }

        if (_this7.settings.resizeMode === 'fit' && !usingShiftKey || _this7.settings.resizeMode === 'flex' && usingShiftKey) {
          var nextIdx = Locale.isRTL() ? idx + 1 : idx - 1;
          var nextColSettings = self.settings.columns[nextIdx];

          if (!nextColSettings) {
            return;
          }

          var nextMinWidth = nextColSettings.minWidth || 12;
          var nextMaxWidth = nextColSettings.maxWidth || 1000;
          var nextColumn = Locale.isRTL() ? DOM.getPreviousSibling(self.currentHeader, ':not(.is-hidden)') : DOM.getNextSibling(self.currentHeader, ':not(.is-hidden)');
          nextColumnId = nextColumn.getAttribute('data-column-id');
          var nextCol = Locale.isRTL() ? DOM.getPreviousSibling(currentCol, ':not(.is-hidden)') : DOM.getNextSibling(currentCol, ':not(.is-hidden)');
          var nextColWidth = parseInt(nextColumn.offsetWidth, 10);
          var nextCssWidth = parseInt(nextCol.style.width || nextColWidth, 10); // Convert from percentage

          if (nextCol.style.width.indexOf('%') > -1) {
            nextCssWidth = nextColWidth;
          }

          nextWidthToSet = nextCssWidth + diff;

          if (nextWidthToSet < nextMinWidth || nextWidthToSet > nextMaxWidth) {
            self.resizeHandle.css('cursor', 'inherit');
            return;
          }

          if (nextWidthToSet === nextCssWidth || !nextCol) {
            return;
          }

          nextCol.style.width = "".concat(nextWidthToSet, "px");
        }
      }).on('dragend.datagrid', function () {
        _this7.dragging = false;

        if (self.isEllipsisActiveHeader(column)) {
          self.activeEllipsisHeader(self.currentHeader[0]);
        }

        self.setColumnWidth(columnId, widthToSet);

        if (nextColumnId && (_this7.settings.resizeMode === 'fit' && !usingShiftKey || _this7.settings.resizeMode === 'flex' && usingShiftKey)) {
          self.setColumnWidth(nextColumnId, nextWidthToSet);
        }
      });
    },

    /**
    * Show Summary and any other count info
    * @private
    * @param {boolean} totals The total to display on the UI.
    */
    displayCounts: function displayCounts(totals) {
      var _this$pagerAPI, _this$pagerAPI$state;

      var self = this;
      var count = self.tableBody.find('tr:visible').length;
      var groupCount = 0;
      var groupCountText = '';
      var selectedRowIdx = [];
      var isClientSide = self.settings.paging && !self.settings.source;

      var formatInteger = function formatInteger(v) {
        return Locale.formatNumber(v, {
          style: 'integer'
        });
      };

      if (isClientSide || !totals) {
        this.recordCount = self.settings.dataset.length;
        count = self.settings.dataset.length;
      }

      if (this.settings.treeGrid && isClientSide || !totals) {
        this.filteredCount = self.settings.dataset.filter(function (item) {
          return item._isFilteredOut;
        }).length;
        count = self.settings.dataset.length;
        this.recordCount = self.settings.dataset.filter(function (item) {
          return !item._isFilteredOut;
        }).length;
      }

      if (self.settings.groupable) {
        groupCount = count;
        count = self.originalDataset.length;
        groupCountText = "({0} ".concat(Locale.translate(groupCount === 1 ? 'Group' : 'Groups'), ")");
        groupCountText = groupCountText.replace('{0}', formatInteger(groupCount));
      } // Update Selected


      if (self.contextualToolbar && self.contextualToolbar.length) {
        self._selectedRows.forEach(function (i) {
          selectedRowIdx.push(i.idx);
          var selectedCount = selectedRowIdx.filter(function (a, b) {
            return selectedRowIdx.indexOf(a) === b;
          });
          self.contextualToolbar.find('.selection-count').text("".concat(selectedCount.length, " ").concat(Locale.translate('Selected')));
        });

        if (self.settings.allowSelectAcrossPages) {
          self.contextualToolbar.find('.selection-count').text("".concat(self._selectedRows.length, " ").concat(Locale.translate('Selected')));
        }
      }

      if (totals && totals !== -1) {
        count = totals;
      }

      if (totals === undefined && this.settings.source) {
        count = self.settings.dataset.length;
      }

      if (totals === undefined && this.settings.source && (_this$pagerAPI = this.pagerAPI) !== null && _this$pagerAPI !== void 0 && (_this$pagerAPI$state = _this$pagerAPI == null ? void 0 : _this$pagerAPI.state) !== null && _this$pagerAPI$state !== void 0 && (_this$pagerAPI$state == null ? void 0 : _this$pagerAPI$state.total)) {
        var _this$pagerAPI2, _this$pagerAPI2$state;

        count = (_this$pagerAPI2 = this.pagerAPI) === null || _this$pagerAPI2 === void 0 ? void 0 : (_this$pagerAPI2$state = _this$pagerAPI2 == null ? void 0 : _this$pagerAPI2.state) === null || _this$pagerAPI2$state === void 0 ? void 0 : _this$pagerAPI2$state == null ? void 0 : _this$pagerAPI2$state.total;
      }

      var countText;

      if (self.settings.showFilterTotal && self.filteredCount > 0) {
        countText = "(".concat(Locale.translate(count === 1 ? 'ResultOf' : 'ResultsOf'), ")");
        countText = countText.replace('{0}', formatInteger(count - self.filteredCount));
        countText = countText.replace('{1}', formatInteger(count));
      } else {
        var translation = Locale.translate(count === 1 ? 'Result' : 'Results');

        if (translation.indexOf('{0}') === -1) {
          countText = "({0} ".concat(translation, ")");
        } else {
          countText = translation;
        }

        countText = countText.replace('{0}', formatInteger(count));
      }

      if (self.settings.resultsText) {
        if (typeof self.settings.resultsText === 'function') {
          if (self.grandTotal) {
            countText = self.settings.resultsText(self, self.grandTotal, count === self.grandTotal ? 0 : count);
          } else {
            var filteredCount = self.filteredCount === 0 ? 0 : count - self.filteredCount;
            countText = self.settings.resultsText(self, count, filteredCount);
          }
        } else {
          countText = self.settings.resultsText;
        }
      }

      if (self.toolbar) {
        DOM.html(self.toolbar.find('.datagrid-result-count'), countText, '<span>');
        DOM.html(self.toolbar.find('.datagrid-group-count'), groupCountText, '<span>');
        self.toolbar[0].setAttribute('aria-label', self.toolbar.find('.title').text());
        self.toolbar.find('.datagrid-row-count').text(count); // Append ID's

        utils.addAttributes(self.toolbar.find('.title'), this, this.settings.attributes, 'title');
        utils.addAttributes(self.toolbar.find('.btn-actions'), this, this.settings.attributes, 'actions');
        var search = self.toolbar.find('#gridfilter');
        utils.addAttributes(search, this, this.settings.attributes, 'search');
        search.prev('label').attr('for', search.attr('id'));
      }

      DOM.html(self.element.closest('.modal').find('.datagrid-result-count'), countText, '<span>');
      this.lastCount = count;
      this.checkEmptyMessage();
    },

    /**
    * Set the content dynamically on the empty message area.
    * @param {object} emptyMessage The update empty message config object.
    */
    setEmptyMessage: function setEmptyMessage(emptyMessage) {
      this.element[(emptyMessage === null || emptyMessage === void 0 ? void 0 : emptyMessage == null ? void 0 : emptyMessage.height) === 'small' ? 'addClass' : 'removeClass']('empty-message-height-small');

      if (!this.emptyMessage) {
        this.emptyMessageContainer = $('<div class="empty-message-container"><div></div></div>');
        this.element.append(this.emptyMessageContainer).addClass('has-empty-message');
        this.emptyMessage = this.emptyMessageContainer.find('div').emptymessage(emptyMessage).data('emptymessage');
        this.checkEmptyMessage();
      } else {
        this.emptyMessage.settings = emptyMessage;
        this.emptyMessage.updated();
      }
    },

    /**
    * Hide/Show the empty message object should be shown.
    * @private
    */
    checkEmptyMessage: function checkEmptyMessage() {
      if (this.emptyMessage && this.emptyMessageContainer) {
        if (this.recordCount === 0) {
          this.emptyMessageContainer.show();
          this.element.addClass('is-empty');
        } else {
          this.emptyMessageContainer.hide();
          this.element.removeClass('is-empty');
        }
      }
    },

    /**
    * Trigger event on parent and compose the args
    * @private
    * @param  {strung} eventName Event to trigger
    * @param  {object} e  Actual event
    * @param  {boolean} stopPropagation If stopPropagation should be done
    * @returns {boolean} False when the event should not propagte.
    */
    triggerRowEvent: function triggerRowEvent(eventName, e, stopPropagation) {
      var self = this;
      var target = $(e.target);
      var rowElem = target.closest('tr');
      var cellElem = target.closest('td');
      var cell = cellElem.index();
      var row = this.settings.treeGrid ? this.actualRowIndex(rowElem) : this.dataRowIndex(rowElem);
      var isTrigger = true;

      if (target.is('a') || target.closest('a').length) {
        stopPropagation = false;
      }

      if (stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      var item = self.settings.dataset[row]; //  Groupable

      if (this.settings.groupable) {
        if (rowElem.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer')) {
          isTrigger = false; // No need to trigger if no data item
        } else {
          row = self.actualPagingRowIndex(self.actualRowIndex(rowElem));
          item = self.settings.dataset[self.groupArray[row].group];

          if (item && item.values) {
            item = item.values[self.groupArray[row].node];
          }
        }
      }

      if (isTrigger) {
        var args = {
          row: row,
          rowElem: rowElem,
          cell: cell,
          cellElem: cellElem,
          item: item,
          originalEvent: e
        };
        self.element.trigger(eventName, [args]);
      }

      return false;
    },

    /**
     * Sync the containers when scrolling on the y axis.
     * @private
     * @param  {jQuery} e The event object
     */
    handleScrollY: function handleScrollY(e) {
      var elem = e.currentTarget;
      var top = elem.scrollTop;

      if (top !== this.scrollTop && this.bodyWrapperCenter && (this.bodyWrapperLeft || this.bodyWrapperRight)) {
        this.scrollTop = top;

        if (this.bodyWrapperLeft) {
          this.bodyWrapperLeft[0].scrollTop = this.scrollTop;
        }

        if (this.bodyWrapperRight) {
          this.bodyWrapperRight[0].scrollTop = this.scrollTop;
        }

        this.bodyWrapperCenter[0].scrollTop = this.scrollTop;
      }
    },

    /**
    * Resize event handler.
    * @private
    */
    rerender: function rerender() {
      this.clearCache();
      this.renderRows();
      this.renderHeader();
    },

    /**
     * Attach All relevant event handlers.
     * @private
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this8 = this;

      var self = this; // Set Focus on rows

      if (!self.settings.cellNavigation && self.settings.rowNavigation) {
        self.element.on('focus.datagrid', 'tbody > tr', function () {
          var rowNodes = self.rowNodes($(this));
          rowNodes.addClass('is-active-row');
        }).on('blur.datagrid', 'tbody > tr', function () {
          var rowNodes = self.rowNodes($(this));
          rowNodes.removeClass('is-active-row');
        });
      } // Handle Paging


      if (this.settings.paging) {
        this.tableBody.on("page.".concat(COMPONENT_NAME$1e), function (e, pagingInfo) {
          if (pagingInfo.type === 'filtered' && _this8.settings.source) {
            return;
          }

          self.saveUserSettings();
          self.render(null, pagingInfo);
          self.afterPaging(pagingInfo);
        }).on("pagesizechange.".concat(COMPONENT_NAME$1e), function (e, pagingInfo) {
          self.render(null, pagingInfo);
          self.afterPaging(pagingInfo);
        });
      } // Handle Hover States


      if (self.settings.showHoverState) {
        self.element.off('mouseenter.datagrid, mouseleave.datagrid').on('mouseenter.datagrid', 'tbody > tr', function () {
          var rowNodes = self.rowNodes($(this));
          rowNodes.addClass('is-hover-row');
        }).on('mouseleave.datagrid', 'tbody > tr', function () {
          var rowNodes = self.rowNodes($(this));
          rowNodes.removeClass('is-hover-row');
        });
      } // Sync Header and Body During scrolling


      if (this.hasLeftPane || this.hasRightPane) {
        self.element.find('.datagrid-wrapper').on('scroll.table', function (e) {
          self.handleScrollY(e);
        });
        self.element.find('.datagrid-wrapper').on('wheel.table', function (e) {
          if (e.originalEvent.deltaY !== 0) {
            e.currentTarget.scrollTop += e.originalEvent.deltaY;
            e.preventDefault();
            self.handleScrollY(e);
          }
        });
      }

      if (this.settings.virtualized) {
        var oldScroll = 0;
        var oldHeight = 0;
        self.bodyWrapperCenter.on('scroll.vtable', debounce(function () {
          var scrollTop = this.scrollTop;
          var buffer = 25;
          var hitBottom = scrollTop > self.virtualRange.bottom - self.virtualRange.bodyHeight - buffer;
          var hitTop = scrollTop < self.virtualRange.top + buffer;

          if (scrollTop !== oldScroll && (hitTop || hitBottom)) {
            oldScroll = this.scrollTop;
            self.clearCache();
            self.renderRows();
          }
        }, 0));
        $('body').on('resize.vtable', function () {
          var height = this.offsetHeight;

          if (height !== oldHeight) {
            oldHeight = this.scrollTop;
            self.clearCache();
            self.renderRows();
          }
        });
      } // Handle Sorting


      this.element.off('click.datagrid-header').on('click.datagrid-header', '.datagrid-header th.is-sortable, .datagrid-header th.btn-filter', function (e) {
        var parent = $(e.target).parent();

        if (parent.is('.datagrid-filter-wrapper') || parent.is('.lookup-wrapper') || parent.is('.has-close-icon-button')) {
          return false;
        } // Prevent parent grid from sorting when nested


        e.stopPropagation();
        self.setSortColumn($(this).attr('data-column-id'));
        return false;
      }); // Prevent redirects

      this.element.off('click.datagrid-links').on('click.datagrid-links', 'tbody .datagrid-row a', function (e) {
        var href = e.currentTarget.getAttribute('href');

        if (!href || href === '#') {
          e.preventDefault();
        }
      }); // Add a paste event for handling pasting from excel

      if (self.settings.editable) {
        this.element.off('paste.datagrid').on('paste.datagrid', function (e) {
          var pastedData;

          if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            pastedData = e.originalEvent.clipboardData.getData('text/plain');
          } else {
            pastedData = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : false;
          }

          var hasLineFeed = /\n/.exec(pastedData);
          var hasCarriageReturn = /\r/.exec(pastedData);
          var hasBoth = /\r\n/.exec(pastedData);

          if (self.activeCell && self.activeCell.node.hasClass('is-readonly')) {
            return; // disallow pasting on non editable cells.
          }

          if (pastedData && hasCarriageReturn || hasLineFeed || hasBoth) {
            var splitData = hasLineFeed ? pastedData.split('\n') : pastedData.split('\r');

            if (hasBoth) {
              splitData = pastedData.split('\r\n');
            }

            splitData.pop();
            var startRowCount = parseInt($(e.target)[0].parentElement.parentElement.parentElement.getAttribute('data-index'), 10);
            var startColIndex = parseInt($(e.target)[0].parentElement.parentElement.getAttribute('aria-colindex'), 10) - 1;

            if (self.editor && self.editor.input) {
              self.commitCellEdit();
            }

            self.copyToDataSet(splitData, startRowCount, startColIndex, self.settings.dataset);
          }
        });
      }

      this.element.off('click.datagrid').on('click.datagrid', 'tbody td', function (e) {
        var rowNode = null;
        var dataRowIdx = null;
        var target = $(e.target);
        var td = target.closest('td');

        if ($(e.currentTarget).closest('.datagrid-expandable-row').length === 1 && $(e.currentTarget).attr('role') !== 'gridcell') {
          return;
        }

        if (td.is('.has-btn-actions') && !target.is('.btn-actions')) {
          self.setActiveCell(td);
          return;
        }

        if (target.parents('td').length > 1) {
          e.preventDefault(); // stop nested clicks from propagating

          e.stopPropagation();
        }
        /**
        * Fires after a row is clicked.
        * @event click
        * @memberof Datagrid
        * @property {object} event The jquery event object
        * @property {object} args Additional arguments
        * @property {number} args.row The current row height
        * @property {number} args.cell The columns object
        * @property {object} args.item The current sort column.
        * @property {object} args.originalEvent The original event object.
        */


        self.triggerRowEvent('click', e, true);
        self.setActiveCell(td); // Dont Expand rows or make cell editable when clicking expand button

        if (target.is('.datagrid-expand-btn')) {
          rowNode = $(this).closest('tr');
          dataRowIdx = self.actualRowIndex(rowNode);
          self.toggleRowDetail(dataRowIdx);
          self.toggleGroupChildren(rowNode);
          self.toggleChildren(e, dataRowIdx);
          return false; //eslint-disable-line
        }

        var isSelectionCheckbox = target.is('.datagrid-selection-checkbox') || target.find('.datagrid-selection-checkbox').length === 1;
        var canSelect = self.settings.clickToSelect ? true : isSelectionCheckbox;

        if (target.is('.datagrid-drilldown')) {
          canSelect = false;
        }

        if (self.settings.selectable === 'mixed') {
          canSelect = isSelectionCheckbox; // Then Activate

          if (!canSelect) {
            if (e.shiftKey && self.activatedRow().length) {
              self.selectRowsBetweenIndexes([self.activatedRow()[0].row, target.closest('tr').attr('aria-rowindex') - 1]);
              e.preventDefault();
            }

            self.toggleRowActivation(target.closest('tr'));
          }
        }

        if (canSelect && self.settings.selectable === 'multiple' && e.shiftKey) {
          self.selectRowsBetweenIndexes([self.lastSelectedRow, target.closest('tr').attr('aria-rowindex') - 1]);
          e.preventDefault();
        } else if (canSelect) {
          self.toggleRowSelection(target.closest('tr'));
        } // Handle Cell Click Event


        var cell = td.attr('aria-colindex') - 1;
        var col = self.columnSettings(cell);

        if (col && !target.is('.datagrid-checkbox') && col.editor === editors.Checkbox) {
          return;
        }

        var isEditable = self.makeCellEditable(self.activeCell.rowIndex, self.activeCell.cell, e);

        if (col.click && typeof col.click === 'function' && target.is('button, input[checkbox], a, a.search-mode i') || target.parent().is('button')) {
          //eslint-disable-line
          var rowElem = $(this).closest('tr');
          var rowIdx = self.actualRowIndex(rowElem);
          dataRowIdx = self.dataRowIndex(rowElem);
          var item = self.settings.treeGrid ? self.settings.treeDepth[rowIdx].node : self.settings.dataset[dataRowIdx];

          if (td.hasClass('is-focusable')) {
            if (!target.is(self.buttonSelector)) {
              if (!target.parent('button').is(self.buttonSelector)) {
                return;
              }
            }
          }

          if (self.settings.groupable) {
            if (!rowElem.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer')) {
              rowIdx = self.actualPagingRowIndex(self.actualRowIndex(rowElem));
              item = self.settings.dataset[self.groupArray[rowIdx].group];

              if (item && item.values) {
                item = item.values[self.groupArray[rowIdx].node];
              }
            }
          }

          if (!td.hasClass('is-cell-readonly') && !target.is('[disabled]') && target.is('button, input[checkbox], a, a.search-mode i') || target.parent().is('button')) {
            //eslint-disable-line
            col.click(e, [{
              row: rowIdx,
              cell: self.activeCell.cell,
              item: item,
              originalEvent: e
            }]);
          }

          if (target.is('[disabled]') && col.formatter === formatters.Hyperlink) {
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        } // Handle Context Menu on Some


        if (col.menuId) {
          self.closePrevPopupmenu();
          var btn = $(this).find('button');
          btn.popupmenu({
            attachToBody: true,
            menuId: col.menuId,
            trigger: 'immediate',
            offset: {
              y: 5
            },
            returnFocus: function returnFocus() {
              return td.focus();
            }
          }).off('close.gridpopupbtn').on('close.gridpopupbtn', function () {
            var el = $(this);

            if (el.data('popupmenu') && !el.data('tooltip')) {
              el.data('popupmenu').destroy();
            }
          });

          if (col.selected) {
            btn.off('selected.gridpopupbtn').on('selected.gridpopupbtn', col.selected);
          }
        } // Apply Quick Edit Mode


        if (isEditable) {
          setTimeout(function () {
            if ($('textarea, input', td).length && !$('.dropdown,' + '[type=file],' + '[type=image],' + '[type=button],' + '[type=submit],' + '[type=reset],' + '[type=checkbox],' + '[type=radio]', td).length) {
              self.quickEditMode = true;
            }
          }, 0);
        }
      });

      if (this.stretchColumn !== 'last') {
        $(window).on('orientationchange.datagrid', function () {
          _this8.rerender();
        });
        $(window).on('resize.datagrid', function () {
          var j = 0;

          _this8.clearCache();

          for (j = 0; j < self.settings.columns.length; j++) {
            var col = self.settings.columns[j];
            self.columnWidth(col, j);
          }

          if (self.stretchColumnDiff > 0 || self.stretchColumnWidth > 0) {
            var currentCol = self.bodyColGroup.find('col').eq(self.getStretchColumnIdx())[0];
            currentCol.style.width = "".concat(self.stretchColumnDiff > 0 ? '99%' : "".concat(self.stretchColumnWidth, "px"));
          }
        });
      }
      /**
      * Fires after a row is double clicked.
      * @event dblclick
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row The current row height
      * @property {number} args.cell The columns object
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */


      this.element.off('dblclick.datagrid').on('dblclick.datagrid', 'tbody tr', function (e) {
        self.triggerRowEvent('dblclick', e, true);
      });
      /**
      * Fires after a row has a right click action.
      * @event contextmenu
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row The current row height
      * @property {number} args.cell The columns object
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */

      this.element.off('contextmenu.datagrid').on('contextmenu.datagrid', 'tbody td', function (e) {
        var td = $(e.currentTarget);
        e.stopPropagation();
        self.closePrevPopupmenu();
        self.triggerRowEvent('contextmenu', e, !!self.settings.menuId);

        var hasMenu = function hasMenu() {
          return self.settings.menuId && $("#".concat(self.settings.menuId)).length > 0;
        };

        if (!hasMenu() || !utils.isSubscribedTo(self.element[0], e, 'contextmenu', 'datagrid') && !hasMenu()) {
          return true;
        }

        e.preventDefault();
        self.setActiveCell(parseInt(td.parent().attr('aria-rowindex'), 10) - 1, parseInt(td.attr('aria-colindex'), 10) - 1);
        self.activeCell.node.focus();
        td.popupmenu({
          menuId: self.settings.menuId,
          eventObj: e,
          beforeOpen: self.settings.menuBeforeOpen,
          attachToBody: true,
          trigger: 'immediate'
        }).off('selected.gridpopuptr').on('selected.gridpopuptr', function (selectedEvent, args) {
          if (self.settings.menuSelected) {
            self.settings.menuSelected(selectedEvent, args);
          }
        }).off('close.gridpopuptr').on('close.gridpopuptr', function () {
          var elem = $(this);

          if (elem.data('popupmenu')) {
            elem.data('popupmenu').destroy();
          }
        });
        return false;
      }); // Move the drag handle to the end or start of the column

      this.headerRow.add(this.headerRowLeft).off('mousemove.datagrid').on('mousemove.datagrid', 'th', function (e) {
        if (self.dragging) {
          return;
        }

        self.currentHeader = $(e.target).closest('th');

        if (!self.currentHeader.hasClass('is-resizable') || self.currentHeader.hasClass('datagrid-header-spacer-column')) {
          return;
        }

        var headerDetail = self.currentHeader.closest('.header-detail');
        var extraMargin = headerDetail.length ? parseInt(headerDetail.css('margin-left'), 10) : 0;
        var leftEdge = parseInt(self.currentHeader.position().left, 10) - (extraMargin || 0) + self.element.scrollLeft();
        var rightEdge = leftEdge + self.currentHeader.outerWidth();
        var alignToLeft = e.pageX - leftEdge > rightEdge - e.pageX;
        var leftPos = 0;
        leftPos = alignToLeft ? rightEdge - 5 : leftEdge - 5;
        var idx = self.currentHeader.parent().find('th:visible').index(self.currentHeader); // Ignore First Column and last column

        if (idx === 0 && (Locale.isRTL() ? alignToLeft : !alignToLeft) || idx === self.visibleColumns().length) {
          leftPos = '-999';
        }

        if (!Locale.isRTL() && !alignToLeft) {
          self.currentHeader = self.currentHeader.prevAll(':visible').not('.is-hidden').first();
        }

        if (Locale.isRTL() && !alignToLeft) {
          self.currentHeader = self.currentHeader.nextAll(':visible').not('.is-hidden').first();
        }

        if (!self.currentHeader.hasClass('is-resizable')) {
          return;
        }

        self.createResizeHandle();
        self.resizeHandle[0].style.left = "".concat(leftPos, "px");
        self.resizeHandle[0].style.cursor = '';
      }).off('contextmenu.datagrid').on('contextmenu.datagrid', 'th', function (e) {
        if (self.settings.headerMenuId) {
          // Add Header Context Menu Support
          e.preventDefault();
          self.closePrevPopupmenu();
          $(e.currentTarget).popupmenu({
            menuId: self.settings.headerMenuId,
            eventObj: e,
            attachToBody: true,
            beforeOpen: self.settings.headerMenuBeforeOpen,
            trigger: 'immediate'
          }).off('selected.gridpopupth').on('selected.gridpopupth', function (selectedEvent, args) {
            self.settings.headerMenuSelected(selectedEvent, args);
          }).off('close.gridpopupth').on('close.gridpopupth', function () {
            var elem = $(this);

            if (elem.data('popupmenu')) {
              elem.data('popupmenu').destroy();
            }
          });
          return false;
        }

        return true;
      }); // Handle Clicking Header Checkbox

      this.element.off('click.datagrid-header-select').on('click.datagrid-header-select', 'th .datagrid-checkbox', function () {
        var checkbox = $(this);

        if (!checkbox.hasClass('is-checked')) {
          checkbox.addClass('is-checked').attr('aria-checked', 'true');

          if (self.settings.selectAllCurrentPage) {
            self.selectAllRowsCurrentPage();
          } else {
            self.selectAllRows();
          }
        } else {
          checkbox.removeClass('is-checked').attr('aria-checked', 'false');

          if (self.settings.selectAllCurrentPage) {
            self.unSelectAllRowsCurrentPage();
          } else {
            self.unSelectAllRows();
          }
        }
      }); // Implement Editing Auto Commit Functionality

      this.element.off('focusout.datagrid').on('focusout.datagrid', 'tbody td input, tbody td textarea, tbody div.dropdown', function (e) {
        // Keep icon clickable in edit mode
        var target = e.target;

        if ($(target).is('input.lookup, input.timepicker, input.datepicker, input.spinbox, input.colorpicker')) {
          // Wait for modal popup, if did not found modal popup means
          // icon was not clicked, then commit cell edit
          setTimeout(function () {
            var focusElem = $('*:focus');

            if (!$('.lookup-modal.is-visible, #timepicker-popup, #monthview-popup, #colorpicker-menu').length && self.editor) {
              if (focusElem.is('.spinbox, .trigger, .code-block-actions') || !$(target).is(':visible')) {
                return;
              }

              if (focusElem && self.editor.className && focusElem.closest(self.editor.className).length > 0) {
                return;
              }

              self.commitCellEdit();
            }
          }, 150);
          return;
        } // Popups are open


        if ($('#dropdown-list, .autocomplete.popupmenu.is-open, #timepicker-popup, .is-editing .code-block').is(':visible')) {
          return;
        }

        if (self.editor && self.editor.input) {
          self.commitCellEdit();
        }
      });
    },

    /**
    * Close any previous opened popupmenus.
    * @private
    * @returns {void}
    */
    closePrevPopupmenu: function closePrevPopupmenu() {
      var nodes = [].slice.call(this.element[0].querySelectorAll('.is-open:not(.popupmenu)'));
      nodes.forEach(function (node) {
        var elem = $(node);

        if (elem.data('popupmenu')) {
          elem.trigger('close');
        }
      });
    },

    /**
    * Refresh the heights based on the rowHeight setting.
    * @private
    */
    refreshSelectedRowHeight: function refreshSelectedRowHeight() {
      var toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
      var actions = toolbar.find('.btn-actions').data('popupmenu');

      if (!(actions !== null && actions !== void 0 && (actions == null ? void 0 : actions.wrapper))) {
        return;
      }

      var extraSmall = actions.wrapper.find('[data-option="row-extra-small"]');
      var small = actions.wrapper.find('[data-option="row-small"]');
      var short = actions.wrapper.find('[data-option="row-short"]');
      var med = actions.wrapper.find('[data-option="row-medium"]');
      var normal = actions.wrapper.find('[data-option="row-normal"]');
      var large = actions.wrapper.find('[data-option="row-large"]');

      if (this.settings.rowHeight === 'extra-small') {
        extraSmall.parent().addClass('is-checked');
        small.parent().removeClass('is-checked');
        short.parent().removeClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().removeClass('is-checked');
        large.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'short' || this.settings.rowHeight === 'small') {
        extraSmall.parent().removeClass('is-checked');
        small.parent().addClass('is-checked');
        short.parent().addClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().removeClass('is-checked');
        large.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'medium') {
        extraSmall.parent().removeClass('is-checked');
        small.parent().removeClass('is-checked');
        short.parent().addClass('is-checked');
        med.parent().addClass('is-checked');
        normal.parent().removeClass('is-checked');
        large.parent().removeClass('is-checked');
      }

      if (this.settings.rowHeight === 'normal' || this.settings.rowHeight === 'large') {
        extraSmall.parent().removeClass('is-checked');
        small.parent().removeClass('is-checked');
        short.parent().addClass('is-checked');
        med.parent().removeClass('is-checked');
        normal.parent().addClass('is-checked');
        large.parent().addClass('is-checked');
      } // Set draggable targets arrow height


      $('.drag-target-arrows', this.element).css('height', "".concat(this.getTargetHeight(), "px"));
    },

    /**
    * Append all the UI elements for the toolbar above the grid.
    * @private
    */
    appendToolbar: function appendToolbar() {
      var toolbar = null;
      var title = '';
      var more = null;
      var self = this;

      if (!this.settings.toolbar) {
        return;
      } // Allow menu to be added manually


      if (this.element.parent().find('.toolbar:not(.contextual-toolbar), .flex-toolbar:not(.contextual-toolbar)').length === 1) {
        toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar), .flex-toolbar:not(.contextual-toolbar)');
        this.refreshSelectedRowHeight();
      } else {
        toolbar = $('<div class="toolbar" role="toolbar"></div>');
        this.removeToolbarOnDestroy = true;

        if (this.settings.toolbar.title) {
          title = $("<div class=\"title\">".concat(this.settings.toolbar.title, "  </div>"));
        }

        if (!title) {
          title = toolbar.find('.title');
        }

        toolbar.append(title);

        if (this.settings.toolbar.results) {
          // Actually value filled in displayResults
          title.append('<span class="datagrid-result-count"></span>');
        }

        var buttonSet = $('<div class="buttonset"></div>').appendTo(toolbar);

        if (this.settings.toolbar.keywordFilter) {
          var labelMarkup = $("<label class=\"audible\" for=\"gridfilter\">".concat(Locale.translate('Keyword'), "</label>"));
          var searchfieldMarkup = $("<input class=\"searchfield\" name=\"searchfield\" placeholder=\"".concat(Locale.translate('Keyword'), "\" id=\"gridfilter\">"));
          buttonSet.append(labelMarkup);

          if (!this.settings.toolbar.collapsibleFilter) {
            searchfieldMarkup.attr('data-options', '{ "collapsible": false }');
          }

          buttonSet.append(searchfieldMarkup);
        }

        if (this.settings.toolbar.dateFilter) {
          buttonSet.append("<button class=\"btn\" type=\"button\">".concat($.createIcon({
            icon: 'calendar'
          }), "<span>").concat(Locale.translate('Date'), "</span></button>"));
        }

        if (this.settings.toolbar.actions) {
          more = $('<div class="more"></div>').insertAfter(buttonSet);
          more.append("<button class=\"btn-actions\" title=\"More\" type=\"button\">".concat($.createIcon({
            icon: 'more'
          }), "<span class=\"audible\">Grid Features</span></button>"));
          toolbar.addClass('has-more-button');
        }

        var menu = $('<ul class="popupmenu"></ul>');

        if (this.settings.toolbar.personalize) {
          menu.append("<li><a href=\"#\" data-option=\"personalize-columns\">".concat(Locale.translate('PersonalizeColumns'), "</a></li>"));
        }

        if (this.settings.toolbar.resetLayout) {
          menu.append("<li><a href=\"#\" data-option=\"reset-layout\">".concat(Locale.translate('ResetDefault'), "</a></li>"));
        }

        if (this.settings.toolbar.exportToExcel) {
          menu.append("<li><a href=\"#\" data-option=\"export-to-excel\">".concat(Locale.translate('ExportToExcel'), "</a></li>"));
        }

        if (this.settings.toolbar.advancedFilter) {
          menu.append("<li><a href=\"#\">".concat(Locale.translate('AdvancedFilter'), "</a></li>"));
        }

        if (this.settings.toolbar.views) {
          menu.append("<li><a href=\"#\">".concat(Locale.translate('SaveCurrentView'), "</a></li> ") + '<li class="separator"></li> ' + "<li class=\"heading\">".concat(Locale.translate('SavedViews'), "</li>") + '<li><a href="#">View One</a></li>');
        }

        if (this.settings.toolbar.rowHeight) {
          menu.append("".concat('<li class="separator single-selectable-section"></li>' + '<li class="heading">').concat(Locale.translate('RowHeight'), "</li>") + "<li class=\"is-selectable".concat(this.settings.rowHeight === 'extra-small' ? ' is-checked' : '', "\"><a href=\"#\" data-option=\"row-extra-small\">").concat(Locale.translate('ExtraSmall'), "</a></li>") + "<li class=\"is-selectable".concat(this.settings.rowHeight === 'short' || this.settings.rowHeight === 'small' ? ' is-checked' : '', "\"><a href=\"#\" data-option=\"row-small\">").concat(Locale.translate('Small'), "</a></li>") + "<li class=\"is-selectable".concat(this.settings.rowHeight === 'medium' ? ' is-checked' : '', "\"><a href=\"#\" data-option=\"row-medium\">").concat(Locale.translate('Medium'), "</a></li>") + "<li class=\"is-selectable".concat(this.settings.rowHeight === 'normal' || this.settings.rowHeight === 'large' ? ' is-checked' : '', "\"><a href=\"#\" data-option=\"row-large\">").concat(Locale.translate('Large'), "</a></li>"));
        }

        if (this.settings.toolbar.filterRow === true) {
          menu.append("".concat('<li class="separator"></li>' + '<li class="heading">').concat(Locale.translate('Filter'), "</li>") + "<li class=\"".concat(this.settings.filterable ? 'is-checked ' : '', "is-toggleable\"><a href=\"#\" data-option=\"show-filter-row\">").concat(Locale.translate('ShowFilterRow'), "</a></li>") + "<li class=\"is-indented\"><a href=\"#\" data-option=\"run-filter\">".concat(Locale.translate('RunFilter'), "</a></li>") + "<li class=\"is-indented\"><a href=\"#\" data-option=\"clear-filter\">".concat(Locale.translate('ClearFilter'), "</a></li>"));
        }

        if (_typeof(this.settings.toolbar.filterRow) === 'object') {
          var filterOptions = '<li class="separator"></li>';

          if (this.settings.toolbar.filterRow.showFilter) {
            filterOptions += "<li class=\"".concat(this.settings.filterable ? 'is-checked ' : '', "is-toggleable\"><a href=\"#\" data-option=\"show-filter-row\">").concat(Locale.translate('ShowFilterRow'), "</a></li>");
          }

          if (this.settings.toolbar.filterRow.runFilter && !this.settings.filterWhenTyping) {
            filterOptions += "<li class=\"is-indented\"><a href=\"#\" data-option=\"run-filter\">".concat(Locale.translate('RunFilter'), "</a></li>");
          }

          if (this.settings.toolbar.filterRow.clearFilter) {
            filterOptions += "<li class=\"is-indented\"><a href=\"#\" data-option=\"clear-filter\">".concat(Locale.translate('ClearFilter'), "</a></li>");
          }

          menu.append(filterOptions);
        }

        if (this.settings.toolbar.actions) {
          more.append(menu);
        }

        if (this.element.prev().is('.contextual-toolbar')) {
          this.element.prev().before(toolbar);
        } else {
          this.element.before(toolbar);
        }
      }

      var actions = toolbar.find('.btn-actions');
      var isFlex = toolbar.is('.flex-toolbar');

      if (this.settings.stickyHeader) {
        toolbar.addClass('is-sticky');
      }

      if (!isFlex) {
        actions.popupmenu();
      }

      var selectHandler = function selectHandler(e, args, args2) {
        var action = args.attr ? args.attr('data-option') : args2.attr('data-option');

        if (!action) {
          return;
        }

        if (action === 'row-extra-small' || action === 'row-small' || action === 'row-short' || action === 'row-medium' || action === 'row-normal' || action === 'row-large') {
          self.rowHeight(action.substr(4));
        }

        if (action === 'personalize-columns') {
          self.personalizeColumns();
        }

        if (action === 'reset-layout') {
          self.resetColumns();
        }

        if (action === 'export-to-excel') {
          self.exportToExcel();
        } // Filter actions


        if (action === 'show-filter-row') {
          self.toggleFilterRow();
        }

        if (action === 'run-filter') {
          self.applyFilter(null, 'menu');
        }

        if (action === 'clear-filter') {
          self.clearFilter();
        }
      };

      (isFlex ? toolbar : actions).on('selected', selectHandler);

      if (this.settings.initializeToolbar && !toolbar.data('toolbar') && !toolbar.hasClass('flex-toolbar')) {
        var opts = $.fn.parseOptions(toolbar);

        if (this.settings.toolbar.fullWidth) {
          opts.rightAligned = true;
        }

        toolbar.toolbar(opts);
      }

      if (this.settings.initializeToolbar && toolbar.hasClass('flex-toolbar') && !toolbar.data('toolbarFlex')) {
        var _opts = $.fn.parseOptions(toolbar);

        toolbar.toolbarFlex(_opts);
      }

      if (this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var thisSearch = toolbar.find('.searchfield');
        var xIcon = thisSearch.parent().find('.close.icon');
        thisSearch.off('keypress.datagrid').on('keypress.datagrid', function (e) {
          if (e.keyCode === 13 || e.type === 'change') {
            e.preventDefault();
            self.keywordSearch(thisSearch.val());
          }
        });
        xIcon.off('click.datagrid').on('click.datagrid', function () {
          self.keywordSearch(thisSearch.val());
        });
      }

      if (this.settings.toolbar && this.settings.toolbar.contextualToolbar) {
        var contextualToolbar = "\n        <div class=\"contextual-toolbar datagrid-contextual-toolbar toolbar is-hidden\">\n          <div class=\"title selection-count\">1 Selected</div>\n        </div>";
        this.element.before(contextualToolbar);
        this.contextualToolbar = this.element.prev('.contextual-toolbar');
      }

      this.toolbar = toolbar;
      this.element.addClass('has-toolbar');
    },

    /**
     * Get or Set the Row Height.
     * @param  {string} height The row height to use, can be 'extra small', 'small, 'normal' or 'large'
     * @Returns {string} The current row height
     */
    rowHeight: function rowHeight(height) {
      var args = [];

      if (height) {
        if (this.settings.rowHeight !== height) {
          args.push({
            before: this.settings.rowHeight,
            after: height
          });
        }

        this.settings.rowHeight = height;
      }

      var rowHeightClass = this.settings.rowHeight;

      if (rowHeightClass === 'short') {
        rowHeightClass = 'small';
      }

      if (rowHeightClass === 'large') {
        rowHeightClass = 'normal';
      }

      this.element.add(this.table).add(this.tableLeft).add(this.tableRight).removeClass('extra-small-rowheight small-rowheight short-rowheight medium-rowheight normal-rowheight large-rowheight').addClass("".concat(rowHeightClass, "-rowheight"));

      if (this.virtualRange && this.virtualRange.rowHeight) {
        this.virtualRange.rowHeight = height === 'normal' || height === 'large' ? 40 : height === 'medium' ? 30 : 25;

        if (height === 'extra-small') {
          this.virtualRange.rowHeight = 22;
        }
      }

      this.saveUserSettings();
      this.refreshSelectedRowHeight();
      this.rerender();

      if (args.length) {
        this.element.triggerHandler('rowheightchanged', args);
      }

      return this.settings.rowHeight;
    },

    /**
    * Search a Term across all columns
    * @param  {string} term The term to search for.
    */
    keywordSearch: function keywordSearch(term) {
      this.element.find('tr[role="row"]').removeClass('is-filtered').show();
      this.filterExpr = [];
      this.element.find('.datagrid-expandable-row').each(function () {
        var row = $(this); // Collapse All rows

        row.prev().find('.datagrid-expand-btn').removeClass('is-expanded');
        row.prev().find('.plus-minus').removeClass('active');
        row.removeClass('is-expanded').css('display', '');
        row.find('.datagrid-row-detail').css('height', '');
      });
      this.element.find('.search-mode').each(function () {
        var cell = $(this);
        var text = cell.text();
        cell.text(text.replace('<i>', '').replace('</i>', ''));
      });
      term = (term || '').toLowerCase();
      this.filterExpr.push({
        column: 'all',
        operator: 'contains',
        value: term,
        keywordSearch: true
      });
      this.filterKeywordSearch();
      this.clearCache();
      this.renderRows();
      this.setSearchActivePage({
        trigger: 'searched',
        type: 'filtered'
      });

      if (!(this.settings.paging && this.settings.source)) {
        this.highlightSearchRows(term);
      }
    },

    /**
     * Sets optional filtering conditions on the pager during changes
     * in searching/filtering of datagrid rows
     * @private
     * @param {object} pagingInfo incoming paging state information
     * @returns {void}
     */
    setSearchActivePage: function setSearchActivePage(pagingInfo) {
      if (!this.pagerAPI) {
        return;
      }

      var self = this;

      if (!pagingInfo) {
        pagingInfo = {};
      }

      function reset(obj) {
        obj.activePage = 1;

        if (self.grandTotal) {
          obj.grandTotal = self.grandTotal;
        }

        return obj;
      }

      var useSelfActive = true;

      if (this.filterExpr && this.filterExpr.length === 1) {
        if (this.filterExpr[0].value !== '') {
          pagingInfo.activePage = this.pagerAPI.filteredActivePage || 1;

          if (this.settings.source && this.settings.allowSelectAcrossPages && pagingInfo.activePage !== this.activePage) {
            useSelfActive = false;
          }
        } else if (this.filterExpr[0].value === '' && this.pagerAPI.filteredActivePage) {
          pagingInfo = reset(pagingInfo);
        }
      } else if (!this.restoreActivePage) {
        pagingInfo = reset(pagingInfo);
        this.restoreActivePage = false;
      }

      if (useSelfActive) {
        pagingInfo.activePage = this.activePage;
      }

      this.renderPager(pagingInfo);
    },

    /**
     * Filter to keyword search.
     * @private
     */
    filterKeywordSearch: function filterKeywordSearch() {
      var self = this;
      var dataset;
      var isFiltered;
      var i;
      var len;
      var filterExpr = self.filterExpr;

      var checkRow = function checkRow(data, row) {
        var isMatch = false;

        var checkColumn = function checkColumn(columnId) {
          var column = self.columnById(columnId)[0];
          var fieldValue = self.fieldValue(data, column.field);
          var value;
          var cell = self.settings.columns.indexOf(column); // Use the formatted value (what the user sees in the cells)
          // since it's a more reliable match

          value = self.formatValue(column.formatter, row, cell, fieldValue, column, data, self);
          value = value.toLowerCase(); // Strip any html markup that might be in the formatted value

          value = value.replace(/(<([^>]+)>)|(amp;)|(&lt;([^>]+)&gt;)/ig, '');
          return value.indexOf(filterExpr.value) > -1;
        }; // Check in all visible columns


        if (filterExpr.column === 'all') {
          self.element.find('th:visible').each(function () {
            //eslint-disable-line
            var th = $(this);
            var columnId = th.attr('data-column-id');

            if (columnId) {
              isMatch = checkColumn(columnId);

              if (isMatch) {
                return false;
              }
            }
          });
        } else if (filterExpr.columnId) {
          // Check in only one column, given by columnId
          isMatch = checkColumn(filterExpr.columnId);
        }

        return isMatch;
      }; // Make sure not more/less than one filter expr


      if (!filterExpr || filterExpr.length !== 1) {
        return;
      }

      filterExpr = filterExpr[0]; // Check in dataset

      if (self.settings.treeGrid) {
        dataset = self.settings.treeDepth;

        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i].node, i);
          dataset[i].node._isFilteredOut = isFiltered;
        }
      } else {
        dataset = self.settings.dataset;

        for (i = 0, len = dataset.length; i < len; i++) {
          isFiltered = filterExpr.value === '' ? false : !checkRow(dataset[i], i);
          dataset[i]._isFilteredOut = isFiltered;
        }
      }
    },

    /**
     * Highlight the term in the grid.
     * @private
     * @param  {string} term The term to highlight
     * @returns {void}
     */
    highlightSearchRows: function highlightSearchRows(term) {
      var _this9 = this;

      var self = this;

      if (!term || term === '') {
        return;
      }

      var findInRows = function findInRows(rowNodes) {
        var found = false;
        rowNodes.toArray().forEach(function (row) {
          [].slice.call(row.querySelectorAll('td')).forEach(function (cell) {
            var cellText = cell.innerText.toLowerCase();
            var isSearchExpandableRow = self.settings.searchExpandableRow ? true : !DOM.hasClass(_this9, 'datagrid-expandable-row');

            if (cellText.indexOf(term) > -1 && isSearchExpandableRow) {
              found = true;
              [].slice.call(cell.querySelectorAll('*')).forEach(function (node) {
                [].slice.call(node.childNodes).forEach(function (childNode) {
                  var parent = childNode.parentElement;

                  if (childNode.nodeType === 3 && parent.tagName.toLowerCase() !== 'i' && xssUtils.unescapeHTML(parent.innerHTML) === childNode.textContent) {
                    var contents = childNode.textContent;
                    var exp = new RegExp("(".concat(stringUtils.escapeRegExp(term), ")"), 'gi');
                    DOM.addClass(parent, 'search-mode');
                    DOM.html(parent, contents.replace(exp, '<i>$1</i>'));
                  }
                });
              });
            }
          });
        });
        return found;
      }; // Move across all visible cells and rows, highlighting


      var visibleRows = self.tableBody.find('tr');
      visibleRows.toArray().forEach(function (row) {
        var rowContainers = self.rowNodes(row.getAttribute('aria-rowindex') - 1);
        var found = findInRows(rowContainers); // Hide non matching rows and non detail rows

        if (!found && !rowContainers.find('.datagrid-row-detail').length) {
          rowContainers.addClass('is-filtered').hide();
        } else if (self.settings.searchExpandableRow && found && rowContainers.is('.datagrid-expandable-row') && term !== '') {
          rowContainers.prev().show();
          rowContainers.prev().find('.datagrid-expand-btn').addClass('is-expanded');
          rowContainers.prev().find('.plus-minus').addClass('active');
          rowContainers.addClass('is-expanded').css('display', 'table-row');
          rowContainers.find('.datagrid-row-detail').css('height', 'auto');
        }
      });
    },

    /**
     * Get the right dataset object to use depending on settings.
     * @private
     * @returns {array} The dataset to use.
     */
    getActiveDataset: function getActiveDataset() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;

      if (s.groupable) {
        dataset = this.originalDataset;
      }

      return dataset;
    },

    /**
     * Return the current data and remove any adding properties.
     * @returns {array} The current dataset.
     */
    getDataset: function getDataset() {
      var dataset = this.settings.dataset;
      return dataset.map(function (item) {
        delete item._isFilteredOut;
        return item;
      });
    },

    /**
    * Select all rows. If serverside paging, this will be only the current page.
    * For client side paging, all rows across all pages are selected.
    */
    selectAllRows: function selectAllRows() {
      var rows = [];
      var dataset = this.getActiveDataset();

      for (var i = 0, l = dataset.length; i < l; i++) {
        var idx = this.settings.groupable ? i : this.pagingRowIndex(i);

        if (this.filterRowRendered || this.filterExpr && this.filterExpr[0] && this.filterExpr[0].keywordSearch) {
          if (!dataset[i]._isFilteredOut && !dataset[i]._selected) {
            rows.push(idx);
          }
        } else if (!dataset[i]._selected) {
          rows.push(idx);
        }
      }

      this.dontSyncUi = true;
      this.selectRows(rows, true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();
      /**
      * Fires after a row is selected.
      * @event selected
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {array} args.selectedRows An array of selected rows.
      * @property {string} args.trigger The action can be 'selectall', 'deselectall', 'select', 'deselect'
      * @property {object} args.item The current sort column.
      * @property {object} args.originalEvent The original event object.
      */

      this.element.triggerHandler('selected', [this._selectedRows, 'selectall']);
    },

    /**
    * Deselect all rows that are currently selected.
    */
    deSelectAllRows: function deSelectAllRows() {
      this.unSelectAllRows();
    },

    /**
    * Deselect all rows that are currently selected.
    * @private
    * @param  {boolean} nosync Do not sync the header
    * @param  {boolean} noTrigger Do not trgger event
    * @returns {void}
    */
    unSelectAllRows: function unSelectAllRows(nosync, noTrigger) {
      // Nothing to do
      if (!this._selectedRows || this._selectedRows.length === 0) {
        this.settings.dataset.map(function (row) {
          delete row._selected;
        }); //eslint-disable-line

        return;
      }

      this.dontSyncUi = true; // Unselect each row backwards so the indexes are correct

      for (var i = this._selectedRows.length - 1; i >= 0; i--) {
        if (this._selectedRows[i]) {
          var idx = this.settings.groupable ? this._selectedRows[i].idx : this.pagingRowIndex(this._selectedRows[i].idx);
          this.unselectRow(idx, true, true);
        }
      }

      this.settings.dataset.map(function (row) {
        delete row._selected;
      }); //eslint-disable-line
      // Sync the Ui and call the events

      this.dontSyncUi = false;
      this._selectedRows = [];

      if (!nosync) {
        this.syncSelectedUI();
      }

      if (!noTrigger) {
        this.element.triggerHandler('selected', [this._selectedRows, 'deselectall']);
      }
    },

    /**
    * Deselect all rows on active page only, that are currently selected.
    * @private
    * @param  {boolean} nosync Do not sync the header
    * @returns {void}
    */
    unSelectAllRowsCurrentPage: function unSelectAllRowsCurrentPage(nosync) {
      var _this$currentPageRows,
          _this10 = this,
          _this$currentPageRows2;

      var s = this.settings;
      this.dontSyncUi = true;
      (_this$currentPageRows = this.currentPageRows) === null || _this$currentPageRows === void 0 ? void 0 : _this$currentPageRows == null ? void 0 : _this$currentPageRows.forEach(function (row) {
        var idx = s.groupable ? row.dataIndex : _this10.pagingRowIndex(row.dataIndex);

        _this10.unselectRow(idx, true, true);
      });
      var dataset = this.getActiveDataset();
      var arrIdx = ((_this$currentPageRows2 = this.currentPageRows) === null || _this$currentPageRows2 === void 0 ? void 0 : _this$currentPageRows2 == null ? void 0 : _this$currentPageRows2.map(function (x) {
        return x.dataIndex;
      })) || [];
      var currentRows = dataset.filter(function (d, i) {
        return arrIdx.indexOf(i) > -1;
      });
      currentRows.map(function (row) {
        return delete row._selected;
      });
      this.dontSyncUi = false;

      if (!nosync) {
        this.syncSelectedUI();
      }
    },

    /**
    * Deselect all rows on active page only, that are currently selected.
    * @private
    * @param  {boolean} nosync Do not sync the header
    * @returns {void}
    */
    selectAllRowsCurrentPage: function selectAllRowsCurrentPage(nosync) {
      var _this$currentPageRows3;

      this.dontSyncUi = true;
      var arrIdx = ((_this$currentPageRows3 = this.currentPageRows) === null || _this$currentPageRows3 === void 0 ? void 0 : _this$currentPageRows3 == null ? void 0 : _this$currentPageRows3.map(function (x) {
        return x.dataIndex;
      })) || [];

      if (arrIdx.length) {
        this.selectRowsBetweenIndexes([arrIdx[0], arrIdx[arrIdx.length - 1]]);
      }

      this.dontSyncUi = false;

      if (!nosync) {
        this.syncSelectedUI();
      }
    },

    /**
    * Check if node index is exists in selected nodes
    * @private
    * @param {object} row The row to compare.
    * @returns {boolean} If its selected or not.
    */
    isRowSelected: function isRowSelected(row) {
      // As of 4.3.3, return the rows that have _selected = true
      return row ? row._selected === true : false;
    },

    /**
     * Select a row node on the UI
     * @private
     * @param {object} elem The row node to select
     * @param {number} index The row index to select
     * @param {object} data The object attached to the row
     * @param {boolean} force Dont check if already selected
     * @returns {void}
     */
    selectNode: function selectNode(elem, index, data, force) {
      var checkbox = null;
      var self = this;
      var selectClasses = "is-selected".concat(self.settings.selectable === 'mixed' ? ' hide-selected-color' : ''); // do not add if already exists in selected

      if ((!data || self.isRowSelected(data)) && !force) {
        return;
      }

      checkbox = elem.find('.datagrid-selection-checkbox').closest('td');
      elem.addClass(selectClasses).attr('aria-selected', 'true');
      checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true').attr('aria-label', 'Selected');

      if (data) {
        data._selected = true;
      }
    },

    /**
     * Toggle selection on a single row
     * @param {number} idx The row index to select
     * @param {boolean} nosync Do sync the header
     * @param {boolean} noTrigger Do not trigger events.
     * @returns {void}
     */
    selectRow: function selectRow(idx, nosync, noTrigger) {
      var _this11 = this;

      var rowNode = null;
      var dataRowIndex;
      var self = this;
      var s = this.settings;
      var args = {};

      if (idx === undefined || idx === -1 || !s.selectable) {
        return;
      }

      if (this.isRowDisabled(idx)) {
        return;
      }

      rowNode = this.settings.groupable ? this.rowNodesByDataIndex(idx) : this.rowNodes(idx);
      dataRowIndex = this.dataRowIndex(rowNode);

      if (isNaN(dataRowIndex)) {
        dataRowIndex = idx;
      }

      if (!rowNode || !rowNode.length && s.source) {
        return;
      }

      if (typeof s.onBeforeSelect === 'function' && !noTrigger) {
        var result = s.onBeforeSelect({
          node: rowNode,
          idx: dataRowIndex
        });

        if (result === false) {
          // Boolean false is returned so cancel
          return;
        }
      }

      var isMatch = function isMatch(i, elem, n) {
        return n && n.idx === i && n.elem && n.elem.is(elem);
      };

      var isExists = function isExists(i, elem) {
        return !!_this11._selectedRows.filter(function (n) {
          return isMatch(i, elem, n);
        }).length;
      };

      if (s.selectable === 'single') {
        var selectedIndex = -1;

        if (this._selectedRows.length > 0) {
          selectedIndex = this._selectedRows[0].pagingIdx;
        } else if (rowNode[0] && rowNode[0].classList.contains('is-selected')) {
          selectedIndex = dataRowIndex;
        }

        if (selectedIndex !== -1) {
          this.unselectRow(selectedIndex, true, true);

          if (!rowNode.length && this._selectedRows.length > 0) {
            this._selectedRows.pop();
          }
        }
      }

      var isServerSideMultiSelect = s.source && s.selectable === 'multiple' && s.allowSelectAcrossPages;

      if (!rowNode.hasClass('is-selected') || isServerSideMultiSelect) {
        var rowData;

        if (s.treeGrid) {
          var level = parseInt(rowNode.attr('aria-level'), 10);
          rowData = s.treeDepth[self.pagerAPI && s.source ? rowNode.index() : idx].node;

          if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
            // Select node and node-children
            rowNode.add(rowNode.nextUntil("[aria-level=\"".concat(level, "\"]"))).each(function (i) {
              var elem = $(this);
              var index = elem.attr('aria-rowindex') - 1;
              var actualIdx = self.actualPagingRowIndex(index);
              var data = s.treeDepth[actualIdx].node; // Allow select node if selectChildren is true or only first node
              // if selectChildren is false

              if (s.selectChildren || !s.selectChildren && i === 0) {
                var canAdd = !elem.is(rowNode) && !elem.hasClass('is-selected');
                self.selectNode(elem, index, data);

                if (canAdd && !isExists(actualIdx, elem)) {
                  args = {
                    idx: actualIdx,
                    data: data,
                    elem: elem,
                    page: self.pagerAPI ? self.pagerAPI.activePage : 1,
                    pagingIdx: actualIdx,
                    pagesize: s.pagesize
                  };

                  if (self.settings.source && self.settings.allowSelectAcrossPages) {
                    var uniqueRowID = self.getUniqueRowID(data);

                    if (uniqueRowID) {
                      args.uniqueRowID = uniqueRowID;
                    }
                  }

                  self._selectedRows.push(args);
                }
              }
            });
          } else if (s.selectable === 'siblings') {
            if (self.settings.selectAllCurrentPage) {
              self.unSelectAllRowsCurrentPage(true);
            } else {
              self.unSelectAllRows(true, true);
            } // Select node and node-siblings


            var nexts;
            var prevs;

            if (level === 1) {
              nexts = rowNode.parent().find('[aria-level="1"]');
            } else if (level > 1) {
              nexts = rowNode.nextUntil("[aria-level=\"".concat(level - 1, "\"]")).filter("[aria-level=\"".concat(level, "\"]"));
              prevs = rowNode.prevUntil("[aria-level=\"".concat(level - 1, "\"]")).filter("[aria-level=\"".concat(level, "\"]"));
            }

            rowNode.add(nexts).add(prevs).each(function (i) {
              var elem = $(this);
              var index = elem.attr('aria-rowindex') - 1;
              var actualIdx = self.actualPagingRowIndex(index);
              var data = s.treeDepth[actualIdx].node; // Allow select node if selectChildren is true or only first node
              // if selectChildren is false

              if (s.selectChildren || !s.selectChildren && i === 0) {
                var canAdd = !elem.is(rowNode) && !elem.hasClass('is-selected');
                self.selectNode(elem, index, data);

                if (canAdd && !isExists(actualIdx, elem)) {
                  args = {
                    idx: actualIdx,
                    data: data,
                    elem: elem,
                    page: self.pagerAPI ? self.pagerAPI.activePage : 1,
                    pagingIdx: actualIdx,
                    pagesize: s.pagesize
                  };

                  if (self.settings.source && self.settings.allowSelectAcrossPages) {
                    var uniqueRowID = self.getUniqueRowID(data);

                    if (uniqueRowID) {
                      args.uniqueRowID = uniqueRowID;
                    }
                  }

                  self._selectedRows.push(args);
                }
              }
            });
          } else {
            // Default to Single element selection
            self.selectNode(rowNode, idx, rowData);
          }

          self.setNodeStatus(rowNode);
        } else {
          rowData = s.dataset[dataRowIndex];

          if (s.groupable) {
            var row = self.actualPagingRowIndex(self.actualRowIndex(rowNode));

            if (isNaN(row)) {
              return;
            }

            var gData = self.groupArray[row];
            rowData = self.settings.dataset[gData.group].values[gData.node];

            if (!isExists(rowData.idx, rowNode)) {
              args = {
                idx: rowData.idx,
                data: rowData,
                elem: rowNode,
                group: s.dataset[self.groupArray[row].group],
                page: self.pagerAPI ? self.pagerAPI.activePage : 1,
                pagingIdx: dataRowIndex,
                pagesize: self.settings.pagesize
              };

              if (self.settings.source && self.settings.allowSelectAcrossPages) {
                var uniqueRowID = self.getUniqueRowID(rowData);

                if (uniqueRowID) {
                  args.uniqueRowID = uniqueRowID;
                }
              }

              this._selectedRows.push(args);
            }
          }

          self.selectNode(rowNode, dataRowIndex, rowData);
          self.lastSelectedRow = idx; // Rememeber index to use shift key
        } // Append data to selectedRows


        if (!s.groupable) {
          var actualIdx = self.actualPagingRowIndex(idx);

          if (actualIdx === -1) {
            actualIdx = idx;
          }

          if (!isExists(actualIdx, self.visualRowNode(actualIdx))) {
            args = {
              idx: actualIdx,
              data: rowData,
              elem: self.visualRowNode(actualIdx),
              page: self.pagerAPI ? self.pagerAPI.activePage : 1,
              pagingIdx: idx,
              pagesize: self.settings.pagesize
            };

            if (self.settings.source && self.settings.allowSelectAcrossPages) {
              var _uniqueRowID = self.getUniqueRowID(rowData);

              if (_uniqueRowID) {
                args.uniqueRowID = _uniqueRowID;
              }
            }

            this._selectedRows.push(args);
          }
        }
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }
    },

    /**
    * Select rows between indexes
    * @private
    * @param  {array} indexes The ranges to select.
    * @returns {void}
    */
    selectRowsBetweenIndexes: function selectRowsBetweenIndexes(indexes) {
      indexes.sort(function (a, b) {
        return a - b;
      });

      for (var i = indexes[0]; i <= indexes[1]; i++) {
        this.selectRow(i);
      }

      this.displayCounts();
    },

    /**
    * Set the checkbox on the header based on selections.
    * @private
    * @param  {array} rows The rows to select.
    * @returns {void}
    */
    syncHeaderCheckbox: function syncHeaderCheckbox(rows) {
      if (this.headerNodes().length === 0) {
        return;
      }

      var s = this.settings;
      var dataset = this.getActiveDataset();
      var headerCheckbox = this.headerNodes().find('.datagrid-checkbox');
      var rowsLength = rows.length;
      var selectedRowsLength = this._selectedRows.length;
      var status = headerCheckbox.data('selected'); // Only on active page selected all checkbox

      if (s.selectAllCurrentPage && this.currentPageRows && dataset.length !== rows.length) {
        var _this$currentPageRows4;

        var arrIdx = ((_this$currentPageRows4 = this.currentPageRows) === null || _this$currentPageRows4 === void 0 ? void 0 : _this$currentPageRows4 == null ? void 0 : _this$currentPageRows4.map(function (x) {
          return x.dataIndex;
        })) || [];
        var currentRows = dataset.filter(function (d, i) {
          return arrIdx.indexOf(i) > -1;
        });
        selectedRowsLength = currentRows.filter(function (x) {
          return x._selected;
        }).length;
      }

      if (s.source && s.allowSelectAcrossPages) {
        selectedRowsLength = dataset.filter(function (i) {
          return i._selected;
        }).length;
      } // Do not run if checkbox in same state


      if (selectedRowsLength !== rowsLength && selectedRowsLength > 0 && status === 'partial' || selectedRowsLength === rowsLength && status === 'all' && selectedRowsLength !== 0 || selectedRowsLength === 0 && status === 'none') {
        return;
      } // Sync the header checkbox


      if (selectedRowsLength > 0) {
        headerCheckbox.data('selected', 'partial').addClass('is-checked is-partial').attr('aria-checked', 'mixed');
      }

      if (selectedRowsLength === rowsLength) {
        headerCheckbox.data('selected', 'all').addClass('is-checked').removeClass('is-partial').attr('aria-checked', 'true');
      }

      if (selectedRowsLength === 0) {
        headerCheckbox.data('selected', 'none').removeClass('is-checked is-partial').attr('aria-checked', 'false');
      }
    },

    /**
     * Get unique id for data node
     * @private
     * @param  {object} data The data node.
     * @returns {string} calculated id
     */
    getUniqueRowID: function getUniqueRowID(data) {
      var str = null;

      if (this.settings.columnIds.length > 0) {
        str = 'rowId';

        for (var i = 0; i < this.settings.columnIds.length; i++) {
          str += " ".concat(data[this.settings.columnIds[i]]);
        }

        str = str.replace(/([0-9A-Z]+)/g, function (m, chr) {
          return " ".concat(chr);
        }).replace(/([0-9a-z]+)/g, function (m, chr) {
          return "".concat(chr, " ");
        }).trim();
        str = xssUtils.toCamelCase(str);
      }

      return str;
    },

    /**
     * Mark selected rows on the page as selected
     * @private
     * @returns {void}
     */
    syncSelectedRows: function syncSelectedRows() {
      var _this12 = this;

      var s = this.settings;
      var dataset = s.groupable && this.originalDataset ? this.originalDataset : s.dataset;
      var idx = null;

      var selectNode = function selectNode(i) {
        var elem = s.groupable ? _this12.dataRowNode(idx) : _this12.visualRowNode(idx);

        if (elem[0]) {
          _this12._selectedRows[i].elem = elem;

          _this12.selectNode(elem, idx, dataset[idx], true);
        }
      };

      var getSelUniqueRowID = function getSelUniqueRowID(node) {
        return node ? node.uniqueRowID : null;
      };

      for (var i = 0, l = this._selectedRows.length; i < l; i++) {
        var selectedUniqueRowID = getSelUniqueRowID(this._selectedRows[i]);

        if (this.settings.source && this.settings.allowSelectAcrossPages && !!selectedUniqueRowID) {
          for (var i2 = 0, l2 = dataset.length; i2 < l2; i2++) {
            if (selectedUniqueRowID === this.getUniqueRowID(dataset[i2])) {
              var elem = s.groupable ? this.dataRowNode(i2) : this.visualRowNode(i2);

              if (elem[0]) {
                this._selectedRows[i].elem = elem;
                this.selectNode(elem, i2, dataset[i2], true);
              }
            }
          }
        } else {
          if (this.pagerAPI && this._selectedRows[i].page === this.pagerAPI.activePage) {
            idx = this._selectedRows[i].idx;
            selectNode(i);
          } // Check for rows that changed page


          if (this._selectedRows[i].pagesize !== s.pagesize && !s.groupable) {
            idx = this._selectedRows[i].pagingIdx;

            if (s.dataset[idx]) {
              selectNode(i);
              this._selectedRows[i].idx = idx;
              this._selectedRows[i].page = this.pagerAPI.activePage;
              this._selectedRows[i].pagesize = s.pagesize;
            } else {
              this._selectedRows[i].idx = idx % s.pagesize;
              this._selectedRows[i].page = Math.round(idx / s.pagesize) + 1;
              this._selectedRows[i].pagesize = s.pagesize;
            }
          }
        }
      }
    },

    /**
     * Calculate pager info for given index.
     * @private
     * @param  {number} idx The index number
     * @param  {object} ds custom dataset (optional)
     * @param  {number} pagesize custom pagesize (optional)
     * @returns {object} calculated pager info
     */
    calculatePagerInfo: function calculatePagerInfo(idx, ds, pagesize) {
      var s = this.settings;
      var dataset = ds || s.treeGrid ? s.treeDepth : s.dataset;
      pagesize = typeof pagesize === 'number' && pagesize > 0 ? pagesize : s.pagesize;
      var pagerInfo = {
        idx: idx,
        page: 1,
        pagesize: pagesize,
        numOfPages: Math.ceil(dataset.length / pagesize)
      };

      for (var i = 0; i < pagerInfo.numOfPages; i++) {
        if (idx >= (pagerInfo.page - 1) * pagerInfo.pagesize && idx < pagerInfo.page * pagerInfo.pagesize) {
          pagerInfo.pagingIdx = idx - pagerInfo.pagesize * i;
          break;
        }

        pagerInfo.page++;
      }

      return pagerInfo;
    },

    /**
     * Run throught the array and remark the idx's after a row reorder.
     * @private
     * @returns {void}
     */
    syncSelectedRowsIdx: function syncSelectedRowsIdx() {
      var dataset = this.settings.groupable && this.originalDataset ? this.originalDataset : this.settings.dataset;

      if (this._selectedRows.length === 0 || dataset.length === 0) {
        return;
      }

      this._selectedRows = [];

      for (var i = 0; i < dataset.length; i++) {
        if (dataset[i]._selected) {
          var selectedRow = {
            idx: i,
            data: dataset[i],
            elem: this.dataRowNode(i),
            pagingIdx: i,
            pagesize: this.settings.pagesize
          };

          if (this.settings.groupable) {
            var rowNode = this.rowNodesByDataIndex(i);

            if (rowNode.length) {
              var row = this.actualPagingRowIndex(this.actualRowIndex(rowNode));
              var group = this.groupArray[row].group;
              selectedRow.group = this.settings.dataset[group];
              selectedRow.page = this.calculatePagerInfo(group).page;
            }
          } else {
            selectedRow.page = this.calculatePagerInfo(i).page;
          }

          this._selectedRows.push(selectedRow);
        }
      }
    },

    /**
     * Set ui elements based on selected rows
     * @private
     * @returns {void}
     */
    syncSelectedUI: function syncSelectedUI() {
      var _this13 = this;

      var dataset = this.getActiveDataset();
      var currentRows = dataset; // Selected all only on active page

      if (this.settings.selectAllCurrentPage) {
        var _this$currentPageRows5;

        var arrIdx = ((_this$currentPageRows5 = this.currentPageRows) === null || _this$currentPageRows5 === void 0 ? void 0 : _this$currentPageRows5 == null ? void 0 : _this$currentPageRows5.map(function (x) {
          return x.dataIndex;
        })) || [];
        currentRows = dataset.filter(function (d, i) {
          return arrIdx.indexOf(i) > -1;
        });
      }

      var rows = currentRows;

      if (this.filterRowRendered) {
        rows = [];

        for (var i = 0, l = currentRows.length; i < l; i++) {
          if (!currentRows[i]._isFilteredOut) {
            rows.push(i);
          }
        }
      }

      this.syncHeaderCheckbox(rows); // Open or Close the Contextual Toolbar.

      if (this.contextualToolbar.length !== 1 || this.dontSyncUi) {
        return;
      }

      if (this._selectedRows.length === 0) {
        this.contextualToolbar.one('animateclosedcomplete.datagrid', function () {
          _this13.contextualToolbar.css('display', 'none');
        }).animateClosed();
      }

      if (this._selectedRows.length > 0 && this.contextualToolbar.height() === 0) {
        this.contextualToolbar.css('display', 'block').one('animateopencomplete.datagrid', function () {
          $(this).triggerHandler('recalculate-buttons');
        }).animateOpen();
      }
    },

    /**
     * Activate a row when in mixed selection mode
     * @param  {number} idx The index.
     */
    activateRow: function activateRow(idx) {
      if (this.activatedRow()[0].row !== idx) {
        this.toggleRowActivation(idx);
      }
    },

    /**
    * Deactivate the currently activated row.
    */
    deactivateRow: function deactivateRow() {
      var idx = this.activatedRow()[0].row;

      if (idx >= 0) {
        this.toggleRowActivation(idx);
      }
    },

    /**
    * Gets the currently activated row.
    * @returns {object} Information about the activated row.
    */
    activatedRow: function activatedRow() {
      var r = [{
        row: -1,
        item: undefined,
        elem: undefined
      }];

      if (this.tableBody) {
        var s = this.settings;
        var dataset = s.treeGrid ? s.treeDepth : s.dataset;
        var activatedRow = this.tableBody.find('tr.is-rowactivated');

        if (activatedRow.length) {
          var dataRowIndex = this.dataRowIndex(activatedRow);
          var rowIndex = s.indeterminate ? dataRowIndex : this.actualRowIndex(activatedRow);
          r = [{
            row: rowIndex,
            item: dataset[rowIndex],
            elem: activatedRow
          }];
        } else {
          r = null; // Activated row may be filtered or on another page, so check all until find it

          for (var i = 0; i < dataset.length; i++) {
            if (dataset[i]._rowactivated) {
              r = [{
                row: i,
                item: dataset[i],
                elem: undefined
              }];
              break;
            }
          }

          if (r === null) {
            r = [{
              row: -1,
              item: undefined,
              elem: activatedRow
            }];
          }
        }
      }

      return r;
    },

    /**
    * Toggle the current activation state from on to off.
    * @param  {number} idx The row to toggle
    * @returns {void}
    */
    toggleRowActivation: function toggleRowActivation(idx) {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var row;
      var rowJq;
      var rowIndex;

      if (typeof idx === 'number') {
        row = this.tableBody[0].querySelector("tr[aria-rowindex=\"".concat(idx + 1, "\"]"));
        rowIndex = idx;

        if (this.pagerAPI && s.source && s.indeterminate) {
          var rowIdx = idx + (this.pagerAPI.activePage - 1) * s.pagesize;
          row = this.tableBody[0].querySelector("tr[aria-rowindex=\"".concat(rowIdx + 1, "\"]"));
        }
      } else {
        rowJq = idx instanceof jQuery ? idx : $(idx);
        row = rowJq[0];
        rowIndex = s.treeGrid || s.groupable ? this.actualRowIndex(rowJq) : this.dataRowIndex(rowJq);
      }

      if (s.indeterminate && !row) {
        rowJq = this.actualRowNode(rowIndex);
        row = rowJq[0];
      }

      var isActivated = dataset[rowIndex] ? dataset[rowIndex]._rowactivated : false; // Toggle it

      if (isActivated) {
        this.deactivateRowNode(rowIndex, dataset);
      } else {
        this.deactivateAllRowNodes(dataset);
        this.activateAllRowNodes(rowIndex, dataset);
      }
    },

    /**
     * Activate given row with mixed selection mode.
     * @private
     * @param  {number} idx The row index to activated
     * @param  {object} dataset Optional data to use
     * @returns {void}
     */
    activateAllRowNodes: function activateAllRowNodes(idx, dataset) {
      var _this14 = this;

      if (typeof idx !== 'number' || idx < 0) {
        return;
      }

      var s = this.settings;

      if (typeof dataset === 'undefined') {
        dataset = s.treeGrid ? s.treeDepth : s.dataset;
      }

      var args = [{
        row: idx,
        item: dataset[idx]
      }];

      var doRowactivated = function doRowactivated() {
        var rowNodes = s.paging && s.source && s.selectable === 'mixed' ? _this14.rowNodesByDataIndex(idx).toArray() : _this14.rowNodes(idx).toArray();
        rowNodes.forEach(function (rowElem) {
          rowElem.classList.add('is-rowactivated');
        });
        dataset[idx]._rowactivated = true;
        args = [{
          row: idx,
          item: dataset[idx]
        }];
        /**
         * Fires after a row is activated in mixed selection mode.
         * @event rowactivated
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {array} args.row An array of selected rows.
         * @property {object} args.item The current sort column.
         */

        _this14.element.triggerHandler('rowactivated', args);
      };

      if (dataset[idx]) {
        $.when(this.element.triggerHandler('beforerowactivated', args)).done(function (response) {
          var isFalse = function isFalse(v) {
            return typeof v === 'string' && v.toLowerCase() === 'false' || typeof v === 'boolean' && v === false || typeof v === 'number' && v === 0;
          };

          if (!isFalse(response)) {
            doRowactivated();
          }
        });
      }
    },

    /**
    * Deactivate given row with mixed selection mode.
    * @private
    * @param  {number} idx The row index to deactivated
    * @param  {object} dataset Optional data to use
    * @returns {void}
    */
    deactivateRowNode: function deactivateRowNode(idx, dataset) {
      if (typeof idx !== 'number' || idx < 0) {
        return;
      }

      var s = this.settings;

      if (typeof dataset === 'undefined') {
        dataset = s.treeGrid ? s.treeDepth : s.dataset;
      }

      if (dataset[idx] && !s.disableRowDeactivation) {
        var rowNodes = this.rowNodes(idx).toArray();
        rowNodes.forEach(function (row) {
          row.classList.remove('is-rowactivated');
        });
        delete dataset[idx]._rowactivated;
        /**
         * Fires after a row is deactivated in mixed selection mode.
         * @event rowdeactivated
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {array} args.row An array of selected rows.
         * @property {object} args.item The current sort column.
         */

        this.element.triggerHandler('rowdeactivated', [{
          row: idx,
          item: dataset[idx]
        }]);
      }
    },

    /**
    * Deactivate all rows with mixed selection mode.
    * @private
    * @param  {object} dataset Optional data to use
    * @returns {void}
    */
    deactivateAllRowNodes: function deactivateAllRowNodes(dataset) {
      var s = this.settings;
      var triggerData = null;

      if (typeof dataset === 'undefined') {
        dataset = s.treeGrid ? s.treeDepth : s.dataset;
      } // Deselect activated row


      var activated = [].slice.call(this.element[0].querySelectorAll('tr.is-rowactivated'));

      if (activated.length > 0) {
        activated.forEach(function (row) {
          row.classList.remove('is-rowactivated');
        });
        var idx = s.treeGrid || s.groupable ? this.actualRowIndex($(activated)) : this.dataRowIndex($(activated));
        triggerData = {
          row: idx,
          item: dataset[idx]
        };

        if (dataset[idx]) {
          delete dataset[idx]._rowactivated;
        }
      } else {
        // actived row may be filtered or on another page, so check all until find it
        for (var i = 0; i < dataset.length; i++) {
          var data = dataset[i];

          if (data._rowactivated) {
            delete data._rowactivated;
            triggerData = {
              row: i,
              item: data
            };
            break;
          }
        }
      }

      if (triggerData !== null) {
        this.element.triggerHandler('rowdeactivated', [triggerData]);
      }
    },

    /**
    * Toggle the current selection state from on to off.
    * @param  {number} idx The row to select/unselect
    * @returns {void}
    */
    toggleRowSelection: function toggleRowSelection(idx) {
      var row = typeof idx === 'number' ? this.tableBody.find("tr[aria-rowindex=\"".concat(idx + 1, "\"]")) : idx;
      var rowIndex = typeof idx === 'number' ? idx : this.actualRowIndex(row);

      if (this.settings.groupable) {
        rowIndex = this.dataRowIndex(row);
      }

      if (this.settings.selectable === false) {
        return;
      }

      if (this.editor && row.hasClass('is-selected')) {
        return;
      }

      if (this.settings.selectable === 'single' && row.hasClass('is-selected') && !this.settings.disableRowDeselection) {
        this.unselectRow(rowIndex);
        this.displayCounts();
        return this._selectedRows; // eslint-disable-line
      }

      if (row.hasClass('is-selected')) {
        if (!this.settings.disableRowDeselection) {
          this.unselectRow(rowIndex);
        }
      } else {
        this.selectRow(rowIndex);
      }

      this.displayCounts();
      return this._selectedRows; // eslint-disable-line
    },

    /**
    * De-select a selected row.
    * @param  {number} idx The row index
    * @param  {boolean} nosync Do not sync the header
    * @param  {boolean} noTrigger Do not trgger any events
    */
    unselectRow: function unselectRow(idx, nosync, noTrigger) {
      var self = this;
      var s = self.settings;
      var rowNode = this.settings.groupable ? this.rowNodesByDataIndex(idx) : this.rowNodes(idx);
      var isServerSideMultiSelect = s.source && s.selectable === 'multiple' && s.allowSelectAcrossPages;
      var checkbox = null;

      if (!rowNode || idx === undefined) {
        return;
      }

      var getSelUniqueRowID = function getSelUniqueRowID(node) {
        return node ? node.uniqueRowID : null;
      }; // Unselect it


      var unselectNode = function unselectNode(elem, index) {
        var removeSelected = function removeSelected(node, selIdx) {
          delete node._selected;

          if (typeof selIdx === 'undefined') {
            selIdx = index;
          }

          for (var i = 0; i < self._selectedRows.length; i++) {
            var selectedUniqueRowID = getSelUniqueRowID(self._selectedRows[i]);

            if (s.source && s.allowSelectAcrossPages && !!selectedUniqueRowID) {
              if (selectedUniqueRowID === self.getUniqueRowID(node)) {
                self._selectedRows.splice(i, 1);

                break;
              }
            } else if (self._selectedRows[i].idx === selIdx) {
              if (isServerSideMultiSelect && self._selectedRows[i].elem && !self._selectedRows[i].elem.is(elem)) {
                continue;
              }

              self._selectedRows.splice(i, 1);

              break;
            }
          }
        };

        var selectClasses = 'is-selected hide-selected-color';
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        elem.removeClass(selectClasses).removeAttr('aria-selected');

        if (self.columnIdxById('selectionCheckbox') !== -1) {
          checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked no-animate').attr('aria-checked', 'false').removeAttr('aria-label');
        }

        if (s.treeGrid) {
          for (var i = 0; i < s.treeDepth.length; i++) {
            if (self.isRowSelected(s.treeDepth[i].node)) {
              if (typeof index !== 'undefined') {
                if (index === s.treeDepth[i].idx - 1) {
                  removeSelected(s.treeDepth[i].node);
                }
              } else {
                removeSelected(s.treeDepth[i].node);
              }
            }
          }
        } else {
          var selIdx = elem.length ? self.dataRowIndex(elem) : index;
          var rowData;

          if (selIdx !== undefined && selIdx > -1) {
            rowData = s.dataset[selIdx];
          }

          if (s.groupable) {
            rowData = self.originalDataset[selIdx];
          }

          if (rowData !== undefined) {
            if (s.paging && s.source) {
              removeSelected(rowData, selIdx);
            } else {
              removeSelected(rowData);
            }
          }
        }
      };

      if (s.treeGrid) {
        var level = parseInt(rowNode.attr('aria-level'), 10);

        if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
          // Select node and node-children
          rowNode.add(rowNode.nextUntil("[aria-level=\"".concat(level, "\"]"))).each(function (i) {
            var elem = $(this);
            var index = elem.attr('aria-rowindex') - 1;
            var actualIndex = self.actualPagingRowIndex(index); // Allow unselect node if selectChildren is true or only first node

            if (s.selectChildren || !s.selectChildren && i === 0) {
              unselectNode(elem, actualIndex);
            }
          });
        } else if (s.selectable === 'siblings') {
          rowNode.parent().find('.is-selected').each(function (i) {
            var elem = $(this);
            var index = elem.attr('aria-rowindex') - 1;
            var actualIndex = self.actualPagingRowIndex(index); // Allow unselect node if selectChildren is true or only first node

            if (s.selectChildren || !s.selectChildren && i === 0) {
              unselectNode(elem, actualIndex);
            }
          });
        } else {
          // Single element unselection
          var actualIdx = self.actualPagingRowIndex(idx);
          unselectNode(rowNode, actualIdx);
        }

        self.setNodeStatus(rowNode);
      } else {
        unselectNode(rowNode, idx);
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!noTrigger) {
        self.element.triggerHandler('selected', [self._selectedRows, 'deselect']);
      }
    },

    /**
     * Set the current status on the row status column
     * @param {HTMLElement} node The node to set the status on
     */
    setNodeStatus: function setNodeStatus(node) {
      var self = this;
      var isMultiselect = self.settings.selectable === 'multiple';
      var s = self.settings;
      var checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox'));
      var nodes; // Not multiselect

      if (!isMultiselect) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked is-partial').attr('aria-checked', 'false');

        if (node.is('.is-selected')) {
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
        }

        return;
      }

      var setStatus = function setStatus(nodeElems, isFirstSkipped) {
        nodeElems.each(function () {
          var nodeToUse = $(this);
          var checkboxToUse = self.cellNode(nodeToUse, self.columnIdxById('selectionCheckbox'));
          var status = self.getSelectedStatus(nodeToUse, isFirstSkipped);
          checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').removeClass('is-checked is-partial').attr('aria-checked', 'false');

          if (status === 'mixed') {
            checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked is-partial').attr('aria-checked', 'mixed');
          } else if (status) {
            checkboxToUse.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
          }
        });
      }; // Multiselect


      nodes = node.add(node.nextUntil('[aria-level="1"]')).filter('.datagrid-tree-parent'); // Prevent selecting of parent element when selectChildren is false

      if (s.selectChildren) {
        setStatus(nodes);
      }

      nodes = node;

      if (+node.attr('aria-level') > 1) {
        nodes = nodes.add(node.prevUntil('[aria-level="1"]')).add(node.prevAll('[aria-level="1"]:first'));
      }

      nodes = nodes.filter('.datagrid-tree-parent'); // Prevent selecting of parent element when selectChildren is false

      if (s.selectChildren) {
        setStatus(nodes);
      }
    },

    /**
    * Get current selection status.
    * @private
    * @param  {object} node The dom element.
    * @returns {object} The status
    */
    getSelectedStatus: function getSelectedStatus(node) {
      var s = this.settings;
      var status = false;
      var total = 0;
      var selected = 0;
      var unselected = 0;
      var targetNodes = node.add(node.nextUntil('[aria-level="1"]'));

      if (s.treeGrid && s.selectable === 'multiple') {
        var level = node.attr('aria-level');
        targetNodes = node.add(node.nextUntil("[aria-level=\"".concat(level, "\"]")));
      }

      targetNodes.each(function () {
        total++;

        if ($(this).is('.is-selected')) {
          selected++;
        } else {
          unselected++;
        }
      });
      status = total === selected ? true : total === unselected ? false : 'mixed';
      return status;
    },

    /**
     * Get the currently selected rows.
     * @returns {array} An array containing the selected rows
     */
    selectedRows: function selectedRows() {
      return this._selectedRows;
    },

    /**
     * Set the selected rows by passing the row index or an array of row indexes.
     * @param  {number/array} row A row index or array of row indexes to select.
     * @param  {boolean} nosync Dont sync the header.
     * @param  {boolean} selectAll Internally used.
     * @returns {void}
     */
    selectRows: function selectRows(row, nosync, selectAll) {
      var idx = -1;
      var s = this.settings;
      var isSiblings = s.selectable === 'siblings';
      var dataset = this.getActiveDataset();

      if (typeof row === 'number') {
        row = [row];
      }

      if (!row || row.length === 0) {
        return this._selectedRows;
      }

      if (s.selectable === 'single') {
        // Unselect
        if (this._selectedRows.length) {
          this.unselectRow(this._selectedRows[0].idx, true, true);
        } // Select - may be passed array or int


        idx = Object.prototype.toString.call(row) === '[object Array]' ? row[0] : row.index();
        this.selectRow(idx, true, true);
      }

      if (s.selectable === 'multiple' || s.selectable === 'mixed' || isSiblings) {
        if (Object.prototype.toString.call(row) === '[object Array]') {
          for (var i = 0; i < row.length; i++) {
            this.selectRow(row[i], true, true);
          }

          if (row.length === 0) {
            for (var j = 0, l = dataset.length; j < l; j++) {
              this.unselectRow(j, true, true);
            }
          }
        } else {
          this.selectRow(row.index(), true, true);
        }
      }

      this.displayCounts();

      if (!nosync) {
        this.syncSelectedUI();
      }

      if (!selectAll) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }

      return this._selectedRows;
    },

    /**
     * Returns an array of row numbers for the rows containing the value for the specified field.
     * @param  {string} fieldName The field name to search.
     * @param  {any} value The value to use in search.
     * @returns {array} an array of row numbers.
     */
    findRowsByValue: function findRowsByValue(fieldName, value) {
      var s = this.settings;
      var dataset = this.getActiveDataset();
      var idx = -1;
      var matchedRows = [];

      for (var i = 0, data; i < dataset.length; i++) {
        if (s.groupable) {
          for (var k = 0; k < dataset[i].values.length; k++) {
            idx++;
            data = dataset[i].values[k];

            if (data[fieldName] === value) {
              matchedRows.push(idx);
            }
          }
        } else {
          data = s.treeGrid ? dataset[i].node : dataset[i];

          if (data[fieldName] === value) {
            matchedRows.push(i);
          }
        }
      }

      return matchedRows;
    },

    /**
    * Sets the row status
    * @param {object} idx The index of the row to add status to.
    * @param {string} status The status type 'error', 'info' ect
    * @param {object} tooltip The information for the message/tooltip
    */
    rowStatus: function rowStatus(idx, status, tooltip) {
      var arrayToUse = this.getActiveDataset();

      if (!status) {
        delete arrayToUse[idx].rowStatus;
        this.updateRow(idx);
        return;
      }

      if (/dirty/.test(status)) {
        return;
      }

      if (!arrayToUse[idx]) {
        return;
      }

      arrayToUse[idx].rowStatus = {};
      var rowStatus = arrayToUse[idx].rowStatus;
      rowStatus.icon = status;
      status = status.charAt(0).toUpperCase() + status.slice(1);
      status = status.replace('-progress', 'Progress');
      rowStatus.text = Locale.translate(status);
      tooltip = tooltip ? tooltip.charAt(0).toUpperCase() + tooltip.slice(1) : rowStatus.text;
      rowStatus.tooltip = tooltip;
      this.updateRow(idx);
      this.setupTooltips(true);
    },

    /**
    * Get the column object by id
    * @param  {number} id The column id to find
    * @returns {object} The corresponding column.
    */
    columnById: function columnById(id) {
      return $.grep(this.settings.columns, function (e) {
        return e.id === id;
      });
    },

    /**
    * Get the column index from the col's id
    * @param  {number} id The column id to find
    * @returns {object} The corresponding columns current position.
    */
    columnIdxById: function columnIdxById(id) {
      var cols = this.settings.columns;
      var idx = -1;

      for (var i = 0; i < cols.length; i++) {
        if (cols[i].id === id) {
          idx = i;
          break;
        }
      }

      return idx;
    },

    /**
    * Handle all keyboard behavior
    * @private
    * @returns {void}
    */
    handleKeys: function handleKeys() {
      var _this15 = this;

      var self = this;
      var checkbox = $('th .datagrid-checkbox', self.headerRow); // Handle header navigation

      self.element.on('keydown.datagrid', 'th', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var th = $(this);
        var index = self.columnIdxById(th.attr('data-column-id'));
        var last = self.visibleColumns().length - 1;
        var triggerEl;
        var move;

        if ($(e.target).closest('.popupmenu').length > 0) {
          return;
        } // Enter or Space


        if (key === 13 || key === 32) {
          triggerEl = self.settings.selectable === 'multiple' && index === 0 ? $('.datagrid-checkbox', th) : th;
          triggerEl.trigger('click.datagrid').focus();
          var selectionCheckbox = triggerEl[0].dataset.columnId === 'selectionCheckbox' || triggerEl.prevObject[0].dataset.columnId === 'selectionCheckbox';

          if ((self.settings.selectable === 'multiple' || this.settings.selectable === 'mixed') && selectionCheckbox) {
            checkbox.addClass('is-checked').removeClass('is-partial').attr('aria-checked', 'true');

            if (self.recordCount === self._selectedRows.length) {
              if (self.settings.selectAllCurrentPage) {
                self.unSelectAllRowsCurrentPage();
              } else {
                self.unSelectAllRows();
              }

              return;
            }

            if (self.settings.selectAllCurrentPage) {
              self.selectAllRowsCurrentPage();
            } else {
              self.selectAllRows();
            }
          }

          if (key === 32) {
            // Prevent scrolling with space
            e.preventDefault();
          }
        } // Press Home, End, Left and Right arrow to move to first, last, previous or next


        if ([35, 36, 37, 39].indexOf(key) !== -1) {
          move = index; // Home, End or Ctrl/Meta + Left/Right arrow to move to the first or last

          if (/35|36/i.test(key) || (e.ctrlKey || e.metaKey) && /37|39/i.test(key)) {
            if (Locale.isRTL()) {
              move = key === 36 || (e.ctrlKey || e.metaKey) && key === 37 ? last : 0;
            } else {
              move = key === 35 || (e.ctrlKey || e.metaKey) && key === 39 ? last : 0;
            }
          } else if (Locale.isRTL()) {
            // Left and Right arrow
            move = key === 39 ? index > 0 ? index - 1 : index : index < last ? index + 1 : last;
          } else {
            move = key === 37 ? index > 0 ? index - 1 : index : index < last ? index + 1 : last;
          } // Update active cell


          self.activeCell.cell = move; // Making moves

          th.removeAttr('tabindex').removeClass('is-active');
          e.preventDefault();
        } // Down arrow


        if (key === 40) {
          th.removeAttr('tabindex');
          self.activeCell.node = self.cellNode(0, self.settings.groupable ? 0 : self.activeCell.cell).attr('tabindex', '0').focus();
          e.preventDefault();
        }
      }); // Handle Editing / Keyboard

      self.element.on('keydown.datagrid', 'td, input', function (e) {
        //eslint-disable-line
        var key = e.which || e.keyCode || e.charCode || 0;
        var handled = false; // F2 - toggles actionableMode "true" and "false"
        // Force to not toggle, if "inlineMode: true"

        if (key === 113 && !_this15.inlineMode) {
          self.settings.actionableMode = !self.settings.actionableMode;
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return handled;
        }
      }); // Press PageUp or PageDown to open the previous or next page and set focus to the first row.
      // Press Alt+Up or Alt+Down to set focus to the first or last row on the current page.
      // Press Alt+PageUp or Alt+PageDown to open the first or last page and
      // set focus to the first row.
      // Handle rest of the keyboard

      self.element.on('keydown.datagrid', 'td', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0;
        var handled = false;
        var target = $(e.target);
        var isRTL = Locale.isRTL();
        var node = self.activeCell.node;
        var rowNode = $(this).parent();
        var prevRow = rowNode.prevAll(':not(.is-hidden, .datagrid-expandable-row)').first();
        var nextRow = rowNode.nextAll(':not(.is-hidden, .datagrid-expandable-row)').first();
        var row = self.activeCell.row;
        var cell = self.activeCell.cell;
        var col = self.columnSettings(cell);
        var isGroupRow = rowNode.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        var item = self.settings.dataset[self.dataRowIndex(rowNode)];
        var visibleRows = self.tableBody.find('tr:visible');

        var getVisibleRows = function getVisibleRows(index) {
          var visibleRow = visibleRows.filter("[aria-rowindex=\"".concat(index + 1, "\"]"));

          if (visibleRow.is('.datagrid-rowgroup-header')) {
            return visibleRow.index();
          }

          return self.dataRowIndex(visibleRow);
        };

        if (!node.length) {
          self.activeCell.node = self.cellNode(row, cell);
          node = self.activeCell.node;
        }

        var getGroupCell = function getGroupCell(currentCell, lastCell, prev) {
          var n = self.activeCell.groupNode || node;
          var nextCell = currentCell + (prev ? -1 : +1);

          if (nextCell > lastCell) {
            nextCell = prev ? n.prevAll(':visible').last() : n.nextAll(':visible').last();
          } else {
            nextCell = prev ? n.prevAll(':visible').first() : n.nextAll(':visible').first();
          }

          return nextCell;
        };

        var getNextVisibleCell = function getNextVisibleCell(currentCell, lastCell, prev) {
          if (isGroupRow) {
            return getGroupCell(currentCell, lastCell, prev);
          }

          var nextCell = currentCell + (prev ? -1 : +1);

          if (nextCell > lastCell) {
            return lastCell;
          }

          while (self.settings.columns[nextCell] && self.settings.columns[nextCell].hidden) {
            nextCell = prev ? nextCell - 1 : nextCell + 1;
          }

          return nextCell;
        };

        var isSelectionCheckbox = !!$('.datagrid-selection-checkbox', node).length;
        var lastRow = visibleRows.last();
        var lastCell = self.settings.columns.length - 1;

        if (self.settings.onKeyDown) {
          var response = function response(isCancelled) {
            if (!isCancelled) {
              e.stopPropagation();
              e.preventDefault();
            }
          };

          var args = {
            activeCell: self.activeCell,
            row: row,
            cell: cell
          };
          var ret = self.settings.onKeyDown(e, args, response);

          if (ret === false || !response) {
            e.stopPropagation();
            e.preventDefault();
            return;
          }
        } // Tab, Left, Up, Right and Down arrow keys.


        if ([9, 37, 38, 39, 40].indexOf(key) !== -1) {
          if (target.closest('.code-block').length && !(key === 9 && e.shiftKey && self.getFocusables(node).index === 0)) {
            return;
          }

          if (key !== 9) {
            if (target.is('.code-block-actions')) {
              return;
            }

            if (target.closest('.popupmenu.is-open').closest('.popupmenu-wrapper').prev().is('.code-block-actions')) {
              return;
            }
          }
        } // Tab, Left and Right arrow keys.


        if ([9, 37, 39].indexOf(key) !== -1) {
          if (key === 9 && !self.settings.actionableMode) {
            return;
          }

          if (key !== 9 && e.altKey) {
            // [Alt + Left/Right arrow] to move to the first or last cell on the current row.
            cell = key === 37 && !isRTL || key === 39 && isRTL ? 0 : lastCell;
            self.setActiveCell(row, cell);
          } else if (!self.quickEditMode || key === 9) {
            // Handle `shift + tab` for code block formatter, it use sometime `.code-block-actions`
            if (key === 9 && e.shiftKey && target.is('.code-block-actions')) {
              self.focusNextPrev('prev', node);
            } else {
              if (!isRTL && (key === 37 || key === 9 && e.shiftKey) || // eslint-disable-line
              isRTL && (key === 39 || key === 9)) {
                // eslint-disable-line
                cell = getNextVisibleCell(cell, lastCell, true);
              } else {
                cell = getNextVisibleCell(cell, lastCell);
              }
            }

            if (cell === -1 && !self.settings.actionableMode) {
              return;
            }

            if (cell === -1 && self.settings.actionableMode) {
              row--;
              cell = lastCell;

              if (row === -1) {
                return;
              }
            }

            if (cell === lastCell && lastCell === self.activeCell.cell && self.settings.actionableMode) {
              row++;
              cell = 0;

              if (row === self.visibleRowCount) {
                return;
              }
            }

            if (cell instanceof jQuery) {
              self.setActiveCell(cell);
            } else {
              self.setActiveCell(row, cell);
            }

            if (self.settings.actionableMode) {
              self.makeCellEditable(self.activeCell.rowIndex, cell, e);

              if (self.containsTextField(node) && self.containsTriggerField(node)) {
                self.quickEditMode = true;
              }
            }

            self.quickEditMode = false;
            handled = true;
          }
        } // Up arrow key


        if (key === 38 && !self.quickEditMode) {
          // Press [Control + Up] arrow to move to the first row on the first page.
          if (e.altKey || e.metaKey) {
            var firstRow = getVisibleRows(0);
            self.setActiveCell(firstRow, cell);
            handled = true;
          } else {
            // Up arrow key to navigate by row.
            if (row === 0 && !prevRow.is('.datagrid-rowgroup-header')) {
              node.removeAttr('tabindex');
              self.element.find('th').eq(cell).attr('tabindex', '0').focus();
              return;
            }

            self.setActiveCell(prevRow, cell);
            handled = true;
          }
        } // Down arrow key


        if (key === 40 && !self.quickEditMode) {
          // Press [Control + Down] arrow to move to the last row on the last page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(lastRow, cell);
            handled = true;
          } else {
            // Down arrow key to navigate by row.
            self.setActiveCell(nextRow, cell);
            handled = true;
          }
        } // Press (Control + Spacebar) to announce the current row when using a screen reader.


        if (key === 32 && e.ctrlKey && node) {
          var string = '';
          row = node.closest('tr');
          row.children().each(function () {
            var cellNode = $(this);
            string += "".concat(cellNode.text(), " ");
          });
          $('body').toast({
            title: '',
            audibleOnly: true,
            message: string
          });
          handled = true;
        } // Press Home or End to move to the first or last cell on the current row.


        if (key === 36) {
          self.setActiveCell(row, 0);
          handled = true;
        } // Home to Move to the end of the current row


        if (key === 35) {
          self.setActiveCell(row, lastCell);
          handled = true;
        } // End to Move to last row of current cell


        if (key === 34) {
          self.setActiveCell(lastRow, cell);
          handled = true;
        } // End to Move to first row of current cell


        if (key === 33) {
          self.setActiveCell(getVisibleRows(0), cell);
          handled = true;
        } // For mode 'Selectable':
        // Press Space to toggle row selection, or click to activate using a mouse.


        if (key === 32 && (!self.settings.editable || isSelectionCheckbox)) {
          row = node.closest('tr');

          if (target.closest('.datagrid-row-detail').length === 1) {
            return;
          }

          e.preventDefault(); // Toggle datagrid-expand with Space press

          var btn = target.find('.datagrid-expand-btn, .datagrid-drilldown');

          if (btn && btn.length) {
            btn.trigger('click.datagrid');
            e.preventDefault();
            return;
          }

          if (self.settings.selectable === 'multiple' && e.shiftKey) {
            self.selectRowsBetweenIndexes([self.lastSelectedRow, row.attr('aria-rowindex') - 1]);
          } else {
            self.toggleRowSelection(row);
          }
        } // For Editable mode - press Enter or Space to edit or toggle a cell,
        // or click to activate using a mouse.


        if (self.settings.editable && key === 32) {
          if (!self.editor) {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
          }
        } // Action button from Formatters.Actions


        if (key === 13 && node.is('.has-btn-actions')) {
          var btnAction = node.find('.btn-actions');

          if (btnAction.length) {
            btnAction.trigger('click');
          }
        } // if column have click function to fire [ie. action button]


        if (key === 13 && col.click && typeof col.click === 'function') {
          if (!node.hasClass('is-cell-readonly')) {
            col.click(e, [{
              row: row,
              cell: cell,
              item: item,
              originalEvent: e
            }]);
          }
        }

        if (self.settings.editable && key === 13) {
          // Allow shift to add a new line
          if (target.is('textarea') && e.shiftKey) {
            return;
          } // Allow the menu buttons


          if (target.is('.btn-menu') || target.closest('.popupmenu.is-open').length) {
            return;
          }

          if (self.editor) {
            self.quickEditMode = false;
            self.commitCellEdit();
            self.setNextActiveCell(e);
          } else {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);

            if (self.containsTextField(node) && self.containsTriggerField(node)) {
              self.quickEditMode = true;
            }
          }

          handled = true;
        } // Any printable character - well make it editable


        if ([9, 13, 32, 35, 36, 37, 38, 39, 40, 113].indexOf(key) === -1 && !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey && self.settings.editable) {
          if (!self.editor) {
            self.makeCellEditable(self.activeCell.rowIndex, cell, e);
          }
        } // If multiSelect or mixedSelect is enabled, press Control+A to toggle select all rows


        if ((self.settings.selectable === 'multiple' || self.settings.selectable === 'mixed') && !self.editor && (e.ctrlKey || e.metaKey) && key === 65) {
          checkbox.addClass('is-checked').removeClass('is-partial').attr('aria-checked', 'true');

          if (self.recordCount === self._selectedRows.length) {
            if (self.settings.selectAllCurrentPage) {
              self.unSelectAllRowsCurrentPage();
            } else {
              self.unSelectAllRows();
            }

            return;
          }

          if (self.settings.selectAllCurrentPage) {
            self.selectAllRowsCurrentPage();
          } else {
            self.selectAllRows();
          }

          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false; // eslint-disable-line
        }
      });
    },

    /**
     * Get focusable elements in given node
     * @param  {object} node The node to get focusable elements
     * @returns {object} array of focusable elements and current index
     */
    getFocusables: function getFocusables(node) {
      var focusables = $(':focusable', node);
      return {
        elements: focusables,
        index: focusables.index($(':focus'))
      };
    },

    /**
     * Set focus to next/prev focusable element in given node
     * @param  {string} opt The element to set focus
     * @param  {object} node The node to get focusable element
     * @returns {void}
     */
    focusNextPrev: function focusNextPrev(opt, node) {
      if (node && typeof opt === 'string') {
        opt = opt.toLowerCase();
        var focusables = this.getFocusables(node);
        var elements = focusables.elements;
        var len = elements.length;
        var index = focusables.index;

        if (/\b(next|prev)\b/g.test(opt)) {
          index = opt === 'next' ? index + 1 >= len ? 0 : index + 1 : index - 1 < 0 ? len : index - 1;
          elements.eq(index).focus();
        }
      }
    },

    /**
     * Does the column editor have a text field.
     * @private
     * @param  {object} container The dom element
     * @returns {boolean} If it does or not
     */
    containsTextField: function containsTextField(container) {
      var noTextTypes = ['image', 'button', 'submit', 'reset', 'checkbox', 'radio'];
      var selector = 'textarea, input';
      var l = noTextTypes.length;
      var i;
      selector += l ? ':not(' : '';

      for (i = 0; i < l; i++) {
        selector += "[type=".concat(noTextTypes[i], "],");
      }

      selector = l ? "".concat(selector.slice(0, -1), ")") : '';
      return !!$(selector, container).length;
    },

    /**
     * Does the column editor have a picker/trigger field.
     * @private
     * @param  {object} container The dom element
     * @returns {boolean} If it does or not
     */
    containsTriggerField: function containsTriggerField(container) {
      var selector = '.dropdown, .datepicker, .lookup';
      return !$(selector, container).length;
    },

    /**
     * Returns if the row has been disabled.
     * @param  {number} row The row index.
     * @returns {boolean} eturns true if the row is disabled
     */
    isRowDisabled: function isRowDisabled(row) {
      if (this.settings.isRowDisabled && typeof this.settings.isRowDisabled === 'function') {
        var rowNode = this.rowNodes(row);

        if (rowNode.attr('aria-disabled') === 'true') {
          return true;
        }
      }

      return false;
    },

    /**
     * Is a specific row/cell editable?
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     * @returns {boolean} returns true if the cell is editable
     */
    isCellEditable: function isCellEditable(row, cell) {
      if (!this.settings.editable) {
        return false;
      }

      var col = this.columnSettings(cell);

      if (col.readonly) {
        return false;
      }

      if (this.isRowDisabled(row) || !this.activeCell.node) {
        return false;
      } // Check if cell is editable via hook function


      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper');
      var cellValue = cellNode.text() ? cellNode.text() : this.fieldValue(this.settings.dataset[row], col.field);

      if (col.isEditable) {
        var rowData = this.settings.dataset[row];

        if (this.settings.treeDepth && this.settings.treeDepth[row]) {
          rowData = this.settings.treeDepth[row].node;
        }

        var canEdit = col.isEditable(row, cell, cellValue, col, rowData, this, 'is-editable');

        if (!canEdit) {
          return false;
        }
      }

      if (!col.editor) {
        return false;
      }

      return true;
    },

    /**
     * Invoked in three cases
     * 1) a row click
     * 2) keyboard and enter
     * 3) In actionable mode and tabbing
     * @private
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     * @param  {object} event The event information.
     * @returns {boolean} returns true if the cell is editable
     */
    makeCellEditable: function makeCellEditable(row, cell, event) {
      var _this$editor;

      if (this.activeCell.node.closest('tr').hasClass('datagrid-summary-row')) {
        return;
      } // Already in edit mode


      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper');
      var cellParent = cellNode.parent('td');
      var treeNode = $('.datagrid-tree-node', cellNode).length > 0;
      var treeExpandBtn = $('.datagrid-expand-btn', cellNode).length > 0;

      if (cellParent.hasClass('is-editing') || cellParent.hasClass('is-editing-inline')) {
        return false; // eslint-disable-line
      } // Commit Previous Edit


      if (this.editor && this.editor.input) {
        this.commitCellEdit();
      } // Locate the Editor


      var col = this.columnSettings(cell); // Select the Rows if the cell is editable

      if (!col.editor) {
        if (event.keyCode === 32 && !$(event.currentTarget).find('.datagrid-selection-checkbox').length) {
          this.toggleRowSelection(this.activeCell.node.closest('tr'));
        }

        return false; // eslint-disable-line
      }

      var thisRow = this.actualRowNode(row);
      var idx = this.settings.treeGrid ? this.actualPagingRowIndex(this.actualRowIndex(thisRow)) : this.dataRowIndex(thisRow);
      var rowData = this.rowData(idx);
      var isEditor = $('.is-editor', cellParent).length > 0;
      var isPlaceholder = $('.is-placeholder', cellNode).length > 0;
      var cellValue = cellNode.text() ? cellNode.text() : this.fieldValue(rowData, col.field);

      if (isEditor || isPlaceholder) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      if (!this.isCellEditable(idx, cell)) {
        return false; // eslint-disable-line
      }

      if (treeExpandBtn || treeNode) {
        if (treeExpandBtn) {
          cellValue = $('> span', cellNode).text();
        }

        if (typeof cellValue === 'string') {
          cellValue = cellValue.replace(/^\s/, '');
        }
      } // In Show Editor mode the editor is on form already


      if (!col.inlineEditor) {
        if (isEditor) {
          cellNode.css({
            position: 'static',
            height: cellNode.outerHeight()
          });
        }

        cellParent.addClass('is-editing');
        cellNode.empty();
      } else {
        cellParent.addClass('is-editing-inline');
      }

      cellValue = xssUtils.sanitizeConsoleMethods(cellValue);
      /**
      * Fires before a cell goes into edit mode. Giving you a chance to adjust column settings.
      * @event beforeentereditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */

      this.element.triggerHandler('beforeentereditmode', [{
        row: idx,
        cell: cell,
        item: rowData,
        target: cellNode,
        value: cellValue,
        column: col,
        editor: this.editor
      }]);

      if (this.visibleColumns().length === 1) {
        cellParent.addClass('has-singlecolumn');
      }

      this.editor = new col.editor(idx, cell, cellValue, cellNode, col, event, this, rowData); // eslint-disable-line

      this.editor.row = idx;
      this.editor.cell = cell;

      if (this.settings.onEditCell) {
        this.settings.onEditCell(this.editor);
      }

      if (this.editor.useValue) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      this.editor.val(cellValue); // Set original data for trackdirty

      if (this.settings.showDirty) {
        var originalVal = cellValue;

        if (originalVal === '' && /checkbox|favorite/i.test(this.getEditorName(this.editor))) {
          originalVal = false;
        }

        var data = {
          originalVal: originalVal,
          isDirty: false
        };
        this.addToDirtyArray(idx, cell, data);
      }

      this.editor.focus(); // Make sure the first keydown gets captured and trigger the dropdown

      if ((_this$editor = this.editor) !== null && _this$editor !== void 0 && (_this$editor == null ? void 0 : _this$editor.input.is('.dropdown')) && event.keyCode && ![9, 13, 32, 37, 38, 39, 40].includes(event.keyCode)) {
        var dropdownApi = this.editor.input.data('dropdown');
        dropdownApi.handleAutoComplete(event);
      }
      /**
      * Fires after a cell goes into edit mode.
      * @event entereditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */


      this.element.triggerHandler('entereditmode', [{
        row: idx,
        cell: cell,
        item: rowData,
        target: cellNode,
        value: cellValue,
        column: col,
        editor: this.editor
      }]);
      return true; //eslint-disable-line
    },

    /**
     * Get the data for a row node
     * @private
     * @param {object} rowIdx The jquery row node.
     * @returns {object} The row of data from the dataset.
     */
    rowData: function rowData(rowIdx) {
      if (this.settings.groupable) {
        return this.originalDataset[rowIdx];
      }

      return this.settings.treeGrid ? this.settings.treeDepth[rowIdx].node : this.settings.dataset[rowIdx];
    },

    /**
     * Commit the cell thats currently in edit mode.
     * @param {boolean} isCallback Indicates a call back so beforeCommitCellEdit is not called.
     */
    commitCellEdit: function commitCellEdit(isCallback) {
      if (!this.editor) {
        return;
      }

      var input = this.editor.input;
      var newValue;
      var cellNode;
      var editorName = this.getEditorName(this.editor);
      var isEditor = editorName === 'editor';
      var isFileupload = editorName === 'fileupload';
      var isUseActiveRow = !input.is('.timepicker, .datepicker, .lookup, .spinbox, .colorpicker'); // Editor.getValue

      if (typeof this.editor.val === 'function') {
        newValue = this.editor.val();
      }

      if (isEditor) {
        cellNode = this.editor.td;
      } else if (isFileupload) {
        if (this.editor.status === 'clear') {
          newValue = '';
        } else if (this.editor.status === 'init' || this.editor.status === 'cancel') {
          newValue = this.editor.originalValue;
        } // Fix: Not sure why, but `input.closest('td')` did not work


        cellNode = this.tableBody.find("#".concat(input.attr('id'))).closest('td');
        newValue = xssUtils.escapeHTML(newValue);
      } else {
        cellNode = input.closest('td');
        newValue = xssUtils.escapeHTML(newValue);
      }

      var rowIndex;
      var dataRowIndex;

      if (this.settings.source !== null && isUseActiveRow) {
        rowIndex = this.activeCell.rowIndex;
        dataRowIndex = this.activeCell.dataRow;
      } else {
        rowIndex = this.actualRowIndex(cellNode.parent());
        dataRowIndex = this.dataRowIndex(cellNode.parent());
      }

      var cell = cellNode.attr('aria-colindex') - 1;
      var col = this.columnSettings(cell);
      var rowData = this.settings.treeGrid ? this.settings.treeDepth[dataRowIndex].node : this.getActiveDataset()[dataRowIndex];
      var oldValue = this.fieldValue(rowData, col.field);

      if (col.beforeCommitCellEdit && !isCallback) {
        var vetoCommit = col.beforeCommitCellEdit({
          cell: cell,
          row: dataRowIndex,
          item: rowData,
          editor: this.editor,
          api: this
        });

        if (vetoCommit === false) {
          return;
        }
      }

      if (!this.editor) {
        return;
      } // Sanitize console methods


      oldValue = xssUtils.sanitizeConsoleMethods(oldValue);
      newValue = xssUtils.sanitizeConsoleMethods(newValue); // Format Cell again

      var isInline = cellNode.hasClass('is-editing-inline');
      cellNode.removeClass('is-editing is-editing-inline has-singlecolumn'); // Editor.destroy

      this.editor.destroy();
      this.editor = null; // Save the Cell Edit back to the data set

      this.updateCellNode(this.settings.groupable ? dataRowIndex : rowIndex, cell, newValue, false, isInline);
      var value = this.fieldValue(rowData, col.field);
      /**
      * Fires after a cell goes out of edit mode.
      * @event exiteditmode
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {number} args.row An array of selected rows.
      * @property {number} args.cell An array of selected rows.
      * @property {object} args.item The current sort column.
      * @property {HTMLElement} args.target The cell html element that was entered.
      * @property {any} args.value The cell value.
      * @property {any} args.oldValue The previous cell value.
      * @property {object} args.column The column object
      * @property {object} args.editor The editor object.
      */

      this.element.triggerHandler('exiteditmode', [{
        row: rowIndex,
        cell: cell,
        item: rowData,
        target: cellNode,
        value: value,
        oldValue: oldValue,
        column: col,
        editor: this.editor
      }]);
    },

    /**
     * Run validation for the column, for a particular cell.
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     */
    validateCell: function validateCell(row, cell) {
      var _$,
          _this16 = this;

      var self = this;
      var column = this.columnSettings(cell);
      var validate = column.validate;
      var validationType;

      if (!validate) {
        return;
      }

      var dfd;
      var dfds = [];
      var rules = column.validate.split(' ');
      var validator = $.fn.validation;
      var cellValue = this.fieldValue(this.settings.dataset[row], column.field);
      var messages = [];
      var messageText = '';
      var i;

      function manageResult(result, displayMessage, ruleName, dfrd) {
        var rule = validator.rules[ruleName];
        validationType = $.fn.validation.ValidationTypes[rule.type] || $.fn.validation.ValidationTypes.error;
        messageText = '';

        if (messages[validationType.type]) {
          messageText = messages[validationType.type];
        }

        if (!result && displayMessage) {
          if (messageText) {
            messageText = (/^\u2022/.test(messageText) ? '' : "\u2022 ") + messageText;
            messageText += "<br/>".concat("\u2022 ", rule.message);
          } else {
            messageText = rule.message;
          }

          messages[validationType.type] = messageText;
        }

        dfrd.resolve();
      }

      for (i = 0; i < rules.length; i++) {
        var rule = validator.rules[rules[i]];
        var gridInfo = {
          row: row,
          cell: cell,
          item: this.settings.dataset[row],
          column: column,
          grid: self
        };
        dfd = $.Deferred();

        if (rule.async) {
          rule.check(cellValue, $('<input>').val(cellValue), gridInfo, manageResult, dfd);
        } else {
          manageResult(rule.check(cellValue, $('<input>').val(cellValue), gridInfo), true, rules[i], dfd);
        }

        dfds.push(dfd);
      }

      (_$ = $).when.apply(_$, dfds).then(function () {
        var validationTypes = $.fn.validation.ValidationTypes;

        for (var props in validationTypes) {
          // eslint-disable-line
          messageText = '';
          validationType = validationTypes[props];

          if (messages[validationType.type]) {
            messageText = messages[validationType.type];
          }

          if (messageText !== '') {
            self.showCellError(row, cell, messageText, validationType.type);

            var rowNode = _this16.dataRowNode(row);

            self.element.trigger("cell".concat(validationType.type), {
              row: row,
              cell: cell,
              message: messageText,
              target: _this16.cellNode(rowNode, cell),
              value: cellValue,
              column: column
            });
          } else {
            self.clearCellError(row, cell, validationType.type);
          }
        }
      });
    },

    /**
    * Show the cell errors.
    * @param  {number} row The row index.
    * @param  {number} cell The cell index.
    * @param  {string} message The message text.
    * @param  {string} type The message type (infor, error, alert )
    * @returns {void}
    */
    showCellError: function showCellError(row, cell, message, type) {
      var rowNode = this.dataRowNode(row);
      var node = this.cellNode(rowNode, cell); // clear the table nonVisibleCellErrors for the row and cell

      this.clearNonVisibleCellErrors(row, cell, type);

      if (!node.length) {
        // Store the nonVisibleCellError
        this.nonVisibleCellErrors.push({
          row: row,
          cell: cell,
          message: message,
          type: type
        });
        this.showNonVisibleCellErrors();
        return;
      } // Add icon and classes


      node.addClass(type).attr("data-".concat(type, "message"), message); // Add and show tooltip

      var icon = node.find(".icon-".concat(type));

      if (!icon.length) {
        var wrapper = node.find('.datagrid-cell-wrapper');
        wrapper.append($($.createIcon({
          classes: ["icon-".concat(type)],
          icon: type
        })));
        icon = node.find(".icon-".concat(type));
        var tooltip = {
          forced: true,
          placement: 'bottom',
          content: message,
          isError: type === 'error' || type === 'dirtyerror',
          wrapper: icon
        };
        this.cacheTooltip(icon, tooltip);
        this.setupTooltips(false, true);
      }
    },

    /**
     * Show all non visible cell errors
     * @private
     * @returns {void}
     */
    showNonVisibleCellErrors: function showNonVisibleCellErrors() {
      var _this17 = this;

      // Create empty toolbar
      if (!this.toolbar) {
        this.settings.toolbar = {
          title: ' '
        };
        this.appendToolbar();
      }

      if (this.nonVisibleCellErrors.length === 0) {
        // remove table-error when not required
        if (this.toolbar && this.toolbar.parent().find('.table-errors').length === 1) {
          this.toolbar.parent().find('.table-errors').remove();
        }
      } else {
        var _loop4 = function _loop4(props) {
          // eslint-disable-line
          var validationType = $.fn.validation.ValidationTypes[props].type;
          var errors = $.grep(_this17.nonVisibleCellErrors, function (error) {
            return error.type === validationType;
          });

          _this17.showNonVisibleCellErrorType(errors, validationType);
        };

        // process via type
        for (var props in $.fn.validation.ValidationTypes) {
          _loop4(props);
        }
      }
    },

    /**
     * Show all non visible cell errors, for a given message/validation type.
     * @private
     * @param  {array} nonVisibleCellErrors An array of non visible cells, in error state.
     * @param  {string} type The message type to show
     */
    showNonVisibleCellErrorType: function showNonVisibleCellErrorType(nonVisibleCellErrors, type) {
      var messages;
      var tableerrors;
      var icon;
      var i;
      var nonVisiblePages = [];
      var validationType = $.fn.validation.ValidationTypes[type] || $.fn.validation.ValidationTypes.error;

      if (this.toolbar.parent().find('.table-errors').length === 1) {
        tableerrors = this.toolbar.parent().find('.table-errors');
      }

      if (nonVisibleCellErrors.length === 0) {
        // clear the displayed message
        if (tableerrors && tableerrors.length) {
          icon = tableerrors.find(".icon-".concat(validationType.type));
          this.hideTooltip();
          tableerrors.find(".icon-".concat(validationType.type)).remove();
        }

        return;
      } // Process message type, so it displays one message per page


      for (i = 0; i < nonVisibleCellErrors.length; i++) {
        var page = Math.floor((nonVisibleCellErrors[i].row + this.settings.pagesize) / this.settings.pagesize);

        if ($.inArray(page, nonVisiblePages) === -1) {
          nonVisiblePages.push(page);
        }
      }

      for (i = 0; i < nonVisiblePages.length; i++) {
        messages = "".concat((messages ? "".concat(messages, "<br>") : '') + Locale.translate(validationType.pagingMessageID), " ").concat(nonVisiblePages[i]);
      }

      if (this.toolbar.parent().find('.table-errors').length === 0) {
        tableerrors = $('<div class="table-errors"></div>');
      }

      icon = tableerrors.find(".icon-".concat(type));

      if (!icon.length) {
        tableerrors.append($($.createIcon({
          classes: ["icon-".concat(type)],
          icon: type
        })));
        icon = tableerrors.find(".icon-".concat(type));
      }

      if (this.element.hasClass('has-toolbar')) {
        // Add Error to the Toolbar
        this.toolbar.children('.title').append(tableerrors);
      }

      this.cacheTooltip(icon, {
        forced: true,
        placement: 'bottom',
        content: messages,
        isError: type === 'error' || type === 'dirtyerror',
        wrapper: icon
      });
      this.setupTooltips(false, true);
    },

    /**
     * Clear all error for a given cell in a row
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @returns {void}
     */
    clearAllCellError: function clearAllCellError(row, cell) {
      var validationTypes = $.fn.validation.ValidationTypes;

      for (var props in validationTypes) {
        // eslint-disable-line
        var validationType = validationTypes[props];
        this.clearCellError(row, cell, validationType.type);
      }
    },

    /**
     * Clear a cell with an error of a given type
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @param {string} type of error.
     * @returns {void}
     */
    clearCellError: function clearCellError(row, cell, type) {
      this.clearNonVisibleCellErrors(row, cell, type);
      var rowNode = this.dataRowNode(row);
      var node = this.cellNode(rowNode, cell);

      if (!node.length) {
        return;
      }

      this.clearNodeErrors(node, type);
    },

    /**
     * Clear a non visible cells from errors of a given type
     * @private
     * @param {number} row The row index.
     * @param {number} cell The cell index.
     * @param {string} type of error.
     * @returns {void}
     */
    clearNonVisibleCellErrors: function clearNonVisibleCellErrors(row, cell, type) {
      if (!this.nonVisibleCellErrors.length) {
        return;
      }

      if (this.toolbar && this.toolbar.parent() && this.toolbar.parent().find('.table-errors').length > 0) {
        var icon = this.toolbar.parent().find('.table-errors').find(".icon-".concat(type));

        if (icon.length) {
          var nonVisibleCellTypeErrors = $.grep(this.nonVisibleCellErrors, function (error) {
            if (error.type === type) {
              return error;
            }

            return '';
          }); // No remaining cell errors of this type

          if (!nonVisibleCellTypeErrors.length) {
            icon.remove();
          }
        }
      }

      this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
        if (!(error.row === row && error.cell === cell && error.type === type)) {
          return error;
        }

        return '';
      });

      if (!this.nonVisibleCellErrors.length) {
        this.showNonVisibleCellErrors();
      }
    },

    /**
     * Clear a row level all errors, alerts, info messages
     * @param {number} row The row index.
     * @returns {void}
     */
    clearRowError: function clearRowError(row) {
      var classList = 'error alert rowstatus-row-error rowstatus-row-alert rowstatus-row-info rowstatus-row-in-progress rowstatus-row-success';
      var rowNode = this.dataRowNode(row);
      rowNode.removeClass(classList);
      this.rowStatus(row, '', '');

      for (var cell = 0; cell < this.settings.columns.length; cell++) {
        this.clearAllCellError(row, cell);
      }
    },

    /**
     * Clear all errors, alerts and info messages in entire datagrid.
     * @returns {void}
     */
    clearAllErrors: function clearAllErrors() {
      var rowStatus = 0;

      for (var row = 0; row < this.settings.dataset.length; row++) {
        if (this.settings.dataset[row].rowStatus) {
          delete this.settings.dataset[row].rowStatus;
          rowStatus++;
        }

        for (var cell = 0; cell < this.settings.columns.length; cell++) {
          this.clearAllCellError(row, cell);
        }
      }

      if (rowStatus > 0) {
        this.render();
      }
    },

    /**
     * Remove messages form a cell element.
     * @private
     * @param {object} node cell element.
     * @param {string} type of messages.
     * @returns {void}
     */
    clearNodeErrors: function clearNodeErrors(node, type) {
      node = node instanceof jQuery ? node[0] : node;
      node.classList.remove(type);
      node.removeAttribute("data-".concat(type, "message"));
      var icon = node.querySelector(".icon-".concat(type));

      if (icon) {
        icon.parentNode.removeChild(icon);
        this.hideTooltip();
      }
    },

    /**
    * Set the row status on a row to none.
    * @returns {void}
    */
    resetRowStatus: function resetRowStatus() {
      var errors = this.settings.dataset.filter(function (row) {
        return row.rowStatus;
      });

      for (var i = 0; i < errors.length; i++) {
        delete errors[i].rowStatus;
      }

      if (errors.length > 0) {
        this.render();
      } // Clear dirty cells


      this.clearDirty();
    },

    /**
     * Clear dirty css class on all cells for given parent element.
     * @private
     * @param  {object} elem The parent element.
     * @returns {void}
     */
    clearDirtyClass: function clearDirtyClass(elem) {
      elem = elem instanceof jQuery ? elem[0] : elem;

      if (elem) {
        var cells = [].slice.call(elem.querySelectorAll('.is-dirty-cell'));
        cells.forEach(function (cell) {
          cell.classList.remove('is-dirty-cell');
        });
      }
    },

    /**
     * Clear all dirty cells.
     * @returns {void}
     */
    clearDirty: function clearDirty() {
      if (this.settings.showDirty) {
        this.clearDirtyClass(this.element);
        this.dirtyArray = undefined;
      }
    },

    /**
     * Clear all dirty cells in given row.
     * @param  {number} row The row index.
     * @returns {void}
     */
    clearDirtyRow: function clearDirtyRow(row) {
      if (this.settings.showDirty && typeof row === 'number') {
        var rowNode = this.rowNodes(row);
        this.clearDirtyClass(rowNode);

        if (this.dirtyArray) {
          this.dirtyArray[row] = undefined;
        }
      }
    },

    /**
     * Clear dirty on given cell.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @returns {void}
     */
    clearDirtyCell: function clearDirtyCell(row, cell) {
      if (this.settings.showDirty && this.dirtyArray && typeof row === 'number' && typeof cell === 'number') {
        var dirtyRow = this.dirtyArray[row];

        if (typeof dirtyRow !== 'undefined') {
          this.cellNode(row, cell).removeClass('is-dirty-cell');
          this.dirtyArray[row][cell] = undefined;
        }
      }
    },

    /**
    * Return all of the currently dirty cells.
    * @returns {array} An array of dirty cells.
    */
    dirtyCells: function dirtyCells() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var cells = [];

      if (s.showDirty && this.dirtyArray && this.dirtyArray.length) {
        for (var i = 0, l = dataset.length; i < l; i++) {
          var row = this.dirtyArray[i];

          if (typeof row !== 'undefined') {
            for (var i2 = 0, l2 = row.length; i2 < l2; i2++) {
              var col = row[i2];

              if (typeof col !== 'undefined' && col.isDirty) {
                cells.push(s.treeGrid ? dataset[i].node : dataset[i]);
              }
            }
          }
        }
      }

      return cells;
    },

    /**
    * Return all of the currently dirty rows by row index.
    * @returns {array} An array of dirty rows.
    */
    dirtyRows: function dirtyRows() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var rows = [];

      if (s.showDirty && this.dirtyArray && this.dirtyArray.length) {
        for (var i = 0, l = dataset.length; i < l; i++) {
          var row = this.dirtyArray[i];

          if (typeof row !== 'undefined') {
            for (var i2 = 0, l2 = row.length; i2 < l2; i2++) {
              var col = row[i2];

              if (typeof col !== 'undefined' && col.isDirty) {
                rows.push(s.treeGrid ? dataset[i].node : dataset[i]);
                break;
              }
            }
          }
        }
      }

      return rows;
    },

    /**
    * Return an array containing all of the currently modified rows, the type of modification
    * and the cells that are dirty and the data.
    * @param  {boolean} onlyChangedValues If true will return an array of only changed values
    * @returns {array} An array showing the dirty row info.
    */
    getModifiedRows: function getModifiedRows(onlyChangedValues) {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var modified = [];

      for (var i = 0; i < dataset.length; i++) {
        var node = s.treeGrid ? dataset[i].node : dataset[i];
        var data = {
          row: i,
          data: node,
          cells: []
        }; // First add the dirty rows

        if (this.isRowDirty(i)) {
          data.type = 'dirty'; // No need to run trhu columns loop, if need only changed values to returns

          for (var j = 0; !onlyChangedValues && j < this.dirtyArray[i].length; j++) {
            var cellData = this.dirtyArray[i][j];

            if (typeof cellData !== 'undefined' && cellData.isDirty) {
              data.cells.push({
                row: i,
                col: j,
                cellData: cellData
              });
            }
          }
        } // Now add error and in progress rows


        if (typeof node.rowStatus !== 'undefined' && (node.rowStatus.icon === 'error' || node.rowStatus.icon === 'in-progress')) {
          data.type = data.type === 'dirty' ? ['dirty', node.rowStatus.icon] : node.rowStatus.icon;
        } // Add to modified


        if (typeof data.type !== 'undefined') {
          modified.push(onlyChangedValues ? node : data);
        }
      }

      return modified;
    },

    /**
     * Show an error on a row of a given type.
     * @param  {number} row The row index.
     * @param  {string} message The row description.
     * @param  {string} type The error type.
     * @returns {void}
     */
    showRowError: function showRowError(row, message, type) {
      var messageType = type || 'error';
      var rowNode = this.dataRowNode(row);
      rowNode.addClass(type);
      this.rowStatus(row, messageType, message);
    },

    /**
     * Validate all visible cells in a row if they have validation on the column
     * @param  {number} row The row index.
     * @returns {void}
     */
    validateRow: function validateRow(row) {
      if (row === undefined) {
        return;
      }

      for (var i = 0; i < this.settings.columns.length; i++) {
        this.validateCell(row, i);
      }
    },

    /**
     * Validate all rows and cells in the entire grid if they have validation on the column
     * @returns {void}
     */
    validateAll: function validateAll() {
      for (var j = 0; j < this.settings.dataset.length; j++) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          this.validateCell(j, i);
        }
      }
    },

    /**
     * Get the settings for a column by index.
     * @private
     * @param  {number} idx The column index.
     * @returns {array} The settings array
     */
    columnSettings: function columnSettings(idx) {
      var foundColumn = this.settings.columns[idx];
      return foundColumn || {};
    },

    /**
     * Attempt to serialize the value back into the dataset
     * @private
     * @param {any} value The new column value
     * @param {any} oldVal The old column value.
     * @param {number} col The column definition
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @returns {void}
     */
    coerceValue: function coerceValue(value, oldVal, col, row, cell) {
      var newVal;

      if (col.serialize) {
        var s = this.settings;
        var dataset = s.treeGrid ? s.treeDepth : s.dataset;

        if (this.settings.groupable) {
          dataset = this.originalDataset || dataset;
        }

        var rowData = s.treeGrid ? dataset[row].node : dataset[row];
        newVal = col.serialize(value, oldVal, col, row, cell, rowData);
        return newVal;
      }

      if (col.sourceFormat) {
        if (value instanceof Date) {
          newVal = Locale.parseDate(value, col.sourceFormat);
        } else {
          newVal = Locale.formatDate(value, {
            pattern: col.sourceFormat
          });
        }
      } else if (typeof oldVal === 'number' && value) {
        newVal = Locale.parseNumber(value); // remove thousands sep , keep a number a number
      }

      return newVal;
    },

    /**
     * Update one cell with a specific value
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @param {any} value The value to use.
     * @returns {void}
     */
    updateCell: function updateCell(row, cell, value) {
      var col = this.columnSettings(cell);

      if (value === undefined) {
        value = this.fieldValue(this.settings.dataset[row], col.field);
      }

      this.updateCellNode(row, cell, value, true);
    },

    /**
     * Update one cell with a specific value
     * @private
     * @param {number} row  The row index.
     * @param {number} cell The cell index.
     * @param {any} value The value to use.
     * @param {boolean} fromApiCall Comes from an api call.
     * @param {boolean} isInline If the editor is an inline value.
     * @returns {void}
     */
    updateCellNode: function updateCellNode(row, cell, value, fromApiCall, isInline) {
      var coercedVal;
      var rowNodes = this.settings.groupable ? this.rowNodesByDataIndex(row) : this.rowNodes(row);
      var cellNode = rowNodes.find('td').eq(cell);
      var col = this.settings.columns[cell] || {};
      var formatted = '';
      var formatter = col.formatter ? col.formatter : this.defaultFormatter;
      var isEditor = $('.editor', cellNode).length > 0;
      var isTreeGrid = this.settings.treeGrid;
      var dataRowIndex = isTreeGrid ? this.actualPagingRowIndex(this.actualRowIndex(rowNodes)) : this.dataRowIndex(rowNodes);

      if (dataRowIndex === null || dataRowIndex === undefined || isNaN(dataRowIndex)) {
        dataRowIndex = row;
      }

      var rowData = this.rowData(dataRowIndex);

      if (rowNodes.length === 0 && this.settings.paging) {
        rowNodes = this.visualRowNode(row);
        cellNode = rowNodes.find('td').eq(cell);
      }

      var oldVal = this.fieldValue(rowData, col.field); // Coerce/Serialize value if from cell edit

      if (!fromApiCall) {
        coercedVal = this.coerceValue(value, oldVal, col, row, cell); // coerced value may be coerced to empty string, null, or 0

        if (coercedVal === undefined) {
          coercedVal = value;
        }
      } else {
        coercedVal = value;
      } // Remove rowStatus icon


      if (rowNodes.length && rowData && !rowData.rowStatus) {
        var rowstatusIcon = rowNodes.find('svg.icon-rowstatus');

        if (rowstatusIcon.length) {
          rowstatusIcon.remove();
        }
      } // Remove older tooltip data


      this.removeTooltipData(cellNode); // Update the value in the dataset

      if (cell === 0 && rowData && rowData.rowStatus) {
        var svg = cellNode.find('svg.icon-rowstatus');

        if (rowNodes && cellNode[0]) {
          for (var i = 0; i < rowNodes.length; i++) {
            rowNodes[i].classList.add("rowstatus-row-".concat(rowData.rowStatus.icon));
          }

          cellNode[0].classList.add('rowstatus-cell');

          if (!svg.length) {
            var svgIcon = rowData.rowStatus.icon === 'success' ? '#icon-check' : '#icon-exclamation';
            cellNode.prepend("<svg class=\"icon icon-rowstatus\" focusable=\"false\" aria-hidden=\"true\" role=\"presentation\"><use href=\"".concat(svgIcon, "\"></use></svg>"));
          }
        }

        if (rowData.rowStatus.tooltip) {
          svg = cellNode.find('svg.icon-rowstatus');
          var statusIcon = rowData.rowStatus.icon;
          this.cacheTooltip(svg, {
            forced: true,
            placement: 'right',
            content: rowData.rowStatus.tooltip,
            isError: statusIcon === 'error' || statusIcon === 'dirtyerror',
            wrapper: cellNode
          });
        }
      }

      coercedVal = xssUtils.unescapeHTML(coercedVal);

      if (col.field && coercedVal !== oldVal) {
        if (col.field.indexOf('.') > -1) {
          var rowDataObj = rowData;
          var nbrParts = col.field.split('.').length;
          col.field.split('.').forEach(function (part, index) {
            if (index === nbrParts - 1) {
              rowDataObj[part] = coercedVal;
            } else {
              rowDataObj = rowDataObj[part];
            }
          });
        } else {
          rowData[col.field] = coercedVal;
        }
      } // Adjust leading/trailing spaces as `&nbsp;`


      var adj = function adj(thisVal, regx) {
        var r = (typeof thisVal === 'string' ? thisVal.match(regx) : ['']) || [''];
        return r[0].replace(/\s/g, '&nbsp;');
      }; // update cell value


      var escapedVal = xssUtils.escapeHTML(coercedVal);
      var val = isEditor ? coercedVal : escapedVal;

      if (typeof val === 'string') {
        val = "".concat(adj(val, /^\s*/)).concat(val.trim()).concat(adj(val, /\s*$/));
      }

      formatted = this.formatValue(formatter, row, cell, val, col, rowData);

      if (col.contentVisible) {
        var canShow = col.contentVisible(row, cell, escapedVal, col, rowData);

        if (!canShow) {
          formatted = '';
        }
      }

      if (!isInline) {
        cellNode.find('.datagrid-cell-wrapper').html(formatted);
      }

      if (!fromApiCall) {
        // Validate the cell
        this.validateCell(dataRowIndex, cell); // Update and set trackdirty

        if (!this.isDirtyCellUndefined(row, cell)) {
          this.dirtyArray[row][cell].value = value;
          this.dirtyArray[row][cell].coercedVal = coercedVal;
          this.dirtyArray[row][cell].escapedCoercedVal = xssUtils.escapeHTML(coercedVal);
          this.dirtyArray[row][cell].cellNodeText = cellNode.text();
          this.dirtyArray[row][cell].cell = cell;
          this.dirtyArray[row][cell].column = this.settings.columns[cell];
          this.setDirtyCell(row, cell);
        }
      } // resize on change


      if (this.settings.stretchColumnOnChange && col) {
        var newWidth = this.calculateTextWidth(col); // make sure that the column is at least the minimum width

        if (col.minWidth && newWidth < col.minWidth) {
          newWidth = col.minWidth;
        } // make sure that the column is no more than the maximum width


        if (col.minWidth && newWidth > col.maxWidth) {
          newWidth = col.maxWidth;
        }

        if (newWidth > 0 && newWidth - this.stretchColumnWidth > this.stretchColumnDiff) {
          this.stretchColumnWidth = newWidth;
          this.stretchColumnDiff = 0;
          this.setColumnWidth(col.id, newWidth, true);
        }
      } // Sanitize console methods


      oldVal = xssUtils.sanitizeConsoleMethods(oldVal);
      coercedVal = xssUtils.sanitizeConsoleMethods(coercedVal);
      var isCellChange;

      if (typeof oldVal === 'string' && typeof coercedVal === 'string') {
        // Some reasion compare spaces not in match, use `&nbsp;` leading/trailing spaces
        var values = {
          oldVal: "".concat(adj(oldVal, /^\s*/)).concat(oldVal.trim()).concat(adj(oldVal, /\s*$/)),
          coercedVal: "".concat(adj(coercedVal, /^\s*/)).concat(coercedVal.trim()).concat(adj(coercedVal, /\s*$/))
        };
        isCellChange = values.coercedVal !== values.oldVal && !fromApiCall;
      } else {
        isCellChange = coercedVal !== oldVal && !fromApiCall;
      }

      if (isCellChange) {
        // if (coercedVal !== oldVal && !fromApiCall) {
        var args = {
          row: this.settings.source !== null ? dataRowIndex : row,
          relativeRow: row,
          cell: cell,
          target: cellNode,
          value: coercedVal,
          oldValue: oldVal,
          column: col,
          api: this
        };
        args.rowData = isTreeGrid && this.settings.treeDepth[row] ? this.settings.treeDepth[row].node : rowData;
        /**
         * Fires when a cell value is changed via the editor.
         * @event cellchange
         * @memberof Datagrid
         * @property {object} event The jquery event object
         * @property {object} args Additional arguments
         * @property {number} args.row An array of selected rows.
         * @property {number} args.cell An array of selected rows.
         * @property {HTMLElement} args.target The cell html element that was entered.
         * @property {any} args.value The cell value.
         * @property {any} args.oldValue The previous cell value.
         * @property {object} args.column The column object
         */

        this.element.trigger('cellchange', args);
        this.wasJustUpdated = true;
      }
    },

    /**
     * Function to check if given row has true value for isDirty in any cell in it
     * @private
     * @param {number} rowIndex The row index
     * @returns {boolean} true if isDirty
     */
    isRowDirty: function isRowDirty(rowIndex) {
      var isDirty = false;

      if (typeof rowIndex === 'number' && this.dirtyArray && this.dirtyArray.length) {
        var row = this.dirtyArray[rowIndex];

        if (typeof row !== 'undefined') {
          for (var i = 0, l = row.length; i < l; i++) {
            var col = row[i];

            if (typeof col !== 'undefined' && col.isDirty) {
              isDirty = true;
              break;
            }
          }
        }
      }

      return isDirty;
    },

    /**
     * Function to check if given cell has true value for isDirty
     * @private
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @returns {boolean} true if isDirty
     */
    isCellDirty: function isCellDirty(row, cell) {
      return this.isDirtyCellUndefined(row, cell) ? false : this.dirtyArray[row][cell].isDirty;
    },

    /**
     * Function to add a dirty entry to the array
     * @param {number} row  The row index
     * @param {number} cell The cell index
     * @param {object} data The cell data to add
     */
    addToDirtyArray: function addToDirtyArray(row, cell, data) {
      if (typeof this.dirtyArray === 'undefined') {
        this.dirtyArray = [];
      }

      if (typeof this.dirtyArray[row] === 'undefined') {
        this.dirtyArray[row] = [];
        this.dirtyArray[row][cell] = data;
      } else if (typeof this.dirtyArray[row][cell] === 'undefined') {
        this.dirtyArray[row][cell] = data;
      }
    },

    /**
     * Set a cell to dirty and add the dirty icon internally.
     * @private
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @param {object} dirtyOptions The cell dirty options
     * @returns {void}
     */
    setDirtyCell: function setDirtyCell(row, cell, dirtyOptions) {
      var cellNode = this.cellNode(row, cell);

      if (dirtyOptions) {
        this.addToDirtyArray(row, cell, dirtyOptions);
      }

      var d = this.dirtyArray[row][cell];

      if (d.originalVal === d.value || d.originalVal === d.coercedVal || d.originalVal === d.escapedCoercedVal || d.originalVal === d.cellNodeText) {
        this.dirtyArray[row][cell].isDirty = false;
        this.setDirtyIndicator(row, cell, false);
      } else {
        this.dirtyArray[row][cell].isDirty = true;
        cellNode[0].classList.add('is-dirty-cell');
        this.setDirtyIndicator(row, cell, true);
      }
    },

    /**
     *  Set a cell to dirty and add the dirty icon visually.
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @param {boolean} toggle True to set it and false to remove it
     * @param {object} data Adds dirty data to the internal tracker
     */
    setDirtyIndicator: function setDirtyIndicator(row, cell, toggle, data) {
      var cellNode = this.cellNode(row, cell);

      if (data) {
        this.addToDirtyArray(row, cell, data);
      }

      if (row < 0 || cell < 0 || !cellNode.length) {
        return;
      }

      if (toggle) {
        cellNode[0].classList.add('is-dirty-cell');
      } else {
        cellNode[0].classList.remove('is-dirty-cell');
      }
    },

    /**
     * Function to check given cell is cache to dirtyArray
     * @private
     * @param {number} row The row index
     * @param {number} cell The cell index
     * @returns {boolean} true if found
     */
    isDirtyCellUndefined: function isDirtyCellUndefined(row, cell) {
      return !(this.settings.showDirty && typeof row === 'number' && typeof cell === 'number' && row > -1 && cell > -1 && typeof this.dirtyArray !== 'undefined' && typeof this.dirtyArray[row] !== 'undefined' && typeof this.dirtyArray[row][cell] !== 'undefined');
    },

    /**
     * For the row node get the index adjusting for paging / invisible rowsCache
     * @private
     * @param {number} row The row index
     * @returns {number} The row index adjusted for paging/non visible rows.
     */
    visualRowIndex: function visualRowIndex(row) {
      var selector = 'tr:visible:not(.is-hidden, .datagrid-expandable-row)';
      var idx = this.tableBody.find(selector).index(row);

      if (idx === -1 && this.tableBodyLeft) {
        idx = this.tableBodyLeft.find(selector).index(row);
      }

      if (idx === -1 && this.tableBodyRight) {
        idx = this.tableBodyRight.find(selector).index(row);
      }

      return idx;
    },

    /**
     * For the row index get the node adjusting for paging / invisible rowsCache
     * @private
     * @param {number} idx The row index
     * @returns {object} The row node adjusted for paging/non visible rows.
     */
    visualRowNode: function visualRowNode(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source) {
        rowIdx += (this.pagerAPI.activePage - 1) * this.settings.pagesize;
      }

      if (!this.isRowVisible(idx)) {
        return $([]);
      }

      return this.tableBody.find("tr[aria-rowindex=\"".concat(rowIdx + 1, "\"]"));
    },

    /**
     * For an internal row index, get the dataset row index
     * @private
     * @param {number} idx The row index
     * @returns {object} The row index in the dataset.
     */
    actualRowNode: function actualRowNode(idx) {
      return this.tableBody.find("tr[aria-rowindex=\"".concat(idx + 1, "\"]"));
    },

    /**
     * Returns the row dom jQuery node.
     * @param  {number} row The row index.
     * @returns {object} The dom jQuery node
     */
    rowNodes: function rowNodes(row) {
      var container = this.element;

      if (row instanceof jQuery) {
        container = row.closest('.datagrid-container');
        row = row.attr('aria-rowindex') - 1;
      }

      return container.find("> .datagrid-wrapper > table > tbody > tr[aria-rowindex=\"".concat(row + 1, "\"]"));
    },

    /**
     * Returns the row dom jQuery node.
     * @private
     * @param  {number} row The row index.
     * @returns {object} The dom jQuery node
     */
    rowNodesByDataIndex: function rowNodesByDataIndex(row) {
      if (row instanceof jQuery) {
        row = row.attr('data-index');
      }

      var leftNodes = this.tableBodyLeft ? this.tableBodyLeft.find("tr[data-index=\"".concat(row, "\"]")) : $();
      var centerNodes = this.tableBody.find("tr[data-index=\"".concat(row, "\"]"));
      var rightNodes = this.tableBodyRight ? this.tableBodyRight.find("tr[data-index=\"".concat(row, "\"]")) : $();
      return $(centerNodes).add(leftNodes).add(rightNodes);
    },

    /**
     * Returns the cell dom node.
     * @param  {number} row The row index.
     * @param  {number} cell The cell index.
     * @returns {object} The dom node
     */
    cellNode: function cellNode(row, cell) {
      var cells = this.settings.groupable ? this.rowNodesByDataIndex(row).find('td') : this.rowNodes(row).find('td');
      return cells.eq(cell >= cells.length ? cells.length - 1 : cell);
    },

    /**
     * For an internal row node, get the dataset row index.
     * @private
     * @param {number} row The row node.
     * @returns {object} The row index in the dataset.
     */
    actualRowIndex: function actualRowIndex(row) {
      row = row instanceof jQuery ? row : $(row);
      return row.attr('aria-rowindex') - 1;
    },

    /**
     * For an internal row index, get row index across page number.
     * This may or may not be the one in the dataset.
     * @private
     * @param {number} idx The row idx.
     * @returns {object} The row index
     */
    pagingRowIndex: function pagingRowIndex(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source && !this.settings.indeterminate) {
        rowIdx += (this.pagerAPI.activePage - 1) * this.settings.pagesize;
      }

      return rowIdx;
    },

    /**
     * For an internal row index, get row index across page number.
     * This may or may not be the one in the dataset.
     * @private
     * @param {number} idx The row idx.
     * @returns {object} The row index
     */
    actualPagingRowIndex: function actualPagingRowIndex(idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source && !this.settings.indeterminate) {
        rowIdx -= (this.pagerAPI.activePage - 1) * this.settings.pagesize;
      }

      return rowIdx;
    },

    /**
     * Return the data node for a row. This is the newer way of getting this info.
     * @private
     * @param {number} idx The row idx to find
     * @returns {object} The row node
     */
    dataRowNode: function dataRowNode(idx) {
      return this.tableBody.find("tr[data-index=\"".concat(idx, "\"]"));
    },

    /**
     * Return the data index for a row. This is the newer way of getting this info.
     * @private
     * @param {number} row The row idx
     * @returns {number} The row index in the dataset.
     */
    dataRowIndex: function dataRowIndex(row) {
      row = row instanceof jQuery ? row : $(row);
      return parseInt(row.attr('data-index'), 10);
    },

    /**
     * Sets focus on a cell.
     * @param  {number} row The row index
     * @param  {number} cell The cell index
     */
    setActiveCell: function setActiveCell(row, cell) {
      var self = this;
      var prevCell = self.activeCell;
      var rowElem = row;
      var rowNum;
      var rowIndex;
      var dataRowNum;
      var isGroupRow = row instanceof jQuery && row.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

      if (row instanceof jQuery && row.length === 0) {
        return;
      }

      if (typeof row === 'number') {
        rowNum = row;
        rowElem = this.tableBody.find('tr:visible').eq(row);
        rowIndex = this.actualRowIndex(rowElem);
        dataRowNum = this.dataRowIndex(rowElem);
      } // Support passing the td in to focus that cell


      if (row instanceof jQuery && row.is('td')) {
        isGroupRow = row.parent().is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

        if (isGroupRow) {
          rowElem = row.parent();
        }

        cell = row.attr('aria-colindex') - 1;
        rowNum = this.visualRowIndex(row.parent());
        rowIndex = this.actualRowIndex(row.parent());
        dataRowNum = this.dataRowIndex(row.parent());
        rowElem = row.parent();
      }

      if (row instanceof jQuery && row.is('tr')) {
        rowNum = this.visualRowIndex(row);
        rowIndex = this.actualRowIndex(row);
        dataRowNum = this.dataRowIndex(row);
        rowElem = row;
      }

      if (rowNum < 0 || cell < 0) {
        return;
      } // Remove previous tab index


      if (prevCell.node && prevCell.node.length === 1) {
        self.activeCell.node.removeAttr('tabindex').removeClass('is-active');
      } // Hide any cell tooltips (Primarily for validation)


      if (prevCell.cell !== cell || prevCell.row !== row) {
        self.hideTooltip();
      } // Find the cell if it exists


      self.activeCell.node = self.cellNode(isGroupRow || rowElem ? rowElem : rowIndex > -1 ? rowIndex : rowNum, cell).attr('tabindex', '0');

      if (self.activeCell.node && prevCell.node.length === 1) {
        self.activeCell.row = rowNum;
        self.activeCell.cell = cell;
        rowIndex = this.actualRowIndex(self.activeCell.node.parent());
        dataRowNum = this.dataRowIndex(self.activeCell.node.parent());
      } else {
        self.activeCell = prevCell;
      }

      if (!$('input, select, button:not(.btn-secondary, .row-btn, .datagrid-expand-btn, .datagrid-drilldown, .btn-icon)', self.activeCell.node).length || self.activeCell.node.is('.has-btn-actions') && self.activeCell.node.find('.btn-actions').length) {
        self.activeCell.node.focus();

        if (isGroupRow) {
          self.activeCell.groupNode = self.activeCell.node;
        }
      }

      if (self.activeCell.node.is('.is-focusable')) {
        self.activeCell.node.find('button').focus();
      }

      if (dataRowNum !== undefined) {
        self.activeCell.dataRow = dataRowNum;
      }

      if (rowIndex !== undefined) {
        self.activeCell.rowIndex = rowIndex;
      }

      var colSpan = +rowElem.find('td[colspan]').attr('colspan');

      if (isGroupRow && self.activeCell.node && prevCell.node && !(row instanceof jQuery && row.is('td'))) {
        if (cell < colSpan) {
          rowElem.find('td[colspan]').attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td[colspan]');
        } else if (cell >= colSpan) {
          rowElem.find('td').eq(cell - colSpan + 1).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell - colSpan + 1);
        } else {
          rowElem.find('td').eq(cell).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell);
        }
      }

      if (isGroupRow && row instanceof jQuery && row.is('td')) {
        self.activeCell.cell = colSpan - 1 + cell;

        if (row.is('[colspan]')) {
          self.activeCell.cell = cell;
        }
      }

      if (this.settings.cellNavigation) {
        var headers = self.headerNodes();
        var prevSpans = 0; // Check if any previous rows are spanned

        if (this.hasColSpans) {
          prevSpans = 0;
          headers.eq(cell).prevAll('[colspan]').each(function (i, elem) {
            var span = $(elem).attr('colspan') - 1;
            prevSpans += span;
          });
          cell -= prevSpans;
        }

        headers.removeClass('is-active');
        headers.eq(cell).addClass('is-active');
      }

      this.activeCell.isFocused = true; // Expand On Activate Feature

      var col = this.settings.columns[cell];

      if (col && col.expandOnActivate && this.activeCell && this.activeCell.node) {
        self.activeCell.node.addClass('is-active');
      }
      /**
      * Fires when a cell is focued.
      * @event activecellchange
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {HTMLElement} args.node  The cell element that was entered.
      * @property {number} args.cell The selected cell
      * @property {number} args.row The selected row
      */


      self.element.trigger('activecellchange', {
        node: this.activeCell.node,
        row: this.activeCell.row,
        cell: this.activeCell.cell,
        api: self
      });
    },

    /**
     * Sets focus to the next active cell, depending on a key.
     * @private
     * @param {object} e The event object
     */
    setNextActiveCell: function setNextActiveCell(e) {
      var self = this;

      if (e.type === 'keydown') {
        if (this.settings.actionableMode) {
          var keyCode = e.keyCode === 13 ? 40 : e.keyCode;

          if (keyCode === 32) {
            return;
          }

          setTimeout(function () {
            var evt = $.Event('keydown.datagrid');
            evt.keyCode = keyCode;
            self.activeCell.node.trigger(evt);
          }, 0);
        } else {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }
      }
    },

    /**
     * Add children to treegrid dataset
     * @private
     * @param {object} parent The parent object
     * @param {object} data The data for the child
     */
    addChildren: function addChildren(parent, data) {
      if (!data || data && !data.length || parent < 0) {
        return;
      }

      var node = this.settings.treeDepth[parent].node;
      node.children = node.children || []; // Make sure it's not reference pointer to data object, make copy of data

      data = JSON.parse(JSON.stringify(data));

      for (var i = 0, len = data.length; i < len; i++) {
        node.children.push(data[i]);
      }

      this.updateDataset(this.settings.dataset);
    },

    /**
     * Set the expanded property in the dataset
     * @private
     * @param {number} dataRowIndex The index in the dataset.
     * @param {boolean} isExpanded Expanded value to set.
     */
    setExpandedInDataset: function setExpandedInDataset(dataRowIndex, isExpanded) {
      this.settings.treeDepth[dataRowIndex].node.expanded = isExpanded;
    },

    /**
     * Expand the tree children
     * @private
     * @param {object} e The event data from the click or keyboard event.
     * @param {number} dataRowIndex Index in the dataset
     */
    toggleChildren: function toggleChildren(e, dataRowIndex) {
      if (this.settings.groupable) {
        return;
      }

      var self = this;
      var s = this.settings;
      var rowElement = this.rowNodes(dataRowIndex);
      var expandButton = rowElement.find('.datagrid-expand-btn');
      var level = parseInt(rowElement.attr('aria-level'), 10);
      var isExpanded = expandButton.hasClass('is-expanded');
      var args = [{
        grid: self,
        row: dataRowIndex,
        item: rowElement
      }];

      if (self.settings.treeDepth && self.settings.treeDepth[dataRowIndex]) {
        args[0].rowData = self.settings.treeDepth[dataRowIndex].node;
      }

      if (!rowElement.hasClass('datagrid-tree-parent') || !$(e.target).is(expandButton) && (self.settings.editable || self.settings.selectable)) {
        return;
      }

      var toggleExpanded = function toggleExpanded() {
        rowElement = self.rowNodes(dataRowIndex);
        expandButton = rowElement.find('.datagrid-expand-btn');
        var children = rowElement.nextUntil("[aria-level=\"".concat(level, "\"]"));
        var parentRowIdx = self.settings.treeGrid && self.settings.source && self.settings.paging ? self.dataRowIndex(rowElement) : dataRowIndex;

        if (isExpanded) {
          rowElement.attr('aria-expanded', false);
          expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');
        } else {
          rowElement.attr('aria-expanded', true);
          expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');
        }

        self.setExpandedInDataset(parentRowIdx, !isExpanded);

        var setChildren = function setChildren(elem, lev, expanded) {
          var nodes = elem.nextUntil("[aria-level=\"".concat(lev, "\"]"));

          if (expanded) {
            nodes.each(function () {
              var node = $(this);
              var nodeLevel = parseInt(node.attr('aria-level'), 10);

              if (nodeLevel > lev) {
                node.addClass('is-hidden');
              }
            });
          } else {
            nodes.each(function () {
              var node = $(this);
              var nodeLevel = parseInt(node.attr('aria-level'), 10); // Handles that child rows get the right states

              if (nodeLevel === lev + 1) {
                if (!node.hasClass('is-filtered')) {
                  node.removeClass('is-hidden');

                  if (self.settings.frozenColumns) {
                    var rowindex = node.attr('aria-rowindex');
                    self.tableBody.find("[aria-rowindex=\"".concat(rowindex, "\"]")).removeClass('is-hidden');
                  }
                }

                if (node.is('.datagrid-tree-parent')) {
                  var nodeIsExpanded = node.find('.datagrid-expand-btn.is-expanded').length > 0;

                  if (nodeIsExpanded) {
                    setChildren(node, nodeLevel, !nodeIsExpanded);
                  }
                }
              }
            });
          }
        };

        setChildren(rowElement, level, isExpanded);
        self.setAlternateRowShading();
        args.children = children;
      };
      /**
      * Fires when a row is collapsed to show its detail.
      * @event collapserow
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {object} args.self The grid api.
      * @property {number} args.row The selected row index
      * @property {object} args.item The selected row data.
      * @property {array} args.children The selected rows children (tree grid)
      */

      /**
      * Fires when a row is expanded to show its detail.
      * @event expandrow
      * @memberof Datagrid
      * @property {object} event The jquery event object
      * @property {object} args Additional arguments
      * @property {object} args.self The grid api.
      * @property {number} args.row The selected row index
      * @property {object} args.item The selected row data.
      * @property {array} args.children The selected rows children (tree grid)
      */


      var triggerEvent = isExpanded ? 'collapserow' : 'expandrow';
      $.when(self.element.triggerHandler(triggerEvent, args)).done(function (response) {
        var isFalse = function isFalse(v) {
          return typeof v === 'string' && v.toLowerCase() === 'false' || typeof v === 'boolean' && v === false || typeof v === 'number' && v === 0;
        };

        if (!isFalse(response)) {
          if (typeof s.onExpandChildren === 'function' && !isExpanded) {
            $.when(s.onExpandChildren(args[0])).done(function (res) {
              if (!isFalse(res)) {
                toggleExpanded();
              }
            });
          } else if (typeof s.onCollapseChildren === 'function' && isExpanded) {
            $.when(s.onCollapseChildren(args[0])).done(function (res) {
              if (!isFalse(res)) {
                toggleExpanded();
              }
            });
          } else {
            toggleExpanded();
          }
        }
      });
    },

    /**
     * Expand Detail Row Or Tree Row
     * @param  {number} dataRowIndex The row to toggle
     * @returns {void}
     */
    toggleRowDetail: function toggleRowDetail(dataRowIndex) {
      var self = this;
      var rowElement = self.rowNodes(dataRowIndex);

      if (!rowElement.length && self.settings.paging && (self.settings.rowTemplate || self.settings.expandableRow)) {
        dataRowIndex += (self.pagerAPI.activePage - 1) * self.settings.pagesize;
        rowElement = self.dataRowNode(dataRowIndex);
      }

      var expandRow = rowElement.next();
      var expandButton = rowElement.find('.datagrid-expand-btn');
      var detail = expandRow.find('.datagrid-row-detail');
      var item = self.settings.dataset[self.dataRowIndex(rowElement)];

      if (rowElement.hasClass('datagrid-tree-parent')) {
        return;
      }

      if (self.settings.allowOneExpandedRow && self.settings.groupable === null) {
        // collapse any other expandable rows
        var tableBody = self.tableBody.add(self.tableBodyLeft).add(self.tableBodyRight);
        var prevExpandRow = tableBody.find('tr.is-expanded');
        var prevExpandButton = prevExpandRow.prev().find('.datagrid-expand-btn');
        var parentRow = prevExpandRow.prev();
        var parentRowIdx = self.actualRowNode(parentRow);
        var parentdataRowIdx = self.dataRowIndex(parentRow);

        if (prevExpandRow.length && expandRow.index() !== prevExpandRow.index()) {
          var prevDetail = prevExpandRow.find('.datagrid-row-detail');
          prevExpandRow.add(prevExpandButton).removeClass('is-expanded');
          parentRow.removeClass('is-rowactivated');
          parentRow.find('.plus-minus').removeClass('active');
          prevDetail.animateClosed().on('animateclosedcomplete', function () {
            prevExpandRow.removeClass('is-expanded');
            self.element.triggerHandler('collapserow', [{
              grid: self,
              row: parentRowIdx,
              detail: prevDetail,
              item: self.settings.dataset[parentdataRowIdx]
            }]);
          });
          var prevActionBtn = prevExpandRow.prev().find('.btn-primary');

          if (prevActionBtn.length) {
            prevActionBtn.attr('class', prevActionBtn.attr('class').replace('btn-primary', 'btn-secondary'));
          }
        } // Toggle the button to make it primary


        var isExpanded = !expandRow.hasClass('is-expanded');
        var actionButton = expandRow.prev().find(isExpanded ? '.btn-secondary' : '.btn-primary');

        if (actionButton.length > 0 && parentRow && actionButton) {
          var currentClass = actionButton.attr('class') || '';
          actionButton.attr('class', currentClass.replace(isExpanded ? 'btn-secondary' : 'btn-primary', isExpanded ? 'btn-primary' : 'btn-secondary'));
        }
      }

      if (expandRow.hasClass('is-expanded')) {
        // expandRow.removeClass('is-expanded');
        detail.one('animateclosedcomplete', function () {
          expandRow.removeClass('is-expanded');
        }).animateClosed();
        expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');

        if (self.settings.allowOneExpandedRow) {
          rowElement.removeClass('is-rowactivated');
        } // detail.animateClosed();


        self.element.triggerHandler('collapserow', [{
          grid: self,
          row: dataRowIndex,
          detail: detail,
          item: item
        }]);
      } else {
        expandRow.addClass('is-expanded');
        expandButton.addClass('is-expanded').find('.plus-minus').addClass('active'); // Optionally Contstrain the width

        expandRow.find('.constrained-width').css('max-width', this.element.outerWidth());
        var eventData = [{
          grid: self,
          row: dataRowIndex,
          detail: detail,
          item: item
        }];
        self.element.triggerHandler('expandrow', eventData);

        if (self.settings.allowOneExpandedRow && this.settings.selectable !== 'multiple') {
          rowElement.addClass('is-rowactivated');
        }

        if (self.settings.onExpandRow) {
          var response = function response(markup) {
            if (markup) {
              detail.find('.datagrid-row-detail-padding').empty().append(markup);
            }

            self.adjustExpandRowHeight(detail);
            detail.animateOpen();
          };

          self.settings.onExpandRow(eventData[0], response);
        } else {
          self.adjustExpandRowHeight(detail);
          detail.animateOpen();
        } // Expandable row for frozen columns expand across all cells


        if (self.settings.frozenColumns.expandRowAcrossAllCells) {
          self.frozenExpandRowAcrossAllCells();
        }

        if (self.settings.frozenColumns.left.length || self.settings.frozenColumns.right.length) {
          var elms = {
            left: detail.eq(0)[0],
            center: detail.eq(1)[0],
            right: detail.eq(2)[0]
          };
          var changedEventStr = {
            theme: "themechanged.".concat(COMPONENT_NAME$1e),
            rowheight: "rowheightchanged.".concat(COMPONENT_NAME$1e)
          };
          $('html').off(changedEventStr.theme).on(changedEventStr.theme, function () {
            self.frozenExpandRowSetHeight(elms);
          });
          self.element.off(changedEventStr.rowheight).on(changedEventStr.rowheight, function () {
            self.frozenExpandRowSetHeight(elms);
          });
        }
      }
    },

    /**
     * Adjust height to expandable row for frozen columns
     * @private
     * @param {jQuery[]} expandRowElms The expandable row elements
     * @returns {void}
     */
    adjustExpandRowHeight: function adjustExpandRowHeight(expandRowElms) {
      if (expandRowElms.length) {
        if (this.settings.frozenColumns.left.length || this.settings.frozenColumns.right.length) {
          var elms = {
            left: expandRowElms.eq(0)[0] ? expandRowElms.eq(0)[0].children[0] : null,
            center: expandRowElms.eq(1)[0],
            right: expandRowElms.eq(2)[0] ? expandRowElms.eq(2)[0].children[0] : null
          };
          var height = 0;

          if (elms.center) {
            elms.center.style.height = 'auto';
            height = elms.center.offsetHeight - 1;
            elms.center.style.height = '';
          }

          if (height > 0) {
            if (elms.left) {
              elms.left.style.height = "".concat(height, "px");
            }

            if (elms.right) {
              elms.right.style.height = "".concat(height, "px");
            }
          }
        }
      }
    },

    /**
     * Set height to expandable row for frozen columns
     * @private
     * @param {object} elms The expandable row `.detail` elements
     * @returns {void}
     */
    frozenExpandRowSetHeight: function frozenExpandRowSetHeight(elms) {
      if (this.settings.frozenColumns.left.length || this.settings.frozenColumns.right.length) {
        var height = 0;

        if (elms && elms.center) {
          elms.padding = elms.center.querySelector('.datagrid-row-detail-padding');
          height = elms.padding.offsetHeight;
        }

        if (height) {
          elms.center.style.height = "".concat(height, "px");

          if (elms.left) {
            elms.left.style.height = "".concat(height, "px");
          }

          if (elms.right) {
            elms.right.style.height = "".concat(height, "px");
          }

          if (this.settings.frozenColumns.expandRowAcrossAllCells) {
            var rect = {
              container: this.element[0].getBoundingClientRect(),
              centerEl: elms.center.getBoundingClientRect()
            };
            var top = "".concat(rect.centerEl.top - rect.container.top, "px");
            elms.padding.style.top = top;
          }
        }
      }
    },

    /**
     * Expand the expandable row to all columns for frozen
     * @private
     * @returns {void}
     */
    frozenExpandRowAcrossAllCells: function frozenExpandRowAcrossAllCells() {
      var _this18 = this;

      if (this.settings.frozenColumns.left.length || this.settings.frozenColumns.right.length) {
        // Selector
        var selector = {
          row: '.datagrid-expandable-row.is-expanded'
        };
        selector.detail = "".concat(selector.row, " > td .datagrid-row-detail");
        selector.padding = "".concat(selector.detail, " .datagrid-row-detail-padding");
        var table = {
          left: this.tableBodyLeft ? this.tableBodyLeft[0] : null,
          center: this.tableBody ? this.tableBody[0] : null,
          right: this.tableBodyRight ? this.tableBodyRight[0] : null
        }; // Elements

        var elms = {
          rows: {
            left: table.left ? table.left.querySelector(selector.row) : null,
            center: table.center ? table.center.querySelector(selector.row) : null,
            right: table.right ? table.right.querySelector(selector.row) : null
          },
          details: {
            left: table.left ? table.left.querySelector(selector.detail) : null,
            center: table.center ? table.center.querySelector(selector.detail) : null,
            right: table.right ? table.right.querySelector(selector.detail) : null
          },
          padding: this.tableBody[0].querySelector(selector.padding)
        };

        if (elms.padding && (elms.details.left || elms.details.right)) {
          var cssClass = 'is-expanded-frozen';
          elms.padding.style.opacity = '0';

          if (elms.rows.left) {
            elms.rows.left.classList.add(cssClass);
          }

          if (elms.rows.right) {
            elms.rows.right.classList.add(cssClass);
          }

          $(elms.details.center).one('animateopencomplete.datagrid.expandedfrozen', function () {
            if (elms.details.left || elms.details.right) {
              setTimeout(function () {
                elms.rows.center.classList.add(cssClass);

                _this18.frozenExpandRowSetHeight(elms.details);

                elms.padding.style.opacity = '';
                $(window).on('resize.datagrid.expandedfrozen', function () {
                  _this18.frozenExpandRowSetHeight(elms.details);
                });
              }, 10);
            }
          }).one('animateclosedstart.datagrid.expandedfrozen', function () {
            $(window).off('resize.datagrid.expandedfrozen');
            elms.padding.style.opacity = '0';
            elms.padding.style.top = '';
            elms.rows.center.classList.remove(cssClass);

            if (elms.rows.left) {
              elms.rows.left.classList.remove(cssClass);
            }

            if (elms.rows.right) {
              elms.rows.right.classList.remove(cssClass);
            }
          }).one('animateclosedcomplete.datagrid.expandedfrozen', function () {
            elms.padding.style.opacity = '';
          });
        }
      }
    },

    /**
     * Expand the grouped row children
     * @private
     * @param {object} rowElement The row DOM element
     */
    toggleGroupChildren: function toggleGroupChildren(rowElement) {
      if (!this.settings.groupable) {
        return;
      }

      var self = this;
      var rowIdx = rowElement.index();
      var childrenLeft = $();
      var children = $();
      var childrenRight = $();

      if (this.hasLeftPane) {
        childrenLeft = this.tableLeft.find('tbody tr').eq(rowIdx).nextUntil('.datagrid-rowgroup-header');
      }

      children = this.table.find('tbody tr').eq(rowIdx).nextUntil('.datagrid-rowgroup-header');

      if (this.hasRightPane) {
        childrenRight = this.tableRight.find('tbody tr').eq(rowIdx).nextUntil('.datagrid-rowgroup-header');
      }

      var expandButton = rowElement.find('.datagrid-expand-btn');

      if (rowElement.hasClass('is-expanded')) {
        expandButton.removeClass('is-expanded').find('.plus-minus').removeClass('active');
        childrenLeft.hide();
        childrenLeft.addClass('is-hidden');
        children.hide();
        children.addClass('is-hidden');
        childrenRight.hide();
        childrenRight.addClass('is-hidden');
        self.element.triggerHandler('collapserow', [{
          grid: self,
          row: rowElement.index(),
          detail: children,
          item: {}
        }]);
        rowElement.removeClass('is-expanded');
      } else {
        expandButton.addClass('is-expanded').find('.plus-minus').addClass('active');
        childrenLeft.show();
        childrenLeft.removeClass('is-hidden');
        children.show();
        children.removeClass('is-hidden');
        childrenRight.show();
        childrenRight.removeClass('is-hidden');
        self.element.triggerHandler('expandrow', [{
          grid: self,
          row: rowElement.index(),
          detail: children,
          item: {}
        }]);
        rowElement.addClass('is-expanded');
      }
    },

    /**
     * Set the current datagrid sort column
     * @param {string} id The column id
     * @param {boolean} ascending Set the sort in ascending or descending order
     */
    setSortColumn: function setSortColumn(id, ascending) {
      var sortColumnChanged = true; // Set Direction based on if passed in or toggling existing field

      if (ascending !== undefined) {
        if (this.sortColumn.sortAsc === ascending && this.sortColumn.sortId === id) {
          sortColumnChanged = false;
        }

        this.sortColumn.sortAsc = ascending;
      } else {
        if (this.sortColumn.sortId === id) {
          this.sortColumn.sortAsc = !this.sortColumn.sortAsc;
        } else {
          this.sortColumn.sortAsc = true;
        }

        ascending = this.sortColumn.sortAsc;
      }

      this.sortColumn.sortId = id;
      this.sortColumn.sortField = this.columnById(id)[0] ? this.columnById(id)[0].field : id;
      this.sortColumn.sortAsc = ascending; // Do Sort on Data Set

      this.setSortIndicator(id, ascending);

      if (sortColumnChanged) {
        this.sortDataset();
      }

      if (!this.settings.focusAfterSort && this.activeCell && this.activeCell.isFocused) {
        this.activeCell.isFocused = false;
      }

      if (sortColumnChanged) {
        var wasFocused = this.activeCell.isFocused;

        if (!this.settings.source) {
          this.setTreeDepth();
          this.setRowGrouping();
          this.setTreeRootNodes();
          this.clearCache();
          this.renderRows(); // Update selected and Sync header checkbox

          this.syncSelectedUI();
        }

        if (wasFocused && this.activeCell.node.length === 1) {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }

        if (this.filterExpr && this.filterExpr[0] && this.filterExpr[0].column === 'all') {
          this.highlightSearchRows(this.filterExpr[0].value);
        }

        if (this.settings.source) {
          this.triggerSource({
            type: 'sorted'
          });
        }
      }

      this.tableBody.removeClass('is-loading');
      this.saveUserSettings();
      this.validateAll();
      this.element.trigger('sorted', [this.sortColumn]);
    },

    /**
     * Sort the currently attached dataset.
     * @private
     */
    sortDataset: function sortDataset() {
      if (this.settings.disableClientSort) {
        this.restoreSortOrder = true;
        return;
      }

      if (this.settings.groupable && this.originalDataset) {
        this.settings.dataset = this.originalDataset;
      }

      var sort = this.sortFunction(this.sortColumn.sortId, this.sortColumn.sortAsc);
      this.saveDirtyRows();
      this.settings.dataset.sort(sort);
      this.setTreeDepth();
      this.restoreDirtyRows(); // Resync the _selectedRows array

      if (this.settings.selectable) {
        this.syncDatasetWithSelectedRows();
      }
    },

    /**
     * Set current data to sync up dirtyArray before sort
     */
    saveDirtyRows: function saveDirtyRows() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;

      if (this.settings.groupable) {
        dataset = this.originalDataset || dataset;
      }

      if (s.showDirty && !this.settings.source && this.dirtyArray && this.dirtyArray.length) {
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (typeof this.dirtyArray[i] !== 'undefined') {
            var node = s.treeGrid ? dataset[i].node : dataset[i];
            node.tempNodeIndex = i;
          }
        }
      }
    },

    /**
    * Set current data to sync up dirtyArray after sort
    * @private
    * @returns {void}
    */
    restoreDirtyRows: function restoreDirtyRows() {
      var s = this.settings;
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;

      if (this.settings.groupable) {
        dataset = this.originalDataset || dataset;
      }

      if (s.showDirty && this.dirtyArray && this.dirtyArray.length) {
        var changes = [];

        for (var i = 0, l = dataset.length; i < l; i++) {
          var node = s.treeGrid ? dataset[i].node : dataset[i];

          if (typeof node.tempNodeIndex !== 'undefined') {
            changes.push({
              newIdx: i,
              oldIdx: node.tempNodeIndex
            });
            delete node.tempNodeIndex;
          }
        }

        var newDirtyArray = [];

        for (var _i8 = 0, _l4 = changes.length; _i8 < _l4; _i8++) {
          newDirtyArray[changes[_i8].newIdx] = this.dirtyArray[changes[_i8].oldIdx];
        }

        this.dirtyArray = newDirtyArray;
      }
    },

    /**
    * Sync the dataset._selected elements with the _selectedRows array
    * @private
    */
    syncDatasetWithSelectedRows: function syncDatasetWithSelectedRows() {
      var _s$columnIds,
          _this19 = this;

      var s = this.settings;

      if (s.source && s.paging && s.allowSelectAcrossPages && (_s$columnIds = s.columnIds) !== null && _s$columnIds !== void 0 && (_s$columnIds == null ? void 0 : _s$columnIds.length)) {
        return;
      }

      this._selectedRows = [];
      var dataset = s.treeGrid ? s.treeDepth : s.dataset;
      var idx = -1;

      var _loop5 = function _loop5(i, _data) {
        if (s.groupable && !_this19.originalDataset) {
          // Object.values is not supported in IE11; hence usage of Object.keys and Map
          for (var k = 0; k < Object.keys(dataset[i]).length; k++) {
            idx++;
            _data = Object.keys(dataset[i]).map(function (v) {
              return dataset[i][v];
            });

            if (_this19.isRowSelected(_data)) {
              _this19._selectedRows.push({
                idx: idx,
                data: _data,
                elem: _this19.dataRowNode(idx),
                group: dataset[i],
                page: _this19.pagerAPI ? _this19.pagerAPI.activePage : 1,
                pagingIdx: idx,
                pagesize: _this19.settings.pagesize
              });
            }
          }
        } else {
          _data = s.treeGrid ? dataset[i].node : dataset[i];

          if (_this19.isRowSelected(_data)) {
            _this19._selectedRows.push({
              idx: i,
              data: _data,
              elem: _this19.visualRowNode(i),
              pagesize: _this19.settings.pagesize,
              page: _this19.pagerAPI ? _this19.pagerAPI.activePage : 1,
              pagingIdx: i
            });
          }
        }

        data = _data;
      };

      for (var i = 0, data; i < dataset.length; i++) {
        _loop5(i, data);
      }
    },

    /**
     * Set the sort indicator on the column.
     * @private
     * @param {string} id The column id
     * @param {boolean} ascending Set the sort in ascending or descending order
     */
    setSortIndicator: function setSortIndicator(id, ascending) {
      if (!this.headerRow) {
        return;
      }

      this.sortColumn = {
        sortId: id,
        sortAsc: ascending,
        sortField: this.columnById(id)[0] ? this.columnById(id)[0].field : id
      }; // Set Visual Indicator

      this.element.find('.is-sorted-asc, .is-sorted-desc').removeClass('is-sorted-asc is-sorted-desc');
      this.element.find("[data-column-id=\"".concat(id, "\"]")).addClass(ascending ? 'is-sorted-asc' : 'is-sorted-desc').attr('aria-sort', ascending ? 'ascending' : 'descending');
    },

    /**
    * Overridable function to conduct array sorting
    * @param {string} id The matching field/id in the array to sort on
    * @param {boolean} ascending Determines direction of the sort.
    * @returns {boolean} If found.
    */
    sortFunction: function sortFunction(id, ascending) {
      var column = this.columnById(id); // Assume the field and id match if no column found

      var col = column.length === 0 ? null : column[0];
      var field = col === null ? id : col.field;
      var self = this;

      var primer = function primer(a) {
        a = a === undefined || a === null ? '' : a;

        if (typeof a === 'string') {
          a = a.toUpperCase();

          if ($.isNumeric(a)) {
            a = parseFloat(a);
          }
        }

        return a;
      };

      var key = function key(x) {
        return primer(self.fieldValue(x, field));
      };

      if (col && col.sortFunction) {
        key = function key(x) {
          return col.sortFunction(self.fieldValue(x, field));
        };
      }

      ascending = !ascending ? -1 : 1;
      return function (a, b) {
        a = key(a);
        b = key(b);

        if (_typeof(a) !== _typeof(b)) {
          a = a.toString().toLowerCase();
          b = b.toString().toLowerCase();
        }

        return ascending * ((a > b) - (b > a));
      };
    },

    /**
     * The default formatter to use (just plain text). When no formatter is specified.
     * @param  {number} row The rowindex
     * @param  {number} cell The cell index
     * @param  {any} value The data value
     * @returns {string} The html string
     */
    defaultFormatter: function defaultFormatter(row, cell, value) {
      return value === null || value === undefined || value === '' ? '' : value.toString();
    },

    /**
    * Add the pager and paging functionality.
    * @private
    */
    handlePaging: function handlePaging() {
      if (!this.settings.paging) {
        return;
      }

      this.element.addClass('paginated');
      this.tableBody.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        hideOnOnePage: this.settings.hidePagerOnOnePage,
        source: this.settings.source,
        pagesize: this.settings.pagesize,
        indeterminate: this.settings.indeterminate,
        rowTemplate: this.settings.rowTemplate,
        pagesizes: this.settings.pagesizes,
        pageSizeSelectorText: this.settings.groupable ? 'GroupsPerPage' : 'RecordsPerPage',
        showPageSizeSelector: this.settings.showPageSizeSelector,
        activePage: this.restoreActivePage ? parseInt(this.savedActivePage, 10) : 1
      });

      if (this.restoreActivePage) {
        this.savedActivePage = null;
        this.restoreActivePage = false;
      }
    },

    /**
    * Add the pager and paging functionality.
    * @param {string} pagingInfo The paging object with activePage ect used by pager.js
    * @param {boolean} isResponse Internal flag used to prevent callbacks from rexecuting.
    * @param {function} callback The callback function.
    */
    renderPager: function renderPager(pagingInfo, isResponse, callback) {
      if (!this.pagerAPI) {
        return;
      }

      if (!this.settings.source) {
        this.pagerAPI.settings.dataset = this.settings.dataset;
        pagingInfo.isFilteredClientside = true;
      }

      this.pagerAPI.updatePagingInfo(pagingInfo, isResponse);

      if (!isResponse) {
        this.triggerSource(pagingInfo, callback);
      } // Update selected and Sync header checkbox


      this.syncSelectedUI();
    },

    /**
     * Reliably gets all the pre-rendered elements in the container and returns them for use.
     * @private
     * @returns {array} TThe pagable items
     */
    getPageableElements: function getPageableElements() {
      var elements = this.element.children().not('.datagrid-expandable-row');

      if (elements.is('table')) {
        elements = elements.find('tbody tr');
      }

      return elements;
    },

    /**
    * Add grid tooltip to the page.
    * @private
    * @param {string} extraClass class to add to target uniqueness
    * @returns {void}
    */
    appendTooltip: function appendTooltip(extraClass) {
      var _this20 = this;

      var defaultClass = 'grid-tooltip';
      var regExp = new RegExp("\\b".concat(defaultClass, "\\b"), 'g'); // Set default css class

      if (typeof extraClass === 'string') {
        if (!regExp.test(extraClass)) {
          extraClass += " ".concat(defaultClass);
        }
      } else {
        extraClass = defaultClass;
      } // Unique id for tooltip


      var tooltipId = this.uniqueId('tooltip');
      this.tooltip = document.getElementById(tooltipId);

      if (!this.tooltip) {
        var tooltip = '' + "<div id=\"".concat(tooltipId, "\" class=\"tooltip ").concat(extraClass, " is-hidden\">\n          <div class=\"arrow\"></div>\n          <div class=\"tooltip-content\"></div>\n        </div>");
        document.body.insertAdjacentHTML('beforeend', tooltip);
        this.tooltip = document.getElementById(tooltipId);

        if (this.isTouch) {
          this.tooltip.style.pointerEvents = 'auto';
          $(this.tooltip).on('touchend.gridtooltip', function () {
            _this20.hideTooltip();
          });
        }
      }
    },

    /**
     * Cache tooltip content so it can use for more then once
     * @private
     * @param  {object} elem The element to be cached.
     * @param  {object} tooltip Optional to cache given data.
     * @returns {object} tooltip object.
     */
    cacheTooltip: function cacheTooltip(elem, tooltip) {
      if (typeof tooltip === 'undefined') {
        var contentTooltip = elem.querySelector('.is-editor.content-tooltip');
        var aTitle = elem.querySelector('a[title]');
        var isRowstatus = DOM.hasClass(elem, 'rowstatus-cell');
        var isSvg = elem.tagName.toLowerCase() === 'svg';
        var isTh = elem.tagName.toLowerCase() === 'th';
        var isHeaderColumn = DOM.hasClass(elem, 'datagrid-column-wrapper');
        var isHeaderFilter = DOM.hasClass(elem.parentNode, 'datagrid-filter-wrapper');
        var cell = elem.getAttribute('aria-colindex') - 1;
        var col = this.columnSettings(cell);
        var title;
        tooltip = {
          content: '',
          wrapper: elem.querySelector('.datagrid-cell-wrapper')
        };

        if (isTh || isHeaderColumn || isHeaderFilter) {
          tooltip.wrapper = elem;
          tooltip.distance = isHeaderFilter ? 15 : null;
          tooltip.placement = isHeaderColumn ? 'top' : 'bottom';
        } // Cache rowStatus cell


        if (isRowstatus || isSvg) {
          var rowNode = this.closest(elem, function (el) {
            return DOM.hasClass(el, 'datagrid-row');
          });
          var classList = rowNode ? rowNode.classList : [];
          tooltip.isError = classList.contains('rowstatus-row-error');
          tooltip.placement = 'right'; // For nonVisibleCellErrors

          if (isSvg) {
            tooltip.wrapper = this.closest(elem, function (el) {
              return el.tagName.toLowerCase() === 'td';
            });
          }
        }

        if (contentTooltip) {
          // Used with rich text editor
          var width = col.editorOptions && col.editorOptions.width ? this.setUnit(col.editorOptions.width) : false; // Width for tooltip can be come from column options

          var newContentTooltip = $(contentTooltip).clone()[0];
          newContentTooltip.style.width = width || "".concat(elem.offsetWidth, "px");
          var tooltipHTML = newContentTooltip.outerHTML;

          if (xssUtils.stripHTML(tooltipHTML) !== '') {
            tooltip.content = tooltipHTML;
            tooltip.extraClassList = ['popover', 'alternate', 'content-tooltip'];
          }
        } else if (aTitle) {
          // Title attribute on links `a`
          tooltip.content = aTitle.getAttribute('title');
          aTitle.removeAttribute('title');
        } else {
          title = elem.getAttribute('title');

          if (title) {
            var disableButton = elem.querySelector('.row-btn[disabled]'); // Title attribute on current element

            tooltip.content = disableButton ? '' : title;
            elem.removeAttribute('title');
          } else if (isTh && !isHeaderFilter) {
            var targetEl = elem.querySelector('.datagrid-header-text');
            tooltip.content = targetEl ? xssUtils.stripHTML(targetEl.textContent) : '';
          } else if (isHeaderFilter) {
            // Disabled filterable headers
            var filterDisabled = elem.parentNode.querySelectorAll('.dropdown.is-disabled, input[type="text"][disabled], .btn-filter[disabled]').length > 0;

            if (!filterDisabled) {
              var _targetEl = elem.parentNode.querySelector('.is-checked');

              tooltip.content = _targetEl ? xssUtils.stripHTML(_targetEl.textContent) : '';
            }
          } else {
            // Default use wrapper content
            if (tooltip.wrapper.querySelector('.datagrid-expand-btn')) {
              Array.prototype.filter.call(tooltip.wrapper.children, function (node) {
                return !node.matches('.datagrid-expand-btn');
              }).forEach(function (node) {
                tooltip.content = node.textContent;
              });
            } else {
              tooltip.content = tooltip.wrapper.textContent;
            }

            tooltip.content = xssUtils.stripHTML(tooltip.content).trim();
          }
        } // Clean up text in selects


        var select = tooltip.wrapper.querySelector('select');

        if (select && select.selectedIndex && select.options[select.selectedIndex] && select.options[select.selectedIndex].innerHTML) {
          tooltip.content = Environment.features.touch ? '' : select.options[select.selectedIndex].innerHTML.trim();
        }

        if (isTh) {
          tooltip.content = tooltip.content.trim();
        }

        if (tooltip.content !== '') {
          var isEllipsis = DOM.hasClass(isHeaderColumn ? elem.parentNode : elem, 'text-ellipsis');
          var icons = [].slice.call(elem.querySelectorAll('.icon'));
          var extraWidth = isEllipsis ? 8 : 0;
          icons.forEach(function (icon) {
            var rect = typeof icon.getBBox === 'function' ? icon.getBBox() : icon.getBoundingClientRect();
            extraWidth += rect.width + 8;
          }); // Treegrid handle indented area (1st column)

          if (this.settings.treeGrid) {
            var presenceOf = function presenceOf(selector) {
              return !!tooltip.wrapper.querySelector(selector);
            };

            if (presenceOf('.datagrid-tree-node') || presenceOf('.datagrid-expand-btn')) {
              var rowElem = this.closest(tooltip.wrapper, function (el) {
                return DOM.hasClass(el, 'datagrid-row');
              });
              var level = parseInt(rowElem.getAttribute('aria-level'), 10);

              if (level) {
                extraWidth += level * 30; // Each level 30px margin
              }
            }
          }

          if (isEllipsis && isHeaderColumn) {
            var textEl = elem.querySelector('.datagrid-header-text');
            tooltip.textwidth = textEl.scrollWidth + (select ? 0 : extraWidth);
          } else {
            tooltip.textwidth = stringUtils.textWidth(tooltip.content) + (select ? 0 : extraWidth);
          }

          if (isTh) {
            tooltip.textwidth = stringUtils.textWidth(tooltip.content);
          }

          tooltip.content = contentTooltip ? tooltip.content : "<p>".concat(tooltip.content, "</p>");

          if (title || isHeaderFilter) {
            tooltip.forced = true;
          }
        }

        if (typeof col.tooltip === 'function') {
          var _rowElem = this.closest(elem, function (el) {
            return DOM.hasClass(el, 'datagrid-row');
          });

          var rowIdx;
          var rowData;

          if (this.settings.treeGrid && this.settings.treeDepth) {
            rowIdx = this.actualRowIndex(_rowElem);
            rowData = this.settings.treeDepth[rowIdx].node;
          } else {
            rowIdx = this.dataRowIndex(_rowElem);
            rowData = this.settings.dataset[rowIdx];
          }

          var value = this.fieldValue(rowData, col.field);
          tooltip.content = col.tooltip(rowIdx, cell, value, col, rowData, this);
          tooltip.textwidth = stringUtils.textWidth(tooltip.content) + 20;

          if (tooltip.content !== undefined && tooltip.content !== null && tooltip.content !== '') {
            tooltip.forced = true;
          }
        }
      }

      elem = elem instanceof jQuery ? elem : $(elem);
      elem.data('gridtooltip', tooltip);
      return tooltip;
    },

    /**
     * Show Tooltip
     * @private
     * @param  {object} [options] for tooltip.
     * @param  {string} [options.content] The tooltip contents.
     * @param  {object} [options.wrapper] The parent DOM element.
     * @param  {boolean} [options.isError] True for if is error color.
     * @param  {string} [options.placement] 'top'|'right'|'bottom'|'left'.
     * @param  {array} [options.extraClassList] list of css classes to be added to tooltip.
     * @returns {void}
     */
    showTooltip: function showTooltip(options) {
      var _this21 = this;

      if (this.tooltip) {
        var tooltip = $(this.tooltip);
        var tooltipContentEl = this.tooltip.querySelector('.tooltip-content');

        if (tooltipContentEl) {
          tooltipContentEl.innerHTML = options.content;
          this.tooltip.classList.remove('is-hidden', 'top', 'right', 'bottom', 'left');
          this.tooltip.style.display = '';
          this.tooltip.classList.add(options.placement || 'top');

          if (options.isError) {
            this.tooltip.classList.add('is-error');
          }

          if (options.extraClassList) {
            options.extraClassList.map(function (className) {
              return _this21.tooltip.classList.add(className);
            });
          }

          var distance = typeof options.distance === 'number' ? options.distance : 10;
          var placeOptions = {
            x: 0,
            y: distance,
            container: this.element.closest('.page-container.scrollable') || $('body'),
            containerOffsetX: options.wrapper.offsetLeft,
            containerOffsetY: options.wrapper.offsetTop,
            parent: $(options.wrapper),
            placement: options.placement || 'top',
            strategies: ['flip', 'nudge']
          };

          if (placeOptions.placement === 'left' || placeOptions.placement === 'right') {
            placeOptions.x = distance;
            placeOptions.y = 0;
          }

          tooltip.one('afterplace.gridtooltip', function (e, placementObj) {
            _this21.handleAfterPlaceTooltip(e, tooltip, placementObj);
          }).on('click.gridtooltip', function () {
            _this21.hideTooltip();
          }); // If not already have place instance

          if (!tooltip.data('place')) {
            tooltip.place(placeOptions);
          } // Apply place


          tooltip.data('place').place(placeOptions); // Flag to mark as gridtooltip

          tooltip.data('gridtooltip', true); // Hide the tooltip when the page scrolls.

          $('body, .scrollable').off('scroll.gridtooltip').on('scroll.gridtooltip', function () {
            _this21.hideTooltip();
          });
        }
      }
    },

    /**
     * Placement behavior's "afterplace" handler.
     * @private
     * @param {jquery.event} e custom `afterPlace` event
     * @param {jquery} tooltip element
     * @param {placementobject} placementObj object containing placement settings
     * @returns {void}
     */
    handleAfterPlaceTooltip: function handleAfterPlaceTooltip(e, tooltip, placementObj) {
      var elem = tooltip || $('#tooltip');

      if (elem[0]) {
        elem.data('place').setArrowPosition(e, placementObj, elem);
        elem.triggerHandler('tooltipafterplace', [placementObj]);
      }
    },

    /**
     * Hide the visible tooltip.
     * @private
     * @returns {void}
     */
    hideTooltip: function hideTooltip() {
      var _this22 = this;

      if (this.tooltip) {
        this.removeTooltipData(this.tooltip); // Remove flag as gridtooltip

        this.tooltip.classList.add('is-hidden');
        this.tooltip.classList.remove('is-error', 'popover', 'alternate', 'content-tooltip');
        this.tooltip.style.left = '-999px';
      } // Remove scroll events


      $('body, .scrollable').off('scroll.gridtooltip', function () {
        _this22.hideTooltip();
      });
    },

    /**
     * Check for tooltip type gridtooltip or component
     * @private
     * @returns {boolean} True if is gridtooltip
     */
    isGridtooltip: function isGridtooltip() {
      var isGridtooltipType = false;

      if (this.tooltip) {
        var tooltipJQ = this.tooltip instanceof jQuery ? this.tooltip : $(this.tooltip);

        if (tooltipJQ.data('gridtooltip')) {
          isGridtooltipType = true;
        }
      }

      return isGridtooltipType;
    },

    /**
     * Remove the tooltip data from given node
     * @private
     * @param {object} elem The DOM element to remove data
     * @returns {void}
     */
    removeTooltipData: function removeTooltipData(elem) {
      elem = elem instanceof jQuery ? elem : $(elem);

      if (elem.data('gridtooltip')) {
        $.removeData(elem[0], 'gridtooltip');
      }
    },

    /**
     * Remove the tooltip from the DOM
     * @private
     * @returns {void}
     */
    removeTooltip: function removeTooltip() {
      var _this23 = this;

      if (this.tooltip) {
        var tooltip = $(this.tooltip); // Set selector

        var selector = {
          th: '.datagrid-header th',
          td: '.datagrid-wrapper tbody tr.datagrid-row td[role="gridcell"]:not(.rowstatus-cell)',
          rowstatus: '.datagrid-wrapper tbody tr.datagrid-row td[role="gridcell"] .icon-rowstatus'
        };
        selector.str = "".concat(selector.th, ", ").concat(selector.td, ", ").concat(selector.rowstatus); // Unbind events

        $('body, .scrollable').off('scroll.gridtooltip');
        tooltip.off('touchend.gridtooltip');
        this.element.off('mouseenter.gridtooltip mouseleave.gridtooltip click.gridtooltip longpress.gridtooltip keydown.gridtooltip', selector.str);

        if (this.toolbar && this.toolbar.parent().find('.table-errors').length > 0) {
          this.toolbar.parent().find('.table-errors').off('mouseenter.tableerrortooltip', '.icon').off('mouseleave.tableerrortooltip click.tableerrortooltip', '.icon').off('longpress.tableerrortooltip', '.icon');
        } // Remove the place component


        var placeApi = tooltip.data('place');

        if (placeApi) {
          placeApi.destroy();
        } // Remove cached tooltip data


        var nodes = [].slice.call(this.element[0].querySelectorAll(selector.str));
        nodes.forEach(function (node) {
          return _this23.removeTooltipData(node);
        });

        if (this.tooltip.parentNode) {
          this.tooltip.parentNode.removeChild(this.tooltip);
        }
      }

      this.tooltip = undefined;
    },

    /**
    * Unwrap the grid back to a simple div, and destory all events and pointers.
    * @returns {object} The plugin api for chaining.
    */
    destroy: function destroy() {
      // Remove grid tooltip
      this.removeTooltip();
      $('html').off("themechanged.".concat(COMPONENT_NAME$1e)); // Unbind context menu events

      this.element.add(this.element.find('*')).off('selected.gridpopupth close.gridpopupth selected.gridpopuptr close.gridpopuptr selected.gridpopupbtn close.gridpopupbtn'); // UnBind the pager

      if (this.pagerAPI) {
        this.tableBody.off("page.".concat(COMPONENT_NAME$1e, " pagesizechange.").concat(COMPONENT_NAME$1e));
        this.pagerAPI.destroy();
      } // Remove the toolbar, clean the div out and remove the pager


      this.element.off().empty().removeClass('datagrid-container');
      var toolbar = this.element.prev('.toolbar');
      this.triggerDestroyCell();

      if (this.removeToolbarOnDestroy && this.settings.toolbar && this.settings.toolbar.keywordFilter) {
        var searchfield = toolbar.find('.searchfield');
        var searchfieldApi = searchfield.data('searchfield');
        var xIcon = searchfield.parent().find('.close.icon');
        searchfield.off('keypress.datagrid');
        xIcon.off('click.datagrid');

        if (searchfieldApi && typeof searchfieldApi.destroy === 'function') {
          searchfieldApi.destroy();
        }

        searchfield.removeData('options');
      }

      if (this.removeToolbarOnDestroy) {
        // only remove toolbar if it was created by this datagrid
        if (toolbar.data('toolbar')) {
          toolbar.data('toolbar').destroy();
        }

        toolbar.remove();
      }

      this.element.next('.pager-toolbar').remove();
      $.removeData(this.element[0], COMPONENT_NAME$1e);
      this.element.off();
      $(document).off('touchstart.datagrid touchend.datagrid touchcancel.datagrid click.datagrid touchmove.datagrid');
      $('body').off('resize.vtable resize.datagrid');
      $(window).off('orientationchange.datagrid');
      $(window).off('resize.datagrid');
      return this;
    },

    /**
    * Update the datagrid and optionally apply new settings.
    * @param  {object} settings the settings to update to.
    * @returns {object} The plugin api for chaining.
    */
    updated: function updated(settings) {
      this.settings = utils.mergeSettings(this.element, settings, this.settings);

      if (this.pagerAPI && typeof this.pagerAPI.destroy === 'function') {
        this.pagerAPI.destroy();
      }

      if (settings && settings.frozenColumns) {
        this.headerRow = undefined;
        this.element.empty();
        this.firstRender();
      }

      if (settings && settings.dataset) {
        this.settings.dataset = settings.dataset;
      }

      if (settings && settings.columns) {
        this.settings.columns = settings.columns;
      }

      this.render();
      this.handlePaging();
      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Datagrid
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.datagrid = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1e);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1e, new Datagrid(this, settings));
      }
    });
  };

  var COMPONENT_NAME$1f = 'formcompact'; // Settings

  var FORMCOMPACT_DEFAULTS = {}; // Others

  var FOCUSED_CSS_CLASS = 'is-focused';
  /**
   * @class FormCompact
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings=null] Incoming settings
   */

  function FormCompact(element, settings) {
    if (!(element instanceof HTMLElement)) {
      throw new Error('Element used for `FormCompact` component must be an instance of HTMLElement');
    }

    this.settings = utils.mergeSettings(element, settings, FORMCOMPACT_DEFAULTS);
    this.element = element;
    this.init();
  }

  FormCompact.prototype = {
    /**
     * @private
     * Builds the component up from scratch
     * @returns {void}
     */
    init: function init() {
      this.form = this.element.querySelector('form');
      this.inputs = utils.getArrayFromList(this.element.querySelectorAll('input'));
      this.renderProps();
      this.handleEvents();
    },

    /**
     * Render CSS classes on column containers for some states
     * @returns {void}
     */
    renderProps: function renderProps() {
      var _this = this;

      if (!this.inputs || !this.inputs.length) {
        return;
      }

      var props = ['disabled', 'readonly'];
      this.inputs.forEach(function (input) {
        props.forEach(function (prop) {
          _this.setState(prop, input);
        });
      });
    },

    /**
     * @private
     * Sets up event listeners on the component
     * @returns {void}
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      $(this.form).on("focusin.".concat(COMPONENT_NAME$1f), 'input', function (e) {
        return _this2.handleFocusIn(e);
      }).on("focusout.".concat(COMPONENT_NAME$1f), 'input', function (e) {
        return _this2.handleFocusOut(e);
      }); // Listen to attribute changes (disabled/readonly) on cells

      var attributeNames = ['disabled', 'readonly'];
      this.inputsObserver = new MutationObserver(function (mutationsList) {
        if (!mutationsList.length) {
          return;
        }

        mutationsList.forEach(function (mutation) {
          if (mutation.type === 'attributes') {
            if (attributeNames.indexOf(mutation.attributeName) > -1) {
              _this2.setState(mutation.attributeName, mutation.target);
            }
          }
        });
      });
      var config = {
        attributes: true
      };
      this.inputs.forEach(function (input) {
        _this2.inputsObserver.observe(input, config);
      });
    },

    /**
     * Event handler for `focusin` events on fields
     * @private
     * @param {jQuery.Event} e the jQuery event wrapper for `focusin`
     * @returns {void}
     */
    handleFocusIn: function handleFocusIn(e) {
      var target = DOM.parents(e.target, '.column, .columns', true);
      target.classList.add(FOCUSED_CSS_CLASS);
    },

    /**
     * Event handler for `focusout` events on fields
     * @private
     * @param {jQuery.Event} e the jQuery event wrapper for `focusout`
     * @returns {void}
     */
    handleFocusOut: function handleFocusOut(e) {
      var target = DOM.parents(e.target, '.column, .columns', true);
      target.classList.remove(FOCUSED_CSS_CLASS);
    },

    /**
     * @private
     * Sets a CSS Class on the parent column of a form input.
     * @param {string} name property being set
     * @param {HTMLElement} target the node to be evaluated
     */
    setState: function setState(name, target) {
      if (typeof name !== 'string' || !(target instanceof HTMLElement)) {
        return;
      } // Ignore "grouped" types for column state management


      var ignoredTypes = ['checkbox', 'radio'];

      if (ignoredTypes.indexOf(target.type) > -1) {
        return;
      }

      if (name === 'readonly') {
        name = 'readOnly';
      }

      var isActive = target[name] === true;
      var operation = isActive ? 'add' : 'remove';
      target.parentNode.classList[operation]("is-".concat(name.toLowerCase()));
    },

    /**
     * Updates the component with new settings
     * @param {object} [settings=null] if defined, new incoming settings
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },

    /**
     * Removes all bound events and extraneous HTML markup
     * @returns {void}
     */
    teardown: function teardown() {
      this.inputsObserver.disconnect();
      delete this.inputsObserver;
      $(this.form).off(["focusin.".concat(COMPONENT_NAME$1f), "focusout.".concat(COMPONENT_NAME$1f)].join(' '));
      delete this.form;
      delete this.inputs;
    },

    /**
     * Destroys the component and removes its contents from the DOM
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$1f);
    }
  };

  /**
   * jQuery Component Wrapper for FormContact
   * @param {object} [settings=undefined] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.formcompact = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1f);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1f, new FormCompact(this, settings));
      }
    });
  };

  var COMPONENT_NAME$1g = 'header';
  /**
   * Special Header with Toolbar at the top of the page used to faciliate IDS Enterprise Nav Patterns
   * @class Header
   * @param {HTMLElement|jQuery[]} element the base element
   * @param {object} [settings] incoming settings
   * @param {boolean} [settings.addScrollClass = false] If true a class will be added as the page scrolls up and down
   * to the header for manipulation. Eg: Docs Page.
   * @param {boolean} [settings.demoOptions = true] Used to enable/disable default IDS Enterprise options for demo purposes
   * @param {array} [settings.tabs = null] If defined as an array of Tab objects, displays a series of tabs that represent application sections
   * @param {object} [settings.toolbarSettings = undefined] If defined, will be passed into the toolbar/toobarFlex component instance as settings
   * @param {boolean} [settings.useAlternate = null] If true, use alternate background/text color for sub-navigation areas
   * @param {boolean} [settings.useBackButton = true] If true, displays a back button next to the title in the header toolbar
   * @param {boolean} [settings.useBreadcrumb = false] If true, displays a breadcrumb on drilldown
   * @param {boolean} [settings.useFlexToolbar = false] If true, uses a Flex Toolbar component instead of a standard Toolbar component.
   * @param {boolean} [settings.usePopupmenu = false] If true, changes the Header Title into a popupmenu that can change the current page
   * @param {array} [settings.wizardTicks = null] If defined as an array of Wizard Ticks, displays a Wizard Control that represents steps in a process
   */

  var HEADER_DEFAULTS = {
    addScrollClass: false,
    demoOptions: true,
    tabs: null,
    toolbarSettings: undefined,
    useAlternate: false,
    useBackButton: true,
    useBreadcrumb: false,
    useFlexToolbar: false,
    usePopupmenu: false,
    wizardTicks: null
  };

  function Header(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, HEADER_DEFAULTS);
    this.init();
  }

  Header.prototype = {
    /**
     * @returns {Toolbar|ToolbarFlex|undefined} component instance, if applicable
     */
    get toolbarAPI() {
      if (!this.toolbarElem) {
        return undefined;
      }

      return this.toolbarElem.data('toolbar-flex') || this.toolbarElem.data('toolbar');
    },

    /**
     * @deprecated as of v4.18.0. Please use the `toolbarAPI` property instead.
     * @returns {Toolbar|ToolbarFlex|undefined} component instance, if applicable.
     */
    get toolbar() {
      warnAboutDeprecation('toolbarAPI', 'toolbar');
      return this.toolbarAPI;
    },

    /**
     * @returns {jQuery[]} reference to the Header's button for controlling drilling/navigation
     */
    get titleButton() {
      var query = '.title > button';

      if (this.toolbarElem && this.toolbarElem.is('.flex-toolbar')) {
        query = '.toolbar-section:first-child > button';
      }

      return this.element.find(query);
    },

    /**
     * @returns {boolean} true if this Header component contains a button that precedes the title
     */
    get hasTitleButton() {
      var btn = this.titleButton;
      return btn.length > 0;
    },

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      this.setup().build().handleEvents(); // Theme, Personalization, Language Changer, Scrolling

      if (this.settings.demoOptions) {
        this.initPageChanger();
      }
    },

    /**
     * @private
     * @returns {this} component instance
     */
    setup: function setup() {
      // TODO: Settings all work independently, but give better descriptions
      this.settings.demoOptions = this.element.attr('data-demo-options') ? this.element.attr('data-demo-options') === 'true' : this.settings.demoOptions;
      this.settings.useBackButton = this.element.attr('data-use-backbutton') ? this.element.attr('data-use-backbutton') === 'true' : this.settings.useBackButton;
      this.settings.useBreadcrumb = this.element.attr('data-use-breadcrumb') ? this.element.attr('data-use-breadcrumb') === 'true' : this.settings.useBreadcrumb;
      this.settings.useAlternate = this.element.attr('data-use-alternate') ? this.element.attr('data-use-alternate') === 'true' : this.settings.useAlternate;
      this.settings.tabs = !$.isArray(this.settings.tabs) ? null : this.settings.tabs;
      this.settings.wizardTicks = !$.isArray(this.settings.wizardTicks) ? null : this.settings.wizardTicks;
      this.titleText = this.element.find('.title > h1'); // Used to track levels deep

      this.levelsDeep = [];
      this.levelsDeep.push("".concat(this.titleText.text()));
      return this;
    },

    /**
     * @private
     * @returns {this} component instance
     */
    build: function build() {
      var isFlex = false;
      var elem = this.element.find('.toolbar, .flex-toolbar');

      if (!elem.length) {
        return this;
      }

      if (elem.is('.flex-toolbar')) {
        isFlex = true;
      }

      this.toolbarElem = elem; // Build/update the toolbar instance

      var toolbarSettings = this.settings.toolbarSettings;
      this.toolbarElem[isFlex ? 'toolbarflex' : 'toolbar'](toolbarSettings); // Build the title button if one is not present, and we are drilled in at least one level deep.

      if (!this.hasTitleButton && this.levelsDeep.length > 1) {
        this.buildTitleButton();
      } // Application Tabs would be available from the Application Start, so activate
      // them during build if they exist


      if (this.settings.tabs && this.settings.tabs.length) {
        this.buildTabs();
      }

      if (this.settings.wizardTicks && this.settings.wizardTicks.length) {
        this.buildWizard();
      }

      if (this.settings.usePopupmenu) {
        this.buildPopupmenu();
      } // Add a Scrolling Class to manipulate the header


      if (this.settings.addScrollClass) {
        var self = $(this.element);
        var scrollDiv = $(this.element).next('.scrollable');
        var container = scrollDiv.length === 1 ? scrollDiv : $(window);
        var scrollThreshold = this.settings.scrollThreshold ? this.settings.scrollThreshold : 15;
        container.on('scroll.header', function () {
          if (this.scrollTop > scrollThreshold) {
            self.addClass('is-scrolled-down');
          } else {
            self.removeClass('is-scrolled-down');
          }
        });

        if (container.scrollTop() > scrollThreshold) {
          self.addClass('is-scrolled-down');
        }
      }

      return this;
    },

    /**
     * @private
     * @returns {void}
     */
    buildTitleButton: function buildTitleButton() {
      if (this.levelsDeep.length > 1 && !this.hasTitleButton && !this.titleButton.length) {
        // Deconstruct Toolbar
        this.toolbarAPI.teardown(); // Build Title Button

        var titleButton = $("<button class=\"btn-icon back-button\" type=\"button\">\n        <span class=\"audible\">".concat(Locale.translate('Drillup'), "</span>\n        <span class=\"icon app-header go-back\">\n          <span class=\"one\"></span>\n          <span class=\"two\"></span>\n          <span class=\"three\"></span>\n        </span>\n      </button>"));
        var titleElem = this.toolbarElem.find('.title');

        if (this.settings.useFlexToolbar) {
          var preTitleSection = titleElem.prev('.toolbar-section');

          if (!preTitleSection.length) {
            preTitleSection = $('<div class="toolbar-section"></div>').insertBefore(titleElem);
          }

          titleButton.prependTo(preTitleSection);
        } else {
          titleButton.prependTo(titleElem);
        } // Rebuild Toolbar


        this.toolbarAPI.init();
      } // Add CSS


      this.toolbarElem.addClass('has-title-button');
      this.titleButton.find('.icon.app-header').addClass('go-back'); // Link to the App Menu as a trigger

      var appMenu = $('#application-menu').data('applicationmenu');

      if (appMenu) {
        appMenu.modifyTriggers([this.titleButton], null, true);
      } else {
        $('#application-menu').applicationmenu({
          triggers: [this.titleButton]
        });
      }

      this.handleTitleButtonEvents();
    },

    /**
     * @private
     * @returns {array} containing breadcrumb-friendly representation of the `levelsDeep` array
     */
    getCurrentBreadcrumbData: function getCurrentBreadcrumbData() {
      var self = this; // Runs in the context of the BreadcrumbItem API

      function callback() {
        var i = this.index;
        var breadcrumbList = self.breadcrumbAPI.list; // Clicking on the current Breadcrumb Item does nothing

        if (this.current) {
          return;
        } // Clicking on the top-level breadcrumb resets the Header display


        if (i === 0) {
          self.reset();
          return;
        }

        var delta;
        var children = breadcrumbList.childNodes.length - 1;

        if (i < children) {
          delta = children - i;

          while (delta > 0) {
            self.drillup();
            self.breadcrumbAPI.remove(children, false, true);
            delta -= 1;
            children -= 1;
          }
        }

        self.breadcrumbAPI.render();
      }

      return this.levelsDeep.map(function (title, i) {
        var id = "header-breadcrumb-".concat(title.replace(' ', '-').toLowerCase());
        var current = i + 1 === self.levelsDeep.length;
        return {
          callback: callback,
          content: title,
          current: current,
          id: id
        };
      });
    },

    /**
     * Used for adding a Breadcrumb Element to the Header
     * @private
     * @returns {void}
     */
    buildBreadcrumb: function buildBreadcrumb() {
      var breadcrumbClass = 'has-breadcrumb';
      var style = 'default';

      if (this.settings.useAlternate) {
        breadcrumbClass = 'has-alternate-breadcrumb';
        style = 'alternate';
      }

      this.element.addClass(breadcrumbClass);
      this.breadcrumb = this.element.find('.breadcrumb');

      if (!this.breadcrumb.length) {
        this.breadcrumb = $('<nav class="breadcrumb hidden" role="navigation"></nav>').appendTo(this.element);
        this.breadcrumb.breadcrumb({
          breadcrumbs: this.getCurrentBreadcrumbData(),
          style: style
        });
        this.breadcrumbAPI = this.breadcrumb.data('breadcrumb');
      }

      this.adjustBreadcrumb();
    },

    /**
     * Builds Breadcrumb markup that reflects the current state of the application
     * @private
     * @returns {void}
     */
    adjustBreadcrumb: function adjustBreadcrumb() {
      if (!this.breadcrumbAPI) {
        return;
      }

      this.breadcrumbAPI.updated({
        breadcrumbs: this.getCurrentBreadcrumbData()
      });
    },

    /**
     * Builds Header Tabs
     * @private
     * @returns {void}
     */
    buildTabs: function buildTabs() {
      this.tabsContainer = this.element.find('.tab-container');

      if (!this.tabsContainer.length) {
        this.tabsContainer = $('<div class="tab-container"></div>').appendTo(this.element); // TODO: Flesh this out so that the header control can build tabs based on options

        var tablist = $('<ul class="tab-list" role="tablist"></ul>').appendTo(this.tabsContainer);
        $('<li class="tab"><a href="#header-tabs-home" role="tab">IDS Enterprise Controls | Patterns</a></li>').appendTo(tablist);
        $('<li class="tab"><a href="#header-tabs-level-1" role="tab">Level 1 Detail</a></li>').appendTo(tablist);
        $('<li class="tab"><a href="#header-tabs-level-2" role="tab">Level 2 Detail</a></li>').appendTo(tablist);
      }

      this.element.addClass(this.settings.useAlternate ? 'has-alternate-tabs' : 'has-tabs');
      this.tabsContainer[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate'); // NOTE: For demo purposes the markup for tab panels is already inside the
      // Nav Patterns Test page.

      $('#header-tabs-level-1').removeAttr('style');
      $('#header-tabs-level-2').removeAttr('style'); // Invoke Tabs Control

      this.tabsContainer.tabs({
        containerElement: '#maincontent'
      });
    },

    /**
     * Builds a Header Wizard
     * @private
     * @returns {void}
     */
    buildWizard: function buildWizard() {
      this.element.addClass('has-wizard');
      this.wizard = this.element.find('.wizard');

      if (!this.wizard.length) {
        this.wizard = $('<div class="wizard"></div>').appendTo(this.element);
        var header = $('<div class="wizard-header"></div>').appendTo(this.wizard);
        var bar = $('<div class="bar"></div>').appendTo(header);
        $('<div class="completed-range"></div>').appendTo(bar); // TODO: Flesh this out so the header control can build the Wizard Ticks based on options

        $('<a href="#" class="tick current"><span class="label">Context Apps</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">Utility Apps</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">Inbound Configuration</span></a>').appendTo(bar);
        $('<a href="#" class="tick"><span class="label">OID Mapping</span></a>').appendTo(bar);
      }

      this.wizard[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate'); // NOTE: For Demo Purposes, the shifting forms associated with the Wizard are coded
      // inside the Nav Patterns Test page.
      // TODO: Build shifting forms
      // Invoke the Wizard Control

      this.wizard.wizard();
    },

    /**
     * Builds a Popupmenu in place of the usual Title text, to allow for context swapping.
     * @private
     * @returns {void}
     */
    buildPopupmenu: function buildPopupmenu() {
      this.toolbarAPI.teardown();
      var title = this.toolbarElem.children('.title');
      this.titlePopup = title.find('.btn-menu');

      if (!this.titlePopup.length) {
        var heading = title.find('h1'); // If H1 doesn't exist here, you're doing it wrong.

        heading.wrap('<button id="header-menu" type="button" class="btn-menu"></button>');
        this.titlePopup = heading.parent('.btn-menu');
      }

      this.titlePopupMenu = this.titlePopup.next('.popupmenu');

      if (!this.titlePopupMenu.length) {
        this.titlePopupMenu = $('<ul class="popupmenu is-selectable"></ul>').insertAfter(this.titlePopup);
        $('<li class="is-checked"><a href="#">Page One Title</a></li>' + '<li><a href="#">Page Two Title</a></li>' + '<li><a href="#">Page Three Title</a></li>' + '<li class="is-disabled"><a href="#">Page Four Title</a></li>' + '<li><a href="#">Page Five Title</a></li>').appendTo(this.titlePopupMenu);
      }

      this.titlePopupMenu.addClass('is-selectable'); // Set the text on the Title

      var selectedText = this.titlePopupMenu.children('.is-checked').first().text();

      if (!selectedText) {
        selectedText = this.titlePopupMenu.children().first().text();
      }

      this.titlePopup.children('h1').text(selectedText); // Invoke the Popupmenu on the Title

      this.titlePopup.button().popupmenu(); // Update the Header toolbar to account for the new button

      this.element.addClass('has-popupmenu-title');
      this.toolbarAPI.init();
    },

    /**
     * Sets up header-level events
     * @fires Header#events
     * @listens updated
     * @listens reset
     * @listens drilldown
     * @listens drillup
     * @listens click
     * @listens selected
     * @returns {this} component instance
     */
    handleEvents: function handleEvents() {
      var _this = this;

      var self = this;
      this.element.on("updated.".concat(COMPONENT_NAME$1g), function (e, settings) {
        self.updated(settings);
      }).on("reset.".concat(COMPONENT_NAME$1g), function () {
        self.reset();
      }).on("drilldown.".concat(COMPONENT_NAME$1g), function (e, viewTitle) {
        self.drilldown(viewTitle);
      }).on("drillup.".concat(COMPONENT_NAME$1g), function (e, viewTitle) {
        self.drillup(viewTitle);
      });
      $('html').on("themechanged.".concat(COMPONENT_NAME$1g), function () {
        _this.updatePageChanger();
      }); // Events for the title button.  e.preventDefault(); stops Application Menu
      // functionality while drilled

      this.handleTitleButtonEvents(); // Popupmenu Events

      if (this.titlePopup && this.titlePopup.length) {
        this.titlePopup.on("selected.".concat(COMPONENT_NAME$1g), function (e, anchor) {
          var text;

          if (!(anchor instanceof $)) {
            // Toolbar Flex Item
            text = $(anchor.element).text();
          } else {
            // standard Toolbar
            text = anchor.text();
          }

          $(this).children('h1').text(text);
        });
      }

      return this;
    },

    /**
     * @private
     * @returns {void}
     */
    handleTitleButtonEvents: function handleTitleButtonEvents() {
      var _this2 = this;

      if (!this.titleButton || !this.titleButton.length) {
        return;
      }

      this.titleButton.bindFirst("click.".concat(COMPONENT_NAME$1g), function (e) {
        if (_this2.levelsDeep.length > 1) {
          e.stopImmediatePropagation();

          _this2.drillup();

          e.returnValue = false;
        }
      });
    },

    /**
     * Sets up the `selected` events on the More Actions area of the header, which can include
     * Menu Options for changing the current theme, persoanlization colors, and language locale.
     * @private
     * @param {jQuery.Event} e `click` event
     * @returns {void}
     */
    initPageChanger: function initPageChanger() {
      this.changer = this.element.find('.page-changer');

      if (!this.changer.length) {
        return;
      }

      var api = this.changer.data('popupmenu');
      var menu = api.menu;
      var colorArea = menu.find('li.personalization-colors');

      if (colorArea.length > 0) {
        var colors = theme.personalizationColors();
        var colorsHtml = colorArea.parent().hasClass('popupmenu') ? '' : '<li class="heading" role="presentation">Personalization</li>';
        Object.keys(colors).forEach(function (color) {
          colorsHtml += "<li class=\"is-selectable".concat(colors[color].name === 'Default' ? ' is-checked is-default' : '', "\"><a href=\"#\" data-rgbcolor=\"").concat(colors[color].value, "\">").concat(colors[color].name, "</a></li>");
          return color;
        });
        colorArea.replaceWith(colorsHtml);
      }

      this.changer.on('selected.header', function (e, link) {
        e.preventDefault(); // handle `ToolbarFlexItem` types

        if (link !== undefined && !(link instanceof $) && link.element instanceof HTMLElement) {
          link = $(link.element);
        } // Change Theme with Variant


        var themeNameAttr = link.attr('data-theme-name');
        var themeVariantAttr = link.attr('data-theme-variant');

        if (themeNameAttr || themeVariantAttr) {
          var name = menu.find('.is-checked a[data-theme-name]').attr('data-theme-name');
          var variant = menu.find('.is-checked a[data-theme-variant]').attr('data-theme-variant');

          if (name && variant) {
            personalization.setTheme("".concat(name, "-").concat(variant));
          }

          return;
        } // Change Theme


        var themeAttr = link.attr('data-theme');

        if (themeAttr) {
          personalization.setTheme(themeAttr);
          return;
        } // Change Color


        var isDefault = link.parent().hasClass('is-default');

        if (isDefault) {
          personalization.setColorsToDefault();
          return;
        }

        var color = link.attr('data-rgbcolor');
        personalization.setColors(color);
      }); // Mark theme as checked

      var currentTheme = theme.currentTheme;

      if (currentTheme.id !== 'theme-soho-light') {
        var themeParts = currentTheme.id.split('-');
        $('body').find('.popupmenu [data-theme-name]').parent().removeClass('is-checked');
        $('body').find(".popupmenu [data-theme-name=\"".concat(themeParts[0], "-").concat(themeParts[1], "\"]")).parent().addClass('is-checked');
        $('body').find('.popupmenu [data-theme-variant]').parent().removeClass('is-checked');
        $('body').find(".popupmenu [data-theme-variant=\"".concat(themeParts[2], "\"]")).parent().addClass('is-checked');
      }

      if (personalization.settings.colors) {
        var _colors = _typeof(personalization.settings.colors) === 'object' ? personalization.settings.colors.header : personalization.settings.colors;

        _colors = _colors.replace('#', '');
        $('body').find('.popupmenu [data-rgbcolor]').parent().removeClass('is-checked');
        $('body').find(".popupmenu [data-rgbcolor=\"#".concat(_colors, "\"]")).parent().addClass('is-checked');
      }
    },

    /**
     * Sets up the page changer after changing theme.
     * @private
     * @returns {void}
     */
    updatePageChanger: function updatePageChanger() {
      if (!this.change || this.changer.length === 0) {
        return;
      }

      var api = this.changer.data('popupmenu');
      var menu = api.menu;
      var tags = menu.find('[data-rgbcolor]');
      var colors = theme.personalizationColors();
      var keys = Object.keys(colors);

      for (var i = 0; i < tags.length; i++) {
        tags[i].setAttribute('data-rgbcolor', colors[keys[i]].value);
      }
    },

    /**
     * Drills deeper into a breadcrumb structure while updating the Header title to reflect state.
     * @private
     * @param {string} viewTitle text contents to put in place of the title area.
     * @returns {void}
     */
    drilldown: function drilldown(viewTitle) {
      this.element.addClass('is-drilldown');
      this.levelsDeep.push(viewTitle.toString());
      this.titleText.text(this.levelsDeep[this.levelsDeep.length - 1]);

      if (this.settings.useBackButton) {
        this.buildTitleButton();
      }

      if (this.settings.useBreadcrumb) {
        if (!this.breadcrumb || !this.breadcrumb.length) {
          this.buildBreadcrumb();
          this.breadcrumb.css({
            display: 'block',
            height: 'auto'
          }).removeClass('hidden');
        } else {
          this.adjustBreadcrumb();
        }
      }
    },

    /**
     * Moves up into a breadcrumb structure while updating the Header title to reflect state.
     * @private
     * @param {string} viewTitle text contents to put in place of the title area.
     * @returns {void}
     */
    drillup: function drillup(viewTitle) {
      var title;
      this.element.removeClass('is-drilldown');

      if (this.levelsDeep.length > 1) {
        this.levelsDeep.pop();
        title = this.levelsDeep[this.levelsDeep.length - 1];
      }

      if (viewTitle !== undefined) {
        title = viewTitle;
      }

      if (this.levelsDeep.length > 1) {
        if (this.settings.useBreadcrumb) {
          this.adjustBreadcrumb();
        }

        this.titleText.text(title);
        return;
      } // Completely reset all the way back to normal


      title = this.levelsDeep[0];

      if (this.settings.useBackButton) {
        this.removeButton();
      }

      if (this.settings.useBreadcrumb) {
        this.removeBreadcrumb();
      }

      if (this.settings.usePopupmenu) {
        this.removePopupmenu();
      }

      this.titleText.text(title);
      this.element.trigger('drillTop');
    },

    /**
     * Reset the toolbar to its default removing the drilled in patterns.
     * @returns {this} component instance
     */
    reset: function reset() {
      while (this.levelsDeep.length > 1) {
        this.levelsDeep.pop();
      }

      this.titleText.text(this.levelsDeep[0]);
      this.removeBreadcrumb();
      this.removeTabs();
      this.removeWizard();
      this.removePopupmenu();
      this.removeButton();
      this.element.trigger('afterreset');
      return this;
    },

    /**
     * Removes a previously-built Button pattern from the Header.
     * @private
     * @returns {void}
     */
    removeButton: function removeButton() {
      if (this.hasTitleButton) {
        this.titleButton.find('.icon.app-header').removeClass('go-back');
        return;
      }

      if (this.titleButton && this.titleButton.length) {
        this.toolbarAPI.teardown(); // Check for an active App Menu, and remove from the internal triggers, if applicable.

        var appMenu = $('#application-menu').data('applicationmenu');

        if (appMenu) {
          appMenu.modifyTriggers([this.titleButton], true, true);
        }

        this.titleButton.off("click.".concat(COMPONENT_NAME$1g)).remove();
        this.titleButton = $(); // Need to trigger an update on the toolbar control to make sure
        // tabindexes and events are all firing on the button

        this.toolbarAPI.init();
      }
    },

    /**
     * @public
     * Manually remove go-back class from button
     */
    removeBackButton: function removeBackButton() {
      if (!this.titleButton.length) {
        return;
      }

      this.element.find('.go-back').removeClass('go-back');
    },

    /**
     * Removes a previously-built Breadcrumb structure from the Header.
     * @private
     * @returns {void}
     */
    removeBreadcrumb: function removeBreadcrumb() {
      if (!this.breadcrumb || !this.breadcrumb.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout;

      function destroyBreadcrumb() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off("".concat(transitionEnd, ".breadcrumb-header"));
        self.breadcrumbAPI.destroy();
        self.breadcrumb.remove();
        delete self.breadcrumbAPI;
        delete self.breadcrumb;
      }

      self.element.removeClass('has-breadcrumb').removeClass('has-alternate-breadcrumb');

      if (this.breadcrumb.is(':not(:hidden)')) {
        this.element.one("".concat(transitionEnd, ".breadcrumb-header"), destroyBreadcrumb);
        timeout = setTimeout(destroyBreadcrumb, 300);
      } else {
        destroyBreadcrumb();
      }
    },

    /**
     * Removes a previously-built Header Tabs pattern from the Header.
     * @private
     * @returns {void}
     */
    removeTabs: function removeTabs() {
      if (!this.tabsContainer || !this.tabsContainer.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout;

      function destroyTabs() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off("".concat(transitionEnd, ".tabs-header"));
        self.tabsContainer.data('tabs').destroy();
        self.tabsContainer.remove();
        self.tabsContainer = null; // NOTE: For demo purposes the markup for tab panels is already
        // inside the Nav Patterns Test page.

        $('#header-tabs-level-1').css('display', 'none');
        $('#header-tabs-level-2').css('display', 'none');
      }

      this.element.removeClass('has-tabs').removeClass('has-alternate-tabs');

      if (this.tabsContainer.is(':not(:hidden)')) {
        this.element.one("".concat(transitionEnd, ".tabs-header"), destroyTabs);
        timeout = setTimeout(destroyTabs, 300);
      } else {
        destroyTabs();
      }
    },

    /**
     * Removes a previously-built Header Wizard pattern from the Header.
     * @private
     * @returns {void}
     */
    removeWizard: function removeWizard() {
      if (!this.wizard || !this.wizard.length) {
        return;
      }

      var self = this;
      var transitionEnd = $.fn.transitionEndName();
      var timeout;

      function destroyWizard() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        self.element.off("".concat(transitionEnd, ".wizard-header"));
        self.wizard.data('wizard').destroy();
        self.wizard.remove();
        self.wizard = null;
      }

      this.element.removeClass('has-wizard');

      if (this.wizard.is(':not(:hidden)')) {
        this.element.one("".concat(transitionEnd, ".wizard-header"), destroyWizard);
        timeout = setTimeout(destroyWizard, 300);
      } else {
        destroyWizard();
      }
    },

    /**
     * Removes a previously-built Popupmenu pattern from the Header's title.
     * @private
     * @returns {void}
     */
    removePopupmenu: function removePopupmenu() {
      var self = this;

      if (!this.titlePopup || !this.titlePopup.length) {
        return;
      }

      this.toolbarAPI.teardown();

      if (this.titlePopup.data('popupmenu')) {
        this.titlePopup.data('popupmenu').destroy();
      }

      if (this.titlePopup.data('popupmenu')) {
        this.titlePopup.data('button').destroy();
      }

      this.titlePopupMenu.remove();
      this.titlePopup.children('h1').detach().insertBefore(self.titlePopup);
      this.titlePopup.remove();
      this.titlePopup = undefined;
      this.titlePopupMenu = undefined;
      this.element.removeClass('has-popupmenu-title');
      this.toolbarAPI.init();
    },

    /**
     * Removes bound events from the Header
     * @private
     * @returns {this} component instance
     */
    unbind: function unbind() {
      if (this.titleButton && this.titleButton.length) {
        this.titleButton.off("click.".concat(COMPONENT_NAME$1g));
      }

      if (this.titlePopup && this.titlePopup.length) {
        this.titlePopup.off("updated.".concat(COMPONENT_NAME$1g));
      }

      this.element.off(["updated.".concat(COMPONENT_NAME$1g), "reset.".concat(COMPONENT_NAME$1g), "drilldown.".concat(COMPONENT_NAME$1g), "drillup.".concat(COMPONENT_NAME$1g)].join(' '));
      $('html').off("themechanged.".concat(COMPONENT_NAME$1g));
      return this;
    },

    /**
     * Sync up the ui with settings.
     * @param {object} [settings] incoming settings.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.reset().unbind().init();
    },

    /**
     * Teardown and destroy the menu and events.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();

      if (this.hasTitleButton) {
        this.toolbarElem.removeClass('has-title-button');
      }

      if (this.changer) {
        var api = this.changer.data('popupmenu');

        if (api && typeof api.destroy === 'function') {
          api.destroy();
        }

        this.changer.remove();
        delete this.changer;
      }

      $.removeData(this.element[0], COMPONENT_NAME$1g);
    }
  };

  /**
   * jQuery Component Wrapper for Header
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.header = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1g);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1g, new Header(this, settings));
      }
    });
  };

  var COMPONENT_NAME$1h = 'multitabs'; // Default Settings for MultiTabs

  var MULTITABS_DEFAULTS = {
    tabContainers: []
  }; // Pre-defined names used internally for tab containers

  var TAB_CONTAINER_NAMES = ['primary', 'secondary', 'tertiary'];
  /**
   * Scaffolding for containment of multiple, associated tabs containers.
   *
   * @class MultiTabs
   * @param {jQuery[]|HTMLElement} element base element
   * @param {object} [settings] incoming settings
   * @param {array} [settings.tabContainers] contains pre-set tab containers
   */

  function MultiTabs(element, settings) {
    this.element = $(element);
    this.settings = utils.mergeSettings(this.element[0], settings, MULTITABS_DEFAULTS); // internal stuff

    this.tabContainers = {};
    return this.init();
  }

  MultiTabs.prototype = {
    /**
     * Extra initializing steps
     * @private
     * @returns {void}
     */
    init: function init() {
      var self = this;
      var tabContainers = [];

      if (this.settings.tabContainers instanceof Array && this.settings.tabContainers.length) {
        tabContainers = this.settings.tabContainers;
      } else {
        tabContainers = this.element.find('.tab-container').filter(function () {
          return !$(this).parents('.tab-panel-container').length;
        });
      }

      $(tabContainers).each(function () {
        self.setupTabsInstance($(this));
      });
    },

    /**
     * Builds and stores an instance of a Tabs component.
     * @param {jQuery[]} tabContainer a reference to a `.tab-container` element.
     * @returns {void}
     */
    setupTabsInstance: function setupTabsInstance(tabContainer) {
      if (!(tabContainer instanceof $)) {
        return;
      }

      var self = this;
      var didAdd = false;
      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (didAdd || Object.prototype.hasOwnProperty.call(self.tabContainers, propname)) {
          return;
        }

        var api = tabContainer.data('tabs');

        if (!api) {
          tabContainer.tabs();
          api = tabContainer.data('tabs');
        }

        api.multitabsID = propname;
        tabContainer.attr('data-multitabs', propname);
        self.tabContainers[propname] = tabContainer;
        didAdd = true;
      });

      if (!didAdd) {
        throw new Error('all tab-container slots in MultiTabs component are taken, so a new tabs container was not invoked and stored');
      }
    },

    /**
     * Pass-through method for adding tabs that takes the container into account.
     * @param {jQuery[]|String} tabContainer the tab container to target
     * @param {string} tabId (directly passed into the Tabs `add` method)
     * @param {object} options (directly passed into the Tabs `add` method)
     * @param {number} [atIndex] (directly passed into the Tabs `add` method)
     * @returns {Tabs} the tabs API
     */
    add: function add(tabContainer, tabId, options, atIndex) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      var api = tabContainer.data('tabs');
      return api.add(tabId, options, atIndex);
    },

    /**
     * Pass-through method for removing tabs that takes the container into account.
     * @param {jQuery[]|String} tabContainer the tab container being removed
     * @param {string} tabId - (directly passed into the Tabs `add` method)
     * @param {boolean} [disableBeforeClose] - (directly passed into the Tabs `add` method)
     * @returns {Tabs} the tabs API instance
     */
    remove: function remove(tabContainer, tabId, disableBeforeClose) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      var api = tabContainer.data('tabs');
      return api.remove(tabId, disableBeforeClose);
    },

    /**
     * Finds an existing Tab Panel in any of the tab containers, and moves it
     *  to a designated target tab container.
     * @param {string} tabId the ID of the tab panel (and HREF attribute of the tab) being moved.
     * @param {string} targetTabContainerName name of the tab container that will receive the panel.
     * @param {boolean} [doActivate] optionally activtes the tab after it's moved.
     * @returns {void}
     */
    move: function move(tabId, targetTabContainerName, doActivate) {
      if (!tabId || !targetTabContainerName) {
        throw new Error('can\'t move a tab without both a tabId and a targetTabContainerName');
      }

      var tabMarkup;
      var panelMarkup;
      var allTabContainers = this.getFilterableTabContainers();
      var originalTabContainerName;
      allTabContainers.each(function () {
        var api = $(this).data('tabs');
        var tab = api.getTab(null, tabId); // No tabs exist by this id

        if (tab === null) {
          return;
        }

        originalTabContainerName = api.multitabsID;
        tabMarkup = tab.clone();
        panelMarkup = api.getPanel(tabId).children();
      });

      if (!tabMarkup) {
        throw new Error("No tab markup was found in any Multitabs container for href \"".concat(tabId, "\""));
      }

      this.remove(originalTabContainerName, tabId);
      this.add(targetTabContainerName, tabId, {
        name: tabMarkup.children('a').text().trim(),
        content: panelMarkup,
        doActivate: doActivate
      }); // TODO: test atIndex
    },

    /**
     * Uses the internal name of the tab container to either get a reference to an existing
     *  Tab container, or a null reference.
     * @private
     * @param {string} name - the internal name used for this tabs instance
     * @returns {jQuery[]|undefined} a tab container reference
     */
    getTabContainer: function getTabContainer(name) {
      var self = this;
      var ref;
      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (ref || !self.tabContainers[propname]) {
          return;
        }

        if (name === propname) {
          ref = self.tabContainers[propname];
        }
      });
      return ref;
    },

    /**
     * Gets all currently-setup tab containers in a jQuery selector.
     * @private
     * @returns {jQuery[]} a jQuery-based collection of all available tab containers
     */
    getFilterableTabContainers: function getFilterableTabContainers() {
      var ret = $();
      this.performOnAllContainers(function (propname, container) {
        ret = ret.add(container);
      });
      return ret;
    },

    /**
     * Validates an incoming tabContainer name, or jQuery-wrapped Tab Container instance, and returns.
     * @private
     * @param {jQuery[]|string} tabContainer the tab container being checked
     * @returns {jQuery[]} the validated tab container
     */
    checkForValidTabContainer: function checkForValidTabContainer(tabContainer) {
      if (!tabContainer) {
        throw new Error('Need to have a tabContainer defined to hide a tabs instance');
      }

      if (typeof tabContainer === 'string') {
        tabContainer = this.getTabContainer(tabContainer);
      }

      if (!(tabContainer instanceof $) || !tabContainer.length) {
        throw new Error('No matching tabContainer could be found and hidden.');
      }

      return tabContainer;
    },

    /**
     * Runs a callback function on all available tab containers.
     * @param {function} callback the callback function to be executed
     * @param {array} [additionalArgs] any additional arguments to be run in the
     *  context of the callback.
     * @returns {void}
     */
    performOnAllContainers: function performOnAllContainers(callback, additionalArgs) {
      var self = this; // Make sure additionalArgs is an array of some sort.

      if (!Array.isArray(additionalArgs)) {
        if (!additionalArgs) {
          additionalArgs = [];
        } else {
          additionalArgs = [additionalArgs];
        }
      }

      TAB_CONTAINER_NAMES.forEach(function (propname) {
        var container = self.tabContainers[propname];
        var args = [];

        if (container) {
          args.push(propname, container);
          args = args.concat(additionalArgs);
          callback.apply(this, args);
        }
      });
    },

    /**
     * Re-adjust Module-tab containers' tab widths/alignments so everything lines up.
     * @private
     * @returns {void}
     */
    adjustModuleTabContainers: function adjustModuleTabContainers() {
      this.performOnAllContainers(function (propname, container) {
        var api = container.data('tabs');

        if (api.isModuleTabs()) {
          api.adjustModuleTabs();
        }
      });
    },

    /**
     * Temporarily removes a tabset from view without destroying it.
     * @param {jQuery[]|string} tabContainer the tab container to be hidden.
     * @returns {void}
     */
    hideTabsInstance: function hideTabsInstance(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      tabContainer.parent('.multitabs-section').addClass('hidden');
      this.adjustModuleTabContainers();
    },

    /**
     * Re-displays a tabset that has temporarily been removed from view.
     * @param {jQuery[]|string} tabContainer the tab container to be shown.
     * @returns {void}
     */
    showTabsInstance: function showTabsInstance(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      tabContainer.parent('.multitabs-section').removeClass('hidden');
      this.adjustModuleTabContainers();
    },

    /**
     * Destroys a tabs instance and removes it from the queue.
     * NOTE: This only happens if the tabContainer is a part of this instance of Multitabs.
     * @param {jQuery[]} tabContainer the tab container to be destroyed.
     * @returns {void}
     */
    destroyTabsInstance: function destroyTabsInstance(tabContainer) {
      if (!(tabContainer instanceof $) || !tabContainer.data('tabs') || typeof tabContainer.data('tabs').destroy !== 'function') {
        return;
      }

      var self = this;
      var doRemove = false;
      TAB_CONTAINER_NAMES.forEach(function (propname) {
        if (doRemove || !self.tabContainers[propname].is(tabContainer)) {
          return;
        }

        var api = tabContainer.data('tabs');
        delete api.multitabsID;
        tabContainer.removeAttr('data-multitabs');
        api.destroy();
        delete self.tabContainers[propname];
        doRemove = true;
      });

      if (!doRemove) {
        throw new Error('could not destroy a tabContainer because it was not associated with this Multitabs instance');
      }
    },

    /**
     * Detects whether or not a Tab Container is currently hidden
     * @param {jQuery[]|string} tabContainer the tab container to be checked.
     * @returns {boolean} whether or not the tab container is currently hidden.
     */
    isHidden: function isHidden(tabContainer) {
      tabContainer = this.checkForValidTabContainer(tabContainer);
      return tabContainer.parent('.multitabs-section').is('.hidden');
    },

    /**
     * Update this multi-tabs instance with new settings
     * @param {object} [settings] incoming settings.
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }
    },

    /**
     * Tears down a Multitabs instance
     * @returns {this} component instance
     */
    teardown: function teardown() {
      var _this = this;

      var containers = Object.keys(this.tabContainers);
      containers.forEach(function (container) {
        _this.destroyTabsInstance(container);
      });
      return this;
    },

    /**
     * Destroys a Multitabs instance
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element[0], COMPONENT_NAME$1h);
    }
  };

  /**
   * jQuery Component Wrapper for MultiTabs
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} invoked/updated component elements
   */

  $.fn.multitabs = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1h);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1h, new MultiTabs(this, settings));
      }
    });
  };

  var COMPONENT_NAME$1i = 'listdetail'; // Available breakpoint types for Edge Bleeding

  var LIST_DETAIL_EDGE_BLEED_BREAKPOINTS = ['phone', 'tablet'];
  /**
   * @class ListDetail
   * @param {string} element The plugin element for the constuctor
   * @param {string} [settings] The settings element.
   * @param {HTMLElement} [settings.backElement] defines a trigger button that will be used to "drill up" from the detail
   * back to the list on the responsive view of this pattern.
   * @param {boolean} [settings.edgeBleed=false] if true, will show an interactive edge of the "list" element while the
   * detail view is active.  Clicking the left edge (or a button in the left edge) will cause the "drillup" operation to occur
   * while making the list active.
   * @param {string} [settings.edgeBleedBreakpoint='phone'] Defines the breakpoint where the responsive "edge bleeding" style will occur.
   * @param {HTMLElement} [settings.listElement] the base element for the Soho component that will be used as the "List" to be chosen from.
   * Must implement a Soho Accordion or Listview element.
   * @param {HTMLElement} [settings.listCloseElement]  defines a trigger button element that can be used to collapse a bleeding-edge list drawer.
   * @param {HTMLElement} [settings.detailElement] the base element for the Soho component that will be used as "detail" or content area that can
   * change based on what is picked from the list.
   */

  var LIST_DETAIL_DEFAULTS = {
    backElement: undefined,
    edgeBleed: false,
    edgeBleedBreakpoint: LIST_DETAIL_EDGE_BLEED_BREAKPOINTS[0],
    listElement: undefined,
    listCloseElement: undefined,
    detailElement: undefined
  }; // Available Soho Elements to be used as the list

  var LIST_DETAIL_SUPPORTED_LIST_TYPES = ['accordion', 'listview'];
  /**
   * Gets the type of list component
   * @private
   * @param {HTMLElement} listElement the element being checked
   * @returns {string|undefined} the type of component, or undefined
   */

  function getListType(listElement) {
    if (!(listElement instanceof HTMLElement)) {
      return undefined;
    }

    var components = Object.keys($(listElement).data());
    var type;
    components.forEach(function (key) {
      if (LIST_DETAIL_SUPPORTED_LIST_TYPES.indexOf(key) > -1) {
        type = key;
      }
    });
    return type;
  }
  /**
   * Checks an HTMLElement for a Soho Component instance that can be used for the list
   * @private
   * @param {HTMLElement} listElement the element being checked
   * @returns {boolean} whether or not the element is a valid list type
   */


  function isValidList(listElement) {
    if (!(listElement instanceof HTMLElement)) {
      return false;
    }

    var type = getListType(listElement);
    return type !== undefined;
  }
  /**
   * Implements cross-functionality between a list component and a content area that are described by
   * a Soho List/Detail pattern
   * @constructor
   * @param {HTMLElement} element the base element
   * @param {object} [settings] incoming settings
   * @returns {void}
   */


  function ListDetail(element, settings) {
    if (!(element instanceof HTMLElement)) {
      return;
    }

    this.element = element;
    this.settings = utils.mergeSettings(this.element, settings, LIST_DETAIL_DEFAULTS);
    this.init();
  }

  ListDetail.prototype = {
    /**
     * @private
     */
    init: function init() {
      var _this = this;

      this.setInternalElementReference('listElement', function (elemType) {
        return isValidList(_this.settings[elemType]);
      });
      this.setInternalElementReference('detailElement');
      this.setInternalElementReference('backElement');
      this.setInternalElementReference('listCloseElement'); // Single sanity-check for showing the detail area.

      this.showDetail = false;

      if (this.element.classList.contains('show-detail')) {
        this.showDetail = true;
      } // If a proper listElement has been provided, set a flag on its Component API
      // that notifies the API that it's controlling an adjacent detail area.


      if (this.listElement) {
        this.listComponentType = getListType(this.listElement);
        var API = this.getListAPI();

        if (API) {
          API.isControllingDetails = true;
        }
      }

      if (this.backElement) {
        this.backElement.classList.add('list-detail-back-button'); // If it's an icon button, get a reference to the icon so we can change its state.

        var hasIcon = this.backElement.querySelector('.icon');

        if (hasIcon) {
          this.backElementIcon = hasIcon;
        } // Setup internal references that can be used to find out where a backElement
        // is located internally in this pattern instance.


        if (this.listContainsBackElement) {
          this.listContainsBackElement = this.listElement.contains(this.backElement);
        }

        this.detailContainsBackElement = this.detailElement.contains(this.backElement);
      } // Gets children list/detail components


      var children = this.element.querySelectorAll('.list-detail');

      if (children) {
        this.childrenListDetailElements = children;
      } // Change edgebleed setting


      if (this.settings.edgeBleed) {
        this.edgeBleed = true;
        this.element.classList.add("bleeding-edge__".concat(this.settings.edgeBleedBreakpoint));
      } else {
        this.edgeBleed = false;
        this.element.classList.remove('bleeding-edge__phone', 'bleeding-edge__tablet');
      } // Flags for responsive behavior


      this.setBreakpointChecks();
      this.handleEvents();
    },

    /**
     * Sets internal checks for certain breakpoints
     * @private
     * @returns {void}
     */
    setBreakpointChecks: function setBreakpointChecks() {
      this.abovePhoneBreakpoint = breakpoints.isAbove('phone-to-tablet');
      this.aboveTabletBreakpoint = breakpoints.isAbove('desktop');
    },

    /**
     * Takes elements defined as settings properties, and evaluates them to determine if they
     * are valid. If so, they are set as internal component properties for future use.
     * @private
     * @param {string} elementType corresponds to a setting on the pattern that
     *  represents an element reference.
     * @param {function} [storageConditions] if defined as a function, will provide an
     *  additional set of parameters for determining if an HTMLElement is valid for this element type.
     * @returns {void}
     */
    setInternalElementReference: function setInternalElementReference(elementType, storageConditions) {
      if (typeof this.settings[elementType] === 'string' && this.settings[elementType].length) {
        var queryForElem = document.querySelector(this.settings[elementType]);

        if (queryForElem) {
          this.settings[elementType] = queryForElem;
        }
      } // Set to true to simply pass the next check, if a callback isn't provided.
      // Otherwise, resolve the callback (which should return a boolean)


      if (typeof storageConditions !== 'function') {
        storageConditions = true;
      } else {
        storageConditions = storageConditions(elementType);
      }

      if (this.settings[elementType] instanceof HTMLElement && storageConditions) {
        this[elementType] = this.settings[elementType];
      }
    },

    /**
     * @private
     * @listens drilldown custom jQuery event that causes the detail area to become active
     * @listens drillup custom jQuery event that causes the list area to become active
     * @listens click
     */
    handleEvents: function handleEvents() {
      var _this2 = this;

      $(this.element).on("drilldown.".concat(COMPONENT_NAME$1i), function (e, item) {
        e.stopPropagation();

        _this2.drilldown(item, e.target);
      }).on("drillup.".concat(COMPONENT_NAME$1i), function (e) {
        e.stopPropagation();

        _this2.drillup();
      });

      if (this.backElement) {
        this.backElement.addEventListener('click', this.handleBackClick.bind(this));
      }

      if (this.listCloseElement) {
        this.listCloseElement.addEventListener('click', this.handleClose.bind(this));
      } // Run certain responsive checks on page resize


      $('body').off("resize.".concat(COMPONENT_NAME$1i)).on("resize.".concat(COMPONENT_NAME$1i), function () {
        _this2.handleResize();
      });
    },

    /**
     * Causes the list/detail pattern to activate the detail area, "drilling down"
     *  into it, away from the list area.
     * @param {HTMLElement} section provides context from the element chosen from the list
     * @param {HTMLElement} [eventTarget] will cause the drilldown operation to stop if the
     *  element provided isn't registered as the list in this list/detail instance (used when
     *  events trigger this method).
     * @returns {void}
     */
    drilldown: function drilldown(section, eventTarget) {
      if (this.showDetail) {
        return;
      } // If eventTarget's provided, check to see if it's the same element as the
      // stored ListElement.  If they're not, don't continue (could have been triggered
      // by an inner-detail area ListView/Accordion)


      if (eventTarget && eventTarget.innerHTML !== this.listElement.innerHTML) {
        return;
      }

      this.showDetail = true;
      this.element.classList.add('show-detail');
      this.addBackElementIconContext();

      if (!this.isAboveBreakpoint()) {
        this.getListAPI().disable();
      } // Pass an event to the Detail Area's main element with some context about
      // what was clicked inside the list.


      if (this.detailArea) {
        $(this.detailElement).triggerHandler('activatescreen', [section]);
      }
    },

    /**
     * Causes the list/detail pattern to activate the list area, "drilling up" from the detail area.
     * @returns {void}
     */
    drillup: function drillup() {
      if (!this.showDetail) {
        return;
      }

      this.removeBackElementIconContext();
      this.getListAPI().enable();
      this.showDetail = false;
      this.element.classList.remove('show-detail');
    },

    /**
     * @private
     * @returns {void}
     */
    addBackElementIconContext: function addBackElementIconContext() {
      if (this.showDetail && this.backElementIcon && !this.backElementIcon.classList.contains('go-back')) {
        this.backElementIcon.classList.add('go-back');
      }
    },

    /**
     * @private
     * @returns {void}
     */
    removeBackElementIconContext: function removeBackElementIconContext() {
      if (this.backElementIcon && this.backElementIcon.classList.contains('go-back')) {
        this.backElementIcon.classList.remove('go-back');
      }
    },

    /**
     * Handles `click` events passed to the `backElement`.
     * @private
     * @param {Event} e `click` event
     * @returns {boolean} whether or not the click operation should be allowed to continue
     */
    handleBackClick: function handleBackClick(e) {
      function cancelClick() {
        // Prevent the normal `click` operation of the backElement.
        // (FX: if `backElement` is the App Menu trigger, prevents the App Menu from opening)
        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();
      }

      if (!this.showDetail) {
        // In "edgeBleed" configuration, the BackElement can be used to drill back into a previously
        // selected list item, if one was previously selected.
        if (this.edgeBleed) {
          var selected = this.getCurrentSelectedListItem();

          if (selected) {
            this.drilldown(selected);
            cancelClick();
            return false;
          }
        }

        return true;
      }

      this.drillup();

      if (this.childrenListDetailElements) {
        this.childrenListDetailElements.forEach(function (elem) {
          var api = $(elem).data(COMPONENT_NAME$1i);

          if (api && typeof api.drillup === 'function') {
            api.drillup();
          }
        });
      }

      cancelClick();
      return false;
    },

    /**
     * Handler for the listCloseElement's `click` event.
     * @returns {void}
     */
    handleClose: function handleClose() {
      if (this.showDetail) {
        return;
      } // `selected` may be undefined here


      var selected = this.getCurrentSelectedListItem();
      this.drilldown(selected);
    },

    /**
     * Event handler for `body.on('resize')`. Runs whenever the page is resized.
     * @returns {void}
     */
    handleResize: function handleResize() {
      this.setBreakpointChecks();
      var listAPI = this.getListAPI();

      if (this.isAboveBreakpoint()) {
        if (this.edgeBleed && !this.showDetail && this.listElement.classList.contains('is-disabled')) {
          listAPI.enable();
        }
      } else if (this.edgeBleed && this.showDetail && !this.listElement.classList.contains('is-disabled')) {
        listAPI.disable();
      } // Removes the `go-back` class from the hamburger icon if we're above the breakpoint.


      if (this.isAboveBreakpoint()) {
        this.removeBackElementIconContext();
      } else {
        this.addBackElementIconContext();
      } // Make sure the list is always re-enabled on desktop


      if (breakpoints.isAbove('desktop')) {
        listAPI.enable();
      }
    },

    /**
     * Checks to see if the screen size is currently above the defined breakpoint
     * @returns {boolean} whether or not the screen size is larger than the defined breakpoint.
     */
    isAboveBreakpoint: function isAboveBreakpoint() {
      var breakpoint = this.settings.edgeBleedBreakpoint;
      var breakpointPropname = "above".concat(stringUtils.capitalize(breakpoint), "Breakpoint");
      return this[breakpointPropname];
    },

    /**
     * Gets a reference to the defined List Element's Component API.
     * @returns {object|undefined} a Soho Component API from a supported list type, or undefined
     * if no API currently exists.
     */
    getListAPI: function getListAPI() {
      if (!this.listElement) {
        return undefined;
      }

      return $(this.listElement).data(this.listComponentType);
    },

    /**
     * Finds whatever item is currently selected by the listElement.
     * @returns {HTMLElement} a reference to that element.
     */
    getCurrentSelectedListItem: function getCurrentSelectedListItem() {
      if (!this.listElement) {
        return '';
      }

      var item;
      var API = this.getListAPI();

      switch (this.listComponentType) {
        case 'accordion':
          item = API.getSelected();
          break;

        default:
          // 'listview'
          item = API.getSelected();
          break;
      } // Most components are still using jQuery,
      // Run through a simple reference extraction to get at the HTMLElement


      item = DOM.convertToHTMLElement(item);
      return item;
    },

    /**
     * Updates the List/Detail pattern with new settings
     * @param {object} [settings] incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element[0], settings, this.settings);
      }

      this.teardown();
      this.init();
    },

    /**
     * Removes all bound events and internal references to other components' elements/APIs
     * @private
     * @returns {void}
     */
    teardown: function teardown() {
      $('body').off("resize.".concat(COMPONENT_NAME$1i));
      $(this.element).off("drilldown.".concat(COMPONENT_NAME$1i, " drillup.").concat(COMPONENT_NAME$1i));

      if (this.backElement) {
        this.backElement.removeEventListener('click', this.handleBackClick.bind(this));
      }

      if (this.listCloseElement) {
        this.listCloseElement.removeEventListener('click', this.handleClose.bind(this));
      }

      if (this.listComponentType) {
        var API = this.getListAPI();

        if (API) {
          delete API.isControllingDetails;
        }
      }

      delete this.listElement;
      delete this.detailElement;
      delete this.backElement;
      delete this.backElementIcon;
      delete this.edgeBleed;
      delete this.listContainsBackElement;
      delete this.detailContainsBackElement;
      delete this.childrenListDetailElements;
      delete this.showDetail;
    },

    /**
     * @private
     * @returns {void}
     */
    destroy: function destroy() {
      this.teardown();
      $.removeData(this.element, COMPONENT_NAME$1i);
    }
  };

  /**
   * jQuery Component Wrapper for List/Detail Pattern
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} jQuery-wrapped components being acted on
   */

  $.fn.listdetail = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1i);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1i, new ListDetail(this, settings));

        instance.destroy = function destroy() {
          this.teardown();
          $.removeData(this, COMPONENT_NAME$1i);
        };
      }
    });
  };

  var COMPONENT_NAME$1j = 'stepprocess'; // Default Stepprocess Options

  var STEPPROCESS_DEFAULTS = {
    linearProgression: false,
    folderIconOpen: 'caret-up',
    folderIconClosed: 'caret-down',
    stepList: '#step-list',
    stepLi: '.js-step',
    stepLink: '.js-step-link',
    stepFolder: '.js-step-folder',
    btnPrev: '.js-step-link-prev',
    btnNext: '.js-step-link-next',
    btnSaveClose: '.js-btn-save-changes',
    beforeSelectStep: null
  };
  /**
   * A Stepprocess/wizard control
   * @class Stepprocess
   * @deprecated as of v4.20.0. This component is no longer supported by the IDS team.
   * @param {string} element The component element.
   * @param {string} [settings] The component settings.
   * @param {boolean} [settings.linearProgression = false] The Main Application Name to display
   in the header. (Defaults to false)
   * @param {string} [settings.folderIconOpen = 'caret-up'] A specific folder open icon. (Defaults to 'caret-up')
   * @param {string} [settings.folderIconClosed =  'caret-down'] A specific folder close icon. (Defaults to 'caret-down')
   * @param {boolean} [settings.stepList = '#step-list'] Determines whether or not to display device
   information (Browser, Platform, Locale, Cookies Enabled).
   * @param {string} [settings.stepLi = '.js-step'] jQuery selector for the step elements.
   * @param {boolean} [settings.stepLink =  '.js-step-link'] jQuery selector for the step link elements.
   * @param {string} [settings.stepFolder = '.js-step-folder'] jQuery selector for the step folder elements.
   * @param {string} [settings.btnPrev = '.js-step-link-prev'] jQuery selector for the previous step button.
   * @param {string} [settings.btnNext = '.js-step-link-prev'] jQuery selector for the next step button.
   * @param {function} [settings.beforeSelectStep] A callback (function or promise)
   that gives args: stepLink (the step link element) and isStepping
   (whether we are prev/next'ing or not).
   */

  function Stepprocess(element, settings) {
    this.settings = utils.mergeSettings(element, settings, STEPPROCESS_DEFAULTS);
    this.element = $(element);
    this.init();
    warnAboutRemoval('Stepprocess');
  } // Stepprocess Methods


  Stepprocess.prototype = {
    /**
     * Init stepprocess
     * @private
     */
    init: function init() {
      this.stepListJq = $(this.settings.stepList);
      this.initStepprocess();
      this.handleKeys();
      this.setupEvents();
      this.focusFirst();
    },

    /**
     * Initialize stepprocess
     * @private
     * @returns {void}
     */
    initStepprocess: function initStepprocess() {
      var steps = this.stepListJq.find(this.settings.stepLi);

      for (var i = 0, l = steps.length; i < l; i++) {
        this.decorateNode(steps[i]);
      }

      var startingStep = $("".concat(this.settings.stepLi, ".is-selected"));
      var startingStepLink = startingStep.find(this.settings.stepLink);
      this.selectStep(startingStepLink);
    },

    /**
     * Set initial attributes on each step its counterparts
     * @private
     * @param  {object} step - The step element to decorate
     * @returns {void}
     */
    decorateNode: function decorateNode(step) {
      var self = this;
      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      var stepFolderJq = stepJq.children(this.settings.stepFolder);
      var isDisabled = stepLinkJq.hasClass('is-disabled');
      var isOpen = stepFolderJq.hasClass('is-open');

      if (isDisabled) {
        stepLinkJq.attr('aria-disabled', 'true');
      }

      if (stepFolderJq.length) {
        stepJq.addClass('folder');
        stepFolderJq.attr('role', 'group');

        if (isDisabled) {
          stepFolderJq.addClass('disabled');

          if (isOpen) {
            var stepLinks = stepFolderJq.children();

            for (var i = 0, l = stepLinks.length; i < l; i++) {
              $(stepLinks[i]).find(self.settings.stepLink).addClass('is-disabled').attr('aria-disabled', 'true');
            }
          }
        }

        stepLinkJq.attr('aria-expanded', isOpen);
      } // parentCount 'aria-level' to the node's level depth


      var parentCount = stepLinkJq.parentsUntil(this.stepListJq, 'ul').length - 1; // Set the current stepprocess item node position relative to its aria-setsize

      var posinset = stepJq.index(); // Set the current stepprocess item aria-setsize

      var listCount = stepJq.siblings().addBack().length;
      stepLinkJq.attr({
        role: 'stepitem',
        tabindex: '-1',
        'aria-selected': 'false',
        'aria-level': parentCount + 1,
        'aria-posinset': posinset + 1,
        'aria-setsize': listCount,
        'aria-disabled': isDisabled
      }).addClass('hide-focus').hideFocus();
    },

    /**
     * Set tabindex to be focus first
     * @private
     * @returns {void}
     */
    focusFirst: function focusFirst() {
      this.stepListJq.find("".concat(this.settings.stepLi, ":first")).attr('tabindex', '0');
    },

    /**
     * Set initial attributes on each step its counterparts
     * @private
     * @param  {object} step - The step element
     * @returns {void}
     */
    folderClose: function folderClose(step) {
      var _this = this;

      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      var stepFolderJq = stepJq.children(this.settings.stepFolder);
      var treeIcon = stepLinkJq.closest('.folder').removeClass('is-open').end().find('svg.icon-tree');
      this.setIcon(treeIcon, this.settings.folderIconClosed);
      this.isAnimating = true;
      stepFolderJq.one('animateclosedcomplete', function () {
        stepFolderJq.removeClass('is-open');
        _this.isAnimating = false;
      }).animateClosed();
      stepLinkJq.attr('aria-expanded', 'false');
    },

    /**
     * Folder open
     * @private
     * @param  {object} step - The step element
     * @returns {void}
     */
    folderOpen: function folderOpen(step) {
      var _this2 = this;

      var stepJq = $(step);

      if (!this.isOpen(stepJq)) {
        var stepLinkJq = stepJq.children(this.settings.stepLink);
        var stepFolderJq = stepJq.children(this.settings.stepFolder);
        stepJq.addClass('is-open');
        stepLinkJq.attr('aria-expanded', 'true');
        var svgElem = stepLinkJq.find('svg.icon-tree');
        this.setIcon(svgElem, this.settings.folderIconOpen);
        this.isAnimating = true;
        stepFolderJq.one('animateopencomplete', function () {
          _this2.isAnimating = false;
        }).addClass('is-open').css('height', 0).animateOpen();
      }
    },

    /**
     * Folder toggle
     * @private
     * @param  {object} stepLink - Description
     * @returns {void}
     */
    folderToggle: function folderToggle(stepLink) {
      var stepJq = stepLink.closest(this.settings.stepLi);

      if (this.isFolder(stepJq)) {
        var stepFolderJq = stepJq.children(this.settings.stepFolder);

        if (this.isOpen(stepFolderJq)) {
          this.folderClose(stepJq);
        } else {
          this.folderOpen(stepJq);
        }
      }
    },

    /**
     * Get selected step
     * @private
     * @returns {object} selected step
     */
    getSelectedStep: function getSelectedStep() {
      return $("".concat(this.settings.stepLi, ".is-selected"), this.stepListJq);
    },

    /**
     * Get next node
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} node
     */
    getNextNode: function getNextNode(stepLink) {
      var s = this.settings;
      var next = stepLink.parent().next().find("".concat(s.stepLink, ":first")); // Possibly Move Into Children

      if (stepLink.next().is(s.stepFolder) && stepLink.next().hasClass('is-open')) {
        next = stepLink.next().find("".concat(s.stepLink, ":first"));
      } // Skip disabled


      if (next.hasClass('is-disabled')) {
        next = this.getNextNode(next);
      } // Bottom of a group..{l=2: max folders to be deep }


      if (next.length === 0) {
        for (var i = 0, l = 2, closest = stepLink; i < l; i++) {
          closest = closest.parent().closest('.folder');
          next = closest.next().find("".concat(s.stepLink, ":first"));

          if (next.length) {
            break;
          }
        }
      }

      return next;
    },

    /**
     * Get the next step in the tree
     * (not to be confused with getNextNode, which includes folders)
     * @private
     * @param  {object} curStepJq - The step link element
     * @returns {object} next step
     */
    getNextStep: function getNextStep(curStepJq) {
      var curStepLinkJq = curStepJq.children(this.settings.stepLink);
      var curStepFolderJq = curStepJq.next(this.settings.stepFolder);
      var nextStepLinkJq = this.getNextNode(curStepLinkJq);
      var nextStepFolderJq = nextStepLinkJq.next(this.settings.stepFolder);
      var stepLinkToSelect = null;
      var theFolder = null;

      if (curStepFolderJq.length) {
        // Select the first node of the current folder,
        // unless its empty, which means nextStep will be the folder's "title"
        theFolder = curStepFolderJq;
        stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : nextStepLinkJq;
      } else if (nextStepFolderJq.length) {
        // Select the first node of the next node's folder,
        // unless its empty, which means nextStep will be the folder's "title"
        theFolder = nextStepFolderJq;
        stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : nextStepLinkJq;
      } else {
        // Neither folders options work so select the next node
        stepLinkToSelect = nextStepLinkJq;
      } // Skip disabled


      if (stepLinkToSelect.hasClass('is-disabled')) {
        stepLinkToSelect = this.getNextStep(stepLinkToSelect.parent());
      }

      return stepLinkToSelect;
    },

    /**
     * Get the previous node
     * @private
     * @param  {object} stepLink - The step link element
     * @returns {object} previous node
     */
    getPreviousNode: function getPreviousNode(stepLink) {
      var s = this.settings;
      var prev = stepLink.parent().prev().find("".concat(s.stepLink, ":first"));
      var prevStepJq = prev.closest(s.stepLi); // Move into children at bottom

      if (prevStepJq.is('.folder.is-open') && prevStepJq.find('ul.is-open a').length && !prevStepJq.find('ul.is-disabled').length) {
        prev = prevStepJq.find("ul.is-open ".concat(s.stepLink, ":last"));
      } // Skip disabled


      if (prev.hasClass('is-disabled')) {
        this.getPreviousNode(prev);
      } // Top of a group


      if (prev.length === 0) {
        prev = stepLink.closest(s.stepFolder).prev(s.stepLink);
      }

      return prev;
    },

    /**
     * Get the previous step in the tree
     * (not to be confused with getPreviousNode, which includes folders)
     * @private
     * @param  {object} curStepJq - The step link element
     * @returns {object} previous step
     */
    getPreviousStep: function getPreviousStep(curStepJq) {
      var s = this.settings;
      var curStepLinkJq = curStepJq.children(s.stepLink); // Get the previous step to switch to

      var prevStepLinkJq = this.getPreviousNode(curStepLinkJq);
      var prevStepJq = prevStepLinkJq.closest(s.stepLi);
      var stepLinkToSelect = prevStepLinkJq; // If we are moving upwards and hit a folder title step

      if (this.isFolder(prevStepJq)) {
        if (this.isOpen(prevStepJq)) {
          // If the folder is open, and we got here, that means we
          // were currently at the first step in the folder and need to
          // go to the prev step above the folder step (aka the prev to the prev)
          stepLinkToSelect = this.getPreviousNode(prevStepLinkJq);
        } else {
          var theFolder = prevStepJq.children(s.stepFolder);

          if (theFolder.children().length) {
            stepLinkToSelect = theFolder.find(s.stepLink).last();
          }
        }
      } // Skip disabled


      if (stepLinkToSelect.hasClass('is-disabled')) {
        stepLinkToSelect = this.getPreviousStep(stepLinkToSelect.parent());
      }

      return stepLinkToSelect;
    },

    /**
     * Go to the next step element
     * @private
     * @returns {void}
     */
    goToNextStep: function goToNextStep() {
      var self = this;
      var curStepJq = this.getSelectedStep();
      var stepLink = self.getNextStep(curStepJq);

      if (stepLink.length) {
        self.selectStep(stepLink, 'next');
      } else if (typeof self.settings.beforeSelectStep === 'function') {
        var args = {
          isStepping: 'next'
        };
        var result = self.settings.beforeSelectStep(args);

        if (result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode, stepLinkToSelect) {
            if (continueSelectNode) {
              if (stepLinkToSelect) {
                self.selectStepFinish(stepLinkToSelect);
              }
            }
          });
        } else if (result) {
          // boolean is returned instead of a promise
          self.selectStepFinish(stepLink);
        }
      }
    },

    /**
     * Go to the previous step element
     * @private
     * @returns {void}
     */
    goToPreviousStep: function goToPreviousStep() {
      var curStepJq = this.getSelectedStep();
      var stepLink = this.getPreviousStep(curStepJq);

      if (stepLink.length) {
        this.selectStep(stepLink, 'prev');
      }
    },

    /**
     * Key Behavior as per:
     * http://access.aol.com/dhtml-style-guide-working-group/#treeview
     * @private
     * @returns {void}
     */
    handleKeys: function handleKeys() {
      /* eslint-disable consistent-return */
      var self = this;
      var s = this.settings;
      this.stepListJq.on('focus.stepprocess', s.stepLink, function () {
        var target = $(this);

        if (parseInt(target.attr('aria-level'), 10) === 0 && parseInt(target.attr('aria-posinset'), 10) === 1) {
          // First element if disabled
          if (target.hasClass('is-disabled')) {
            var e = $.Event('keydown.stepprocess');
            e.keyCode = 40; // move down

            target.trigger(e);
            return; // eslint-disable-line
          }
        }
      }); // Handle Up/Down Arrow Keys and Space

      this.stepListJq.on('keydown.stepprocess', s.stepLink, function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);
        var next;
        var prev;

        if (self.isAnimating) {
          return;
        } // Down arrow


        if (charCode === 40) {
          var nextNode = self.getNextNode(target);
          self.setFocus(nextNode);
        } // Up arrow,


        if (charCode === 38) {
          var prevNode = self.getPreviousNode(target);
          self.setFocus(prevNode);
        } // Space


        if (e.keyCode === 32) {
          target.trigger('click.stepprocess');
        } // Left arrow


        if (charCode === 37) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              prev = target.next().find("".concat(s.stepLink, ":first"));
              self.setFocus(prev);
            } else {
              self.folderToggle(target);
            }
          } else if (target.next().hasClass('is-open')) {
            self.folderToggle(target);
          } else {
            prev = target.closest('.folder').find("".concat(s.stepLink, ":first"));
            self.setFocus(prev);
          }

          e.stopPropagation();
          return false;
        } // Right arrow


        if (charCode === 39) {
          if (Locale.isRTL()) {
            if (target.next().hasClass('is-open')) {
              self.folderToggle(target);
            } else {
              next = target.closest('.folder').find("".concat(s.stepLink, ":first"));
              self.setFocus(next);
            }
          } else if (target.next().hasClass('is-open')) {
            next = target.next().find("".concat(s.stepLink, ":first"));
            self.setFocus(next);
          } else {
            self.folderToggle(target);
            self.setFocus(target);
          }

          e.stopPropagation();
          return false; // eslint-disable-line
        } // Home  (fn-right on mac)


        if (charCode === 36) {
          next = self.stepListJq.find("".concat(s.stepLink, ":first:visible"));
          self.setFocus(next);
        } // End (fn-right on mac)


        if (charCode === 35) {
          next = self.stepListJq.find("".concat(s.stepLink, ":last:visible"));
          self.setFocus(next);
        }
      }); // Handle Left/Right Arrow Keys

      this.stepListJq.on('keypress.stepprocess', s.stepLink, function (e) {
        var charCode = e.charCode || e.keyCode;
        var target = $(this);

        if (charCode >= 37 && charCode <= 40 || charCode === 32) {
          e.stopPropagation();
          return false;
        } // Printable Chars Jump to first high level node with it...


        if (e.which !== 0) {
          target.closest(s.stepLi).nextAll().find('.js-step-link:visible').each(function () {
            var node = $(this);
            var first = node.text().substr(0, 1).toLowerCase();
            var term = String.fromCharCode(e.which).toLowerCase();

            if (first === term) {
              self.setFocus(node);
              return false;
            }
          });
        }
      });
      /* eslint-enable consistent-return */
    },

    /**
     * Checks if given step element is folder.
     * @private
     * @param {object} step - The step element
     * @returns {boolean} true if folder
     */
    isFolder: function isFolder(step) {
      return $(step).hasClass('folder');
    },

    /**
     * Checks if given step element is in folder.
     * @private
     * @param {object} step - The step element
     * @returns {boolean} true is in folder
     */
    isInFolder: function isInFolder(step) {
      return $(step).closest(this.settings.stepFolder, this.stepListJq).length;
    },

    /**
     * Checks if given step folder is open.
     * @private
     * @param {object} stepFolder element
     * @returns {boolean} true is open
     */
    isOpen: function isOpen(stepFolder) {
      return $(stepFolder).hasClass('is-open');
    },

    /**
     * Set focus on given step link.
     * @private
     * @param {object} stepLink element
     * @returns {void}
     */
    setFocus: function setFocus(stepLink) {
      stepLink.focus();
    },

    /**
     * Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing.
     * @private
     * @param {object} svg element.
     * @param {string} icon to set.
     * @returns {void}
     */
    setIcon: function setIcon(svg, icon) {
      var iconStr = icon.replace(/icon-|hide-focus|\s?/gi, '');
      svg.changeIcon(iconStr);
    },

    /**
     * Select a step
     * @private
     * @param  {object} stepLink - The jquery object for the step link element
     * @param  {string} linearDirection - [none|previous|next] Which direction we are traveling
     * @returns {void}
     */
    selectStep: function selectStep(stepLink, linearDirection) {
      var self = this;

      if (linearDirection === undefined) {
        linearDirection = 'none';
      } // Possibly Call the beforeSelectStep


      var result;

      if (typeof self.settings.beforeSelectStep === 'function') {
        var args = {
          stepLink: stepLink,
          isStepping: linearDirection
        };
        result = self.settings.beforeSelectStep(args);

        if (result.done && typeof result.done === 'function') {
          // A promise is returned
          result.done(function (continueSelectNode, stepLinkToSelect) {
            if (continueSelectNode) {
              if (stepLinkToSelect) {
                stepLink = stepLinkToSelect;
              }

              self.selectStepFinish(stepLink, linearDirection);
            }
          });
        } else if (result) {
          // boolean is returned instead of a promise
          self.selectStepFinish(stepLink, linearDirection);
        }
      } else {
        // No Callback specified
        self.selectStepFinish(stepLink, linearDirection);
      }
    },

    /**
     * Finishes selecting a step
     * @private
     * @param  {object} stepLink - Description
     * @param  {string} [linearDirection=previous|next] - Description
     * @returns {void}
     */
    selectStepFinish: function selectStepFinish(stepLink, linearDirection) {
      var self = this;
      var allStepLinksJq = $(this.settings.stepLink, this.stepListJq);
      var stepJq = stepLink.closest(this.settings.stepLi);

      if (!this.isFolder(stepJq)) {
        allStepLinksJq.attr({
          tabindex: '-1',
          'aria-selected': 'false'
        }).parent().removeClass('is-selected');
        stepLink.attr({
          tabindex: '0',
          'aria-selected': 'true'
        });
        stepJq.addClass('is-selected');
      }

      if (this.isFolder(stepJq)) {
        // It is a folder
        if (linearDirection === 'none') {
          this.folderToggle(stepJq); // clicking toggles
        } else {
          this.folderOpen(stepJq); // going prev/next always opens
        }
      } else {
        // Its not a folder
        var parentIsFolder = stepJq.closest(this.settings.stepFolder, this.stepListJq);

        if (parentIsFolder.length) {
          // If the step is in a folder, make sure that folder opens
          this.folderOpen(parentIsFolder.closest(this.settings.stepLi));
        } // Show the step's panel


        this.showStepPanel(stepLink.attr('href'));
      }

      stepLink.focus();
      setTimeout(function () {
        /**
         * Fires when selected step link.
         * @event selected
         * @memberof Stepprocess
         * @type {object}
         * @property {object} event - The jquery event object
         * @property {object} stepLink element
         */
        self.element.triggerHandler('selected', stepLink);
      }, 0);
    },

    /**
     * Un selected node
     * @private
     * @param {object} step - The step element to decorate
     * @returns {void}
     */
    unSelectedNode: function unSelectedNode(step) {
      var aTags = $(this.settings.stepLink, this.stepListJq);
      var stepJq = $(step);
      var stepLinkJq = stepJq.children(this.settings.stepLink);
      aTags.attr('tabindex', '-1');
      stepLinkJq.attr('tabindex', '0');
      stepJq.removeClass('is-selected');
      stepLinkJq.attr('aria-selected', 'false');
    },

    /**
     * Setup events
     * @private
     * @returns {void}
     */
    setupEvents: function setupEvents() {
      var _this3 = this;

      var self = this;
      var s = this.settings; // Updated and Click events

      this.stepListJq.on('updated.stepprocess', function () {
        _this3.initStepprocess();
      }).on('click.stepprocess', "".concat(s.stepLink, ":not(.is-clone)"), function (e) {
        e.preventDefault();

        if (!s.linearProgression) {
          var targetJq = $(this);

          if (!targetJq.is('.is-disabled, .is-loading')) {
            self.selectStep(targetJq);
            e.stopPropagation();
          }
        }
      }); // Next Button Click

      $(s.btnPrev).on('click', function (e) {
        e.preventDefault();

        _this3.goToPreviousStep.call(self);
      }); // Previous Button Click

      $(s.btnNext).on('click', function (e) {
        e.preventDefault();

        _this3.goToNextStep.call(self);
      }); // Setup main scrolling

      $(s.contentScroll).scrollaction({
        scrollActionTarget: '.main'
      }); // Setup sidebar scrolling

      $(s.stepListScroll).scrollaction({
        scrollActionTarget: '.sidebar'
      }); // Toggle sidebar
      // Button to toggle the tree in responsive view

      $('.js-toggle-sidebar').click(function (e) {
        e.preventDefault();

        _this3.element.toggleClass('tablet-hide-steps').toggleClass('phone-hide-steps');
      });
    },

    /**
     * Show the content panel for the step
     * @private
     * @param  {string} contentId - The contentId to show
     * @returns {void}
     */
    showStepPanel: function showStepPanel(contentId) {
      $('.step-panel-active').removeClass('step-panel-active');
      $(contentId).addClass('step-panel-active');
      this.element.addClass('phone-hide-steps');
    },

    /**
     * Removes event bindings from the instance.
     * @private
     * @returns {object} The api
     */
    unbind: function unbind() {
      this.stepListJq.off('updated.stepprocess click.stepprocess focus.stepprocess keydown.stepprocess keypress.stepprocess').empty();
      return this;
    },

    /**
     * Resync the UI and Settings.
     * @param {object} settings The settings to apply.
     * @returns {object} The api
     */
    updated: function updated(settings) {
      if (typeof settings !== 'undefined') {
        this.settings = utils.mergeSettings(this.element, settings, STEPPROCESS_DEFAULTS);
      }

      return this.unbind().init();
    },

    /**
     * Destroy this component instance and remove the link from its base element.
     * @returns {void}
     */
    destroy: function destroy() {
      this.unbind();
      $.removeData(this.element[0], COMPONENT_NAME$1j);
    }
  };

  /**
   * jQuery Component Wrapper for Stepprocess
   * @param {object} [settings] incoming settings
   * @returns {jQuery[]} elements being acted on
   */

  $.fn.stepprocess = function (settings) {
    return this.each(function () {
      var instance = $.data(this, COMPONENT_NAME$1j);

      if (instance) {
        instance.updated(settings);
      } else {
        instance = $.data(this, COMPONENT_NAME$1j, new Stepprocess(this, settings));
      }
    });
  };

  var INITIALIZE_DEFAULTS = {
    locale: 'en-US',
    language: null // same as locale by default

  }; // Contains excluded CSS selectors that prevent automatic initialization

  var noinitExcludes = '.no-init, [data-init]'; // Invokes a Soho component against an Element

  function invoke(elem, pluginName, settings) {
    return $(elem)[pluginName](settings);
  } // Finds child elements that match a CSS selector


  function matchedItems(elem, selector) {
    var items = elem.find(selector).not(noinitExcludes);

    if (elem.filter(selector).length) {
      items = items.add(elem);
    }

    return items;
  } // Array of plugin names, selectors (optional), and callback functions (optional),
  // for no-configuration initializations.


  var PLUGIN_MAPPINGS = [// Inline text translations by Locale, via the `data-translate` attribute.
  // (Not all inline text items are powered by JS components)
  ['texttranslations', '[data-translate="text"]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var obj = $(item);
      obj.attr('data-translate-key', obj.text());
      obj.text(Locale.translate(obj.text(), true));
    });
  }], ['texttranslations', '[data-translate="value"]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var obj = $(item);
      obj.attr('data-translate-key', obj.attr('value'));
      obj.attr('value', Locale.translate(obj.attr('value'), true));
    });
  }], ['texttranslations', '[data-translate="placeholder"]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var obj = $(item);
      obj.attr('data-translate-key', obj.attr('placeholder'));
      obj.attr('placeholder', Locale.translate(obj.attr('placeholder'), true));
    });
  }], // Application Menu
  ['applicationmenu', '#application-menu', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      $(item).applicationmenu({
        triggers: rootElem.find('.application-menu-trigger')
      });
    });
  }], // Personalization
  ['personalize', null, function () {
    $('html').personalize();
  }], // Hyperlinks
  ['hyperlink'], // Icons
  ['icon'], // Radio switch
  ['radio', '.radio-section input:radio.handle', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).change(function () {
      if (this.checked) {
        var option = $(this).closest('.option');
        var siblings = option.siblings();
        var fields = 'button, select, input[type="text"]';
        $(fields, option).removeAttr('disabled');
        $(fields, siblings).attr('disabled', 'disabled');
      }
    });
  }], ['splitter'], // Tabs
  ['tabs', '.tab-container:not(.vertical)'], // Vertical Tabs
  ['verticaltabs', '.tab-container.vertical'], // MultiTabs Containers
  ['multitabs', '.multitabs-container'], // Select / DropDowns
  ['dropdown', 'select.dropdown:not(.multiselect)'], ['dropdown', 'select.dropdown-xs:not(.multiselect)'], ['dropdown', 'select.dropdown-sm:not(.multiselect)'], ['dropdown', 'select.dropdown-lg:not(.multiselect)'], // Modals
  ['modal'], // Password Reveal
  ['revealText', 'input.input-password-reveal'], // Sliders
  ['slider', 'input[type="range"], .slider'], // Editors
  ['editor'], // Tooltips
  ['tooltip', 'button[title], span[title], .hyperlink[title], .icon[title], input[title]'], // Tree
  ['tree'], // Rating
  ['rating'], // Listbuilder
  ['listbuilder'], // Composite Form Wrapper
  ['compositeform', '.composite-form'], // Progress
  ['progress', '.progress-bar'], // Format
  ['mask', 'input[data-mask], .new-mask'], // Auto Complete
  ['autocomplete', '.autocomplete:not([data-init])'], // Multiselect
  ['multiselect', 'select[multiple]:not(.dropdown), .multiselect:not([data-init])'], // Button with Effects
  // NOTE: don't invoke buttons inside of modals, wait for the modal to be invoked.
  ['button', ['.btn', '.btn-toggle', '.btn-secondary', '.btn-primary', '.btn-modal-primary', '.btn-tertiary', '.btn-icon', '.btn-actions', '.btn-menu', '.btn-split', '.btn-secondary-border'].join(', '), function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var parents = $(item).parents('.modal');

      if (parents.length) {
        return;
      }

      $(item).button();
    });
  }], // Hide Focus
  ['hideFocus', 'a.hide-focus, a.tick, .checkbox, .radio, .switch'], // Circle Pager
  ['circlepager'], // Clear x
  ['clearable', '[data-clearable="true"]'], // Text Area
  ['textarea', 'textarea'], // Spinbox
  ['spinbox'], // sort drag and drop
  ['arrange'], // Swap List
  ['swaplist'], // Color Picker
  ['colorpicker'], // Date Picker
  ['datepicker'], // Time Picker
  ['timepicker'], // Tag
  ['tag'], // Busy Indicator
  ['busyindicator', '.busy, .busy-xs, .busy-sm'], ['header'], ['fileupload', 'input.fileupload:not(.fileupload-background-transparent):not([type="text"])'], ['fileuploadadvanced', '.fileupload-advanced'], ['fieldfilter', '.field-filter'], ['fieldoptions', '.field-options'], ['about'], ['contextualactionpanel', '.contextual-action-panel-trigger'], ['expandablearea', '.expandable-area'], ['signin'], ['homepage'], ['lookup', '.lookup:not([data-init])'], ['wizard'], ['popdown', '[data-popdown]'], ['stepchart', '.step-chart'], ['calendar', '.calendar'], ['calendartoolbar', '.calendar-toolbar'], ['monthview', '.monthview'], ['weekview', '.week-view'], ['listview'], // Track Dirty
  ['trackdirty', '[data-trackdirty="true"]'], // Context Menus - Popupmenu Components with no trigger buttons
  ['popupmenu', '[data-popupmenu]:not(.btn-actions, .btn-filter, .btn-menu)', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var popupElem = $(item);
      var settings = $.extend({}, utils.parseOptions(popupElem));
      var popupData = popupElem.attr('data-popupmenu');

      if (popupData) {
        settings.menuId = popupData;
      }

      invoke(popupElem, pluginName, settings);
    });
  }], // Menu Buttons - Popupmenu Components attached to trigger buttons
  ['popupmenu', '.btn-actions, .btn-filter, .btn-menu', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var triggerButton = $(item); // Don't auto-invoke Toolbar's Popupmenus.
      // Toolbar needs to completely control its contents and invoke each one manually.

      if (triggerButton.parents('.toolbar, .flex-toolbar').length > 0) {
        return;
      }

      invoke(triggerButton, pluginName);
    });
  }], // Popover
  ['popover', '[data-popover]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function () {
      var options = utils.parseOptions(this);
      var obj = $(this);
      var trigger = obj.attr('data-trigger');
      var title = obj.attr('data-title');
      var placement = obj.attr('data-placement');

      if (!$.isEmptyObject(options)) {
        obj.popover({
          content: $(options.content),
          popover: true,
          trigger: options.trigger || 'click',
          title: options.title || undefined,
          placement: options.placement || 'right',
          extraClass: options.extraClass || undefined
        });
      } else {
        obj.popover({
          content: $("#".concat(obj.attr('data-popover'))),
          popover: true,
          trigger: trigger || 'click',
          title: title || undefined,
          placement: placement || 'right',
          extraClass: options.extraClass || undefined
        });
      }
    });
  }], // Searchfield components need to be filtered for ToolbarSearchfield components,
  // which are invoked separately by their Toolbar element containers.
  ['searchfield', '.searchfield', function (rootElem, pluginName, selector) {
    var searchfields = matchedItems(rootElem, selector);
    var toolbarSearchfields = searchfields.filter(function () {
      return $(this).parents('.toolbar').length;
    });
    searchfields = searchfields.not(toolbarSearchfields);
    searchfields.each(function () {
      invoke(this, 'searchfield');
    });
  }], // Toolbar components that are invoked by parent Headers, Contextual Action Panels, and
  // Modal components should be excluded.
  ['toolbar', '.toolbar', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var t = $(item);

      if (t.parents('.header, .contextual-action-panel .modal-header').length && !rootElem.is('.toolbar')) {
        return;
      }

      invoke(t, 'toolbar');
    });
  }], // Flex Toolbar
  ['toolbarflex', '.flex-toolbar'], // Accordion components that are invoked by Application Menus should be excluded.
  ['accordion', '.accordion', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      var a = $(item);

      if (a.parents('.application-menu').length) {
        return;
      }

      invoke(a, 'accordion');
    });
  }], // Tag List
  ['taglist', '.tag-list'], // Breadcrumb
  ['breadcrumb', '.breadcrumb'], // Form Compact Component
  ['formcompact', '.form-compact-container', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      invoke($(item), 'formcompact');
    });
  }], // List/Detail Pattern
  ['listdetail', '.list-detail', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).each(function (i, item) {
      invoke($(item), 'listdetail');
    });
  }], // Translate `aria-label` attributes on Breadcrumb lists
  // (Breadcrumbs aren't invoked with a JS component)
  ['breadcrumblabels', '.breadcrumb ol', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).attr('aria-label', Locale.translate('Breadcrumb'));
  }], // Validation on individual fields (Should run last)
  ['validate', '[data-validate]', function (rootElem, pluginName, selector) {
    matchedItems(rootElem, selector).closest('form, body').validate();
  }], // Form validation
  ['validate', 'form[data-validate-on="submit"]']]; // Invokes a specific Soho component type against an element, in some cases with
  // specified rules or CSS selectors.

  function mapToInit(elem, plugin, selector, callback) {
    // Don't continue if the jQuery constructor for this plugin isn't loaded.
    if (!$.fn[plugin] && plugin !== 'texttranslations') {
      return;
    } // Allow only the plugin name to be specified if the default selector is
    // a class with the same name, Like `$.fn.header` applying to elements that
    // match `.header`


    if (typeof selector === 'undefined') {
      selector = ".".concat(plugin);
    } // If a callback function is provided, run that instead of the normal init.
    // Functions contain more-customized initialization for some components.


    if (typeof callback === 'function') {
      callback(elem, plugin, selector);
      return;
    } // Run the matcher and do normal init.


    matchedItems(elem, selector).each(function () {
      var thisElem = $(this); // Don't init if this element or one of its containing elements is flagged
      // with `[data-init]` or `.no-init`.

      if (thisElem.is(noinitExcludes) || thisElem.parents(noinitExcludes).length) {
        return;
      }

      invoke(this, plugin);
    });
  }
  /**
   * Page Bootstrapper, will initialize all components on a page with default settings.
   * @class Initialize
   * @constructor
   * @param {jQuery[]|HTMLElement} element the root element to initialize
   * @param {object} [settings] incoming settings
   */


  function Initialize(element, settings) {
    // Fall back for old way of calling locale
    var newSettings = settings;

    if (typeof settings === 'string') {
      newSettings = {
        locale: settings
      };
    }

    this.element = $(element);

    if (Locale.currentLocale && Locale.currentLocale.name && !settings) {
      newSettings = {
        locale: Locale.currentLocale.name
      };
    }

    if (Locale.currentLanguage && Locale.currentLanguage.name && Locale.currentLocale.name.substr(0, 2) !== Locale.currentLanguage.name && !settings) {
      newSettings.language = Locale.currentLanguage.name;
    }

    this.settings = utils.mergeSettings(this.element[0], newSettings, INITIALIZE_DEFAULTS);
    this.init();
  } // Plugin Methods


  Initialize.prototype = {
    /**
     * Makes sure the Locale is set before attempting initialize components
     * @private
     * @returns {this} component instance
     */
    init: function init() {
      var _this = this;

      var self = this;
      Locale.set(this.settings.locale).done(function () {
        if (_this.settings.language) {
          Locale.setLanguage(_this.settings.language).done(function () {
            self.initAll();
          });
          return;
        }

        self.initAll();
      });
      return this;
    },

    /**
     * Initializes all Soho components inside the root element provided.
      * @returns {this} component instance
     */
    initAll: function initAll() {
      var self = this; // Iterate all objects we are initializing

      this.element.each(function () {
        for (var i = 0; i < PLUGIN_MAPPINGS.length; i++) {
          mapToInit.apply(void 0, [$(this)].concat(_toConsumableArray(PLUGIN_MAPPINGS[i])));
        }
      }); // NOTE: use of .triggerHandler() here causes event listeners for "initialized"
      // to fire, but prevents the "initialized" event from bubbling up the DOM.
      // It should be possible to initialize just the contents of an element on
      // the page without causing the entire page to re-initialize.

      this.element.triggerHandler('initialized', {
        locale: Locale.currentLocale
      }); // Run validation on the entire element, if applicable.

      if ($.fn.validate) {
        self.element.validate();
      }

      return this;
    }
  };

  /**
   * jQuery Component Wrapper for Initialize
   * @param {object} settings The settings to apply.
   * @returns {jQuery[]} The jquery object for chaining.
   */

  $.fn.initialize = function (settings) {
    return this.each(function () {
      return new Initialize(this, settings);
    });
  };

  var BEHAVIOR_NAME = 'longpress'; // Default LongPress settings

  var LONGPRESS_DEFAULTS = {
    delay: 400,
    mouseEvents: false
  };
  /**
   * @class LongPress
   * @constructor
   * @param {Object} [settings] incoming settings
   * @param {Number} [settings.delay] the amount of time that should pass between the touch start, and
   *  the trigger of the "longpress" event.
   * @param {boolean} [settings.mouseEvents] if true, will setup longpress capability against mouse events
   *  as well as touch events.  If false, only touch events will be enabled, excluding mice from triggering
   *  the event.
   */

  function LongPress(settings) {
    this.settings = utils.mergeSettings(this.element, settings, LONGPRESS_DEFAULTS);
    return this.init();
  }

  LongPress.prototype = {
    /**
     * @property {RenderLoopItem} [timer=null]
     */
    timer: null,

    /**
     * @private
     * @returns {void}
     */
    init: function init() {
      var _this = this;

      var evts = this.getInputEventNames();
      var self = this; // User touches the screen.
      // If this goes uninterrupted for the defined duration, it causes a
      // `longpress` event to trigger on the target element.

      $(document).on("".concat(evts.mousedown, ".").concat(BEHAVIOR_NAME), function (e) {
        var target = e.target; // Add a timer to the renderLoop

        _this.timer = new RenderLoopItem({
          id: "".concat(BEHAVIOR_NAME, "-timer"),
          duration: math.convertDelayToFPS(_this.settings.delay),
          timeoutCallback: function timeoutCallback() {
            self.fire(target, e);
          }
        });
        renderLoop.register(_this.timer);
      }); // User moves or releases the touch, causing the timer to be cancelled.

      $(document).on(["".concat(evts.mouseup, ".").concat(BEHAVIOR_NAME), "".concat(evts.mouseout, ".").concat(BEHAVIOR_NAME), "".concat(evts.mousemove, ".").concat(BEHAVIOR_NAME)].join(' '), function () {
        _this.killTimer();
      });
    },

    /**
     * @param {HTMLElement} target the target element on which to trigger the event
     * @param {jQuery.Event} [e=undefined] the original event, if applicable
     * @returns {void}
     */
    fire: function fire(target, e) {
      $(target).trigger("".concat(BEHAVIOR_NAME), [e]);
    },

    /**
     * @private
     * @returns {void}
     */
    killTimer: function killTimer() {
      if (!this.timer) {
        return;
      } // Kill the renderloop item with no call to the timeout callback


      this.timer.destroy(true);
      this.timer = null;
    },

    /**
     * @private
     * @returns {object} containing desired event names
     */
    getInputEventNames: function getInputEventNames() {
      var isTouch = Environment.features.touch;
      var useMouse = this.settings.mouseEvents;
      var testCondition = isTouch || !useMouse;
      return {
        mousedown: testCondition ? 'touchstart' : 'mousedown',
        mouseout: testCondition ? 'touchcancel' : 'mouseout',
        mouseup: testCondition ? 'touchend' : 'mouseup',
        mousemove: testCondition ? 'touchmove' : 'mousemove'
      };
    },

    /**
     * @param {object} settings updated incoming settings
     * @returns {void}
     */
    updated: function updated(settings) {
      if (settings) {
        this.settings = utils.mergeSettings(this.element, settings, this.settings);
      }

      this.teardown();
      this.init();
    },

    /**
     * @returns {void}
     */
    teardown: function teardown() {
      var evts = this.getInputEventNames();
      this.killTimer();
      $(document).off(["".concat(evts.mousedown, ".").concat(BEHAVIOR_NAME), "".concat(evts.mouseup, ".").concat(BEHAVIOR_NAME), "".concat(evts.mouseout, ".").concat(BEHAVIOR_NAME), "".concat(evts.mousemove, ".").concat(BEHAVIOR_NAME)].join(' '));
    }
  }; // Setup a single instance of the LongPress behavior for export

  var longPress = new LongPress();

  // All desired Soho components ==================== /

  var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Button: Button,
    ButtonSet: ButtonSet,
    Hyperlink: Hyperlink,
    Icon: Icon,
    ListFilter: ListFilter,
    MaskInput: MaskInput,
    Modal: Modal,
    PopupMenu: PopupMenu,
    Tmpl: Tmpl,
    About: About,
    Accordion: Accordion,
    ApplicationMenu: ApplicationMenu,
    Autocomplete: Autocomplete,
    Bar: Bar,
    Blockgrid: Blockgrid,
    Breadcrumb: Breadcrumb,
    Bullet: Bullet,
    BusyIndicator: BusyIndicator,
    ColorPicker: ColorPicker,
    Column: Column,
    CompletionChart: CompletionChart,
    ContextualActionPanel: ContextualActionPanel,
    Drag: Drag,
    DatePicker: DatePicker,
    Dropdown: Dropdown,
    EmptyMessage: EmptyMessage,
    ExpandableArea: ExpandableArea,
    FontPicker: FontPicker,
    FontPickerStyle: FontPickerStyle,
    Line: Line,
    ListBuilder: ListBuilder,
    ListView: ListView,
    Message: Message,
    MultiSelect: MultiSelect,
    Notification: Notification,
    Pager: Pager,
    Pie: Pie,
    Popdown: Popdown,
    Radar: Radar,
    SearchField: SearchField,
    Slider: Slider,
    Sparkline: Sparkline,
    Spinbox: Spinbox,
    Splitter: Splitter,
    StepChart: StepChart,
    Tabs: Tabs,
    Tag: Tag,
    TagList: TagList,
    Textarea: Textarea,
    TimePicker: TimePicker,
    Toast: Toast,
    Toolbar: Toolbar,
    ToolbarFlex: ToolbarFlex,
    Tooltip: Tooltip,
    Tree: Tree,
    Treemap: Treemap,
    Validator: Validator,
    Wizard: Wizard,
    Calendar: Calendar,
    CalendarToolbar: CalendarToolbar,
    CompositeForm: CompositeForm,
    Datagrid: Datagrid,
    FormCompact: FormCompact,
    Header: Header,
    Lookup: Lookup,
    MonthView: MonthView,
    WeekView: WeekView,
    MultiTabs: MultiTabs,
    ListDetail: ListDetail,
    Stepprocess: Stepprocess
  });

  exports.DOM = DOM;
  exports.Editors = editors;
  exports.Formatters = formatters;
  exports.GroupBy = groupBy;
  exports.HideFocus = HideFocus;
  exports.Initialize = Initialize;
  exports.Locale = Locale;
  exports.Place = Place;
  exports.RenderLoopItem = RenderLoopItem;
  exports.Validation = Validation;
  exports.base = base;
  exports.breakpoints = breakpoints;
  exports.colors = colorUtils;
  exports.components = components;
  exports.debug = debug;
  exports.defer = defer;
  exports.env = Environment;
  exports.excel = excel;
  exports.getColorStyleSheet = getColorStyleSheet;
  exports.keyboard = keyboard;
  exports.longPress = longPress;
  exports.masks = masks;
  exports.modalManager = modalManager;
  exports.number = numberUtils;
  exports.object = objectUtils;
  exports.personalization = personalization;
  exports.renderLoop = renderLoop;
  exports.setColors = setColors;
  exports.setTheme = setTheme;
  exports.smoothScrollTo = smoothScrollTo;
  exports.string = stringUtils;
  exports.theme = theme;
  exports.uniqueIdCount = uniqueIdCount;
  exports.utils = utils;
  exports.version = version;
  exports.xss = xssUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
//# sourceMappingURL=sohoxi.js.map
